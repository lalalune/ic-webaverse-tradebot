function _mergeNamespaces(n2, m2) {
  for (var i2 = 0; i2 < m2.length; i2++) {
    const e2 = m2[i2];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d2 = Object.getOwnPropertyDescriptor(e2, k2);
          if (d2) {
            Object.defineProperty(n2, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node2 of mutation.addedNodes) {
        if (node2.tagName === "LINK" && node2.rel === "modulepreload")
          processPreload(node2);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(script) {
    const fetchOpts = {};
    if (script.integrity)
      fetchOpts.integrity = script.integrity;
    if (script.referrerpolicy)
      fetchOpts.referrerPolicy = script.referrerpolicy;
    if (script.crossorigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (script.crossorigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a = function() {
      return f2.apply(this, arguments);
    };
    a.prototype = f2.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a;
}
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$4 = Symbol.for("react.element"), n$5 = Symbol.for("react.portal"), p$6 = Symbol.for("react.fragment"), q$5 = Symbol.for("react.strict_mode"), r$5 = Symbol.for("react.profiler"), t$4 = Symbol.for("react.provider"), u$2 = Symbol.for("react.context"), v$4 = Symbol.for("react.forward_ref"), w$3 = Symbol.for("react.suspense"), x$2 = Symbol.for("react.memo"), y$2 = Symbol.for("react.lazy"), z$3 = Symbol.iterator;
function A$3(a) {
  if (null === a || "object" !== typeof a)
    return null;
  a = z$3 && a[z$3] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var B$1 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$1 = Object.assign, D$1 = {};
function E$1(a, b2, e2) {
  this.props = a;
  this.context = b2;
  this.refs = D$1;
  this.updater = e2 || B$1;
}
E$1.prototype.isReactComponent = {};
E$1.prototype.setState = function(a, b2) {
  if ("object" !== typeof a && "function" !== typeof a && null != a)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a, b2, "setState");
};
E$1.prototype.forceUpdate = function(a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function F() {
}
F.prototype = E$1.prototype;
function G$1(a, b2, e2) {
  this.props = a;
  this.context = b2;
  this.refs = D$1;
  this.updater = e2 || B$1;
}
var H$1 = G$1.prototype = new F();
H$1.constructor = G$1;
C$1(H$1, E$1.prototype);
H$1.isPureReactComponent = true;
var I$1 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
function M$1(a, b2, e2) {
  var d2, c2 = {}, k2 = null, h2 = null;
  if (null != b2)
    for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
      J.call(b2, d2) && !L$1.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g2 = arguments.length - 2;
  if (1 === g2)
    c2.children = e2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
      f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a && a.defaultProps)
    for (d2 in g2 = a.defaultProps, g2)
      void 0 === c2[d2] && (c2[d2] = g2[d2]);
  return { $$typeof: l$4, type: a, key: k2, ref: h2, props: c2, _owner: K$1.current };
}
function N$1(a, b2) {
  return { $$typeof: l$4, type: a.type, key: b2, ref: a.ref, props: a.props, _owner: a._owner };
}
function O$1(a) {
  return "object" === typeof a && null !== a && a.$$typeof === l$4;
}
function escape$2(a) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a.replace(/[=:]/g, function(a2) {
    return b2[a2];
  });
}
var P$1 = /\/+/g;
function Q$1(a, b2) {
  return "object" === typeof a && null !== a && null != a.key ? escape$2("" + a.key) : b2.toString(36);
}
function R$1(a, b2, e2, d2, c2) {
  var k2 = typeof a;
  if ("undefined" === k2 || "boolean" === k2)
    a = null;
  var h2 = false;
  if (null === a)
    h2 = true;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a.$$typeof) {
          case l$4:
          case n$5:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a, c2 = c2(h2), a = "" === d2 ? "." + Q$1(h2, 0) : d2, I$1(c2) ? (e2 = "", null != a && (e2 = a.replace(P$1, "$&/") + "/"), R$1(c2, b2, e2, "", function(a2) {
      return a2;
    })) : null != c2 && (O$1(c2) && (c2 = N$1(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$1, "$&/") + "/") + a)), b2.push(c2)), 1;
  h2 = 0;
  d2 = "" === d2 ? "." : d2 + ":";
  if (I$1(a))
    for (var g2 = 0; g2 < a.length; g2++) {
      k2 = a[g2];
      var f2 = d2 + Q$1(k2, g2);
      h2 += R$1(k2, b2, e2, f2, c2);
    }
  else if (f2 = A$3(a), "function" === typeof f2)
    for (a = f2.call(a), g2 = 0; !(k2 = a.next()).done; )
      k2 = k2.value, f2 = d2 + Q$1(k2, g2++), h2 += R$1(k2, b2, e2, f2, c2);
  else if ("object" === k2)
    throw b2 = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$1(a, b2, e2) {
  if (null == a)
    return a;
  var d2 = [], c2 = 0;
  R$1(a, d2, "", "", function(a2) {
    return b2.call(e2, a2, c2++);
  });
  return d2;
}
function T$1(a) {
  if (-1 === a._status) {
    var b2 = a._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a._status || -1 === a._status)
        a._status = 1, a._result = b3;
    }, function(b3) {
      if (0 === a._status || -1 === a._status)
        a._status = 2, a._result = b3;
    });
    -1 === a._status && (a._status = 0, a._result = b2);
  }
  if (1 === a._status)
    return a._result.default;
  throw a._result;
}
var U$1 = { current: null }, V$1 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$1, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 };
react_production_min.Children = { map: S$1, forEach: function(a, b2, e2) {
  S$1(a, function() {
    b2.apply(this, arguments);
  }, e2);
}, count: function(a) {
  var b2 = 0;
  S$1(a, function() {
    b2++;
  });
  return b2;
}, toArray: function(a) {
  return S$1(a, function(a2) {
    return a2;
  }) || [];
}, only: function(a) {
  if (!O$1(a))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a;
} };
react_production_min.Component = E$1;
react_production_min.Fragment = p$6;
react_production_min.Profiler = r$5;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$5;
react_production_min.Suspense = w$3;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
react_production_min.cloneElement = function(a, b2, e2) {
  if (null === a || void 0 === a)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
  var d2 = C$1({}, a.props), c2 = a.key, k2 = a.ref, h2 = a._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = K$1.current);
    void 0 !== b2.key && (c2 = "" + b2.key);
    if (a.type && a.type.defaultProps)
      var g2 = a.type.defaultProps;
    for (f2 in b2)
      J.call(b2, f2) && !L$1.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    d2.children = e2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g2[m2] = arguments[m2 + 2];
    d2.children = g2;
  }
  return { $$typeof: l$4, type: a.type, key: c2, ref: k2, props: d2, _owner: h2 };
};
react_production_min.createContext = function(a) {
  a = { $$typeof: u$2, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a.Provider = { $$typeof: t$4, _context: a };
  return a.Consumer = a;
};
react_production_min.createElement = M$1;
react_production_min.createFactory = function(a) {
  var b2 = M$1.bind(null, a);
  b2.type = a;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a) {
  return { $$typeof: v$4, render: a };
};
react_production_min.isValidElement = O$1;
react_production_min.lazy = function(a) {
  return { $$typeof: y$2, _payload: { _status: -1, _result: a }, _init: T$1 };
};
react_production_min.memo = function(a, b2) {
  return { $$typeof: x$2, type: a, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a) {
  var b2 = V$1.transition;
  V$1.transition = {};
  try {
    a();
  } finally {
    V$1.transition = b2;
  }
};
react_production_min.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
react_production_min.useCallback = function(a, b2) {
  return U$1.current.useCallback(a, b2);
};
react_production_min.useContext = function(a) {
  return U$1.current.useContext(a);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a) {
  return U$1.current.useDeferredValue(a);
};
react_production_min.useEffect = function(a, b2) {
  return U$1.current.useEffect(a, b2);
};
react_production_min.useId = function() {
  return U$1.current.useId();
};
react_production_min.useImperativeHandle = function(a, b2, e2) {
  return U$1.current.useImperativeHandle(a, b2, e2);
};
react_production_min.useInsertionEffect = function(a, b2) {
  return U$1.current.useInsertionEffect(a, b2);
};
react_production_min.useLayoutEffect = function(a, b2) {
  return U$1.current.useLayoutEffect(a, b2);
};
react_production_min.useMemo = function(a, b2) {
  return U$1.current.useMemo(a, b2);
};
react_production_min.useReducer = function(a, b2, e2) {
  return U$1.current.useReducer(a, b2, e2);
};
react_production_min.useRef = function(a) {
  return U$1.current.useRef(a);
};
react_production_min.useState = function(a) {
  return U$1.current.useState(a);
};
react_production_min.useSyncExternalStore = function(a, b2, e2) {
  return U$1.current.useSyncExternalStore(a, b2, e2);
};
react_production_min.useTransition = function() {
  return U$1.current.useTransition();
};
react_production_min.version = "18.2.0";
(function(module2) {
  {
    module2.exports = react_production_min;
  }
})(react);
const React = /* @__PURE__ */ getDefaultExportFromCjs(react.exports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [react.exports]);
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports2) {
  function f2(a, b2) {
    var c2 = a.length;
    a.push(b2);
    a:
      for (; 0 < c2; ) {
        var d2 = c2 - 1 >>> 1, e2 = a[d2];
        if (0 < g2(e2, b2))
          a[d2] = b2, a[c2] = e2, c2 = d2;
        else
          break a;
      }
  }
  function h2(a) {
    return 0 === a.length ? null : a[0];
  }
  function k2(a) {
    if (0 === a.length)
      return null;
    var b2 = a[0], c2 = a.pop();
    if (c2 !== b2) {
      a[0] = c2;
      a:
        for (var d2 = 0, e2 = a.length, w2 = e2 >>> 1; d2 < w2; ) {
          var m2 = 2 * (d2 + 1) - 1, C2 = a[m2], n2 = m2 + 1, x2 = a[n2];
          if (0 > g2(C2, c2))
            n2 < e2 && 0 > g2(x2, C2) ? (a[d2] = x2, a[n2] = c2, d2 = n2) : (a[d2] = C2, a[m2] = c2, d2 = m2);
          else if (n2 < e2 && 0 > g2(x2, c2))
            a[d2] = x2, a[n2] = c2, d2 = n2;
          else
            break a;
        }
    }
    return b2;
  }
  function g2(a, b2) {
    var c2 = a.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports2.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports2.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a) {
    for (var b2 = h2(t2); null !== b2; ) {
      if (null === b2.callback)
        k2(t2);
      else if (b2.startTime <= a)
        k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else
        break;
      b2 = h2(t2);
    }
  }
  function H2(a) {
    B2 = false;
    G2(a);
    if (!A2)
      if (null !== h2(r2))
        A2 = true, I2(J2);
      else {
        var b2 = h2(t2);
        null !== b2 && K2(H2, b2.startTime - a);
      }
  }
  function J2(a, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c2 = y2;
    try {
      G2(b2);
      for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a && !M2()); ) {
        var d2 = v2.callback;
        if ("function" === typeof d2) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e2 = d2(v2.expirationTime <= b2);
          b2 = exports2.unstable_now();
          "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
          G2(b2);
        } else
          k2(r2);
        v2 = h2(r2);
      }
      if (null !== v2)
        var w2 = true;
      else {
        var m2 = h2(t2);
        null !== m2 && K2(H2, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c2, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports2.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a = exports2.unstable_now();
      Q2 = a;
      var b2 = true;
      try {
        b2 = O2(true, a);
      } finally {
        b2 ? S2() : (N2 = false, O2 = null);
      }
    } else
      N2 = false;
  }
  var S2;
  if ("function" === typeof F2)
    S2 = function() {
      F2(R2);
    };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else
    S2 = function() {
      D2(R2, 0);
    };
  function I2(a) {
    O2 = a;
    N2 || (N2 = true, S2());
  }
  function K2(a, b2) {
    L2 = D2(function() {
      a(exports2.unstable_now());
    }, b2);
  }
  exports2.unstable_IdlePriority = 5;
  exports2.unstable_ImmediatePriority = 1;
  exports2.unstable_LowPriority = 4;
  exports2.unstable_NormalPriority = 3;
  exports2.unstable_Profiling = null;
  exports2.unstable_UserBlockingPriority = 2;
  exports2.unstable_cancelCallback = function(a) {
    a.callback = null;
  };
  exports2.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports2.unstable_forceFrameRate = function(a) {
    0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a ? Math.floor(1e3 / a) : 5;
  };
  exports2.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports2.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports2.unstable_next = function(a) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a();
    } finally {
      y2 = c2;
    }
  };
  exports2.unstable_pauseExecution = function() {
  };
  exports2.unstable_requestPaint = function() {
  };
  exports2.unstable_runWithPriority = function(a, b2) {
    switch (a) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a = 3;
    }
    var c2 = y2;
    y2 = a;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  };
  exports2.unstable_scheduleCallback = function(a, b2, c2) {
    var d2 = exports2.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a = { id: u2++, callback: b2, priorityLevel: a, startTime: c2, expirationTime: e2, sortIndex: -1 };
    c2 > d2 ? (a.sortIndex = c2, f2(t2, a), null === h2(r2) && a === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a.sortIndex = e2, f2(r2, a), A2 || z2 || (A2 = true, I2(J2)));
    return a;
  };
  exports2.unstable_shouldYield = M2;
  exports2.unstable_wrapCallback = function(a) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
(function(module2) {
  {
    module2.exports = scheduler_production_min;
  }
})(scheduler);
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = react.exports, ca = scheduler.exports;
function p$5(a) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a, b2) {
  ha(a, b2);
  ha(a + "Capture", b2);
}
function ha(a, b2) {
  ea[a] = b2;
  for (a = 0; a < b2.length; a++)
    da.add(b2[a]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a) {
  if (ja.call(ma, a))
    return true;
  if (ja.call(la, a))
    return false;
  if (ka.test(a))
    return ma[a] = true;
  la[a] = true;
  return false;
}
function pa(a, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type)
    return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2)
        return false;
      if (null !== c2)
        return !c2.acceptsBooleans;
      a = a.toLowerCase().slice(0, 5);
      return "data-" !== a && "aria-" !== a;
    default:
      return false;
  }
}
function qa(a, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || pa(a, b2, c2, d2))
    return true;
  if (d2)
    return false;
  if (null !== c2)
    switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return false;
}
function v$3(a, b2, c2, d2, e2, f2, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z$2 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
  z$2[a] = new v$3(a, 0, false, a, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
  var b2 = a[0];
  z$2[b2] = new v$3(b2, 1, false, a[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
  z$2[a] = new v$3(a, 2, false, a.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
  z$2[a] = new v$3(a, 2, false, a, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
  z$2[a] = new v$3(a, 3, false, a.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a) {
  z$2[a] = new v$3(a, 3, true, a, null, false, false);
});
["capture", "download"].forEach(function(a) {
  z$2[a] = new v$3(a, 4, false, a, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a) {
  z$2[a] = new v$3(a, 6, false, a, null, false, false);
});
["rowSpan", "start"].forEach(function(a) {
  z$2[a] = new v$3(a, 5, false, a.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
  var b2 = a.replace(
    ra,
    sa
  );
  z$2[b2] = new v$3(b2, 1, false, a, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
  var b2 = a.replace(ra, sa);
  z$2[b2] = new v$3(b2, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
  var b2 = a.replace(ra, sa);
  z$2[b2] = new v$3(b2, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a) {
  z$2[a] = new v$3(a, 1, false, a.toLowerCase(), null, false, false);
});
z$2.xlinkHref = new v$3("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a) {
  z$2[a] = new v$3(a, 1, false, a.toLowerCase(), null, true, true);
});
function ta(a, b2, c2, d2) {
  var e2 = z$2.hasOwnProperty(b2) ? z$2[b2] : null;
  if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
    qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a.removeAttribute(b2) : a.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a.setAttributeNS(d2, b2, c2) : a.setAttribute(b2, c2)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a) {
  if (null === a || "object" !== typeof a)
    return null;
  a = Ja && a[Ja] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var A$2 = Object.assign, La;
function Ma(a) {
  if (void 0 === La)
    try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      La = b2 && b2[1] || "";
    }
  return "\n" + La + a;
}
var Na = false;
function Oa(a, b2) {
  if (!a || Na)
    return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d2 = l2;
        }
        Reflect.construct(a, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d2 = l2;
        }
        a.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a();
    }
  } catch (l2) {
    if (l2 && d2 && "string" === typeof l2.stack) {
      for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
        h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--)
        if (e2[g2] !== f2[h2]) {
          if (1 !== g2 || 1 !== h2) {
            do
              if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                var k2 = "\n" + e2[g2].replace(" at new ", " at ");
                a.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a.displayName));
                return k2;
              }
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
}
function Pa(a) {
  switch (a.tag) {
    case 5:
      return Ma(a.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a = Oa(a.type, false), a;
    case 11:
      return a = Oa(a.type.render, false), a;
    case 1:
      return a = Oa(a.type, true), a;
    default:
      return "";
  }
}
function Qa(a) {
  if (null == a)
    return null;
  if ("function" === typeof a)
    return a.displayName || a.name || null;
  if ("string" === typeof a)
    return a;
  switch (a) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a)
    switch (a.$$typeof) {
      case Ca:
        return (a.displayName || "Context") + ".Consumer";
      case Ba:
        return (a._context.displayName || "Context") + ".Provider";
      case Da:
        var b2 = a.render;
        a = a.displayName;
        a || (a = b2.displayName || b2.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
        return a;
      case Ga:
        return b2 = a.displayName || null, null !== b2 ? b2 : Qa(a.type) || "Memo";
      case Ha:
        b2 = a._payload;
        a = a._init;
        try {
          return Qa(a(b2));
        } catch (c2) {
        }
    }
  return null;
}
function Ra(a) {
  var b2 = a.type;
  switch (a.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a = b2.render, a = a.displayName || a.name || "", b2.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2)
        return b2.displayName || b2.name || null;
      if ("string" === typeof b2)
        return b2;
  }
  return null;
}
function Sa(a) {
  switch (typeof a) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a;
    case "object":
      return a;
    default:
      return "";
  }
}
function Ta(a) {
  var b2 = a.type;
  return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a) {
  var b2 = Ta(a) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a.constructor.prototype, b2), d2 = "" + a[b2];
  if (!a.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f2 = c2.set;
    Object.defineProperty(a, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a2) {
      d2 = "" + a2;
      f2.call(this, a2);
    } });
    Object.defineProperty(a, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a2) {
      d2 = "" + a2;
    }, stopTracking: function() {
      a._valueTracker = null;
      delete a[b2];
    } };
  }
}
function Va(a) {
  a._valueTracker || (a._valueTracker = Ua(a));
}
function Wa(a) {
  if (!a)
    return false;
  var b2 = a._valueTracker;
  if (!b2)
    return true;
  var c2 = b2.getValue();
  var d2 = "";
  a && (d2 = Ta(a) ? a.checked ? "true" : "false" : a.value);
  a = d2;
  return a !== c2 ? (b2.setValue(a), true) : false;
}
function Xa(a) {
  a = a || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a)
    return null;
  try {
    return a.activeElement || a.body;
  } catch (b2) {
    return a.body;
  }
}
function Ya(a, b2) {
  var c2 = b2.checked;
  return A$2({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a._wrapperState.initialChecked });
}
function Za(a, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa(null != b2.value ? b2.value : c2);
  a._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a, b2) {
  b2 = b2.checked;
  null != b2 && ta(a, "checked", b2, false);
}
function bb(a, b2) {
  ab(a, b2);
  var c2 = Sa(b2.value), d2 = b2.type;
  if (null != c2)
    if ("number" === d2) {
      if (0 === c2 && "" === a.value || a.value != c2)
        a.value = "" + c2;
    } else
      a.value !== "" + c2 && (a.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a.defaultChecked = !!b2.defaultChecked);
}
function db(a, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
      return;
    b2 = "" + a._wrapperState.initialValue;
    c2 || b2 === a.value || (a.value = b2);
    a.defaultValue = b2;
  }
  c2 = a.name;
  "" !== c2 && (a.name = "");
  a.defaultChecked = !!a._wrapperState.initialChecked;
  "" !== c2 && (a.name = c2);
}
function cb(a, b2, c2) {
  if ("number" !== b2 || Xa(a.ownerDocument) !== a)
    null == c2 ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c2 && (a.defaultValue = "" + c2);
}
var eb = Array.isArray;
function fb(a, b2, c2, d2) {
  a = a.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++)
      b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a.length; c2++)
      e2 = b2.hasOwnProperty("$" + a[c2].value), a[c2].selected !== e2 && (a[c2].selected = e2), e2 && d2 && (a[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b2 = null;
    for (e2 = 0; e2 < a.length; e2++) {
      if (a[e2].value === c2) {
        a[e2].selected = true;
        d2 && (a[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a[e2].disabled || (b2 = a[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a, b2) {
  if (null != b2.dangerouslySetInnerHTML)
    throw Error(p$5(91));
  return A$2({}, b2, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
}
function hb(a, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2)
        throw Error(p$5(92));
      if (eb(c2)) {
        if (1 < c2.length)
          throw Error(p$5(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a._wrapperState = { initialValue: Sa(c2) };
}
function ib(a, b2) {
  var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a.value && (a.value = c2), null == b2.defaultValue && a.defaultValue !== c2 && (a.defaultValue = c2));
  null != d2 && (a.defaultValue = "" + d2);
}
function jb(a) {
  var b2 = a.textContent;
  b2 === a._wrapperState.initialValue && "" !== b2 && null !== b2 && (a.value = b2);
}
function kb(a) {
  switch (a) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a, b2) {
  return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b2) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a;
}
var mb, nb = function(a) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a(b2, c2, d2, e2);
    });
  } : a;
}(function(a, b2) {
  if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a)
    a.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a.firstChild; )
      a.removeChild(a.firstChild);
    for (; b2.firstChild; )
      a.appendChild(b2.firstChild);
  }
});
function ob(a, b2) {
  if (b2) {
    var c2 = a.firstChild;
    if (c2 && c2 === a.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a) {
  qb.forEach(function(b2) {
    b2 = b2 + a.charAt(0).toUpperCase() + a.substring(1);
    pb[b2] = pb[a];
  });
});
function rb(a, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a) && pb[a] ? ("" + b2).trim() : b2 + "px";
}
function sb(a, b2) {
  a = a.style;
  for (var c2 in b2)
    if (b2.hasOwnProperty(c2)) {
      var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
      "float" === c2 && (c2 = "cssFloat");
      d2 ? a.setProperty(c2, e2) : a[c2] = e2;
    }
}
var tb = A$2({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a, b2) {
  if (b2) {
    if (tb[a] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
      throw Error(p$5(137, a));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children)
        throw Error(p$5(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
        throw Error(p$5(61));
    }
    if (null != b2.style && "object" !== typeof b2.style)
      throw Error(p$5(62));
  }
}
function vb(a, b2) {
  if (-1 === a.indexOf("-"))
    return "string" === typeof b2.is;
  switch (a) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a) {
  a = a.target || a.srcElement || window;
  a.correspondingUseElement && (a = a.correspondingUseElement);
  return 3 === a.nodeType ? a.parentNode : a;
}
var yb = null, zb = null, Ab = null;
function Bb(a) {
  if (a = Cb(a)) {
    if ("function" !== typeof yb)
      throw Error(p$5(280));
    var b2 = a.stateNode;
    b2 && (b2 = Db(b2), yb(a.stateNode, a.type, b2));
  }
}
function Eb(a) {
  zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
}
function Fb() {
  if (zb) {
    var a = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a);
    if (b2)
      for (a = 0; a < b2.length; a++)
        Bb(b2[a]);
  }
}
function Gb(a, b2) {
  return a(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a, b2, c2) {
  if (Ib)
    return a(b2, c2);
  Ib = true;
  try {
    return Gb(a, b2, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab)
      Hb(), Fb();
  }
}
function Kb(a, b2) {
  var c2 = a.stateNode;
  if (null === c2)
    return null;
  var d2 = Db(c2);
  if (null === d2)
    return null;
  c2 = d2[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a = a.type, d2 = !("button" === a || "input" === a || "select" === a || "textarea" === a));
        a = !d2;
        break a;
      default:
        a = false;
    }
  if (a)
    return null;
  if (c2 && "function" !== typeof c2)
    throw Error(p$5(231, b2, typeof c2));
  return c2;
}
var Lb = false;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a) {
    Lb = false;
  }
function Nb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
  Ob = true;
  Pb = a;
} };
function Tb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else
      throw Error(p$5(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a) {
  var b2 = a, c2 = a;
  if (a.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a = b2;
    do
      b2 = a, 0 !== (b2.flags & 4098) && (c2 = b2.return), a = b2.return;
    while (a);
  }
  return 3 === b2.tag ? c2 : null;
}
function Wb(a) {
  if (13 === a.tag) {
    var b2 = a.memoizedState;
    null === b2 && (a = a.alternate, null !== a && (b2 = a.memoizedState));
    if (null !== b2)
      return b2.dehydrated;
  }
  return null;
}
function Xb(a) {
  if (Vb(a) !== a)
    throw Error(p$5(188));
}
function Yb(a) {
  var b2 = a.alternate;
  if (!b2) {
    b2 = Vb(a);
    if (null === b2)
      throw Error(p$5(188));
    return b2 !== a ? null : a;
  }
  for (var c2 = a, d2 = b2; ; ) {
    var e2 = c2.return;
    if (null === e2)
      break;
    var f2 = e2.alternate;
    if (null === f2) {
      d2 = e2.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c2)
          return Xb(e2), a;
        if (f2 === d2)
          return Xb(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(p$5(188));
    }
    if (c2.return !== d2.return)
      c2 = e2, d2 = f2;
    else {
      for (var g2 = false, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e2;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e2;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2)
          throw Error(p$5(189));
      }
    }
    if (c2.alternate !== d2)
      throw Error(p$5(190));
  }
  if (3 !== c2.tag)
    throw Error(p$5(188));
  return c2.stateNode.current === c2 ? a : b2;
}
function Zb(a) {
  a = Yb(a);
  return null !== a ? $b(a) : null;
}
function $b(a) {
  if (5 === a.tag || 6 === a.tag)
    return a;
  for (a = a.child; null !== a; ) {
    var b2 = $b(a);
    if (null !== b2)
      return b2;
    a = a.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic$1 = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a) {
  if (lc && "function" === typeof lc.onCommitFiberRoot)
    try {
      lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
    } catch (b2) {
    }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a) {
  a >>>= 0;
  return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a) {
  switch (a & -a) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a;
  }
}
function uc(a, b2) {
  var c2 = a.pendingLanes;
  if (0 === c2)
    return 0;
  var d2 = 0, e2 = a.suspendedLanes, f2 = a.pingedLanes, g2 = c2 & 268435455;
  if (0 !== g2) {
    var h2 = g2 & ~e2;
    0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
  } else
    g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
  if (0 === d2)
    return 0;
  if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240)))
    return b2;
  0 !== (d2 & 4) && (d2 |= c2 & 16);
  b2 = a.entangledLanes;
  if (0 !== b2)
    for (a = a.entanglements, b2 &= d2; 0 < b2; )
      c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a[c2], b2 &= ~e2;
  return d2;
}
function vc(a, b2) {
  switch (a) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a, b2) {
  for (var c2 = a.suspendedLanes, d2 = a.pingedLanes, e2 = a.expirationTimes, f2 = a.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
    if (-1 === k2) {
      if (0 === (h2 & c2) || 0 !== (h2 & d2))
        e2[g2] = vc(h2, b2);
    } else
      k2 <= b2 && (a.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc(a) {
  a = a.pendingLanes & -1073741825;
  return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a;
}
function zc(a) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++)
    b2.push(a);
  return b2;
}
function Ac(a, b2, c2) {
  a.pendingLanes |= b2;
  536870912 !== b2 && (a.suspendedLanes = 0, a.pingedLanes = 0);
  a = a.eventTimes;
  b2 = 31 - oc(b2);
  a[b2] = c2;
}
function Bc(a, b2) {
  var c2 = a.pendingLanes & ~b2;
  a.pendingLanes = b2;
  a.suspendedLanes = 0;
  a.pingedLanes = 0;
  a.expiredLanes &= b2;
  a.mutableReadLanes &= b2;
  a.entangledLanes &= b2;
  b2 = a.entanglements;
  var d2 = a.eventTimes;
  for (a = a.expirationTimes; 0 < c2; ) {
    var e2 = 31 - oc(c2), f2 = 1 << e2;
    b2[e2] = 0;
    d2[e2] = -1;
    a[e2] = -1;
    c2 &= ~f2;
  }
}
function Cc(a, b2) {
  var c2 = a.entangledLanes |= b2;
  for (a = a.entanglements; c2; ) {
    var d2 = 31 - oc(c2), e2 = 1 << d2;
    e2 & b2 | a[d2] & b2 && (a[d2] |= b2);
    c2 &= ~e2;
  }
}
var C = 0;
function Dc(a) {
  a &= -a;
  return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a, b2) {
  switch (a) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a, b2, c2, d2, e2, f2) {
  if (null === a || a.nativeEvent !== f2)
    return a = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a;
  a.eventSystemFlags |= d2;
  b2 = a.targetContainers;
  null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
  return a;
}
function Uc(a, b2, c2, d2, e2) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a, b2, c2, d2, e2), true;
    case "dragenter":
      return Mc = Tc(Mc, a, b2, c2, d2, e2), true;
    case "mouseover":
      return Nc = Tc(Nc, a, b2, c2, d2, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a, b2, c2, d2, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a, b2, c2, d2, e2)), true;
  }
  return false;
}
function Vc(a) {
  var b2 = Wc(a.target);
  if (null !== b2) {
    var c2 = Vb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = Wb(c2), null !== b2) {
          a.blockedOn = b2;
          Ic(a.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
        a.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a.blockedOn = null;
}
function Xc(a) {
  if (null !== a.blockedOn)
    return false;
  for (var b2 = a.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a.domEventName, a.eventSystemFlags, b2[0], a.nativeEvent);
    if (null === c2) {
      c2 = a.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb = d2;
      c2.target.dispatchEvent(d2);
      wb = null;
    } else
      return b2 = Cb(c2), null !== b2 && Fc(b2), a.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function Zc(a, b2, c2) {
  Xc(a) && c2.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a, b2) {
  a.blockedOn === b2 && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a) {
  function b2(b3) {
    return ad(b3, a);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d2 = Kc[c2];
      d2.blockedOn === a && (d2.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a);
  null !== Mc && ad(Mc, a);
  null !== Nc && ad(Nc, a);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c2 = 0; c2 < Qc.length; c2++)
    d2 = Qc[c2], d2.blockedOn === a && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
    Vc(c2), null === c2.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a, b2, c2, d2) {
  var e2 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 1, fd(a, b2, c2, d2);
  } finally {
    C = e2, cd.transition = f2;
  }
}
function gd(a, b2, c2, d2) {
  var e2 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 4, fd(a, b2, c2, d2);
  } finally {
    C = e2, cd.transition = f2;
  }
}
function fd(a, b2, c2, d2) {
  if (dd) {
    var e2 = Yc(a, b2, c2, d2);
    if (null === e2)
      hd(a, b2, d2, id, c2), Sc(a, d2);
    else if (Uc(e2, a, b2, c2, d2))
      d2.stopPropagation();
    else if (Sc(a, d2), b2 & 4 && -1 < Rc.indexOf(a)) {
      for (; null !== e2; ) {
        var f2 = Cb(e2);
        null !== f2 && Ec(f2);
        f2 = Yc(a, b2, c2, d2);
        null === f2 && hd(a, b2, d2, id, c2);
        if (f2 === e2)
          break;
        e2 = f2;
      }
      null !== e2 && d2.stopPropagation();
    } else
      hd(a, b2, d2, null, c2);
  }
}
var id = null;
function Yc(a, b2, c2, d2) {
  id = null;
  a = xb(d2);
  a = Wc(a);
  if (null !== a)
    if (b2 = Vb(a), null === b2)
      a = null;
    else if (c2 = b2.tag, 13 === c2) {
      a = Wb(b2);
      if (null !== a)
        return a;
      a = null;
    } else if (3 === c2) {
      if (b2.stateNode.current.memoizedState.isDehydrated)
        return 3 === b2.tag ? b2.stateNode.containerInfo : null;
      a = null;
    } else
      b2 !== a && (a = null);
  id = a;
  return null;
}
function jd(a) {
  switch (a) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic$1:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a = 0; a < c2 && b2[a] === e2[a]; a++)
    ;
  var g2 = c2 - a;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
    ;
  return md = e2.slice(a, 1 < d2 ? 1 - d2 : void 0);
}
function od(a) {
  var b2 = a.keyCode;
  "charCode" in a ? (a = a.charCode, 0 === a && 13 === b2 && (a = 13)) : a = b2;
  10 === a && (a = 13);
  return 32 <= a || 13 === a ? a : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a) {
  function b2(b3, d2, e2, f2, g2) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a)
      a.hasOwnProperty(c2) && (b3 = a[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$2(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a2 = this.nativeEvent;
    a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a2 = this.nativeEvent;
    a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
  return a.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$2({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$2({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
  return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
}, movementX: function(a) {
  if ("movementX" in a)
    return a.movementX;
  a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
  return wd;
}, movementY: function(a) {
  return "movementY" in a ? a.movementY : xd;
} }), Bd = rd(Ad), Cd = A$2({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$2({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$2({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$2({}, sd, { clipboardData: function(a) {
  return "clipboardData" in a ? a.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$2({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a) : (a = Od[a]) ? !!b2[a] : false;
}
function zd() {
  return Pd;
}
var Qd = A$2({}, ud, { key: function(a) {
  if (a.key) {
    var b2 = Md[a.key] || a.key;
    if ("Unidentified" !== b2)
      return b2;
  }
  return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
  return "keypress" === a.type ? od(a) : 0;
}, keyCode: function(a) {
  return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
}, which: function(a) {
  return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$2({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$2({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$2({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$2({}, Ad, {
  deltaX: function(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  },
  deltaY: function(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
ia && "documentMode" in document && (be = document.documentMode);
var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
function ge(a, b2) {
  switch (a) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a) {
  a = a.detail;
  return "object" === typeof a && "data" in a ? a.data : null;
}
var ie = false;
function je(a, b2) {
  switch (a) {
    case "compositionend":
      return he(b2);
    case "keypress":
      if (32 !== b2.which)
        return null;
      fe = true;
      return ee;
    case "textInput":
      return a = b2.data, a === ee && fe ? null : a;
    default:
      return null;
  }
}
function ke(a, b2) {
  if (ie)
    return "compositionend" === a || !ae && ge(a, b2) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
  switch (a) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a) {
  var b2 = a && a.nodeName && a.nodeName.toLowerCase();
  return "input" === b2 ? !!le[a.type] : "textarea" === b2 ? true : false;
}
function ne(a, b2, c2, d2) {
  Eb(d2);
  b2 = oe(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a.push({ event: c2, listeners: b2 }));
}
var pe = null, qe = null;
function re(a) {
  se(a, 0);
}
function te(a) {
  var b2 = ue(a);
  if (Wa(b2))
    return a;
}
function ve(a, b2) {
  if ("change" === a)
    return b2;
}
var we = false;
if (ia) {
  var xe;
  if (ia) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }
    xe = ye;
  } else
    xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a) {
  if ("value" === a.propertyName && te(qe)) {
    var b2 = [];
    ne(b2, qe, a, xb(a));
    Jb(re, b2);
  }
}
function Ce(a, b2, c2) {
  "focusin" === a ? (Ae(), pe = b2, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
}
function De(a) {
  if ("selectionchange" === a || "keyup" === a || "keydown" === a)
    return te(qe);
}
function Ee(a, b2) {
  if ("click" === a)
    return te(b2);
}
function Fe(a, b2) {
  if ("input" === a || "change" === a)
    return te(b2);
}
function Ge(a, b2) {
  return a === b2 && (0 !== a || 1 / a === 1 / b2) || a !== a && b2 !== b2;
}
var He = "function" === typeof Object.is ? Object.is : Ge;
function Ie(a, b2) {
  if (He(a, b2))
    return true;
  if ("object" !== typeof a || null === a || "object" !== typeof b2 || null === b2)
    return false;
  var c2 = Object.keys(a), d2 = Object.keys(b2);
  if (c2.length !== d2.length)
    return false;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    if (!ja.call(b2, e2) || !He(a[e2], b2[e2]))
      return false;
  }
  return true;
}
function Je(a) {
  for (; a && a.firstChild; )
    a = a.firstChild;
  return a;
}
function Ke(a, b2) {
  var c2 = Je(a);
  a = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a + c2.textContent.length;
      if (a <= b2 && d2 >= b2)
        return { node: c2, offset: b2 - a };
      a = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je(c2);
  }
}
function Le(a, b2) {
  return a && b2 ? a === b2 ? true : a && 3 === a.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a, b2.parentNode) : "contains" in a ? a.contains(b2) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b2) & 16) : false : false;
}
function Me() {
  for (var a = window, b2 = Xa(); b2 instanceof a.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2)
      a = b2.contentWindow;
    else
      break;
    b2 = Xa(a.document);
  }
  return b2;
}
function Ne(a) {
  var b2 = a && a.nodeName && a.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b2 || "true" === a.contentEditable);
}
function Oe(a) {
  var b2 = Me(), c2 = a.focusedElem, d2 = a.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
    if (null !== d2 && Ne(c2)) {
      if (b2 = d2.start, a = d2.end, void 0 === a && (a = b2), "selectionStart" in c2)
        c2.selectionStart = b2, c2.selectionEnd = Math.min(a, c2.value.length);
      else if (a = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a.getSelection) {
        a = a.getSelection();
        var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
        d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
        !a.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
        e2 = Ke(c2, f2);
        var g2 = Ke(
          c2,
          d2
        );
        e2 && g2 && (1 !== a.rangeCount || a.anchorNode !== e2.node || a.anchorOffset !== e2.offset || a.focusNode !== g2.node || a.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a.removeAllRanges(), f2 > d2 ? (a.addRange(b2), a.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a.addRange(b2)));
      }
    }
    b2 = [];
    for (a = c2; a = a.parentNode; )
      1 === a.nodeType && b2.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++)
      a = b2[c2], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
function Ue(a, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a.push({ event: b2, listeners: d2 }), b2.target = Qe)));
}
function Ve(a, b2) {
  var c2 = {};
  c2[a.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a] = "webkit" + b2;
  c2["Moz" + a] = "moz" + b2;
  return c2;
}
var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
function Ze(a) {
  if (Xe[a])
    return Xe[a];
  if (!We[a])
    return a;
  var b2 = We[a], c2;
  for (c2 in b2)
    if (b2.hasOwnProperty(c2) && c2 in Ye)
      return Xe[a] = b2[c2];
  return a;
}
var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a, b2) {
  df.set(a, b2);
  fa(b2, [a]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a, b2, c2) {
  var d2 = a.type || "unknown-event";
  a.currentTarget = c2;
  Ub(d2, b2, void 0, a);
  a.currentTarget = null;
}
function se(a, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a.length; c2++) {
    var d2 = a[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2)
        for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
      else
        for (g2 = 0; g2 < d2.length; g2++) {
          h2 = d2[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
    }
  }
  if (Qb)
    throw a = Rb, Qb = false, Rb = null, a;
}
function D(a, b2) {
  var c2 = b2[of];
  void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
  var d2 = a + "__bubble";
  c2.has(d2) || (pf(b2, a, 2, false), c2.add(d2));
}
function qf(a, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4);
  pf(c2, a, d2, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a) {
  if (!a[rf]) {
    a[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a), qf(b3, true, a));
    });
    var b2 = 9 === a.nodeType ? a : a.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a, b2, c2, d2) {
  switch (jd(b2)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c2 = e2.bind(null, b2, c2, a);
  e2 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
  d2 ? void 0 !== e2 ? a.addEventListener(b2, c2, { capture: true, passive: e2 }) : a.addEventListener(b2, c2, true) : void 0 !== e2 ? a.addEventListener(b2, c2, { passive: e2 }) : a.addEventListener(b2, c2, false);
}
function hd(a, b2, c2, d2, e2) {
  var f2 = d2;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
    a:
      for (; ; ) {
        if (null === d2)
          return;
        var g2 = d2.tag;
        if (3 === g2 || 4 === g2) {
          var h2 = d2.stateNode.containerInfo;
          if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
            break;
          if (4 === g2)
            for (g2 = d2.return; null !== g2; ) {
              var k2 = g2.tag;
              if (3 === k2 || 4 === k2) {
                if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                  return;
              }
              g2 = g2.return;
            }
          for (; null !== h2; ) {
            g2 = Wc(h2);
            if (null === g2)
              return;
            k2 = g2.tag;
            if (5 === k2 || 6 === k2) {
              d2 = f2 = g2;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d2 = d2.return;
      }
  Jb(function() {
    var d3 = f2, e3 = xb(c2), g3 = [];
    a: {
      var h3 = df.get(a);
      if (void 0 !== h3) {
        var k3 = td, n2 = a;
        switch (a) {
          case "keypress":
            if (0 === od(c2))
              break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c2.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d3, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
          if (J2)
            break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a || "pointerover" === a;
        k3 = "mouseout" === a || "pointerout" === a;
        if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf]))
          break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
              n2 = null;
          } else
            k3 = null, n2 = d3;
          if (k3 !== n2) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a || "pointerover" === a)
              t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue(k3);
            u2 = null == n2 ? h3 : ue(n2);
            h3 = new t2(F2, w2 + "leave", k3, c2, e3);
            h3.target = J2;
            h3.relatedTarget = u2;
            F2 = null;
            Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k3 && n2)
              b: {
                t2 = k3;
                x2 = n2;
                w2 = 0;
                for (u2 = t2; u2; u2 = vf(u2))
                  w2++;
                u2 = 0;
                for (F2 = x2; F2; F2 = vf(F2))
                  u2++;
                for (; 0 < w2 - u2; )
                  t2 = vf(t2), w2--;
                for (; 0 < u2 - w2; )
                  x2 = vf(x2), u2--;
                for (; w2--; ) {
                  if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                    break b;
                  t2 = vf(t2);
                  x2 = vf(x2);
                }
                t2 = null;
              }
            else
              t2 = null;
            null !== k3 && wf(g3, h3, k3, t2, false);
            null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type)
          var na = ve;
        else if (me(h3))
          if (we)
            na = Fe;
          else {
            na = De;
            var xa = Ce;
          }
        else
          (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
        if (na && (na = na(a, d3))) {
          ne(g3, na, c2, e3);
          break a;
        }
        xa && xa(a, h3, d3);
        "focusout" === a && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
      }
      xa = d3 ? ue(d3) : window;
      switch (a) {
        case "focusin":
          if (me(xa) || "true" === xa.contentEditable)
            Qe = xa, Re = d3, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g3, c2, e3);
          break;
        case "selectionchange":
          if (Pe)
            break;
        case "keydown":
        case "keyup":
          Ue(g3, c2, e3);
      }
      var $a;
      if (ae)
        b: {
          switch (a) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
      else
        ie ? ge(a, c2) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c2.keyCode && (ba = "onCompositionStart");
      ba && (de && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d3, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c2), null !== $a && (ba.data = $a))));
      if ($a = ce ? je(a, c2) : ke(a, c2))
        d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
    }
    se(g3, b2);
  });
}
function tf(a, b2, c2) {
  return { instance: a, listener: b2, currentTarget: c2 };
}
function oe(a, b2) {
  for (var c2 = b2 + "Capture", d2 = []; null !== a; ) {
    var e2 = a, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a, c2), null != f2 && d2.unshift(tf(a, f2, e2)), f2 = Kb(a, b2), null != f2 && d2.push(tf(a, f2, e2)));
    a = a.return;
  }
  return d2;
}
function vf(a) {
  if (null === a)
    return null;
  do
    a = a.return;
  while (a && 5 !== a.tag);
  return a ? a : null;
}
function wf(a, b2, c2, d2, e2) {
  for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2)
      break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g2.length && a.push({ event: b2, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a) {
  return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
}
function Af(a, b2, c2) {
  b2 = zf(b2);
  if (zf(a) !== b2 && c2)
    throw Error(p$5(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a, b2) {
  return "textarea" === a || "noscript" === a || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
  return Hf.resolve(null).then(a).catch(If);
} : Ff;
function If(a) {
  setTimeout(function() {
    throw a;
  });
}
function Kf(a, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e2 = c2.nextSibling;
    a.removeChild(c2);
    if (e2 && 8 === e2.nodeType)
      if (c2 = e2.data, "/$" === c2) {
        if (0 === d2) {
          a.removeChild(e2);
          bd(b2);
          return;
        }
        d2--;
      } else
        "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
    c2 = e2;
  } while (c2);
  bd(b2);
}
function Lf(a) {
  for (; null != a; a = a.nextSibling) {
    var b2 = a.nodeType;
    if (1 === b2 || 3 === b2)
      break;
    if (8 === b2) {
      b2 = a.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2)
        break;
      if ("/$" === b2)
        return null;
    }
  }
  return a;
}
function Mf(a) {
  a = a.previousSibling;
  for (var b2 = 0; a; ) {
    if (8 === a.nodeType) {
      var c2 = a.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2)
          return a;
        b2--;
      } else
        "/$" === c2 && b2++;
    }
    a = a.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a) {
  var b2 = a[Of];
  if (b2)
    return b2;
  for (var c2 = a.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child)
        for (a = Mf(a); null !== a; ) {
          if (c2 = a[Of])
            return c2;
          a = Mf(a);
        }
      return b2;
    }
    a = c2;
    c2 = a.parentNode;
  }
  return null;
}
function Cb(a) {
  a = a[Of] || a[uf];
  return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
}
function ue(a) {
  if (5 === a.tag || 6 === a.tag)
    return a.stateNode;
  throw Error(p$5(33));
}
function Db(a) {
  return a[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a) {
  return { current: a };
}
function E(a) {
  0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G(a, b2) {
  Tf++;
  Sf[Tf] = a.current;
  a.current = b2;
}
var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a, b2) {
  var c2 = a.type.contextTypes;
  if (!c2)
    return Vf;
  var d2 = a.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2)
    e2[f2] = b2[f2];
  d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b2, a.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a) {
  a = a.childContextTypes;
  return null !== a && void 0 !== a;
}
function $f() {
  E(Wf);
  E(H);
}
function ag(a, b2, c2) {
  if (H.current !== Vf)
    throw Error(p$5(168));
  G(H, b2);
  G(Wf, c2);
}
function bg(a, b2, c2) {
  var d2 = a.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext)
    return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2)
    if (!(e2 in b2))
      throw Error(p$5(108, Ra(a) || "Unknown", e2));
  return A$2({}, c2, d2);
}
function cg(a) {
  a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H.current;
  G(H, a);
  G(Wf, Wf.current);
  return true;
}
function dg(a, b2, c2) {
  var d2 = a.stateNode;
  if (!d2)
    throw Error(p$5(169));
  c2 ? (a = bg(a, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
  G(Wf, c2);
}
var eg = null, fg = false, gg = false;
function hg(a) {
  null === eg ? eg = [a] : eg.push(a);
}
function ig(a) {
  fg = true;
  hg(a);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a = 0, b2 = C;
    try {
      var c2 = eg;
      for (C = 1; a < c2.length; a++) {
        var d2 = c2[a];
        do
          d2 = d2(true);
        while (null !== d2);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e2;
    } finally {
      C = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a;
  ng = b2;
}
function ug(a, b2, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a;
  var d2 = rg;
  a = sg;
  var e2 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e2);
  c2 += 1;
  var f2 = 32 - oc(b2) + e2;
  if (30 < f2) {
    var g2 = e2 - e2 % 5;
    f2 = (d2 & (1 << g2) - 1).toString(32);
    d2 >>= g2;
    e2 -= g2;
    rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
    sg = f2 + a;
  } else
    rg = 1 << f2 | c2 << e2 | d2, sg = a;
}
function vg(a) {
  null !== a.return && (tg(a, 1), ug(a, 1, 0));
}
function wg(a) {
  for (; a === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I = false, zg = null;
function Ag(a, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a;
  b2 = a.deletions;
  null === b2 ? (a.deletions = [c2], a.flags |= 16) : b2.push(c2);
}
function Cg(a, b2) {
  switch (a.tag) {
    case 5:
      var c2 = a.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a.stateNode = b2, xg = a, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a.stateNode = b2, xg = a, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a, a.child = c2, xg = a, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a) {
  return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
}
function Eg(a) {
  if (I) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a, b2)) {
        if (Dg(a))
          throw Error(p$5(418));
        b2 = Lf(c2.nextSibling);
        var d2 = xg;
        b2 && Cg(a, b2) ? Ag(d2, c2) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
      }
    } else {
      if (Dg(a))
        throw Error(p$5(418));
      a.flags = a.flags & -4097 | 2;
      I = false;
      xg = a;
    }
  }
}
function Fg(a) {
  for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; )
    a = a.return;
  xg = a;
}
function Gg(a) {
  if (a !== xg)
    return false;
  if (!I)
    return Fg(a), I = true, false;
  var b2;
  (b2 = 3 !== a.tag) && !(b2 = 5 !== a.tag) && (b2 = a.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a.type, a.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a))
      throw Hg(), Error(p$5(418));
    for (; b2; )
      Ag(a, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a);
  if (13 === a.tag) {
    a = a.memoizedState;
    a = null !== a ? a.dehydrated : null;
    if (!a)
      throw Error(p$5(317));
    a: {
      a = a.nextSibling;
      for (b2 = 0; a; ) {
        if (8 === a.nodeType) {
          var c2 = a.data;
          if ("/$" === c2) {
            if (0 === b2) {
              yg = Lf(a.nextSibling);
              break a;
            }
            b2--;
          } else
            "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a = a.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a = yg; a; )
    a = Lf(a.nextSibling);
}
function Ig() {
  yg = xg = null;
  I = false;
}
function Jg(a) {
  null === zg ? zg = [a] : zg.push(a);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a, b2) {
  if (a && a.defaultProps) {
    b2 = A$2({}, b2);
    a = a.defaultProps;
    for (var c2 in a)
      void 0 === b2[c2] && (b2[c2] = a[c2]);
    return b2;
  }
  return b2;
}
var Mg = Uf(null), Ng = null, Og = null, Pg = null;
function Qg() {
  Pg = Og = Ng = null;
}
function Rg(a) {
  var b2 = Mg.current;
  E(Mg);
  a._currentValue = b2;
}
function Sg(a, b2, c2) {
  for (; null !== a; ) {
    var d2 = a.alternate;
    (a.childLanes & b2) !== b2 ? (a.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
    if (a === c2)
      break;
    a = a.return;
  }
}
function Tg(a, b2) {
  Ng = a;
  Pg = Og = null;
  a = a.dependencies;
  null !== a && null !== a.firstContext && (0 !== (a.lanes & b2) && (Ug = true), a.firstContext = null);
}
function Vg(a) {
  var b2 = a._currentValue;
  if (Pg !== a)
    if (a = { context: a, memoizedValue: b2, next: null }, null === Og) {
      if (null === Ng)
        throw Error(p$5(308));
      Og = a;
      Ng.dependencies = { lanes: 0, firstContext: a };
    } else
      Og = Og.next = a;
  return b2;
}
var Wg = null;
function Xg(a) {
  null === Wg ? Wg = [a] : Wg.push(a);
}
function Yg(a, b2, c2, d2) {
  var e2 = b2.interleaved;
  null === e2 ? (c2.next = c2, Xg(b2)) : (c2.next = e2.next, e2.next = c2);
  b2.interleaved = c2;
  return Zg(a, d2);
}
function Zg(a, b2) {
  a.lanes |= b2;
  var c2 = a.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a;
  for (a = a.return; null !== a; )
    a.childLanes |= b2, c2 = a.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a, a = a.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
var $g = false;
function ah(a) {
  a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function bh(a, b2) {
  a = a.updateQueue;
  b2.updateQueue === a && (b2.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
}
function ch(a, b2) {
  return { eventTime: a, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function dh(a, b2, c2) {
  var d2 = a.updateQueue;
  if (null === d2)
    return null;
  d2 = d2.shared;
  if (0 !== (K & 2)) {
    var e2 = d2.pending;
    null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
    d2.pending = b2;
    return Zg(a, c2);
  }
  e2 = d2.interleaved;
  null === e2 ? (b2.next = b2, Xg(d2)) : (b2.next = e2.next, e2.next = b2);
  d2.interleaved = b2;
  return Zg(a, c2);
}
function eh(a, b2, c2) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
    var d2 = b2.lanes;
    d2 &= a.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a, c2);
  }
}
function fh(a, b2) {
  var c2 = a.updateQueue, d2 = a.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else
      e2 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a.updateQueue = c2;
    return;
  }
  a = c2.lastBaseUpdate;
  null === a ? c2.firstBaseUpdate = b2 : a.next = b2;
  c2.lastBaseUpdate = b2;
}
function gh(a, b2, c2, d2) {
  var e2 = a.updateQueue;
  $g = false;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var m2 = a.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e2.baseState;
    g2 = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a, t2 = h2;
          r2 = b2;
          y2 = c2;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2)
                break a;
              q2 = A$2({}, q2, r2);
              break a;
            case 2:
              $g = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
      } else
        y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
      h2 = h2.next;
      if (null === h2)
        if (h2 = e2.shared.pending, null === h2)
          break;
        else
          r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b2 = e2.shared.interleaved;
    if (null !== b2) {
      e2 = b2;
      do
        g2 |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else
      null === f2 && (e2.shared.lanes = 0);
    hh |= g2;
    a.lanes = g2;
    a.memoizedState = q2;
  }
}
function ih(a, b2, c2) {
  a = b2.effects;
  b2.effects = null;
  if (null !== a)
    for (b2 = 0; b2 < a.length; b2++) {
      var d2 = a[b2], e2 = d2.callback;
      if (null !== e2) {
        d2.callback = null;
        d2 = c2;
        if ("function" !== typeof e2)
          throw Error(p$5(191, e2));
        e2.call(d2);
      }
    }
}
var jh = new aa.Component().refs;
function kh(a, b2, c2, d2) {
  b2 = a.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : A$2({}, b2, c2);
  a.memoizedState = c2;
  0 === a.lanes && (a.updateQueue.baseState = c2);
}
var nh = { isMounted: function(a) {
  return (a = a._reactInternals) ? Vb(a) === a : false;
}, enqueueSetState: function(a, b2, c2) {
  a = a._reactInternals;
  var d2 = L(), e2 = lh(a), f2 = ch(d2, e2);
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a, f2, e2);
  null !== b2 && (mh(b2, a, e2, d2), eh(b2, a, e2));
}, enqueueReplaceState: function(a, b2, c2) {
  a = a._reactInternals;
  var d2 = L(), e2 = lh(a), f2 = ch(d2, e2);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a, f2, e2);
  null !== b2 && (mh(b2, a, e2, d2), eh(b2, a, e2));
}, enqueueForceUpdate: function(a, b2) {
  a = a._reactInternals;
  var c2 = L(), d2 = lh(a), e2 = ch(c2, d2);
  e2.tag = 2;
  void 0 !== b2 && null !== b2 && (e2.callback = b2);
  b2 = dh(a, e2, d2);
  null !== b2 && (mh(b2, a, d2, c2), eh(b2, a, d2));
} };
function oh(a, b2, c2, d2, e2, f2, g2) {
  a = a.stateNode;
  return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c2, d2) || !Ie(e2, f2) : true;
}
function ph(a, b2, c2) {
  var d2 = false, e2 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e2 = Zf(b2) ? Xf : H.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a, e2) : Vf);
  b2 = new b2(c2, f2);
  a.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = nh;
  a.stateNode = b2;
  b2._reactInternals = a;
  d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e2, a.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function qh(a, b2, c2, d2) {
  a = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a && nh.enqueueReplaceState(b2, b2.state, null);
}
function rh(a, b2, c2, d2) {
  var e2 = a.stateNode;
  e2.props = c2;
  e2.state = a.memoizedState;
  e2.refs = jh;
  ah(a);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = Vg(f2) : (f2 = Zf(b2) ? Xf : H.current, e2.context = Yf(a, f2));
  e2.state = a.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (kh(a, b2, f2, c2), e2.state = a.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a, c2, e2, d2), e2.state = a.memoizedState);
  "function" === typeof e2.componentDidMount && (a.flags |= 4194308);
}
function sh(a, b2, c2) {
  a = c2.ref;
  if (null !== a && "function" !== typeof a && "object" !== typeof a) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag)
          throw Error(p$5(309));
        var d2 = c2.stateNode;
      }
      if (!d2)
        throw Error(p$5(147, a));
      var e2 = d2, f2 = "" + a;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
        return b2.ref;
      b2 = function(a2) {
        var b3 = e2.refs;
        b3 === jh && (b3 = e2.refs = {});
        null === a2 ? delete b3[f2] : b3[f2] = a2;
      };
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a)
      throw Error(p$5(284));
    if (!c2._owner)
      throw Error(p$5(290, a));
  }
  return a;
}
function th(a, b2) {
  a = Object.prototype.toString.call(b2);
  throw Error(p$5(31, "[object Object]" === a ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a));
}
function uh(a) {
  var b2 = a._init;
  return b2(a._payload);
}
function vh(a) {
  function b2(b3, c3) {
    if (a) {
      var d3 = b3.deletions;
      null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  function c2(c3, d3) {
    if (!a)
      return null;
    for (; null !== d3; )
      b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a2, b3) {
    for (a2 = /* @__PURE__ */ new Map(); null !== b3; )
      null !== b3.key ? a2.set(b3.key, b3) : a2.set(b3.index, b3), b3 = b3.sibling;
    return a2;
  }
  function e2(a2, b3) {
    a2 = wh(a2, b3);
    a2.index = 0;
    a2.sibling = null;
    return a2;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a)
      return b3.flags |= 1048576, c3;
    d3 = b3.alternate;
    if (null !== d3)
      return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
    b3.flags |= 2;
    return c3;
  }
  function g2(b3) {
    a && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h2(a2, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag)
      return b3 = xh(c3, a2.mode, d3), b3.return = a2, b3;
    b3 = e2(b3, c3);
    b3.return = a2;
    return b3;
  }
  function k2(a2, b3, c3, d3) {
    var f3 = c3.type;
    if (f3 === ya)
      return m2(a2, b3, c3.props.children, d3, c3.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && uh(f3) === b3.type))
      return d3 = e2(b3, c3.props), d3.ref = sh(a2, b3, c3), d3.return = a2, d3;
    d3 = yh(c3.type, c3.key, c3.props, null, a2.mode, d3);
    d3.ref = sh(a2, b3, c3);
    d3.return = a2;
    return d3;
  }
  function l2(a2, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
      return b3 = zh(c3, a2.mode, d3), b3.return = a2, b3;
    b3 = e2(b3, c3.children || []);
    b3.return = a2;
    return b3;
  }
  function m2(a2, b3, c3, d3, f3) {
    if (null === b3 || 7 !== b3.tag)
      return b3 = Ah(c3, a2.mode, d3, f3), b3.return = a2, b3;
    b3 = e2(b3, c3);
    b3.return = a2;
    return b3;
  }
  function q2(a2, b3, c3) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
      return b3 = xh("" + b3, a2.mode, c3), b3.return = a2, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c3 = yh(b3.type, b3.key, b3.props, null, a2.mode, c3), c3.ref = sh(a2, null, b3), c3.return = a2, c3;
        case wa:
          return b3 = zh(b3, a2.mode, c3), b3.return = a2, b3;
        case Ha:
          var d3 = b3._init;
          return q2(a2, d3(b3._payload), c3);
      }
      if (eb(b3) || Ka(b3))
        return b3 = Ah(b3, a2.mode, c3, null), b3.return = a2, b3;
      th(a2, b3);
    }
    return null;
  }
  function r2(a2, b3, c3, d3) {
    var e3 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
      return null !== e3 ? null : h2(a2, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e3 ? k2(a2, b3, c3, d3) : null;
        case wa:
          return c3.key === e3 ? l2(a2, b3, c3, d3) : null;
        case Ha:
          return e3 = c3._init, r2(
            a2,
            b3,
            e3(c3._payload),
            d3
          );
      }
      if (eb(c3) || Ka(c3))
        return null !== e3 ? null : m2(a2, b3, c3, d3, null);
      th(a2, c3);
    }
    return null;
  }
  function y2(a2, b3, c3, d3, e3) {
    if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
      return a2 = a2.get(c3) || null, h2(b3, a2, "" + d3, e3);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case va:
          return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a2, d3, e3);
        case wa:
          return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a2, d3, e3);
        case Ha:
          var f3 = d3._init;
          return y2(a2, b3, c3, f3(d3._payload), e3);
      }
      if (eb(d3) || Ka(d3))
        return a2 = a2.get(c3) || null, m2(b3, a2, d3, e3, null);
      th(b3, d3);
    }
    return null;
  }
  function n2(e3, g3, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n3 = r2(e3, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x2);
        break;
      }
      a && u2 && null === n3.alternate && b2(e3, u2);
      g3 = f2(n3, g3, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x2;
    }
    if (w2 === h3.length)
      return c2(e3, u2), I && tg(e3, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++)
        u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I && tg(e3, w2);
      return l3;
    }
    for (u2 = d2(e3, u2); w2 < h3.length; w2++)
      x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a && u2.forEach(function(a2) {
      return b2(e3, a2);
    });
    I && tg(e3, w2);
    return l3;
  }
  function t2(e3, g3, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3)
      throw Error(p$5(150));
    h3 = l3.call(h3);
    if (null == h3)
      throw Error(p$5(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e3, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x2);
        break;
      }
      a && m3 && null === t3.alternate && b2(e3, m3);
      g3 = f2(t3, g3, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x2;
    }
    if (n3.done)
      return c2(
        e3,
        m3
      ), I && tg(e3, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next())
        n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I && tg(e3, w2);
      return l3;
    }
    for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next())
      n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a && m3.forEach(function(a2) {
      return b2(e3, a2);
    });
    I && tg(e3, w2);
    return l3;
  }
  function J2(a2, d3, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d3; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c2(a2, l3.sibling);
                    d3 = e2(l3, f3.props.children);
                    d3.return = a2;
                    a2 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && uh(k3) === l3.type) {
                  c2(a2, l3.sibling);
                  d3 = e2(l3, f3.props);
                  d3.ref = sh(a2, l3, f3);
                  d3.return = a2;
                  a2 = d3;
                  break a;
                }
                c2(a2, l3);
                break;
              } else
                b2(a2, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d3 = Ah(f3.props.children, a2.mode, h3, f3.key), d3.return = a2, a2 = d3) : (h3 = yh(f3.type, f3.key, f3.props, null, a2.mode, h3), h3.ref = sh(a2, d3, f3), h3.return = a2, a2 = h3);
          }
          return g2(a2);
        case wa:
          a: {
            for (l3 = f3.key; null !== d3; ) {
              if (d3.key === l3)
                if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a2, d3.sibling);
                  d3 = e2(d3, f3.children || []);
                  d3.return = a2;
                  a2 = d3;
                  break a;
                } else {
                  c2(a2, d3);
                  break;
                }
              else
                b2(a2, d3);
              d3 = d3.sibling;
            }
            d3 = zh(f3, a2.mode, h3);
            d3.return = a2;
            a2 = d3;
          }
          return g2(a2);
        case Ha:
          return l3 = f3._init, J2(a2, d3, l3(f3._payload), h3);
      }
      if (eb(f3))
        return n2(a2, d3, f3, h3);
      if (Ka(f3))
        return t2(a2, d3, f3, h3);
      th(a2, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a2, d3.sibling), d3 = e2(d3, f3), d3.return = a2, a2 = d3) : (c2(a2, d3), d3 = xh(f3, a2.mode, h3), d3.return = a2, a2 = d3), g2(a2)) : c2(a2, d3);
  }
  return J2;
}
var Bh = vh(true), Ch = vh(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
function Hh(a) {
  if (a === Dh)
    throw Error(p$5(174));
  return a;
}
function Ih(a, b2) {
  G(Gh, b2);
  G(Fh, a);
  G(Eh, Dh);
  a = b2.nodeType;
  switch (a) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a = 8 === a ? b2.parentNode : b2, b2 = a.namespaceURI || null, a = a.tagName, b2 = lb(b2, a);
  }
  E(Eh);
  G(Eh, b2);
}
function Jh() {
  E(Eh);
  E(Fh);
  E(Gh);
}
function Kh(a) {
  Hh(Gh.current);
  var b2 = Hh(Eh.current);
  var c2 = lb(b2, a.type);
  b2 !== c2 && (G(Fh, a), G(Eh, c2));
}
function Lh(a) {
  Fh.current === a && (E(Eh), E(Fh));
}
var M = Uf(0);
function Mh(a) {
  for (var b2 = a; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
        return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128))
        return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a)
      break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Nh = [];
function Oh() {
  for (var a = 0; a < Nh.length; a++)
    Nh[a]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N = null, O = null, P = null, Sh = false, Th = false, Uh = 0, Vh = 0;
function Q() {
  throw Error(p$5(321));
}
function Wh(a, b2) {
  if (null === b2)
    return false;
  for (var c2 = 0; c2 < b2.length && c2 < a.length; c2++)
    if (!He(a[c2], b2[c2]))
      return false;
  return true;
}
function Xh(a, b2, c2, d2, e2, f2) {
  Rh = f2;
  N = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Ph.current = null === a || null === a.memoizedState ? Yh : Zh;
  a = c2(d2, e2);
  if (Th) {
    f2 = 0;
    do {
      Th = false;
      Uh = 0;
      if (25 <= f2)
        throw Error(p$5(301));
      f2 += 1;
      P = O = null;
      b2.updateQueue = null;
      Ph.current = $h;
      a = c2(d2, e2);
    } while (Th);
  }
  Ph.current = ai;
  b2 = null !== O && null !== O.next;
  Rh = 0;
  P = O = N = null;
  Sh = false;
  if (b2)
    throw Error(p$5(300));
  return a;
}
function bi() {
  var a = 0 !== Uh;
  Uh = 0;
  return a;
}
function ci() {
  var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === P ? N.memoizedState = P = a : P = P.next = a;
  return P;
}
function di() {
  if (null === O) {
    var a = N.alternate;
    a = null !== a ? a.memoizedState : null;
  } else
    a = O.next;
  var b2 = null === P ? N.memoizedState : P.next;
  if (null !== b2)
    P = b2, O = a;
  else {
    if (null === a)
      throw Error(p$5(310));
    O = a;
    a = { memoizedState: O.memoizedState, baseState: O.baseState, baseQueue: O.baseQueue, queue: O.queue, next: null };
    null === P ? N.memoizedState = P = a : P = P.next = a;
  }
  return P;
}
function ei(a, b2) {
  return "function" === typeof b2 ? b2(a) : b2;
}
function fi(a) {
  var b2 = di(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$5(311));
  c2.lastRenderedReducer = a;
  var d2 = O, e2 = d2.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g2 = e2.next;
      e2.next = f2.next;
      f2.next = g2;
    }
    d2.baseQueue = e2 = f2;
    c2.pending = null;
  }
  if (null !== e2) {
    f2 = e2.next;
    d2 = d2.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Rh & m2) === m2)
        null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a(d2, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
        N.lanes |= m2;
        hh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g2 = d2 : k2.next = h2;
    He(d2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = d2;
    b2.baseState = g2;
    b2.baseQueue = k2;
    c2.lastRenderedState = d2;
  }
  a = c2.interleaved;
  if (null !== a) {
    e2 = a;
    do
      f2 = e2.lane, N.lanes |= f2, hh |= f2, e2 = e2.next;
    while (e2 !== a);
  } else
    null === e2 && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
function gi(a) {
  var b2 = di(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$5(311));
  c2.lastRenderedReducer = a;
  var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
  if (null !== e2) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He(f2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function hi() {
}
function ii(a, b2) {
  var c2 = N, d2 = di(), e2 = b2(), f2 = !He(d2.memoizedState, e2);
  f2 && (d2.memoizedState = e2, Ug = true);
  d2 = d2.queue;
  ji(ki.bind(null, c2, d2, a), [a]);
  if (d2.getSnapshot !== b2 || f2 || null !== P && P.memoizedState.tag & 1) {
    c2.flags |= 2048;
    li(9, mi.bind(null, c2, d2, e2, b2), void 0, null);
    if (null === R)
      throw Error(p$5(349));
    0 !== (Rh & 30) || ni(c2, b2, e2);
  }
  return e2;
}
function ni(a, b2, c2) {
  a.flags |= 16384;
  a = { getSnapshot: b2, value: c2 };
  b2 = N.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N.updateQueue = b2, b2.stores = [a]) : (c2 = b2.stores, null === c2 ? b2.stores = [a] : c2.push(a));
}
function mi(a, b2, c2, d2) {
  b2.value = c2;
  b2.getSnapshot = d2;
  oi(b2) && pi(a);
}
function ki(a, b2, c2) {
  return c2(function() {
    oi(b2) && pi(a);
  });
}
function oi(a) {
  var b2 = a.getSnapshot;
  a = a.value;
  try {
    var c2 = b2();
    return !He(a, c2);
  } catch (d2) {
    return true;
  }
}
function pi(a) {
  var b2 = Zg(a, 1);
  null !== b2 && mh(b2, a, 1, -1);
}
function qi(a) {
  var b2 = ci();
  "function" === typeof a && (a = a());
  b2.memoizedState = b2.baseState = a;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a };
  b2.queue = a;
  a = a.dispatch = ri.bind(null, N, a);
  return [b2.memoizedState, a];
}
function li(a, b2, c2, d2) {
  a = { tag: a, create: b2, destroy: c2, deps: d2, next: null };
  b2 = N.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N.updateQueue = b2, b2.lastEffect = a.next = a) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a.next = a : (d2 = c2.next, c2.next = a, a.next = d2, b2.lastEffect = a));
  return a;
}
function si() {
  return di().memoizedState;
}
function ti(a, b2, c2, d2) {
  var e2 = ci();
  N.flags |= a;
  e2.memoizedState = li(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
}
function ui(a, b2, c2, d2) {
  var e2 = di();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== O) {
    var g2 = O.memoizedState;
    f2 = g2.destroy;
    if (null !== d2 && Wh(d2, g2.deps)) {
      e2.memoizedState = li(b2, c2, f2, d2);
      return;
    }
  }
  N.flags |= a;
  e2.memoizedState = li(1 | b2, c2, f2, d2);
}
function vi(a, b2) {
  return ti(8390656, 8, a, b2);
}
function ji(a, b2) {
  return ui(2048, 8, a, b2);
}
function wi(a, b2) {
  return ui(4, 2, a, b2);
}
function xi(a, b2) {
  return ui(4, 4, a, b2);
}
function yi(a, b2) {
  if ("function" === typeof b2)
    return a = a(), b2(a), function() {
      b2(null);
    };
  if (null !== b2 && void 0 !== b2)
    return a = a(), b2.current = a, function() {
      b2.current = null;
    };
}
function zi(a, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
  return ui(4, 4, yi.bind(null, b2, a), c2);
}
function Ai() {
}
function Bi(a, b2) {
  var c2 = di();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  c2.memoizedState = [a, b2];
  return a;
}
function Ci(a, b2) {
  var c2 = di();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  a = a();
  c2.memoizedState = [a, b2];
  return a;
}
function Di(a, b2, c2) {
  if (0 === (Rh & 21))
    return a.baseState && (a.baseState = false, Ug = true), a.memoizedState = c2;
  He(c2, b2) || (c2 = yc(), N.lanes |= c2, hh |= c2, a.baseState = true);
  return b2;
}
function Ei(a, b2) {
  var c2 = C;
  C = 0 !== c2 && 4 > c2 ? c2 : 4;
  a(true);
  var d2 = Qh.transition;
  Qh.transition = {};
  try {
    a(false), b2();
  } finally {
    C = c2, Qh.transition = d2;
  }
}
function Fi() {
  return di().memoizedState;
}
function Gi(a, b2, c2) {
  var d2 = lh(a);
  c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a))
    Ii(b2, c2);
  else if (c2 = Yg(a, b2, c2, d2), null !== c2) {
    var e2 = L();
    mh(c2, a, d2, e2);
    Ji(c2, b2, d2);
  }
}
function ri(a, b2, c2) {
  var d2 = lh(a), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a))
    Ii(b2, e2);
  else {
    var f2 = a.alternate;
    if (0 === a.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
      try {
        var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
        e2.hasEagerState = true;
        e2.eagerState = h2;
        if (He(h2, g2)) {
          var k2 = b2.interleaved;
          null === k2 ? (e2.next = e2, Xg(b2)) : (e2.next = k2.next, k2.next = e2);
          b2.interleaved = e2;
          return;
        }
      } catch (l2) {
      } finally {
      }
    c2 = Yg(a, b2, e2, d2);
    null !== c2 && (e2 = L(), mh(c2, a, d2, e2), Ji(c2, b2, d2));
  }
}
function Hi(a) {
  var b2 = a.alternate;
  return a === N || null !== b2 && b2 === N;
}
function Ii(a, b2) {
  Th = Sh = true;
  var c2 = a.pending;
  null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a.pending = b2;
}
function Ji(a, b2, c2) {
  if (0 !== (c2 & 4194240)) {
    var d2 = b2.lanes;
    d2 &= a.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a, c2);
  }
}
var ai = { readContext: Vg, useCallback: Q, useContext: Q, useEffect: Q, useImperativeHandle: Q, useInsertionEffect: Q, useLayoutEffect: Q, useMemo: Q, useReducer: Q, useRef: Q, useState: Q, useDebugValue: Q, useDeferredValue: Q, useTransition: Q, useMutableSource: Q, useSyncExternalStore: Q, useId: Q, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a, b2) {
  ci().memoizedState = [a, void 0 === b2 ? null : b2];
  return a;
}, useContext: Vg, useEffect: vi, useImperativeHandle: function(a, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
  return ti(
    4194308,
    4,
    yi.bind(null, b2, a),
    c2
  );
}, useLayoutEffect: function(a, b2) {
  return ti(4194308, 4, a, b2);
}, useInsertionEffect: function(a, b2) {
  return ti(4, 2, a, b2);
}, useMemo: function(a, b2) {
  var c2 = ci();
  b2 = void 0 === b2 ? null : b2;
  a = a();
  c2.memoizedState = [a, b2];
  return a;
}, useReducer: function(a, b2, c2) {
  var d2 = ci();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b2 };
  d2.queue = a;
  a = a.dispatch = Gi.bind(null, N, a);
  return [d2.memoizedState, a];
}, useRef: function(a) {
  var b2 = ci();
  a = { current: a };
  return b2.memoizedState = a;
}, useState: qi, useDebugValue: Ai, useDeferredValue: function(a) {
  return ci().memoizedState = a;
}, useTransition: function() {
  var a = qi(false), b2 = a[0];
  a = Ei.bind(null, a[1]);
  ci().memoizedState = a;
  return [b2, a];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a, b2, c2) {
  var d2 = N, e2 = ci();
  if (I) {
    if (void 0 === c2)
      throw Error(p$5(407));
    c2 = c2();
  } else {
    c2 = b2();
    if (null === R)
      throw Error(p$5(349));
    0 !== (Rh & 30) || ni(d2, b2, c2);
  }
  e2.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  e2.queue = f2;
  vi(ki.bind(
    null,
    d2,
    f2,
    a
  ), [a]);
  d2.flags |= 2048;
  li(9, mi.bind(null, d2, f2, c2, b2), void 0, null);
  return c2;
}, useId: function() {
  var a = ci(), b2 = R.identifierPrefix;
  if (I) {
    var c2 = sg;
    var d2 = rg;
    c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
    b2 = ":" + b2 + "R" + c2;
    c2 = Uh++;
    0 < c2 && (b2 += "H" + c2.toString(32));
    b2 += ":";
  } else
    c2 = Vh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a.memoizedState = b2;
}, unstable_isNewReconciler: false }, Zh = {
  readContext: Vg,
  useCallback: Bi,
  useContext: Vg,
  useEffect: ji,
  useImperativeHandle: zi,
  useInsertionEffect: wi,
  useLayoutEffect: xi,
  useMemo: Ci,
  useReducer: fi,
  useRef: si,
  useState: function() {
    return fi(ei);
  },
  useDebugValue: Ai,
  useDeferredValue: function(a) {
    var b2 = di();
    return Di(b2, O.memoizedState, a);
  },
  useTransition: function() {
    var a = fi(ei)[0], b2 = di().memoizedState;
    return [a, b2];
  },
  useMutableSource: hi,
  useSyncExternalStore: ii,
  useId: Fi,
  unstable_isNewReconciler: false
}, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
  return gi(ei);
}, useDebugValue: Ai, useDeferredValue: function(a) {
  var b2 = di();
  return null === O ? b2.memoizedState = a : Di(b2, O.memoizedState, a);
}, useTransition: function() {
  var a = gi(ei)[0], b2 = di().memoizedState;
  return [a, b2];
}, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
function Ki(a, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Pa(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a, source: b2, stack: e2, digest: null };
}
function Li(a, b2, c2) {
  return { value: a, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
}
function Mi(a, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Ni = "function" === typeof WeakMap ? WeakMap : Map;
function Oi(a, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Pi || (Pi = true, Qi = d2);
    Mi(a, b2);
  };
  return c2;
}
function Ri(a, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  var d2 = a.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e2 = b2.value;
    c2.payload = function() {
      return d2(e2);
    };
    c2.callback = function() {
      Mi(a, b2);
    };
  }
  var f2 = a.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    Mi(a, b2);
    "function" !== typeof d2 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
function Ti(a, b2, c2) {
  var d2 = a.pingCache;
  if (null === d2) {
    d2 = a.pingCache = new Ni();
    var e2 = /* @__PURE__ */ new Set();
    d2.set(b2, e2);
  } else
    e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
  e2.has(c2) || (e2.add(c2), a = Ui.bind(null, a, b2, c2), b2.then(a, a));
}
function Vi(a) {
  do {
    var b2;
    if (b2 = 13 === a.tag)
      b2 = a.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2)
      return a;
    a = a.return;
  } while (null !== a);
  return null;
}
function Wi(a, b2, c2, d2, e2) {
  if (0 === (a.mode & 1))
    return a === b2 ? a.flags |= 65536 : (a.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c2, b2, 1))), c2.lanes |= 1), a;
  a.flags |= 65536;
  a.lanes = e2;
  return a;
}
var Xi = ua.ReactCurrentOwner, Ug = false;
function Yi(a, b2, c2, d2) {
  b2.child = null === a ? Ch(b2, null, c2, d2) : Bh(b2, a.child, c2, d2);
}
function Zi(a, b2, c2, d2, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  Tg(b2, e2);
  d2 = Xh(a, b2, c2, d2, f2, e2);
  c2 = bi();
  if (null !== a && !Ug)
    return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, $i(a, b2, e2);
  I && c2 && vg(b2);
  b2.flags |= 1;
  Yi(a, b2, d2, e2);
  return b2.child;
}
function aj(a, b2, c2, d2, e2) {
  if (null === a) {
    var f2 = c2.type;
    if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
      return b2.tag = 15, b2.type = f2, cj(a, b2, f2, d2, e2);
    a = yh(c2.type, null, d2, b2, b2.mode, e2);
    a.ref = b2.ref;
    a.return = b2;
    return b2.child = a;
  }
  f2 = a.child;
  if (0 === (a.lanes & e2)) {
    var g2 = f2.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie;
    if (c2(g2, d2) && a.ref === b2.ref)
      return $i(a, b2, e2);
  }
  b2.flags |= 1;
  a = wh(f2, d2);
  a.ref = b2.ref;
  a.return = b2;
  return b2.child = a;
}
function cj(a, b2, c2, d2, e2) {
  if (null !== a) {
    var f2 = a.memoizedProps;
    if (Ie(f2, d2) && a.ref === b2.ref)
      if (Ug = false, b2.pendingProps = d2 = f2, 0 !== (a.lanes & e2))
        0 !== (a.flags & 131072) && (Ug = true);
      else
        return b2.lanes = a.lanes, $i(a, b2, e2);
  }
  return dj(a, b2, c2, d2, e2);
}
function ej(a, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a ? a.memoizedState : null;
  if ("hidden" === d2.mode)
    if (0 === (b2.mode & 1))
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(fj, gj), gj |= c2;
    else {
      if (0 === (c2 & 1073741824))
        return a = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b2.updateQueue = null, G(fj, gj), gj |= a, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d2 = null !== f2 ? f2.baseLanes : c2;
      G(fj, gj);
      gj |= d2;
    }
  else
    null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G(fj, gj), gj |= d2;
  Yi(a, b2, e2, c2);
  return b2.child;
}
function hj(a, b2) {
  var c2 = b2.ref;
  if (null === a && null !== c2 || null !== a && a.ref !== c2)
    b2.flags |= 512, b2.flags |= 2097152;
}
function dj(a, b2, c2, d2, e2) {
  var f2 = Zf(c2) ? Xf : H.current;
  f2 = Yf(b2, f2);
  Tg(b2, e2);
  c2 = Xh(a, b2, c2, d2, f2, e2);
  d2 = bi();
  if (null !== a && !Ug)
    return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, $i(a, b2, e2);
  I && d2 && vg(b2);
  b2.flags |= 1;
  Yi(a, b2, c2, e2);
  return b2.child;
}
function ij(a, b2, c2, d2, e2) {
  if (Zf(c2)) {
    var f2 = true;
    cg(b2);
  } else
    f2 = false;
  Tg(b2, e2);
  if (null === b2.stateNode)
    jj(a, b2), ph(b2, c2, d2), rh(b2, c2, d2, e2), d2 = true;
  else if (null === a) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H.current, l2 = Yf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && qh(b2, g2, d2, l2);
    $g = false;
    var r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e2);
    k2 = b2.memoizedState;
    h2 !== d2 || r2 !== k2 || Wf.current || $g ? ("function" === typeof m2 && (kh(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = $g || oh(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
  } else {
    g2 = b2.stateNode;
    bh(a, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2);
    g2.props = l2;
    q2 = b2.pendingProps;
    r2 = g2.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c2) ? Xf : H.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && qh(b2, g2, d2, k2);
    $g = false;
    r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e2);
    var n2 = b2.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = $g || oh(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), d2 = false);
  }
  return kj(a, b2, c2, d2, f2, e2);
}
function kj(a, b2, c2, d2, e2, f2) {
  hj(a, b2);
  var g2 = 0 !== (b2.flags & 128);
  if (!d2 && !g2)
    return e2 && dg(b2, c2, false), $i(a, b2, f2);
  d2 = b2.stateNode;
  Xi.current = b2;
  var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.flags |= 1;
  null !== a && g2 ? (b2.child = Bh(b2, a.child, null, f2), b2.child = Bh(b2, null, h2, f2)) : Yi(a, b2, h2, f2);
  b2.memoizedState = d2.state;
  e2 && dg(b2, c2, true);
  return b2.child;
}
function lj(a) {
  var b2 = a.stateNode;
  b2.pendingContext ? ag(a, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a, b2.context, false);
  Ih(a, b2.containerInfo);
}
function mj(a, b2, c2, d2, e2) {
  Ig();
  Jg(e2);
  b2.flags |= 256;
  Yi(a, b2, c2, d2);
  return b2.child;
}
var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
function oj(a) {
  return { baseLanes: a, cachePool: null, transitions: null };
}
function pj(a, b2, c2) {
  var d2 = b2.pendingProps, e2 = M.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
  (h2 = g2) || (h2 = null !== a && null === a.memoizedState ? false : 0 !== (e2 & 2));
  if (h2)
    f2 = true, b2.flags &= -129;
  else if (null === a || null !== a.memoizedState)
    e2 |= 1;
  G(M, e2 & 1);
  if (null === a) {
    Eg(b2);
    a = b2.memoizedState;
    if (null !== a && (a = a.dehydrated, null !== a))
      return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g2 = d2.children;
    a = d2.fallback;
    return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = qj(g2, d2, 0, null), a = Ah(a, d2, c2, null), f2.return = b2, a.return = b2, f2.sibling = a, b2.child = f2, b2.child.memoizedState = oj(c2), b2.memoizedState = nj, a) : rj(b2, g2);
  }
  e2 = a.memoizedState;
  if (null !== e2 && (h2 = e2.dehydrated, null !== h2))
    return sj(a, b2, g2, d2, h2, e2, c2);
  if (f2) {
    f2 = d2.fallback;
    g2 = b2.mode;
    e2 = a.child;
    h2 = e2.sibling;
    var k2 = { mode: "hidden", children: d2.children };
    0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = wh(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h2 ? f2 = wh(h2, f2) : (f2 = Ah(f2, g2, c2, null), f2.flags |= 2);
    f2.return = b2;
    d2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    d2 = f2;
    f2 = b2.child;
    g2 = a.child.memoizedState;
    g2 = null === g2 ? oj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a.childLanes & ~c2;
    b2.memoizedState = nj;
    return d2;
  }
  f2 = a.child;
  a = f2.sibling;
  d2 = wh(f2, { mode: "visible", children: d2.children });
  0 === (b2.mode & 1) && (d2.lanes = c2);
  d2.return = b2;
  d2.sibling = null;
  null !== a && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a], b2.flags |= 16) : c2.push(a));
  b2.child = d2;
  b2.memoizedState = null;
  return d2;
}
function rj(a, b2) {
  b2 = qj({ mode: "visible", children: b2 }, a.mode, 0, null);
  b2.return = a;
  return a.child = b2;
}
function tj(a, b2, c2, d2) {
  null !== d2 && Jg(d2);
  Bh(b2, a.child, null, c2);
  a = rj(b2, b2.pendingProps.children);
  a.flags |= 2;
  b2.memoizedState = null;
  return a;
}
function sj(a, b2, c2, d2, e2, f2, g2) {
  if (c2) {
    if (b2.flags & 256)
      return b2.flags &= -257, d2 = Li(Error(p$5(422))), tj(a, b2, g2, d2);
    if (null !== b2.memoizedState)
      return b2.child = a.child, b2.flags |= 128, null;
    f2 = d2.fallback;
    e2 = b2.mode;
    d2 = qj({ mode: "visible", children: d2.children }, e2, 0, null);
    f2 = Ah(f2, e2, g2, null);
    f2.flags |= 2;
    d2.return = b2;
    f2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    0 !== (b2.mode & 1) && Bh(b2, a.child, null, g2);
    b2.child.memoizedState = oj(g2);
    b2.memoizedState = nj;
    return f2;
  }
  if (0 === (b2.mode & 1))
    return tj(a, b2, g2, null);
  if ("$!" === e2.data) {
    d2 = e2.nextSibling && e2.nextSibling.dataset;
    if (d2)
      var h2 = d2.dgst;
    d2 = h2;
    f2 = Error(p$5(419));
    d2 = Li(f2, d2, void 0);
    return tj(a, b2, g2, d2);
  }
  h2 = 0 !== (g2 & a.childLanes);
  if (Ug || h2) {
    d2 = R;
    if (null !== d2) {
      switch (g2 & -g2) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
      0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, Zg(a, e2), mh(d2, a, e2, -1));
    }
    uj();
    d2 = Li(Error(p$5(421)));
    return tj(a, b2, g2, d2);
  }
  if ("$?" === e2.data)
    return b2.flags |= 128, b2.child = a.child, b2 = vj.bind(null, a), e2._reactRetry = b2, null;
  a = f2.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b2;
  I = true;
  zg = null;
  null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b2);
  b2 = rj(b2, d2.children);
  b2.flags |= 4096;
  return b2;
}
function wj(a, b2, c2) {
  a.lanes |= b2;
  var d2 = a.alternate;
  null !== d2 && (d2.lanes |= b2);
  Sg(a.return, b2, c2);
}
function xj(a, b2, c2, d2, e2) {
  var f2 = a.memoizedState;
  null === f2 ? a.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
}
function yj(a, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
  Yi(a, b2, d2.children, c2);
  d2 = M.current;
  if (0 !== (d2 & 2))
    d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a && 0 !== (a.flags & 128))
      a:
        for (a = b2.child; null !== a; ) {
          if (13 === a.tag)
            null !== a.memoizedState && wj(a, c2, b2);
          else if (19 === a.tag)
            wj(a, c2, b2);
          else if (null !== a.child) {
            a.child.return = a;
            a = a.child;
            continue;
          }
          if (a === b2)
            break a;
          for (; null === a.sibling; ) {
            if (null === a.return || a.return === b2)
              break a;
            a = a.return;
          }
          a.sibling.return = a.return;
          a = a.sibling;
        }
    d2 &= 1;
  }
  G(M, d2);
  if (0 === (b2.mode & 1))
    b2.memoizedState = null;
  else
    switch (e2) {
      case "forwards":
        c2 = b2.child;
        for (e2 = null; null !== c2; )
          a = c2.alternate, null !== a && null === Mh(a) && (e2 = c2), c2 = c2.sibling;
        c2 = e2;
        null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
        xj(b2, false, e2, c2, f2);
        break;
      case "backwards":
        c2 = null;
        e2 = b2.child;
        for (b2.child = null; null !== e2; ) {
          a = e2.alternate;
          if (null !== a && null === Mh(a)) {
            b2.child = e2;
            break;
          }
          a = e2.sibling;
          e2.sibling = c2;
          c2 = e2;
          e2 = a;
        }
        xj(b2, true, c2, null, f2);
        break;
      case "together":
        xj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
function jj(a, b2) {
  0 === (b2.mode & 1) && null !== a && (a.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function $i(a, b2, c2) {
  null !== a && (b2.dependencies = a.dependencies);
  hh |= b2.lanes;
  if (0 === (c2 & b2.childLanes))
    return null;
  if (null !== a && b2.child !== a.child)
    throw Error(p$5(153));
  if (null !== b2.child) {
    a = b2.child;
    c2 = wh(a, a.pendingProps);
    b2.child = c2;
    for (c2.return = b2; null !== a.sibling; )
      a = a.sibling, c2 = c2.sibling = wh(a, a.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function zj(a, b2, c2) {
  switch (b2.tag) {
    case 3:
      lj(b2);
      Ig();
      break;
    case 5:
      Kh(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      Ih(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e2 = b2.memoizedProps.value;
      G(Mg, d2._currentValue);
      d2._currentValue = e2;
      break;
    case 13:
      d2 = b2.memoizedState;
      if (null !== d2) {
        if (null !== d2.dehydrated)
          return G(M, M.current & 1), b2.flags |= 128, null;
        if (0 !== (c2 & b2.child.childLanes))
          return pj(a, b2, c2);
        G(M, M.current & 1);
        a = $i(a, b2, c2);
        return null !== a ? a.sibling : null;
      }
      G(M, M.current & 1);
      break;
    case 19:
      d2 = 0 !== (c2 & b2.childLanes);
      if (0 !== (a.flags & 128)) {
        if (d2)
          return yj(a, b2, c2);
        b2.flags |= 128;
      }
      e2 = b2.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G(M, M.current);
      if (d2)
        break;
      else
        return null;
    case 22:
    case 23:
      return b2.lanes = 0, ej(a, b2, c2);
  }
  return $i(a, b2, c2);
}
var Aj, Bj, Cj, Dj;
Aj = function(a, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag)
      a.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Bj = function() {
};
Cj = function(a, b2, c2, d2) {
  var e2 = a.memoizedProps;
  if (e2 !== d2) {
    a = b2.stateNode;
    Hh(Eh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a, e2);
        d2 = Ya(a, d2);
        f2 = [];
        break;
      case "select":
        e2 = A$2({}, e2, { value: void 0 });
        d2 = A$2({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb(a, e2);
        d2 = gb(a, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a.onclick = Bf);
    }
    ub(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e2)
      if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
        if ("style" === l2) {
          var h2 = e2[l2];
          for (g2 in h2)
            h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
        if ("style" === l2)
          if (h2) {
            for (g2 in h2)
              !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
            for (g2 in k2)
              k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
          } else
            c2 || (f2 || (f2 = []), f2.push(
              l2,
              c2
            )), c2 = k2;
        else
          "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D("scroll", a), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    if (b2.updateQueue = l2)
      b2.flags |= 4;
  }
};
Dj = function(a, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
};
function Ej(a, b2) {
  if (!I)
    switch (a.tailMode) {
      case "hidden":
        b2 = a.tail;
        for (var c2 = null; null !== b2; )
          null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
        null === c2 ? a.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a.tail;
        for (var d2 = null; null !== c2; )
          null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
        null === d2 ? b2 || null === a.tail ? a.tail = null : a.tail.sibling = null : d2.sibling = null;
    }
}
function S(a) {
  var b2 = null !== a.alternate && a.alternate.child === a.child, c2 = 0, d2 = 0;
  if (b2)
    for (var e2 = a.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a, e2 = e2.sibling;
  else
    for (e2 = a.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a, e2 = e2.sibling;
  a.subtreeFlags |= d2;
  a.childLanes = c2;
  return b2;
}
function Fj(a, b2, c2) {
  var d2 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S(b2), null;
    case 3:
      d2 = b2.stateNode;
      Jh();
      E(Wf);
      E(H);
      Oh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a || null === a.child)
        Gg(b2) ? b2.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Gj(zg), zg = null));
      Bj(a, b2);
      S(b2);
      return null;
    case 5:
      Lh(b2);
      var e2 = Hh(Gh.current);
      c2 = b2.type;
      if (null !== a && null != b2.stateNode)
        Cj(a, b2, c2, d2, e2), a.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (null === b2.stateNode)
            throw Error(p$5(166));
          S(b2);
          return null;
        }
        a = Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[Of] = b2;
          d2[Pf] = f2;
          a = 0 !== (b2.mode & 1);
          switch (c2) {
            case "dialog":
              D("cancel", d2);
              D("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D("load", d2);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++)
                D(lf[e2], d2);
              break;
            case "source":
              D("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D(
                "error",
                d2
              );
              D("load", d2);
              break;
            case "details":
              D("toggle", d2);
              break;
            case "input":
              Za(d2, f2);
              D("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              D("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), D("invalid", d2);
          }
          ub(c2, f2);
          e2 = null;
          for (var g2 in f2)
            if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                d2.textContent,
                h2,
                a
              ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D("scroll", d2);
            }
          switch (c2) {
            case "input":
              Va(d2);
              db(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = Bf);
          }
          d2 = e2;
          b2.updateQueue = d2;
          null !== d2 && (b2.flags |= 4);
        } else {
          g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a && (a = kb(c2));
          "http://www.w3.org/1999/xhtml" === a ? "script" === c2 ? (a = g2.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d2.is ? a = g2.createElement(c2, { is: d2.is }) : (a = g2.createElement(c2), "select" === c2 && (g2 = a, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a = g2.createElementNS(a, c2);
          a[Of] = b2;
          a[Pf] = d2;
          Aj(a, b2, false, false);
          b2.stateNode = a;
          a: {
            g2 = vb(c2, d2);
            switch (c2) {
              case "dialog":
                D("cancel", a);
                D("close", a);
                e2 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", a);
                e2 = d2;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++)
                  D(lf[e2], a);
                e2 = d2;
                break;
              case "source":
                D("error", a);
                e2 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  a
                );
                D("load", a);
                e2 = d2;
                break;
              case "details":
                D("toggle", a);
                e2 = d2;
                break;
              case "input":
                Za(a, d2);
                e2 = Ya(a, d2);
                D("invalid", a);
                break;
              case "option":
                e2 = d2;
                break;
              case "select":
                a._wrapperState = { wasMultiple: !!d2.multiple };
                e2 = A$2({}, d2, { value: void 0 });
                D("invalid", a);
                break;
              case "textarea":
                hb(a, d2);
                e2 = gb(a, d2);
                D("invalid", a);
                break;
              default:
                e2 = d2;
            }
            ub(c2, e2);
            h2 = e2;
            for (f2 in h2)
              if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb(a, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a, k2) : "number" === typeof k2 && ob(a, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D("scroll", a) : null != k2 && ta(a, f2, k2, g2));
              }
            switch (c2) {
              case "input":
                Va(a);
                db(a, d2, false);
                break;
              case "textarea":
                Va(a);
                jb(a);
                break;
              case "option":
                null != d2.value && a.setAttribute("value", "" + Sa(d2.value));
                break;
              case "select":
                a.multiple = !!d2.multiple;
                f2 = d2.value;
                null != f2 ? fb(a, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                  a,
                  !!d2.multiple,
                  d2.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S(b2);
      return null;
    case 6:
      if (a && null != b2.stateNode)
        Dj(a, b2, a.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b2.stateNode)
          throw Error(p$5(166));
        c2 = Hh(Gh.current);
        Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.memoizedProps;
          d2[Of] = b2;
          if (f2 = d2.nodeValue !== c2) {
            if (a = xg, null !== a)
              switch (a.tag) {
                case 3:
                  Af(d2.nodeValue, c2, 0 !== (a.mode & 1));
                  break;
                case 5:
                  true !== a.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a.mode & 1));
              }
          }
          f2 && (b2.flags |= 4);
        } else
          d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
      }
      S(b2);
      return null;
    case 13:
      E(M);
      d2 = b2.memoizedState;
      if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
        if (I && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
          Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
          if (null === a) {
            if (!f2)
              throw Error(p$5(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2)
              throw Error(p$5(317));
            f2[Of] = b2;
          } else
            Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S(b2);
          f2 = false;
        } else
          null !== zg && (Gj(zg), zg = null), f2 = true;
        if (!f2)
          return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128))
        return b2.lanes = c2, b2;
      d2 = null !== d2;
      d2 !== (null !== a && null !== a.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a || 0 !== (M.current & 1) ? 0 === T && (T = 3) : uj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S(b2);
      return null;
    case 4:
      return Jh(), Bj(a, b2), null === a && sf(b2.stateNode.containerInfo), S(b2), null;
    case 10:
      return Rg(b2.type._context), S(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S(b2), null;
    case 19:
      E(M);
      f2 = b2.memoizedState;
      if (null === f2)
        return S(b2), null;
      d2 = 0 !== (b2.flags & 128);
      g2 = f2.rendering;
      if (null === g2)
        if (d2)
          Ej(f2, false);
        else {
          if (0 !== T || null !== a && 0 !== (a.flags & 128))
            for (a = b2.child; null !== a; ) {
              g2 = Mh(a);
              if (null !== g2) {
                b2.flags |= 128;
                Ej(f2, false);
                d2 = g2.updateQueue;
                null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
                b2.subtreeFlags = 0;
                d2 = c2;
                for (c2 = b2.child; null !== c2; )
                  f2 = c2, a = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a = g2.dependencies, f2.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c2 = c2.sibling;
                G(M, M.current & 1 | 2);
                return b2.child;
              }
              a = a.sibling;
            }
          null !== f2.tail && B() > Hj && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        }
      else {
        if (!d2)
          if (a = Mh(g2), null !== a) {
            if (b2.flags |= 128, d2 = true, c2 = a.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I)
              return S(b2), null;
          } else
            2 * B() - f2.renderingStartTime > Hj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      if (null !== f2.tail)
        return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B(), b2.sibling = null, c2 = M.current, G(M, d2 ? c2 & 1 | 2 : c2 & 1), b2;
      S(b2);
      return null;
    case 22:
    case 23:
      return Ij(), d2 = null !== b2.memoizedState, null !== a && null !== a.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (gj & 1073741824) && (S(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$5(156, b2.tag));
}
function Jj(a, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a = b2.flags, a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
    case 3:
      return Jh(), E(Wf), E(H), Oh(), a = b2.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b2.flags = a & -65537 | 128, b2) : null;
    case 5:
      return Lh(b2), null;
    case 13:
      E(M);
      a = b2.memoizedState;
      if (null !== a && null !== a.dehydrated) {
        if (null === b2.alternate)
          throw Error(p$5(340));
        Ig();
      }
      a = b2.flags;
      return a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
    case 19:
      return E(M), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(b2.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Kj = false, U = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
function Mj(a, b2) {
  var c2 = a.ref;
  if (null !== c2)
    if ("function" === typeof c2)
      try {
        c2(null);
      } catch (d2) {
        W(a, b2, d2);
      }
    else
      c2.current = null;
}
function Nj(a, b2, c2) {
  try {
    c2();
  } catch (d2) {
    W(a, b2, d2);
  }
}
var Oj = false;
function Pj(a, b2) {
  Cf = dd;
  a = Me();
  if (Ne(a)) {
    if ("selectionStart" in a)
      var c2 = { start: a.selectionStart, end: a.selectionEnd };
    else
      a: {
        c2 = (c2 = a.ownerDocument) && c2.defaultView || window;
        var d2 = c2.getSelection && c2.getSelection();
        if (d2 && 0 !== d2.rangeCount) {
          c2 = d2.anchorNode;
          var e2 = d2.anchorOffset, f2 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c2.nodeType, f2.nodeType;
          } catch (F2) {
            c2 = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a, r2 = null;
          b:
            for (; ; ) {
              for (var y2; ; ) {
                q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
                q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
                3 === q2.nodeType && (g2 += q2.nodeValue.length);
                if (null === (y2 = q2.firstChild))
                  break;
                r2 = q2;
                q2 = y2;
              }
              for (; ; ) {
                if (q2 === a)
                  break b;
                r2 === c2 && ++l2 === e2 && (h2 = g2);
                r2 === f2 && ++m2 === d2 && (k2 = g2);
                if (null !== (y2 = q2.nextSibling))
                  break;
                q2 = r2;
                r2 = q2.parentNode;
              }
              q2 = y2;
            }
          c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else
          c2 = null;
      }
    c2 = c2 || { start: 0, end: 0 };
  } else
    c2 = null;
  Df = { focusedElem: a, selectionRange: c2 };
  dd = false;
  for (V = b2; null !== V; )
    if (b2 = V, a = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a)
      a.return = b2, V = a;
    else
      for (; null !== V; ) {
        b2 = V;
        try {
          var n2 = b2.alternate;
          if (0 !== (b2.flags & 1024))
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n2) {
                  var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Lg(b2.type, t2), J2);
                  x2.__reactInternalSnapshotBeforeUpdate = w2;
                }
                break;
              case 3:
                var u2 = b2.stateNode.containerInfo;
                1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$5(163));
            }
        } catch (F2) {
          W(b2, b2.return, F2);
        }
        a = b2.sibling;
        if (null !== a) {
          a.return = b2.return;
          V = a;
          break;
        }
        V = b2.return;
      }
  n2 = Oj;
  Oj = false;
  return n2;
}
function Qj(a, b2, c2) {
  var d2 = b2.updateQueue;
  d2 = null !== d2 ? d2.lastEffect : null;
  if (null !== d2) {
    var e2 = d2 = d2.next;
    do {
      if ((e2.tag & a) === a) {
        var f2 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f2 && Nj(b2, c2, f2);
      }
      e2 = e2.next;
    } while (e2 !== d2);
  }
}
function Rj(a, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a) === a) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
function Sj(a) {
  var b2 = a.ref;
  if (null !== b2) {
    var c2 = a.stateNode;
    switch (a.tag) {
      case 5:
        a = c2;
        break;
      default:
        a = c2;
    }
    "function" === typeof b2 ? b2(a) : b2.current = a;
  }
}
function Tj(a) {
  var b2 = a.alternate;
  null !== b2 && (a.alternate = null, Tj(b2));
  a.child = null;
  a.deletions = null;
  a.sibling = null;
  5 === a.tag && (b2 = a.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a.stateNode = null;
  a.return = null;
  a.dependencies = null;
  a.memoizedProps = null;
  a.memoizedState = null;
  a.pendingProps = null;
  a.stateNode = null;
  a.updateQueue = null;
}
function Uj(a) {
  return 5 === a.tag || 3 === a.tag || 4 === a.tag;
}
function Vj(a) {
  a:
    for (; ; ) {
      for (; null === a.sibling; ) {
        if (null === a.return || Uj(a.return))
          return null;
        a = a.return;
      }
      a.sibling.return = a.return;
      for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
        if (a.flags & 2)
          continue a;
        if (null === a.child || 4 === a.tag)
          continue a;
        else
          a.child.return = a, a = a.child;
      }
      if (!(a.flags & 2))
        return a.stateNode;
    }
}
function Wj(a, b2, c2) {
  var d2 = a.tag;
  if (5 === d2 || 6 === d2)
    a = a.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a, b2) : c2.insertBefore(a, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a, c2)) : (b2 = c2, b2.appendChild(a)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d2 && (a = a.child, null !== a))
    for (Wj(a, b2, c2), a = a.sibling; null !== a; )
      Wj(a, b2, c2), a = a.sibling;
}
function Xj(a, b2, c2) {
  var d2 = a.tag;
  if (5 === d2 || 6 === d2)
    a = a.stateNode, b2 ? c2.insertBefore(a, b2) : c2.appendChild(a);
  else if (4 !== d2 && (a = a.child, null !== a))
    for (Xj(a, b2, c2), a = a.sibling; null !== a; )
      Xj(a, b2, c2), a = a.sibling;
}
var X = null, Yj = false;
function Zj(a, b2, c2) {
  for (c2 = c2.child; null !== c2; )
    ak(a, b2, c2), c2 = c2.sibling;
}
function ak(a, b2, c2) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount)
    try {
      lc.onCommitFiberUnmount(kc, c2);
    } catch (h2) {
    }
  switch (c2.tag) {
    case 5:
      U || Mj(c2, b2);
    case 6:
      var d2 = X, e2 = Yj;
      X = null;
      Zj(a, b2, c2);
      X = d2;
      Yj = e2;
      null !== X && (Yj ? (a = X, c2 = c2.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c2) : a.removeChild(c2)) : X.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X && (Yj ? (a = X, c2 = c2.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c2) : 1 === a.nodeType && Kf(a, c2), bd(a)) : Kf(X, c2.stateNode));
      break;
    case 4:
      d2 = X;
      e2 = Yj;
      X = c2.stateNode.containerInfo;
      Yj = true;
      Zj(a, b2, c2);
      X = d2;
      Yj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
        e2 = d2 = d2.next;
        do {
          var f2 = e2, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Nj(c2, b2, g2) : 0 !== (f2 & 4) && Nj(c2, b2, g2));
          e2 = e2.next;
        } while (e2 !== d2);
      }
      Zj(a, b2, c2);
      break;
    case 1:
      if (!U && (Mj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount))
        try {
          d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
        } catch (h2) {
          W(c2, b2, h2);
        }
      Zj(a, b2, c2);
      break;
    case 21:
      Zj(a, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U = (d2 = U) || null !== c2.memoizedState, Zj(a, b2, c2), U = d2) : Zj(a, b2, c2);
      break;
    default:
      Zj(a, b2, c2);
  }
}
function bk(a) {
  var b2 = a.updateQueue;
  if (null !== b2) {
    a.updateQueue = null;
    var c2 = a.stateNode;
    null === c2 && (c2 = a.stateNode = new Lj());
    b2.forEach(function(b3) {
      var d2 = ck.bind(null, a, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function dk(a, b2) {
  var c2 = b2.deletions;
  if (null !== c2)
    for (var d2 = 0; d2 < c2.length; d2++) {
      var e2 = c2[d2];
      try {
        var f2 = a, g2 = b2, h2 = g2;
        a:
          for (; null !== h2; ) {
            switch (h2.tag) {
              case 5:
                X = h2.stateNode;
                Yj = false;
                break a;
              case 3:
                X = h2.stateNode.containerInfo;
                Yj = true;
                break a;
              case 4:
                X = h2.stateNode.containerInfo;
                Yj = true;
                break a;
            }
            h2 = h2.return;
          }
        if (null === X)
          throw Error(p$5(160));
        ak(f2, g2, e2);
        X = null;
        Yj = false;
        var k2 = e2.alternate;
        null !== k2 && (k2.return = null);
        e2.return = null;
      } catch (l2) {
        W(e2, b2, l2);
      }
    }
  if (b2.subtreeFlags & 12854)
    for (b2 = b2.child; null !== b2; )
      ek(b2, a), b2 = b2.sibling;
}
function ek(a, b2) {
  var c2 = a.alternate, d2 = a.flags;
  switch (a.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      dk(b2, a);
      fk(a);
      if (d2 & 4) {
        try {
          Qj(3, a, a.return), Rj(3, a);
        } catch (t2) {
          W(a, a.return, t2);
        }
        try {
          Qj(5, a, a.return);
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      break;
    case 1:
      dk(b2, a);
      fk(a);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      break;
    case 5:
      dk(b2, a);
      fk(a);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      if (a.flags & 32) {
        var e2 = a.stateNode;
        try {
          ob(e2, "");
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      if (d2 & 4 && (e2 = a.stateNode, null != e2)) {
        var f2 = a.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a.type, k2 = a.updateQueue;
        a.updateQueue = null;
        if (null !== k2)
          try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
            vb(h2, g2);
            var l2 = vb(h2, f2);
            for (g2 = 0; g2 < k2.length; g2 += 2) {
              var m2 = k2[g2], q2 = k2[g2 + 1];
              "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb(e2, f2);
                break;
              case "textarea":
                ib(e2, f2);
                break;
              case "select":
                var r2 = e2._wrapperState.wasMultiple;
                e2._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e2,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e2[Pf] = f2;
          } catch (t2) {
            W(a, a.return, t2);
          }
      }
      break;
    case 6:
      dk(b2, a);
      fk(a);
      if (d2 & 4) {
        if (null === a.stateNode)
          throw Error(p$5(162));
        e2 = a.stateNode;
        f2 = a.memoizedProps;
        try {
          e2.nodeValue = f2;
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      break;
    case 3:
      dk(b2, a);
      fk(a);
      if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
        try {
          bd(b2.containerInfo);
        } catch (t2) {
          W(a, a.return, t2);
        }
      break;
    case 4:
      dk(b2, a);
      fk(a);
      break;
    case 13:
      dk(b2, a);
      fk(a);
      e2 = a.child;
      e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (gk = B()));
      d2 & 4 && bk(a);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a.mode & 1 ? (U = (l2 = U) || m2, dk(b2, a), U = l2) : dk(b2, a);
      fk(a);
      if (d2 & 8192) {
        l2 = null !== a.memoizedState;
        if ((a.stateNode.isHidden = l2) && !m2 && 0 !== (a.mode & 1))
          for (V = a, m2 = a.child; null !== m2; ) {
            for (q2 = V = m2; null !== V; ) {
              r2 = V;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qj(4, r2, r2.return);
                  break;
                case 1:
                  Mj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d2 = r2;
                    c2 = r2.return;
                    try {
                      b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W(d2, c2, t2);
                    }
                  }
                  break;
                case 5:
                  Mj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    hk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V = y2) : hk(q2);
            }
            m2 = m2.sibling;
          }
        a:
          for (m2 = null, q2 = a; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                } catch (t2) {
                  W(a, a.return, t2);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2)
                try {
                  q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                } catch (t2) {
                  W(a, a.return, t2);
                }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a)
              break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a)
                break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
      }
      break;
    case 19:
      dk(b2, a);
      fk(a);
      d2 & 4 && bk(a);
      break;
    case 21:
      break;
    default:
      dk(
        b2,
        a
      ), fk(a);
  }
}
function fk(a) {
  var b2 = a.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a.return; null !== c2; ) {
          if (Uj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$5(160));
      }
      switch (d2.tag) {
        case 5:
          var e2 = d2.stateNode;
          d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
          var f2 = Vj(a);
          Xj(a, f2, e2);
          break;
        case 3:
        case 4:
          var g2 = d2.stateNode.containerInfo, h2 = Vj(a);
          Wj(a, h2, g2);
          break;
        default:
          throw Error(p$5(161));
      }
    } catch (k2) {
      W(a, a.return, k2);
    }
    a.flags &= -3;
  }
  b2 & 4096 && (a.flags &= -4097);
}
function ik(a, b2, c2) {
  V = a;
  jk(a);
}
function jk(a, b2, c2) {
  for (var d2 = 0 !== (a.mode & 1); null !== V; ) {
    var e2 = V, f2 = e2.child;
    if (22 === e2.tag && d2) {
      var g2 = null !== e2.memoizedState || Kj;
      if (!g2) {
        var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U;
        h2 = Kj;
        var l2 = U;
        Kj = g2;
        if ((U = k2) && !l2)
          for (V = e2; null !== V; )
            g2 = V, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? kk(e2) : null !== k2 ? (k2.return = g2, V = k2) : kk(e2);
        for (; null !== f2; )
          V = f2, jk(f2), f2 = f2.sibling;
        V = e2;
        Kj = h2;
        U = l2;
      }
      lk(a);
    } else
      0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V = f2) : lk(a);
  }
}
function lk(a) {
  for (; null !== V; ) {
    var b2 = V;
    if (0 !== (b2.flags & 8772)) {
      var c2 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772))
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U || Rj(5, b2);
              break;
            case 1:
              var d2 = b2.stateNode;
              if (b2.flags & 4 && !U)
                if (null === c2)
                  d2.componentDidMount();
                else {
                  var e2 = b2.elementType === b2.type ? c2.memoizedProps : Lg(b2.type, c2.memoizedProps);
                  d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                }
              var f2 = b2.updateQueue;
              null !== f2 && ih(b2, f2, d2);
              break;
            case 3:
              var g2 = b2.updateQueue;
              if (null !== g2) {
                c2 = null;
                if (null !== b2.child)
                  switch (b2.child.tag) {
                    case 5:
                      c2 = b2.child.stateNode;
                      break;
                    case 1:
                      c2 = b2.child.stateNode;
                  }
                ih(b2, g2, c2);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (null === c2 && b2.flags & 4) {
                c2 = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c2.focus();
                    break;
                  case "img":
                    k2.src && (c2.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b2.memoizedState) {
                var l2 = b2.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$5(163));
          }
        U || b2.flags & 512 && Sj(b2);
      } catch (r2) {
        W(b2, b2.return, r2);
      }
    }
    if (b2 === a) {
      V = null;
      break;
    }
    c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V = c2;
      break;
    }
    V = b2.return;
  }
}
function hk(a) {
  for (; null !== V; ) {
    var b2 = V;
    if (b2 === a) {
      V = null;
      break;
    }
    var c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V = c2;
      break;
    }
    V = b2.return;
  }
}
function kk(a) {
  for (; null !== V; ) {
    var b2 = V;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Rj(4, b2);
          } catch (k2) {
            W(b2, c2, k2);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if ("function" === typeof d2.componentDidMount) {
            var e2 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              W(b2, e2, k2);
            }
          }
          var f2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W(b2, g2, k2);
          }
      }
    } catch (k2) {
      W(b2, b2.return, k2);
    }
    if (b2 === a) {
      V = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V = h2;
      break;
    }
    V = b2.return;
  }
}
var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K = 0, R = null, Y = null, Z = 0, gj = 0, fj = Uf(0), T = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
function L() {
  return 0 !== (K & 6) ? B() : -1 !== Bk ? Bk : Bk = B();
}
function lh(a) {
  if (0 === (a.mode & 1))
    return 1;
  if (0 !== (K & 2) && 0 !== Z)
    return Z & -Z;
  if (null !== Kg.transition)
    return 0 === Ck && (Ck = yc()), Ck;
  a = C;
  if (0 !== a)
    return a;
  a = window.event;
  a = void 0 === a ? 16 : jd(a.type);
  return a;
}
function mh(a, b2, c2, d2) {
  if (50 < zk)
    throw zk = 0, Ak = null, Error(p$5(185));
  Ac(a, c2, d2);
  if (0 === (K & 2) || a !== R)
    a === R && (0 === (K & 2) && (rk |= c2), 4 === T && Dk(a, Z)), Ek(a, d2), 1 === c2 && 0 === K && 0 === (b2.mode & 1) && (Hj = B() + 500, fg && jg());
}
function Ek(a, b2) {
  var c2 = a.callbackNode;
  wc(a, b2);
  var d2 = uc(a, a === R ? Z : 0);
  if (0 === d2)
    null !== c2 && bc(c2), a.callbackNode = null, a.callbackPriority = 0;
  else if (b2 = d2 & -d2, a.callbackPriority !== b2) {
    null != c2 && bc(c2);
    if (1 === b2)
      0 === a.tag ? ig(Fk.bind(null, a)) : hg(Fk.bind(null, a)), Jf(function() {
        0 === (K & 6) && jg();
      }), c2 = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Gk(c2, Hk.bind(null, a));
    }
    a.callbackPriority = b2;
    a.callbackNode = c2;
  }
}
function Hk(a, b2) {
  Bk = -1;
  Ck = 0;
  if (0 !== (K & 6))
    throw Error(p$5(327));
  var c2 = a.callbackNode;
  if (Ik() && a.callbackNode !== c2)
    return null;
  var d2 = uc(a, a === R ? Z : 0);
  if (0 === d2)
    return null;
  if (0 !== (d2 & 30) || 0 !== (d2 & a.expiredLanes) || b2)
    b2 = Jk(a, d2);
  else {
    b2 = d2;
    var e2 = K;
    K |= 2;
    var f2 = Kk();
    if (R !== a || Z !== b2)
      vk = null, Hj = B() + 500, Lk(a, b2);
    do
      try {
        Mk();
        break;
      } catch (h2) {
        Nk(a, h2);
      }
    while (1);
    Qg();
    nk.current = f2;
    K = e2;
    null !== Y ? b2 = 0 : (R = null, Z = 0, b2 = T);
  }
  if (0 !== b2) {
    2 === b2 && (e2 = xc(a), 0 !== e2 && (d2 = e2, b2 = Ok(a, e2)));
    if (1 === b2)
      throw c2 = qk, Lk(a, 0), Dk(a, d2), Ek(a, B()), c2;
    if (6 === b2)
      Dk(a, d2);
    else {
      e2 = a.current.alternate;
      if (0 === (d2 & 30) && !Pk(e2) && (b2 = Jk(a, d2), 2 === b2 && (f2 = xc(a), 0 !== f2 && (d2 = f2, b2 = Ok(a, f2))), 1 === b2))
        throw c2 = qk, Lk(a, 0), Dk(a, d2), Ek(a, B()), c2;
      a.finishedWork = e2;
      a.finishedLanes = d2;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$5(345));
        case 2:
          Qk(a, uk, vk);
          break;
        case 3:
          Dk(a, d2);
          if ((d2 & 130023424) === d2 && (b2 = gk + 500 - B(), 10 < b2)) {
            if (0 !== uc(a, 0))
              break;
            e2 = a.suspendedLanes;
            if ((e2 & d2) !== d2) {
              L();
              a.pingedLanes |= a.suspendedLanes & e2;
              break;
            }
            a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), b2);
            break;
          }
          Qk(a, uk, vk);
          break;
        case 4:
          Dk(a, d2);
          if ((d2 & 4194240) === d2)
            break;
          b2 = a.eventTimes;
          for (e2 = -1; 0 < d2; ) {
            var g2 = 31 - oc(d2);
            f2 = 1 << g2;
            g2 = b2[g2];
            g2 > e2 && (e2 = g2);
            d2 &= ~f2;
          }
          d2 = e2;
          d2 = B() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
          if (10 < d2) {
            a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), d2);
            break;
          }
          Qk(a, uk, vk);
          break;
        case 5:
          Qk(a, uk, vk);
          break;
        default:
          throw Error(p$5(329));
      }
    }
  }
  Ek(a, B());
  return a.callbackNode === c2 ? Hk.bind(null, a) : null;
}
function Ok(a, b2) {
  var c2 = tk;
  a.current.memoizedState.isDehydrated && (Lk(a, b2).flags |= 256);
  a = Jk(a, b2);
  2 !== a && (b2 = uk, uk = c2, null !== b2 && Gj(b2));
  return a;
}
function Gj(a) {
  null === uk ? uk = a : uk.push.apply(uk, a);
}
function Pk(a) {
  for (var b2 = a; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2))
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2], f2 = e2.getSnapshot;
          e2 = e2.value;
          try {
            if (!He(f2(), e2))
              return false;
          } catch (g2) {
            return false;
          }
        }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c2)
      c2.return = b2, b2 = c2;
    else {
      if (b2 === a)
        break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a)
          return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Dk(a, b2) {
  b2 &= ~sk;
  b2 &= ~rk;
  a.suspendedLanes |= b2;
  a.pingedLanes &= ~b2;
  for (a = a.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d2 = 1 << c2;
    a[c2] = -1;
    b2 &= ~d2;
  }
}
function Fk(a) {
  if (0 !== (K & 6))
    throw Error(p$5(327));
  Ik();
  var b2 = uc(a, 0);
  if (0 === (b2 & 1))
    return Ek(a, B()), null;
  var c2 = Jk(a, b2);
  if (0 !== a.tag && 2 === c2) {
    var d2 = xc(a);
    0 !== d2 && (b2 = d2, c2 = Ok(a, d2));
  }
  if (1 === c2)
    throw c2 = qk, Lk(a, 0), Dk(a, b2), Ek(a, B()), c2;
  if (6 === c2)
    throw Error(p$5(345));
  a.finishedWork = a.current.alternate;
  a.finishedLanes = b2;
  Qk(a, uk, vk);
  Ek(a, B());
  return null;
}
function Rk(a, b2) {
  var c2 = K;
  K |= 1;
  try {
    return a(b2);
  } finally {
    K = c2, 0 === K && (Hj = B() + 500, fg && jg());
  }
}
function Sk(a) {
  null !== xk && 0 === xk.tag && 0 === (K & 6) && Ik();
  var b2 = K;
  K |= 1;
  var c2 = pk.transition, d2 = C;
  try {
    if (pk.transition = null, C = 1, a)
      return a();
  } finally {
    C = d2, pk.transition = c2, K = b2, 0 === (K & 6) && jg();
  }
}
function Ij() {
  gj = fj.current;
  E(fj);
}
function Lk(a, b2) {
  a.finishedWork = null;
  a.finishedLanes = 0;
  var c2 = a.timeoutHandle;
  -1 !== c2 && (a.timeoutHandle = -1, Gf(c2));
  if (null !== Y)
    for (c2 = Y.return; null !== c2; ) {
      var d2 = c2;
      wg(d2);
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && $f();
          break;
        case 3:
          Jh();
          E(Wf);
          E(H);
          Oh();
          break;
        case 5:
          Lh(d2);
          break;
        case 4:
          Jh();
          break;
        case 13:
          E(M);
          break;
        case 19:
          E(M);
          break;
        case 10:
          Rg(d2.type._context);
          break;
        case 22:
        case 23:
          Ij();
      }
      c2 = c2.return;
    }
  R = a;
  Y = a = wh(a.current, null);
  Z = gj = b2;
  T = 0;
  qk = null;
  sk = rk = hh = 0;
  uk = tk = null;
  if (null !== Wg) {
    for (b2 = 0; b2 < Wg.length; b2++)
      if (c2 = Wg[b2], d2 = c2.interleaved, null !== d2) {
        c2.interleaved = null;
        var e2 = d2.next, f2 = c2.pending;
        if (null !== f2) {
          var g2 = f2.next;
          f2.next = e2;
          d2.next = g2;
        }
        c2.pending = d2;
      }
    Wg = null;
  }
  return a;
}
function Nk(a, b2) {
  do {
    var c2 = Y;
    try {
      Qg();
      Ph.current = ai;
      if (Sh) {
        for (var d2 = N.memoizedState; null !== d2; ) {
          var e2 = d2.queue;
          null !== e2 && (e2.pending = null);
          d2 = d2.next;
        }
        Sh = false;
      }
      Rh = 0;
      P = O = N = null;
      Th = false;
      Uh = 0;
      ok.current = null;
      if (null === c2 || null === c2.return) {
        T = 1;
        qk = b2;
        Y = null;
        break;
      }
      a: {
        var f2 = a, g2 = c2.return, h2 = c2, k2 = b2;
        b2 = Z;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Vi(g2);
          if (null !== y2) {
            y2.flags &= -257;
            Wi(y2, g2, h2, f2, b2);
            y2.mode & 1 && Ti(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b2.updateQueue = t2;
            } else
              n2.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Ti(f2, l2, b2);
              uj();
              break a;
            }
            k2 = Error(p$5(426));
          }
        } else if (I && h2.mode & 1) {
          var J2 = Vi(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Wi(J2, g2, h2, f2, b2);
            Jg(Ki(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ki(k2, h2);
        4 !== T && (T = 2);
        null === tk ? tk = [f2] : tk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x2 = Oi(f2, k2, b2);
              fh(f2, x2);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si || !Si.has(u2)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F2 = Ri(f2, h2, b2);
                fh(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Tk(c2);
    } catch (na) {
      b2 = na;
      Y === c2 && null !== c2 && (Y = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Kk() {
  var a = nk.current;
  nk.current = ai;
  return null === a ? ai : a;
}
function uj() {
  if (0 === T || 3 === T || 2 === T)
    T = 4;
  null === R || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R, Z);
}
function Jk(a, b2) {
  var c2 = K;
  K |= 2;
  var d2 = Kk();
  if (R !== a || Z !== b2)
    vk = null, Lk(a, b2);
  do
    try {
      Uk();
      break;
    } catch (e2) {
      Nk(a, e2);
    }
  while (1);
  Qg();
  K = c2;
  nk.current = d2;
  if (null !== Y)
    throw Error(p$5(261));
  R = null;
  Z = 0;
  return T;
}
function Uk() {
  for (; null !== Y; )
    Vk(Y);
}
function Mk() {
  for (; null !== Y && !cc(); )
    Vk(Y);
}
function Vk(a) {
  var b2 = Wk(a.alternate, a, gj);
  a.memoizedProps = a.pendingProps;
  null === b2 ? Tk(a) : Y = b2;
  ok.current = null;
}
function Tk(a) {
  var b2 = a;
  do {
    var c2 = b2.alternate;
    a = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c2 = Fj(c2, b2, gj), null !== c2) {
        Y = c2;
        return;
      }
    } else {
      c2 = Jj(c2, b2);
      if (null !== c2) {
        c2.flags &= 32767;
        Y = c2;
        return;
      }
      if (null !== a)
        a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
      else {
        T = 6;
        Y = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y = b2;
      return;
    }
    Y = b2 = a;
  } while (null !== b2);
  0 === T && (T = 5);
}
function Qk(a, b2, c2) {
  var d2 = C, e2 = pk.transition;
  try {
    pk.transition = null, C = 1, Xk(a, b2, c2, d2);
  } finally {
    pk.transition = e2, C = d2;
  }
  return null;
}
function Xk(a, b2, c2, d2) {
  do
    Ik();
  while (null !== xk);
  if (0 !== (K & 6))
    throw Error(p$5(327));
  c2 = a.finishedWork;
  var e2 = a.finishedLanes;
  if (null === c2)
    return null;
  a.finishedWork = null;
  a.finishedLanes = 0;
  if (c2 === a.current)
    throw Error(p$5(177));
  a.callbackNode = null;
  a.callbackPriority = 0;
  var f2 = c2.lanes | c2.childLanes;
  Bc(a, f2);
  a === R && (Y = R = null, Z = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || wk || (wk = true, Gk(hc, function() {
    Ik();
    return null;
  }));
  f2 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f2) {
    f2 = pk.transition;
    pk.transition = null;
    var g2 = C;
    C = 1;
    var h2 = K;
    K |= 4;
    ok.current = null;
    Pj(a, c2);
    ek(c2, a);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a.current = c2;
    ik(c2);
    dc();
    K = h2;
    C = g2;
    pk.transition = f2;
  } else
    a.current = c2;
  wk && (wk = false, xk = a, yk = e2);
  f2 = a.pendingLanes;
  0 === f2 && (Si = null);
  mc(c2.stateNode);
  Ek(a, B());
  if (null !== b2)
    for (d2 = a.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
      e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Pi)
    throw Pi = false, a = Qi, Qi = null, a;
  0 !== (yk & 1) && 0 !== a.tag && Ik();
  f2 = a.pendingLanes;
  0 !== (f2 & 1) ? a === Ak ? zk++ : (zk = 0, Ak = a) : zk = 0;
  jg();
  return null;
}
function Ik() {
  if (null !== xk) {
    var a = Dc(yk), b2 = pk.transition, c2 = C;
    try {
      pk.transition = null;
      C = 16 > a ? 16 : a;
      if (null === xk)
        var d2 = false;
      else {
        a = xk;
        xk = null;
        yk = 0;
        if (0 !== (K & 6))
          throw Error(p$5(331));
        var e2 = K;
        K |= 4;
        for (V = a.current; null !== V; ) {
          var f2 = V, g2 = f2.child;
          if (0 !== (V.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V = l2; null !== V; ) {
                  var m2 = V;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2)
                    q2.return = m2, V = q2;
                  else
                    for (; null !== V; ) {
                      m2 = V;
                      var r2 = m2.sibling, y2 = m2.return;
                      Tj(m2);
                      if (m2 === l2) {
                        V = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V = r2;
                        break;
                      }
                      V = y2;
                    }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
            g2.return = f2, V = g2;
          else
            b:
              for (; null !== V; ) {
                f2 = V;
                if (0 !== (f2.flags & 2048))
                  switch (f2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, f2, f2.return);
                  }
                var x2 = f2.sibling;
                if (null !== x2) {
                  x2.return = f2.return;
                  V = x2;
                  break b;
                }
                V = f2.return;
              }
        }
        var w2 = a.current;
        for (V = w2; null !== V; ) {
          g2 = V;
          var u2 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u2)
            u2.return = g2, V = u2;
          else
            b:
              for (g2 = w2; null !== V; ) {
                h2 = V;
                if (0 !== (h2.flags & 2048))
                  try {
                    switch (h2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Rj(9, h2);
                    }
                  } catch (na) {
                    W(h2, h2.return, na);
                  }
                if (h2 === g2) {
                  V = null;
                  break b;
                }
                var F2 = h2.sibling;
                if (null !== F2) {
                  F2.return = h2.return;
                  V = F2;
                  break b;
                }
                V = h2.return;
              }
        }
        K = e2;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot)
          try {
            lc.onPostCommitFiberRoot(kc, a);
          } catch (na) {
          }
        d2 = true;
      }
      return d2;
    } finally {
      C = c2, pk.transition = b2;
    }
  }
  return false;
}
function Yk(a, b2, c2) {
  b2 = Ki(c2, b2);
  b2 = Oi(a, b2, 1);
  a = dh(a, b2, 1);
  b2 = L();
  null !== a && (Ac(a, 1, b2), Ek(a, b2));
}
function W(a, b2, c2) {
  if (3 === a.tag)
    Yk(a, a, c2);
  else
    for (; null !== b2; ) {
      if (3 === b2.tag) {
        Yk(b2, a, c2);
        break;
      } else if (1 === b2.tag) {
        var d2 = b2.stateNode;
        if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si || !Si.has(d2))) {
          a = Ki(c2, a);
          a = Ri(b2, a, 1);
          b2 = dh(b2, a, 1);
          a = L();
          null !== b2 && (Ac(b2, 1, a), Ek(b2, a));
          break;
        }
      }
      b2 = b2.return;
    }
}
function Ui(a, b2, c2) {
  var d2 = a.pingCache;
  null !== d2 && d2.delete(b2);
  b2 = L();
  a.pingedLanes |= a.suspendedLanes & c2;
  R === a && (Z & c2) === c2 && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - gk ? Lk(a, 0) : sk |= c2);
  Ek(a, b2);
}
function Zk(a, b2) {
  0 === b2 && (0 === (a.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = L();
  a = Zg(a, b2);
  null !== a && (Ac(a, b2, c2), Ek(a, c2));
}
function vj(a) {
  var b2 = a.memoizedState, c2 = 0;
  null !== b2 && (c2 = b2.retryLane);
  Zk(a, c2);
}
function ck(a, b2) {
  var c2 = 0;
  switch (a.tag) {
    case 13:
      var d2 = a.stateNode;
      var e2 = a.memoizedState;
      null !== e2 && (c2 = e2.retryLane);
      break;
    case 19:
      d2 = a.stateNode;
      break;
    default:
      throw Error(p$5(314));
  }
  null !== d2 && d2.delete(b2);
  Zk(a, c2);
}
var Wk;
Wk = function(a, b2, c2) {
  if (null !== a)
    if (a.memoizedProps !== b2.pendingProps || Wf.current)
      Ug = true;
    else {
      if (0 === (a.lanes & c2) && 0 === (b2.flags & 128))
        return Ug = false, zj(a, b2, c2);
      Ug = 0 !== (a.flags & 131072) ? true : false;
    }
  else
    Ug = false, I && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d2 = b2.type;
      jj(a, b2);
      a = b2.pendingProps;
      var e2 = Yf(b2, H.current);
      Tg(b2, c2);
      e2 = Xh(null, b2, d2, a, e2, c2);
      var f2 = bi();
      b2.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, ah(b2), e2.updater = nh, b2.stateNode = e2, e2._reactInternals = b2, rh(b2, d2, a, c2), b2 = kj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I && f2 && vg(b2), Yi(null, b2, e2, c2), b2 = b2.child);
      return b2;
    case 16:
      d2 = b2.elementType;
      a: {
        jj(a, b2);
        a = b2.pendingProps;
        e2 = d2._init;
        d2 = e2(d2._payload);
        b2.type = d2;
        e2 = b2.tag = $k(d2);
        a = Lg(d2, a);
        switch (e2) {
          case 0:
            b2 = dj(null, b2, d2, a, c2);
            break a;
          case 1:
            b2 = ij(null, b2, d2, a, c2);
            break a;
          case 11:
            b2 = Zi(null, b2, d2, a, c2);
            break a;
          case 14:
            b2 = aj(null, b2, d2, Lg(d2.type, a), c2);
            break a;
        }
        throw Error(p$5(
          306,
          d2,
          ""
        ));
      }
      return b2;
    case 0:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), dj(a, b2, d2, e2, c2);
    case 1:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), ij(a, b2, d2, e2, c2);
    case 3:
      a: {
        lj(b2);
        if (null === a)
          throw Error(p$5(387));
        d2 = b2.pendingProps;
        f2 = b2.memoizedState;
        e2 = f2.element;
        bh(a, b2);
        gh(b2, d2, null, c2);
        var g2 = b2.memoizedState;
        d2 = g2.element;
        if (f2.isDehydrated)
          if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e2 = Ki(Error(p$5(423)), b2);
            b2 = mj(a, b2, d2, c2, e2);
            break a;
          } else if (d2 !== e2) {
            e2 = Ki(Error(p$5(424)), b2);
            b2 = mj(a, b2, d2, c2, e2);
            break a;
          } else
            for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I = true, zg = null, c2 = Ch(b2, null, d2, c2), b2.child = c2; c2; )
              c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d2 === e2) {
            b2 = $i(a, b2, c2);
            break a;
          }
          Yi(a, b2, d2, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Kh(b2), null === a && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a ? a.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), hj(a, b2), Yi(a, b2, g2, c2), b2.child;
    case 6:
      return null === a && Eg(b2), null;
    case 13:
      return pj(a, b2, c2);
    case 4:
      return Ih(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a ? b2.child = Bh(b2, null, d2, c2) : Yi(a, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), Zi(a, b2, d2, e2, c2);
    case 7:
      return Yi(a, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Yi(a, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Yi(a, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e2 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g2 = e2.value;
        G(Mg, d2._currentValue);
        d2._currentValue = g2;
        if (null !== f2)
          if (He(f2.value, g2)) {
            if (f2.children === e2.children && !Wf.current) {
              b2 = $i(a, b2, c2);
              break a;
            }
          } else
            for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
              var h2 = f2.dependencies;
              if (null !== h2) {
                g2 = f2.child;
                for (var k2 = h2.firstContext; null !== k2; ) {
                  if (k2.context === d2) {
                    if (1 === f2.tag) {
                      k2 = ch(-1, c2 & -c2);
                      k2.tag = 2;
                      var l2 = f2.updateQueue;
                      if (null !== l2) {
                        l2 = l2.shared;
                        var m2 = l2.pending;
                        null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                        l2.pending = k2;
                      }
                    }
                    f2.lanes |= c2;
                    k2 = f2.alternate;
                    null !== k2 && (k2.lanes |= c2);
                    Sg(
                      f2.return,
                      c2,
                      b2
                    );
                    h2.lanes |= c2;
                    break;
                  }
                  k2 = k2.next;
                }
              } else if (10 === f2.tag)
                g2 = f2.type === b2.type ? null : f2.child;
              else if (18 === f2.tag) {
                g2 = f2.return;
                if (null === g2)
                  throw Error(p$5(341));
                g2.lanes |= c2;
                h2 = g2.alternate;
                null !== h2 && (h2.lanes |= c2);
                Sg(g2, c2, b2);
                g2 = f2.sibling;
              } else
                g2 = f2.child;
              if (null !== g2)
                g2.return = f2;
              else
                for (g2 = f2; null !== g2; ) {
                  if (g2 === b2) {
                    g2 = null;
                    break;
                  }
                  f2 = g2.sibling;
                  if (null !== f2) {
                    f2.return = g2.return;
                    g2 = f2;
                    break;
                  }
                  g2 = g2.return;
                }
              f2 = g2;
            }
        Yi(a, b2, e2.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, d2 = b2.pendingProps.children, Tg(b2, c2), e2 = Vg(e2), d2 = d2(e2), b2.flags |= 1, Yi(a, b2, d2, c2), b2.child;
    case 14:
      return d2 = b2.type, e2 = Lg(d2, b2.pendingProps), e2 = Lg(d2.type, e2), aj(a, b2, d2, e2, c2);
    case 15:
      return cj(a, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), jj(a, b2), b2.tag = 1, Zf(d2) ? (a = true, cg(b2)) : a = false, Tg(b2, c2), ph(b2, d2, e2), rh(b2, d2, e2, c2), kj(null, b2, d2, true, a, c2);
    case 19:
      return yj(a, b2, c2);
    case 22:
      return ej(a, b2, c2);
  }
  throw Error(p$5(156, b2.tag));
};
function Gk(a, b2) {
  return ac(a, b2);
}
function al(a, b2, c2, d2) {
  this.tag = a;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a, b2, c2, d2) {
  return new al(a, b2, c2, d2);
}
function bj(a) {
  a = a.prototype;
  return !(!a || !a.isReactComponent);
}
function $k(a) {
  if ("function" === typeof a)
    return bj(a) ? 1 : 0;
  if (void 0 !== a && null !== a) {
    a = a.$$typeof;
    if (a === Da)
      return 11;
    if (a === Ga)
      return 14;
  }
  return 2;
}
function wh(a, b2) {
  var c2 = a.alternate;
  null === c2 ? (c2 = Bg(a.tag, b2, a.key, a.mode), c2.elementType = a.elementType, c2.type = a.type, c2.stateNode = a.stateNode, c2.alternate = a, a.alternate = c2) : (c2.pendingProps = b2, c2.type = a.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a.flags & 14680064;
  c2.childLanes = a.childLanes;
  c2.lanes = a.lanes;
  c2.child = a.child;
  c2.memoizedProps = a.memoizedProps;
  c2.memoizedState = a.memoizedState;
  c2.updateQueue = a.updateQueue;
  b2 = a.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a.sibling;
  c2.index = a.index;
  c2.ref = a.ref;
  return c2;
}
function yh(a, b2, c2, d2, e2, f2) {
  var g2 = 2;
  d2 = a;
  if ("function" === typeof a)
    bj(a) && (g2 = 1);
  else if ("string" === typeof a)
    g2 = 5;
  else
    a:
      switch (a) {
        case ya:
          return Ah(c2.children, e2, f2, b2);
        case za:
          g2 = 8;
          e2 |= 8;
          break;
        case Aa:
          return a = Bg(12, c2, b2, e2 | 2), a.elementType = Aa, a.lanes = f2, a;
        case Ea:
          return a = Bg(13, c2, b2, e2), a.elementType = Ea, a.lanes = f2, a;
        case Fa:
          return a = Bg(19, c2, b2, e2), a.elementType = Fa, a.lanes = f2, a;
        case Ia:
          return qj(c2, e2, f2, b2);
        default:
          if ("object" === typeof a && null !== a)
            switch (a.$$typeof) {
              case Ba:
                g2 = 10;
                break a;
              case Ca:
                g2 = 9;
                break a;
              case Da:
                g2 = 11;
                break a;
              case Ga:
                g2 = 14;
                break a;
              case Ha:
                g2 = 16;
                d2 = null;
                break a;
            }
          throw Error(p$5(130, null == a ? a : typeof a, ""));
      }
  b2 = Bg(g2, c2, b2, e2);
  b2.elementType = a;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
function Ah(a, b2, c2, d2) {
  a = Bg(7, a, d2, b2);
  a.lanes = c2;
  return a;
}
function qj(a, b2, c2, d2) {
  a = Bg(22, a, d2, b2);
  a.elementType = Ia;
  a.lanes = c2;
  a.stateNode = { isHidden: false };
  return a;
}
function xh(a, b2, c2) {
  a = Bg(6, a, null, b2);
  a.lanes = c2;
  return a;
}
function zh(a, b2, c2) {
  b2 = Bg(4, null !== a.children ? a.children : [], a.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
  return b2;
}
function bl(a, b2, c2, d2, e2) {
  this.tag = b2;
  this.containerInfo = a;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function cl(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  a = new bl(a, b2, c2, h2, k2);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a.current = f2;
  f2.stateNode = a;
  f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  ah(f2);
  return a;
}
function dl(a, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a, containerInfo: b2, implementation: c2 };
}
function el(a) {
  if (!a)
    return Vf;
  a = a._reactInternals;
  a: {
    if (Vb(a) !== a || 1 !== a.tag)
      throw Error(p$5(170));
    var b2 = a;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$5(171));
  }
  if (1 === a.tag) {
    var c2 = a.type;
    if (Zf(c2))
      return bg(a, c2, b2);
  }
  return b2;
}
function fl(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  a = cl(c2, d2, true, a, e2, f2, g2, h2, k2);
  a.context = el(null);
  c2 = a.current;
  d2 = L();
  e2 = lh(c2);
  f2 = ch(d2, e2);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  dh(c2, f2, e2);
  a.current.lanes = e2;
  Ac(a, e2, d2);
  Ek(a, d2);
  return a;
}
function gl(a, b2, c2, d2) {
  var e2 = b2.current, f2 = L(), g2 = lh(e2);
  c2 = el(c2);
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = ch(f2, g2);
  b2.payload = { element: a };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b2.callback = d2);
  a = dh(e2, b2, g2);
  null !== a && (mh(a, e2, g2, f2), eh(a, e2, g2));
  return g2;
}
function hl(a) {
  a = a.current;
  if (!a.child)
    return null;
  switch (a.child.tag) {
    case 5:
      return a.child.stateNode;
    default:
      return a.child.stateNode;
  }
}
function il(a, b2) {
  a = a.memoizedState;
  if (null !== a && null !== a.dehydrated) {
    var c2 = a.retryLane;
    a.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function jl(a, b2) {
  il(a, b2);
  (a = a.alternate) && il(a, b2);
}
function kl() {
  return null;
}
var ll = "function" === typeof reportError ? reportError : function(a) {
  console.error(a);
};
function ml(a) {
  this._internalRoot = a;
}
nl.prototype.render = ml.prototype.render = function(a) {
  var b2 = this._internalRoot;
  if (null === b2)
    throw Error(p$5(409));
  gl(a, b2, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function() {
  var a = this._internalRoot;
  if (null !== a) {
    this._internalRoot = null;
    var b2 = a.containerInfo;
    Sk(function() {
      gl(null, a, null, null);
    });
    b2[uf] = null;
  }
};
function nl(a) {
  this._internalRoot = a;
}
nl.prototype.unstable_scheduleHydration = function(a) {
  if (a) {
    var b2 = Hc();
    a = { blockedOn: null, target: a, priority: b2 };
    for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++)
      ;
    Qc.splice(c2, 0, a);
    0 === c2 && Vc(a);
  }
};
function ol(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
}
function pl(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
}
function ql() {
}
function rl(a, b2, c2, d2, e2) {
  if (e2) {
    if ("function" === typeof d2) {
      var f2 = d2;
      d2 = function() {
        var a2 = hl(g2);
        f2.call(a2);
      };
    }
    var g2 = fl(b2, d2, a, 0, null, false, false, "", ql);
    a._reactRootContainer = g2;
    a[uf] = g2.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    Sk();
    return g2;
  }
  for (; e2 = a.lastChild; )
    a.removeChild(e2);
  if ("function" === typeof d2) {
    var h2 = d2;
    d2 = function() {
      var a2 = hl(k2);
      h2.call(a2);
    };
  }
  var k2 = cl(a, 0, false, null, null, false, false, "", ql);
  a._reactRootContainer = k2;
  a[uf] = k2.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  Sk(function() {
    gl(b2, k2, c2, d2);
  });
  return k2;
}
function sl(a, b2, c2, d2, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a2 = hl(g2);
        h2.call(a2);
      };
    }
    gl(b2, g2, a, e2);
  } else
    g2 = rl(c2, b2, a, e2, d2);
  return hl(g2);
}
Ec = function(a) {
  switch (a.tag) {
    case 3:
      var b2 = a.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc(b2.pendingLanes);
        0 !== c2 && (Cc(b2, c2 | 1), Ek(b2, B()), 0 === (K & 6) && (Hj = B() + 500, jg()));
      }
      break;
    case 13:
      Sk(function() {
        var b3 = Zg(a, 1);
        if (null !== b3) {
          var c3 = L();
          mh(b3, a, 1, c3);
        }
      }), jl(a, 1);
  }
};
Fc = function(a) {
  if (13 === a.tag) {
    var b2 = Zg(a, 134217728);
    if (null !== b2) {
      var c2 = L();
      mh(b2, a, 134217728, c2);
    }
    jl(a, 134217728);
  }
};
Gc = function(a) {
  if (13 === a.tag) {
    var b2 = lh(a), c2 = Zg(a, b2);
    if (null !== c2) {
      var d2 = L();
      mh(c2, a, b2, d2);
    }
    jl(a, b2);
  }
};
Hc = function() {
  return C;
};
Ic = function(a, b2) {
  var c2 = C;
  try {
    return C = a, b2();
  } finally {
    C = c2;
  }
};
yb = function(a, b2, c2) {
  switch (b2) {
    case "input":
      bb(a, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a; c2.parentNode; )
          c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a && d2.form === a.form) {
            var e2 = Db(d2);
            if (!e2)
              throw Error(p$5(90));
            Wa(d2);
            bb(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb(a, !!c2.multiple, b2, false);
  }
};
Gb = Rk;
Hb = Sk;
var tl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
  a = Zb(a);
  return null === a ? null : a.stateNode;
}, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber)
    try {
      kc = wl.inject(vl), lc = wl;
    } catch (a) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
reactDom_production_min.createPortal = function(a, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!ol(b2))
    throw Error(p$5(200));
  return dl(a, b2, null, c2);
};
reactDom_production_min.createRoot = function(a, b2) {
  if (!ol(a))
    throw Error(p$5(299));
  var c2 = false, d2 = "", e2 = ll;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
  b2 = cl(a, 1, false, null, null, c2, false, d2, e2);
  a[uf] = b2.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  return new ml(b2);
};
reactDom_production_min.findDOMNode = function(a) {
  if (null == a)
    return null;
  if (1 === a.nodeType)
    return a;
  var b2 = a._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a.render)
      throw Error(p$5(188));
    a = Object.keys(a).join(",");
    throw Error(p$5(268, a));
  }
  a = Zb(b2);
  a = null === a ? null : a.stateNode;
  return a;
};
reactDom_production_min.flushSync = function(a) {
  return Sk(a);
};
reactDom_production_min.hydrate = function(a, b2, c2) {
  if (!pl(b2))
    throw Error(p$5(200));
  return sl(null, a, b2, true, c2);
};
reactDom_production_min.hydrateRoot = function(a, b2, c2) {
  if (!ol(a))
    throw Error(p$5(405));
  var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = ll;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
  b2 = fl(b2, null, a, 1, null != c2 ? c2 : null, e2, false, f2, g2);
  a[uf] = b2.current;
  sf(a);
  if (d2)
    for (a = 0; a < d2.length; a++)
      c2 = d2[a], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
        c2,
        e2
      );
  return new nl(b2);
};
reactDom_production_min.render = function(a, b2, c2) {
  if (!pl(b2))
    throw Error(p$5(200));
  return sl(null, a, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a) {
  if (!pl(a))
    throw Error(p$5(40));
  return a._reactRootContainer ? (Sk(function() {
    sl(null, null, a, false, function() {
      a._reactRootContainer = null;
      a[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Rk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b2, c2, d2) {
  if (!pl(c2))
    throw Error(p$5(200));
  if (null == a || void 0 === a._reactInternals)
    throw Error(p$5(38));
  return sl(a, b2, c2, false, d2);
};
reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
(function(module2) {
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    module2.exports = reactDom_production_min;
  }
})(reactDom);
var m$4 = reactDom.exports;
{
  client.createRoot = m$4.createRoot;
  client.hydrateRoot = m$4.hydrateRoot;
}
const css$2 = '/*\n1. Add the correct height in Firefox.\n2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)\n3. Ensure horizontal rules are visible by default.\n*/\n\nhr {\n  height: 0;\n  /* 1 */\n  color: inherit;\n  /* 2 */\n  border-top-width: 1px;\n  /* 3 */\n}\n\n/*\nAdd the correct text decoration in Chrome, Edge, and Safari.\n*/\n\nabbr:where([title]) {\n  -webkit-text-decoration: underline dotted;\n          text-decoration: underline dotted;\n}\n\n/*\nRemove the default font size and weight for headings.\n*/\n\nh1,\nh2,\nh3,\nh4,\nh5,\nh6 {\n  font-size: inherit;\n  font-weight: inherit;\n}\n\n/*\nReset links to optimize for opt-in styling instead of opt-out.\n*/\n\na {\n  color: inherit;\n  text-decoration: inherit;\n}\n\n/*\nAdd the correct font weight in Edge and Safari.\n*/\n\nb,\nstrong {\n  font-weight: bolder;\n}\n\n/*\n1. Use the user\'s configured `mono` font family by default.\n2. Correct the odd `em` font sizing in all browsers.\n*/\n\ncode,\nkbd,\nsamp,\npre {\n  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;\n  /* 1 */\n  font-size: 1em;\n  /* 2 */\n}\n\n/*\nAdd the correct font size in all browsers.\n*/\n\nsmall {\n  font-size: 80%;\n}\n\n/*\nPrevent `sub` and `sup` elements from affecting the line height in all browsers.\n*/\n\nsub,\nsup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline;\n}\n\nsub {\n  bottom: -0.25em;\n}\n\nsup {\n  top: -0.5em;\n}\n\n/*\n1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)\n2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)\n3. Remove gaps between table borders by default.\n*/\n\ntable {\n  text-indent: 0;\n  /* 1 */\n  border-color: inherit;\n  /* 2 */\n  border-collapse: collapse;\n  /* 3 */\n}\n\n/*\n1. Change the font styles in all browsers.\n2. Remove the margin in Firefox and Safari.\n3. Remove default padding in all browsers.\n*/\n\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font-family: inherit;\n  /* 1 */\n  font-size: 100%;\n  /* 1 */\n  font-weight: inherit;\n  /* 1 */\n  line-height: inherit;\n  /* 1 */\n  color: inherit;\n  /* 1 */\n  margin: 0;\n  /* 2 */\n  padding: 0;\n  /* 3 */\n}\n\n/*\nRemove the inheritance of text transform in Edge and Firefox.\n*/\n\nbutton,\nselect {\n  text-transform: none;\n}\n\n/*\n1. Correct the inability to style clickable types in iOS and Safari.\n2. Remove default button styles.\n*/\n\nbutton,\n[type=\'button\'],\n[type=\'reset\'],\n[type=\'submit\'] {\n  -webkit-appearance: button;\n  /* 1 */\n  background-color: transparent;\n  /* 2 */\n  background-image: none;\n  /* 2 */\n}\n\n/*\nUse the modern Firefox focus style for all focusable elements.\n*/\n\n:-moz-focusring {\n  outline: auto;\n}\n\n/*\nRemove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)\n*/\n\n:-moz-ui-invalid {\n  box-shadow: none;\n}\n\n/*\nAdd the correct vertical alignment in Chrome and Firefox.\n*/\n\nprogress {\n  vertical-align: baseline;\n}\n\n/*\nCorrect the cursor style of increment and decrement buttons in Safari.\n*/\n\n::-webkit-inner-spin-button,\n::-webkit-outer-spin-button {\n  height: auto;\n}\n\n/*\n1. Correct the odd appearance in Chrome and Safari.\n2. Correct the outline style in Safari.\n*/\n\n[type=\'search\'] {\n  -webkit-appearance: textfield;\n  /* 1 */\n  outline-offset: -2px;\n  /* 2 */\n}\n\n/*\nRemove the inner padding in Chrome and Safari on macOS.\n*/\n\n::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n\n/*\n1. Correct the inability to style clickable types in iOS and Safari.\n2. Change font properties to `inherit` in Safari.\n*/\n\n::-webkit-file-upload-button {\n  -webkit-appearance: button;\n  /* 1 */\n  font: inherit;\n  /* 2 */\n}\n\n/*\nAdd the correct display in Chrome and Safari.\n*/\n\nsummary {\n  display: list-item;\n}\n\n/*\nRemoves the default spacing and border for appropriate elements.\n*/\n\nblockquote,\ndl,\ndd,\nh1,\nh2,\nh3,\nh4,\nh5,\nh6,\nhr,\nfigure,\np,\npre {\n  margin: 0;\n}\n\nfieldset {\n  margin: 0;\n  padding: 0;\n}\n\nlegend {\n  padding: 0;\n}\n\nol,\nul,\nmenu {\n  list-style: none;\n  margin: 0;\n  padding: 0;\n}\n\n/*\nPrevent resizing textareas horizontally by default.\n*/\n\ntextarea {\n  resize: vertical;\n}\n\n/*\n1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)\n2. Set the default placeholder color to the user\'s configured gray 400 color.\n*/\n\ninput::-moz-placeholder, textarea::-moz-placeholder {\n  opacity: 1;\n  /* 1 */\n  color: #9ca3af;\n  /* 2 */\n}\n\ninput::placeholder,\ntextarea::placeholder {\n  opacity: 1;\n  /* 1 */\n  color: #9ca3af;\n  /* 2 */\n}\n\n/*\nSet the default cursor for buttons.\n*/\n\nbutton,\n[role="button"] {\n  cursor: pointer;\n}\n\n/*\nMake sure disabled buttons don\'t get the pointer cursor.\n*/\n\n:disabled {\n  cursor: default;\n}\n\n/*\n1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)\n2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)\n   This can trigger a poorly considered lint error in some tools but is included by design.\n*/\n\nimg,\nsvg,\nvideo,\ncanvas,\naudio,\niframe,\nembed,\nobject {\n  display: block;\n  /* 1 */\n  vertical-align: middle;\n  /* 2 */\n}\n\n/*\nConstrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)\n*/\n\nimg,\nvideo {\n  max-width: 100%;\n  height: auto;\n}\n\n/* Make elements with the HTML hidden attribute stay hidden by default */\n\n[hidden] {\n  display: none;\n}\n\n*, ::before, ::after {\n  --tw-border-spacing-x: 0;\n  --tw-border-spacing-y: 0;\n  --tw-translate-x: 0;\n  --tw-translate-y: 0;\n  --tw-rotate: 0;\n  --tw-skew-x: 0;\n  --tw-skew-y: 0;\n  --tw-scale-x: 1;\n  --tw-scale-y: 1;\n  --tw-pan-x:  ;\n  --tw-pan-y:  ;\n  --tw-pinch-zoom:  ;\n  --tw-scroll-snap-strictness: proximity;\n  --tw-ordinal:  ;\n  --tw-slashed-zero:  ;\n  --tw-numeric-figure:  ;\n  --tw-numeric-spacing:  ;\n  --tw-numeric-fraction:  ;\n  --tw-ring-inset:  ;\n  --tw-ring-offset-width: 0px;\n  --tw-ring-offset-color: #fff;\n  --tw-ring-color: rgb(59 130 246 / 0.5);\n  --tw-ring-offset-shadow: 0 0 #0000;\n  --tw-ring-shadow: 0 0 #0000;\n  --tw-shadow: 0 0 #0000;\n  --tw-shadow-colored: 0 0 #0000;\n  --tw-blur:  ;\n  --tw-brightness:  ;\n  --tw-contrast:  ;\n  --tw-grayscale:  ;\n  --tw-hue-rotate:  ;\n  --tw-invert:  ;\n  --tw-saturate:  ;\n  --tw-sepia:  ;\n  --tw-drop-shadow:  ;\n  --tw-backdrop-blur:  ;\n  --tw-backdrop-brightness:  ;\n  --tw-backdrop-contrast:  ;\n  --tw-backdrop-grayscale:  ;\n  --tw-backdrop-hue-rotate:  ;\n  --tw-backdrop-invert:  ;\n  --tw-backdrop-opacity:  ;\n  --tw-backdrop-saturate:  ;\n  --tw-backdrop-sepia:  ;\n}\n\n::backdrop {\n  --tw-border-spacing-x: 0;\n  --tw-border-spacing-y: 0;\n  --tw-translate-x: 0;\n  --tw-translate-y: 0;\n  --tw-rotate: 0;\n  --tw-skew-x: 0;\n  --tw-skew-y: 0;\n  --tw-scale-x: 1;\n  --tw-scale-y: 1;\n  --tw-pan-x:  ;\n  --tw-pan-y:  ;\n  --tw-pinch-zoom:  ;\n  --tw-scroll-snap-strictness: proximity;\n  --tw-ordinal:  ;\n  --tw-slashed-zero:  ;\n  --tw-numeric-figure:  ;\n  --tw-numeric-spacing:  ;\n  --tw-numeric-fraction:  ;\n  --tw-ring-inset:  ;\n  --tw-ring-offset-width: 0px;\n  --tw-ring-offset-color: #fff;\n  --tw-ring-color: rgb(59 130 246 / 0.5);\n  --tw-ring-offset-shadow: 0 0 #0000;\n  --tw-ring-shadow: 0 0 #0000;\n  --tw-shadow: 0 0 #0000;\n  --tw-shadow-colored: 0 0 #0000;\n  --tw-blur:  ;\n  --tw-brightness:  ;\n  --tw-contrast:  ;\n  --tw-grayscale:  ;\n  --tw-hue-rotate:  ;\n  --tw-invert:  ;\n  --tw-saturate:  ;\n  --tw-sepia:  ;\n  --tw-drop-shadow:  ;\n  --tw-backdrop-blur:  ;\n  --tw-backdrop-brightness:  ;\n  --tw-backdrop-contrast:  ;\n  --tw-backdrop-grayscale:  ;\n  --tw-backdrop-hue-rotate:  ;\n  --tw-backdrop-invert:  ;\n  --tw-backdrop-opacity:  ;\n  --tw-backdrop-saturate:  ;\n  --tw-backdrop-sepia:  ;\n}\n\n.container {\n  width: 100%;\n}\n\n@media (min-width: 640px) {\n  .container {\n    max-width: 640px;\n  }\n}\n\n@media (min-width: 768px) {\n  .container {\n    max-width: 768px;\n  }\n}\n\n@media (min-width: 1024px) {\n  .container {\n    max-width: 1024px;\n  }\n}\n\n@media (min-width: 1280px) {\n  .container {\n    max-width: 1280px;\n  }\n}\n\n@media (min-width: 1536px) {\n  .container {\n    max-width: 1536px;\n  }\n}\n\n.fixed {\n  position: fixed;\n}\n\n.absolute {\n  position: absolute;\n}\n\n.relative {\n  position: relative;\n}\n\n.top-0 {\n  top: 0px;\n}\n\n.bottom-0 {\n  bottom: 0px;\n}\n\n.left-0 {\n  left: 0px;\n}\n\n.right-0 {\n  right: 0px;\n}\n\n.z-10 {\n  z-index: 10;\n}\n\n.flex {\n  display: flex;\n}\n\n.hidden {\n  display: none;\n}\n\n.h-full {\n  height: 100%;\n}\n\n.h-32 {\n  height: 8rem;\n}\n\n.w-full {\n  width: 100%;\n}\n\n.w-1\\/4 {\n  width: 25%;\n}\n\n.w-4\\/5 {\n  width: 80%;\n}\n\n.w-32 {\n  width: 8rem;\n}\n\n.w-3\\/4 {\n  width: 75%;\n}\n\n.transform {\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\n}\n\n@keyframes spin {\n  to {\n    transform: rotate(360deg);\n  }\n}\n\n.animate-spin {\n  animation: spin 1s linear infinite;\n}\n\n.cursor-pointer {\n  cursor: pointer;\n}\n\n.flex-col {\n  flex-direction: column;\n}\n\n.flex-wrap {\n  flex-wrap: wrap;\n}\n\n.items-center {\n  align-items: center;\n}\n\n.justify-center {\n  justify-content: center;\n}\n\n.justify-between {\n  justify-content: space-between;\n}\n\n.gap-1 {\n  gap: 0.25rem;\n}\n\n.gap-2 {\n  gap: 0.5rem;\n}\n\n.gap-3 {\n  gap: 0.75rem;\n}\n\n.gap-8 {\n  gap: 2rem;\n}\n\n.overflow-auto {\n  overflow: auto;\n}\n\n.rounded {\n  border-radius: 0.25rem;\n}\n\n.rounded-full {\n  border-radius: 9999px;\n}\n\n.border {\n  border-width: 1px;\n}\n\n.border-8 {\n  border-width: 8px;\n}\n\n.border-t-green-900 {\n  --tw-border-opacity: 1;\n  border-top-color: rgb(20 83 45 / var(--tw-border-opacity));\n}\n\n.bg-black {\n  --tw-bg-opacity: 1;\n  background-color: rgb(0 0 0 / var(--tw-bg-opacity));\n}\n\n.bg-white {\n  --tw-bg-opacity: 1;\n  background-color: rgb(255 255 255 / var(--tw-bg-opacity));\n}\n\n.bg-amber-900 {\n  --tw-bg-opacity: 1;\n  background-color: rgb(120 53 15 / var(--tw-bg-opacity));\n}\n\n.bg-\\[url\\(\\\'\\/frame\\/bg\\.jpg\\\'\\)\\] {\n  background-image: url(\'/frame/bg.jpg\');\n}\n\n.bg-cover {\n  background-size: cover;\n}\n\n.bg-center {\n  background-position: center;\n}\n\n.p-3 {\n  padding: 0.75rem;\n}\n\n.p-4 {\n  padding: 1rem;\n}\n\n.p-0\\.5 {\n  padding: 0.125rem;\n}\n\n.p-0 {\n  padding: 0px;\n}\n\n.p-2 {\n  padding: 0.5rem;\n}\n\n.text-2xl {\n  font-size: 1.5rem;\n  line-height: 2rem;\n}\n\n.text-xl {\n  font-size: 1.25rem;\n  line-height: 1.75rem;\n}\n\n.font-bold {\n  font-weight: 700;\n}\n\n.text-red-900 {\n  --tw-text-opacity: 1;\n  color: rgb(127 29 29 / var(--tw-text-opacity));\n}\n\n.text-blue-900 {\n  --tw-text-opacity: 1;\n  color: rgb(30 58 138 / var(--tw-text-opacity));\n}\n\n.opacity-30 {\n  opacity: 0.3;\n}\n\n.shadow-inner {\n  --tw-shadow: inset 0 2px 4px 0 rgb(0 0 0 / 0.05);\n  --tw-shadow-colored: inset 0 2px 4px 0 var(--tw-shadow-color);\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\n}\n\n.filter {\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\n}\n\n* {\n  box-sizing: border-box;\n}\n\n.body {\n  margin: 0;\n  font-family: "Roboto", BlinkMacSystemFont, "Segoe UI", "Oxygen", "Ubuntu",\n    "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  height: 100%;\n  width: 100%;\n  background-color: black;\n}\n\n.body:before {\n  content: "";\n  background-repeat: repeat;\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: -1;\n}\n\ncode {\n  font-family: source-code-pro, Menlo, Monaco, Consolas, "Courier New",\n    monospace;\n}\n\nul {\n  list-style-type: none;\n  margin: 0;\n  padding: 0;\n}\n\n#root {\n  width: 100vw;\n  height: 100vh;\n  margin: 0;\n  border: 0;\n}\n';
function styleInject(css2, ref) {
  if (ref === void 0)
    ref = {};
  var insertAt = ref.insertAt;
  if (!css2 || typeof document === "undefined") {
    return;
  }
  var head = document.head || document.getElementsByTagName("head")[0];
  var style2 = document.createElement("style");
  style2.type = "text/css";
  if (insertAt === "top") {
    if (head.firstChild) {
      head.insertBefore(style2, head.firstChild);
    } else {
      head.appendChild(style2);
    }
  } else {
    head.appendChild(style2);
  }
  if (style2.styleSheet) {
    style2.styleSheet.cssText = css2;
  } else {
    style2.appendChild(document.createTextNode(css2));
  }
}
const common = {
  black: "#000",
  white: "#fff"
};
const common$1 = common;
const red = {
  50: "#ffebee",
  100: "#ffcdd2",
  200: "#ef9a9a",
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  600: "#e53935",
  700: "#d32f2f",
  800: "#c62828",
  900: "#b71c1c",
  A100: "#ff8a80",
  A200: "#ff5252",
  A400: "#ff1744",
  A700: "#d50000"
};
const red$1 = red;
const purple = {
  50: "#f3e5f5",
  100: "#e1bee7",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  600: "#8e24aa",
  700: "#7b1fa2",
  800: "#6a1b9a",
  900: "#4a148c",
  A100: "#ea80fc",
  A200: "#e040fb",
  A400: "#d500f9",
  A700: "#aa00ff"
};
const purple$1 = purple;
const blue = {
  50: "#e3f2fd",
  100: "#bbdefb",
  200: "#90caf9",
  300: "#64b5f6",
  400: "#42a5f5",
  500: "#2196f3",
  600: "#1e88e5",
  700: "#1976d2",
  800: "#1565c0",
  900: "#0d47a1",
  A100: "#82b1ff",
  A200: "#448aff",
  A400: "#2979ff",
  A700: "#2962ff"
};
const blue$1 = blue;
const lightBlue = {
  50: "#e1f5fe",
  100: "#b3e5fc",
  200: "#81d4fa",
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  600: "#039be5",
  700: "#0288d1",
  800: "#0277bd",
  900: "#01579b",
  A100: "#80d8ff",
  A200: "#40c4ff",
  A400: "#00b0ff",
  A700: "#0091ea"
};
const lightBlue$1 = lightBlue;
const green = {
  50: "#e8f5e9",
  100: "#c8e6c9",
  200: "#a5d6a7",
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  600: "#43a047",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20",
  A100: "#b9f6ca",
  A200: "#69f0ae",
  A400: "#00e676",
  A700: "#00c853"
};
const green$1 = green;
const orange = {
  50: "#fff3e0",
  100: "#ffe0b2",
  200: "#ffcc80",
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  600: "#fb8c00",
  700: "#f57c00",
  800: "#ef6c00",
  900: "#e65100",
  A100: "#ffd180",
  A200: "#ffab40",
  A400: "#ff9100",
  A700: "#ff6d00"
};
const orange$1 = orange;
const grey = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
};
const grey$1 = grey;
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function memoize$3(fn) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache[arg] === void 0)
      cache[arg] = fn(arg);
    return cache[arg];
  };
}
var reactPropsRegex$1 = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = /* @__PURE__ */ memoize$3(
  function(prop) {
    return reactPropsRegex$1.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
);
function sheetForTag$1(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i2 = 0; i2 < document.styleSheets.length; i2++) {
    if (document.styleSheets[i2].ownerNode === tag) {
      return document.styleSheets[i2];
    }
  }
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet$1 = /* @__PURE__ */ function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag$1(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e2) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
}();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash$2(value2, length2) {
  return charat(value2, 0) ^ 45 ? (((length2 << 2 ^ charat(value2, 0)) << 2 ^ charat(value2, 1)) << 2 ^ charat(value2, 2)) << 2 ^ charat(value2, 3) : 0;
}
function trim$1(value2) {
  return value2.trim();
}
function match(value2, pattern) {
  return (value2 = pattern.exec(value2)) ? value2[0] : value2;
}
function replace(value2, pattern, replacement) {
  return value2.replace(pattern, replacement);
}
function indexof(value2, search) {
  return value2.indexOf(search);
}
function charat(value2, index2) {
  return value2.charCodeAt(index2) | 0;
}
function substr(value2, begin, end) {
  return value2.slice(begin, end);
}
function strlen(value2) {
  return value2.length;
}
function sizeof(value2) {
  return value2.length;
}
function append(value2, array2) {
  return array2.push(value2), value2;
}
function combine(array2, callback) {
  return array2.map(callback).join("");
}
var line = 1;
var column = 1;
var length = 0;
var position$1 = 0;
var character = 0;
var characters = "";
function node(value2, root2, parent, type, props, children, length2) {
  return { value: value2, root: root2, parent, type, props, children, line, column, length: length2, return: "" };
}
function copy(root2, props) {
  return assign(node("", null, null, "", null, null, 0), root2, { length: -root2.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position$1 > 0 ? charat(characters, --position$1) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position$1 < length ? charat(characters, position$1++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position$1);
}
function caret() {
  return position$1;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token$1(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value2) {
  return line = column = 1, length = strlen(characters = value2), position$1 = 0, [];
}
function dealloc(value2) {
  return characters = "", value2;
}
function delimit(type) {
  return trim$1(slice(position$1 - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token$1(type) > 2 || token$1(character) > 3 ? "" : " ";
}
function escaping(index2, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      case type:
        return position$1;
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      case 92:
        next();
        break;
    }
  return position$1;
}
function commenter(type, index2) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index2, position$1 - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index2) {
  while (!token$1(peek()))
    next();
  return slice(index2, position$1);
}
function compile(value2) {
  return dealloc(parse("", null, null, null, [""], value2 = alloc(value2), 0, [0], value2));
}
function parse(value2, root2, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root2, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset:
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root2, parent, index2, offset, rules, points, type, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset === 0)
                parse(characters2, root2, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 109:
                  case 115:
                    parse(value2, reference, reference, rule && append(ruleset(value2, reference, reference, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index2 = offset = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value2, root2, parent, index2, offset, rules, points, type, props, children, length2) {
  var post = offset - 1;
  var rule = offset === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i2 = 0, j = 0, k2 = 0; i2 < index2; ++i2)
    for (var x2 = 0, y2 = substr(value2, post + 1, post = abs(j = points[i2])), z2 = value2; x2 < size; ++x2)
      if (z2 = trim$1(j > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
        props[k2++] = z2;
  return node(value2, root2, parent, offset === 0 ? RULESET : type, props, children, length2);
}
function comment(value2, root2, parent) {
  return node(value2, root2, parent, COMMENT, from(char()), substr(value2, 2, -2), 0);
}
function declaration(value2, root2, parent, length2) {
  return node(value2, root2, parent, DECLARATION, substr(value2, 0, length2), substr(value2, length2 + 1, -1), length2);
}
function serialize(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i2 = 0; i2 < length2; i2++)
    output += callback(children[i2], i2, children, callback) || "";
  return output;
}
function stringify(element, index2, children, callback) {
  switch (element.type) {
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index2, children, callback) {
    var output = "";
    for (var i2 = 0; i2 < length2; i2++)
      output += collection[i2](element, index2, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index2) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index2] = 1;
    }
    if (token$1(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position$1);
};
var toRules = function toRules2(parsed, points) {
  var index2 = -1;
  var character2 = 44;
  do {
    switch (token$1(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index2] = 1;
        }
        parsed[index2] += identifierWithPointTracking(position$1 - 1, points, index2);
        break;
      case 2:
        parsed[index2] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index2] = peek() === 58 ? "&\f" : "";
          points[index2] = parsed[index2].length;
          break;
        }
      default:
        parsed[index2] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value2, points) {
  return dealloc(toRules(alloc(value2), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || element.length < 1) {
    return;
  }
  var value2 = element.value, parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent)
      return;
  }
  if (element.props.length === 1 && value2.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value2, points);
  var parentRules = parent.props;
  for (var i2 = 0, k2 = 0; i2 < rules.length; i2++) {
    for (var j = 0; j < parentRules.length; j++, k2++) {
      element.props[k2] = points[i2] ? rules[i2].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i2];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value2 = element.value;
    if (value2.charCodeAt(0) === 108 && value2.charCodeAt(2) === 98) {
      element["return"] = "";
      element.value = "";
    }
  }
};
function prefix(value2, length2) {
  switch (hash$2(value2, length2)) {
    case 5103:
      return WEBKIT + "print-" + value2 + value2;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value2 + value2;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value2 + MOZ + value2 + MS + value2 + value2;
    case 6828:
    case 4268:
      return WEBKIT + value2 + MS + value2 + value2;
    case 6165:
      return WEBKIT + value2 + MS + "flex-" + value2 + value2;
    case 5187:
      return WEBKIT + value2 + replace(value2, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value2;
    case 5443:
      return WEBKIT + value2 + MS + "flex-item-" + replace(value2, /flex-|-self/, "") + value2;
    case 4675:
      return WEBKIT + value2 + MS + "flex-line-pack" + replace(value2, /align-content|flex-|-self/, "") + value2;
    case 5548:
      return WEBKIT + value2 + MS + replace(value2, "shrink", "negative") + value2;
    case 5292:
      return WEBKIT + value2 + MS + replace(value2, "basis", "preferred-size") + value2;
    case 6060:
      return WEBKIT + "box-" + replace(value2, "-grow", "") + WEBKIT + value2 + MS + replace(value2, "grow", "positive") + value2;
    case 4554:
      return WEBKIT + replace(value2, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value2;
    case 6187:
      return replace(replace(replace(value2, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value2, "") + value2;
    case 5495:
    case 3959:
      return replace(value2, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value2, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value2 + value2;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value2, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value2;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value2) - 1 - length2 > 6)
        switch (charat(value2, length2 + 1)) {
          case 109:
            if (charat(value2, length2 + 4) !== 45)
              break;
          case 102:
            return replace(value2, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value2, length2 + 3) == 108 ? "$3" : "$2-$3")) + value2;
          case 115:
            return ~indexof(value2, "stretch") ? prefix(replace(value2, "stretch", "fill-available"), length2) + value2 : value2;
        }
      break;
    case 4949:
      if (charat(value2, length2 + 1) !== 115)
        break;
    case 6444:
      switch (charat(value2, strlen(value2) - 3 - (~indexof(value2, "!important") && 10))) {
        case 107:
          return replace(value2, ":", ":" + WEBKIT) + value2;
        case 101:
          return replace(value2, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value2, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value2;
      }
      break;
    case 5936:
      switch (charat(value2, length2 + 11)) {
        case 114:
          return WEBKIT + value2 + MS + replace(value2, /[svh]\w+-[tblr]{2}/, "tb") + value2;
        case 108:
          return WEBKIT + value2 + MS + replace(value2, /[svh]\w+-[tblr]{2}/, "tb-rl") + value2;
        case 45:
          return WEBKIT + value2 + MS + replace(value2, /[svh]\w+-[tblr]{2}/, "lr") + value2;
      }
      return WEBKIT + value2 + MS + value2 + value2;
  }
  return value2;
}
var prefixer = function prefixer2(element, index2, children, callback) {
  if (element.length > -1) {
    if (!element["return"])
      switch (element.type) {
        case DECLARATION:
          element["return"] = prefix(element.value, element.length);
          break;
        case KEYFRAMES:
          return serialize([copy(element, {
            value: replace(element.value, "@", "@" + WEBKIT)
          })], callback);
        case RULESET:
          if (element.length)
            return combine(element.props, function(value2) {
              switch (match(value2, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return serialize([copy(element, {
                    props: [replace(value2, /:(read-\w+)/, ":" + MOZ + "$1")]
                  })], callback);
                case "::placeholder":
                  return serialize([copy(element, {
                    props: [replace(value2, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                  }), copy(element, {
                    props: [replace(value2, /:(plac\w+)/, ":" + MOZ + "$1")]
                  }), copy(element, {
                    props: [replace(value2, /:(plac\w+)/, MS + "input-$1")]
                  })], callback);
              }
              return "";
            });
      }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key = options.key;
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i2 = 1; i2 < attrib.length; i2++) {
          inserted[attrib[i2]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer2 = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis2 = function stylis3(styles) {
      return serialize(compile(styles), serializer2);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis2(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key,
    sheet: new StyleSheet$1({
      key,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};
var reactIs$2 = { exports: {} };
var reactIs_production_min$1 = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$1 = "function" === typeof Symbol && Symbol.for, c$2 = b$1 ? Symbol.for("react.element") : 60103, d$1 = b$1 ? Symbol.for("react.portal") : 60106, e$2 = b$1 ? Symbol.for("react.fragment") : 60107, f$2 = b$1 ? Symbol.for("react.strict_mode") : 60108, g$1 = b$1 ? Symbol.for("react.profiler") : 60114, h$3 = b$1 ? Symbol.for("react.provider") : 60109, k$3 = b$1 ? Symbol.for("react.context") : 60110, l$3 = b$1 ? Symbol.for("react.async_mode") : 60111, m$3 = b$1 ? Symbol.for("react.concurrent_mode") : 60111, n$4 = b$1 ? Symbol.for("react.forward_ref") : 60112, p$4 = b$1 ? Symbol.for("react.suspense") : 60113, q$4 = b$1 ? Symbol.for("react.suspense_list") : 60120, r$4 = b$1 ? Symbol.for("react.memo") : 60115, t$3 = b$1 ? Symbol.for("react.lazy") : 60116, v$2 = b$1 ? Symbol.for("react.block") : 60121, w$2 = b$1 ? Symbol.for("react.fundamental") : 60117, x$1 = b$1 ? Symbol.for("react.responder") : 60118, y$1 = b$1 ? Symbol.for("react.scope") : 60119;
function z$1(a) {
  if ("object" === typeof a && null !== a) {
    var u2 = a.$$typeof;
    switch (u2) {
      case c$2:
        switch (a = a.type, a) {
          case l$3:
          case m$3:
          case e$2:
          case g$1:
          case f$2:
          case p$4:
            return a;
          default:
            switch (a = a && a.$$typeof, a) {
              case k$3:
              case n$4:
              case t$3:
              case r$4:
              case h$3:
                return a;
              default:
                return u2;
            }
        }
      case d$1:
        return u2;
    }
  }
}
function A$1(a) {
  return z$1(a) === m$3;
}
reactIs_production_min$1.AsyncMode = l$3;
reactIs_production_min$1.ConcurrentMode = m$3;
reactIs_production_min$1.ContextConsumer = k$3;
reactIs_production_min$1.ContextProvider = h$3;
reactIs_production_min$1.Element = c$2;
reactIs_production_min$1.ForwardRef = n$4;
reactIs_production_min$1.Fragment = e$2;
reactIs_production_min$1.Lazy = t$3;
reactIs_production_min$1.Memo = r$4;
reactIs_production_min$1.Portal = d$1;
reactIs_production_min$1.Profiler = g$1;
reactIs_production_min$1.StrictMode = f$2;
reactIs_production_min$1.Suspense = p$4;
reactIs_production_min$1.isAsyncMode = function(a) {
  return A$1(a) || z$1(a) === l$3;
};
reactIs_production_min$1.isConcurrentMode = A$1;
reactIs_production_min$1.isContextConsumer = function(a) {
  return z$1(a) === k$3;
};
reactIs_production_min$1.isContextProvider = function(a) {
  return z$1(a) === h$3;
};
reactIs_production_min$1.isElement = function(a) {
  return "object" === typeof a && null !== a && a.$$typeof === c$2;
};
reactIs_production_min$1.isForwardRef = function(a) {
  return z$1(a) === n$4;
};
reactIs_production_min$1.isFragment = function(a) {
  return z$1(a) === e$2;
};
reactIs_production_min$1.isLazy = function(a) {
  return z$1(a) === t$3;
};
reactIs_production_min$1.isMemo = function(a) {
  return z$1(a) === r$4;
};
reactIs_production_min$1.isPortal = function(a) {
  return z$1(a) === d$1;
};
reactIs_production_min$1.isProfiler = function(a) {
  return z$1(a) === g$1;
};
reactIs_production_min$1.isStrictMode = function(a) {
  return z$1(a) === f$2;
};
reactIs_production_min$1.isSuspense = function(a) {
  return z$1(a) === p$4;
};
reactIs_production_min$1.isValidElementType = function(a) {
  return "string" === typeof a || "function" === typeof a || a === e$2 || a === m$3 || a === g$1 || a === f$2 || a === p$4 || a === q$4 || "object" === typeof a && null !== a && (a.$$typeof === t$3 || a.$$typeof === r$4 || a.$$typeof === h$3 || a.$$typeof === k$3 || a.$$typeof === n$4 || a.$$typeof === w$2 || a.$$typeof === x$1 || a.$$typeof === y$1 || a.$$typeof === v$2);
};
reactIs_production_min$1.typeOf = z$1;
(function(module2) {
  {
    module2.exports = reactIs_production_min$1;
  }
})(reactIs$2);
var reactIs$1 = reactIs$2.exports;
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS$1 = {};
TYPE_STATICS$1[reactIs$1.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS$1[reactIs$1.Memo] = MEMO_STATICS;
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = "";
  classNames.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache, serialized, isStringTag2) {
  var className = cache.key + "-" + serialized.name;
  if ((isStringTag2 === false || isBrowser === false) && cache.registered[className] === void 0) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache, serialized, isStringTag2) {
  registerStyles(cache, serialized, isStringTag2);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
function murmur2(str) {
  var h2 = 0;
  var k2, i2 = 0, len2 = str.length;
  for (; len2 >= 4; ++i2, len2 -= 4) {
    k2 = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
    k2 = (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= k2 >>> 24;
    h2 = (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len2) {
    case 3:
      h2 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i2) & 255;
      h2 = (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
var unitlessKeys$1 = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value2) {
  return value2 != null && typeof value2 !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize$3(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value2) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value2 === "string") {
        return value2.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys$1[key] !== 1 && !isCustomProperty(key) && typeof value2 === "number" && value2 !== 0) {
    return value2 + "px";
  }
  return value2;
};
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  if (interpolation.__emotion_styles !== void 0) {
    return interpolation;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      if (interpolation.anim === 1) {
        cursor = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor
        };
        return interpolation.name;
      }
      if (interpolation.styles !== void 0) {
        var next2 = interpolation.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles = interpolation.styles + ";";
        return styles;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  if (registered == null) {
    return interpolation;
  }
  var cached = registered[interpolation];
  return cached !== void 0 ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string2 = "";
  if (Array.isArray(obj)) {
    for (var i2 = 0; i2 < obj.length; i2++) {
      string2 += handleInterpolation(mergedProps, registered, obj[i2]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value2 = obj[_key];
      if (typeof value2 !== "object") {
        if (registered != null && registered[value2] !== void 0) {
          string2 += _key + "{" + registered[value2] + "}";
        } else if (isProcessableValue(value2)) {
          string2 += processStyleName(_key) + ":" + processStyleValue(_key, value2) + ";";
        }
      } else {
        if (_key === "NO_COMPONENT_SELECTOR" && false) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value2) && typeof value2[0] === "string" && (registered == null || registered[value2[0]] === void 0)) {
          for (var _i = 0; _i < value2.length; _i++) {
            if (isProcessableValue(value2[_i])) {
              string2 += processStyleName(_key) + ":" + processStyleValue(_key, value2[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value2);
          switch (_key) {
            case "animation":
            case "animationName": {
              string2 += processStyleName(_key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string2 += _key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string2;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var cursor;
var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings);
  } else {
    styles += strings[0];
  }
  for (var i2 = 1; i2 < args.length; i2++) {
    styles += handleInterpolation(mergedProps, registered, args[i2]);
    if (stringMode) {
      styles += strings[i2];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles)) !== null) {
    identifierName += "-" + match2[1];
  }
  var name = murmur2(styles) + identifierName;
  return {
    name,
    styles,
    next: cursor
  };
};
var syncFallback = function syncFallback2(create2) {
  return create2();
};
var useInsertionEffect = React$1["useInsertionEffect"] ? React$1["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var EmotionCacheContext = /* @__PURE__ */ react.exports.createContext(
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
    var cache = react.exports.useContext(EmotionCacheContext);
    return func(props, cache, ref);
  });
};
var ThemeContext$3 = /* @__PURE__ */ react.exports.createContext({});
function css$1() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
var keyframes = function keyframes2() {
  var insertable = css$1.apply(void 0, arguments);
  var name = "animation-" + insertable.name;
  return {
    name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString2() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};
var testOmitPropsOnStringTag = isPropValid;
var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
  return key !== "theme";
};
var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
  return typeof tag === "string" && tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
  var shouldForwardProp2;
  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp2 !== "function" && isReal) {
    shouldForwardProp2 = tag.__emotion_forwardProp;
  }
  return shouldForwardProp2;
};
var Insertion = function Insertion2(_ref) {
  var cache = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag2);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag2);
  });
  return null;
};
var createStyled$1 = function createStyled2(tag, options) {
  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal);
  var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp("as");
  return function() {
    var args = arguments;
    var styles = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
    if (identifierName !== void 0) {
      styles.push("label:" + identifierName + ";");
    }
    if (args[0] == null || args[0].raw === void 0) {
      styles.push.apply(styles, args);
    } else {
      styles.push(args[0][0]);
      var len2 = args.length;
      var i2 = 1;
      for (; i2 < len2; i2++) {
        styles.push(args[i2], args[0][i2]);
      }
    }
    var Styled = withEmotionCache(function(props, cache, ref) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = "";
      var classInterpolations = [];
      var mergedProps = props;
      if (props.theme == null) {
        mergedProps = {};
        for (var key in props) {
          mergedProps[key] = props[key];
        }
        mergedProps.theme = react.exports.useContext(ThemeContext$3);
      }
      if (typeof props.className === "string") {
        className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = serializeStyles(styles.concat(classInterpolations), cache.registered, mergedProps);
      className += cache.key + "-" + serialized.name;
      if (targetClassName !== void 0) {
        className += " " + targetClassName;
      }
      var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};
      for (var _key in props) {
        if (shouldUseAs && _key === "as")
          continue;
        if (finalShouldForwardProp(_key)) {
          newProps[_key] = props[_key];
        }
      }
      newProps.className = className;
      newProps.ref = ref;
      return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement(Insertion, {
        cache,
        serialized,
        isStringTag: typeof FinalTag === "string"
      }), /* @__PURE__ */ react.exports.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles;
    Styled.__emotion_forwardProp = shouldForwardProp2;
    Object.defineProperty(Styled, "toString", {
      value: function value2() {
        if (targetClassName === void 0 && false) {
          return "NO_COMPONENT_SELECTOR";
        }
        return "." + targetClassName;
      }
    });
    Styled.withComponent = function(nextTag, nextOptions) {
      return createStyled2(nextTag, _extends$1({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      })).apply(void 0, styles);
    };
    return Styled;
  };
};
var tags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
var newStyled = createStyled$1.bind();
tags.forEach(function(tagName) {
  newStyled[tagName] = newStyled(tagName);
});
const emStyled = newStyled;
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$1 = react.exports, k$2 = Symbol.for("react.element"), l$2 = Symbol.for("react.fragment"), m$2 = Object.prototype.hasOwnProperty, n$3 = f$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$3 = { key: true, ref: true, __self: true, __source: true };
function q$3(c2, a, g2) {
  var b2, d2 = {}, e2 = null, h2 = null;
  void 0 !== g2 && (e2 = "" + g2);
  void 0 !== a.key && (e2 = "" + a.key);
  void 0 !== a.ref && (h2 = a.ref);
  for (b2 in a)
    m$2.call(a, b2) && !p$3.hasOwnProperty(b2) && (d2[b2] = a[b2]);
  if (c2 && c2.defaultProps)
    for (b2 in a = c2.defaultProps, a)
      void 0 === d2[b2] && (d2[b2] = a[b2]);
  return { $$typeof: k$2, type: c2, key: e2, ref: h2, props: d2, _owner: n$3.current };
}
reactJsxRuntime_production_min.Fragment = l$2;
reactJsxRuntime_production_min.jsx = q$3;
reactJsxRuntime_production_min.jsxs = q$3;
(function(module2) {
  {
    module2.exports = reactJsxRuntime_production_min;
  }
})(jsxRuntime);
const Fragment = jsxRuntime.exports.Fragment;
const jsx = jsxRuntime.exports.jsx;
const jsxs = jsxRuntime.exports.jsxs;
/** @license MUI v5.10.14
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function styled$4(tag, options) {
  const stylesFactory = emStyled(tag, options);
  return stylesFactory;
}
const internal_processStyles = (tag, processor) => {
  if (Array.isArray(tag.__emotion_styles)) {
    tag.__emotion_styles = processor(tag.__emotion_styles);
  }
};
function isPlainObject$4(item) {
  return item !== null && typeof item === "object" && item.constructor === Object;
}
function deepmerge(target, source, options = {
  clone: true
}) {
  const output = options.clone ? _extends$1({}, target) : target;
  if (isPlainObject$4(target) && isPlainObject$4(source)) {
    Object.keys(source).forEach((key) => {
      if (key === "__proto__") {
        return;
      }
      if (isPlainObject$4(source[key]) && key in target && isPlainObject$4(target[key])) {
        output[key] = deepmerge(target[key], source[key], options);
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}
function formatMuiErrorMessage(code2) {
  let url2 = "https://mui.com/production-error/?code=" + code2;
  for (let i2 = 1; i2 < arguments.length; i2 += 1) {
    url2 += "&args[]=" + encodeURIComponent(arguments[i2]);
  }
  return "Minified MUI error #" + code2 + "; visit " + url2 + " for the full message.";
}
function capitalize(string2) {
  if (typeof string2 !== "string") {
    throw new Error(formatMuiErrorMessage(7));
  }
  return string2.charAt(0).toUpperCase() + string2.slice(1);
}
function setRef$1(ref, value2) {
  if (typeof ref === "function") {
    ref(value2);
  } else if (ref) {
    ref.current = value2;
  }
}
const useEnhancedEffect = typeof window !== "undefined" ? react.exports.useLayoutEffect : react.exports.useEffect;
const useEnhancedEffect$1 = useEnhancedEffect;
function useEventCallback(fn) {
  const ref = react.exports.useRef(fn);
  useEnhancedEffect$1(() => {
    ref.current = fn;
  });
  return react.exports.useCallback((...args) => (0, ref.current)(...args), []);
}
function useForkRef(...refs) {
  return react.exports.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (instance) => {
      refs.forEach((ref) => {
        setRef$1(ref, instance);
      });
    };
  }, refs);
}
let hadKeyboardEvent = true;
let hadFocusVisibleRecently = false;
let hadFocusVisibleRecentlyTimeout;
const inputTypesWhitelist = {
  text: true,
  search: true,
  url: true,
  tel: true,
  email: true,
  password: true,
  number: true,
  date: true,
  month: true,
  week: true,
  time: true,
  datetime: true,
  "datetime-local": true
};
function focusTriggersKeyboardModality(node2) {
  const {
    type,
    tagName
  } = node2;
  if (tagName === "INPUT" && inputTypesWhitelist[type] && !node2.readOnly) {
    return true;
  }
  if (tagName === "TEXTAREA" && !node2.readOnly) {
    return true;
  }
  if (node2.isContentEditable) {
    return true;
  }
  return false;
}
function handleKeyDown(event) {
  if (event.metaKey || event.altKey || event.ctrlKey) {
    return;
  }
  hadKeyboardEvent = true;
}
function handlePointerDown() {
  hadKeyboardEvent = false;
}
function handleVisibilityChange() {
  if (this.visibilityState === "hidden") {
    if (hadFocusVisibleRecently) {
      hadKeyboardEvent = true;
    }
  }
}
function prepare(doc) {
  doc.addEventListener("keydown", handleKeyDown, true);
  doc.addEventListener("mousedown", handlePointerDown, true);
  doc.addEventListener("pointerdown", handlePointerDown, true);
  doc.addEventListener("touchstart", handlePointerDown, true);
  doc.addEventListener("visibilitychange", handleVisibilityChange, true);
}
function isFocusVisible(event) {
  const {
    target
  } = event;
  try {
    return target.matches(":focus-visible");
  } catch (error) {
  }
  return hadKeyboardEvent || focusTriggersKeyboardModality(target);
}
function useIsFocusVisible() {
  const ref = react.exports.useCallback((node2) => {
    if (node2 != null) {
      prepare(node2.ownerDocument);
    }
  }, []);
  const isFocusVisibleRef = react.exports.useRef(false);
  function handleBlurVisible() {
    if (isFocusVisibleRef.current) {
      hadFocusVisibleRecently = true;
      window.clearTimeout(hadFocusVisibleRecentlyTimeout);
      hadFocusVisibleRecentlyTimeout = window.setTimeout(() => {
        hadFocusVisibleRecently = false;
      }, 100);
      isFocusVisibleRef.current = false;
      return true;
    }
    return false;
  }
  function handleFocusVisible(event) {
    if (isFocusVisible(event)) {
      isFocusVisibleRef.current = true;
      return true;
    }
    return false;
  }
  return {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref
  };
}
function resolveProps(defaultProps2, props) {
  const output = _extends$1({}, props);
  Object.keys(defaultProps2).forEach((propName) => {
    if (output[propName] === void 0) {
      output[propName] = defaultProps2[propName];
    }
  });
  return output;
}
function composeClasses(slots, getUtilityClass, classes) {
  const output = {};
  Object.keys(slots).forEach(
    (slot) => {
      output[slot] = slots[slot].reduce((acc, key) => {
        if (key) {
          acc.push(getUtilityClass(key));
          if (classes && classes[key]) {
            acc.push(classes[key]);
          }
        }
        return acc;
      }, []).join(" ");
    }
  );
  return output;
}
const defaultGenerator = (componentName) => componentName;
const createClassNameGenerator = () => {
  let generate = defaultGenerator;
  return {
    configure(generator) {
      generate = generator;
    },
    generate(componentName) {
      return generate(componentName);
    },
    reset() {
      generate = defaultGenerator;
    }
  };
};
const ClassNameGenerator = createClassNameGenerator();
const ClassNameGenerator$1 = ClassNameGenerator;
const globalStateClassesMapping = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  required: "required",
  selected: "selected"
};
function generateUtilityClass(componentName, slot, globalStatePrefix = "Mui") {
  const globalStateClass = globalStateClassesMapping[slot];
  return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator$1.generate(componentName)}-${slot}`;
}
function generateUtilityClasses(componentName, slots, globalStatePrefix = "Mui") {
  const result = {};
  slots.forEach((slot) => {
    result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
  });
  return result;
}
function merge$2(acc, item) {
  if (!item) {
    return acc;
  }
  return deepmerge(acc, item, {
    clone: false
  });
}
const values$1 = {
  xs: 0,
  sm: 600,
  md: 900,
  lg: 1200,
  xl: 1536
};
const defaultBreakpoints = {
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (key) => `@media (min-width:${values$1[key]}px)`
};
function handleBreakpoints(props, propValue, styleFromPropValue) {
  const theme = props.theme || {};
  if (Array.isArray(propValue)) {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return propValue.reduce((acc, item, index2) => {
      acc[themeBreakpoints.up(themeBreakpoints.keys[index2])] = styleFromPropValue(propValue[index2]);
      return acc;
    }, {});
  }
  if (typeof propValue === "object") {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return Object.keys(propValue).reduce((acc, breakpoint) => {
      if (Object.keys(themeBreakpoints.values || values$1).indexOf(breakpoint) !== -1) {
        const mediaKey = themeBreakpoints.up(breakpoint);
        acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
      } else {
        const cssKey = breakpoint;
        acc[cssKey] = propValue[cssKey];
      }
      return acc;
    }, {});
  }
  const output = styleFromPropValue(propValue);
  return output;
}
function createEmptyBreakpointObject(breakpointsInput = {}) {
  var _breakpointsInput$key;
  const breakpointsInOrder = (_breakpointsInput$key = breakpointsInput.keys) == null ? void 0 : _breakpointsInput$key.reduce((acc, key) => {
    const breakpointStyleKey = breakpointsInput.up(key);
    acc[breakpointStyleKey] = {};
    return acc;
  }, {});
  return breakpointsInOrder || {};
}
function removeUnusedBreakpoints(breakpointKeys, style2) {
  return breakpointKeys.reduce((acc, key) => {
    const breakpointOutput = acc[key];
    const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
    if (isBreakpointUnused) {
      delete acc[key];
    }
    return acc;
  }, style2);
}
function getPath(obj, path, checkVars = true) {
  if (!path || typeof path !== "string") {
    return null;
  }
  if (obj && obj.vars && checkVars) {
    const val = `vars.${path}`.split(".").reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
    if (val != null) {
      return val;
    }
  }
  return path.split(".").reduce((acc, item) => {
    if (acc && acc[item] != null) {
      return acc[item];
    }
    return null;
  }, obj);
}
function getValue$1(themeMapping, transform2, propValueFinal, userValue = propValueFinal) {
  let value2;
  if (typeof themeMapping === "function") {
    value2 = themeMapping(propValueFinal);
  } else if (Array.isArray(themeMapping)) {
    value2 = themeMapping[propValueFinal] || userValue;
  } else {
    value2 = getPath(themeMapping, propValueFinal) || userValue;
  }
  if (transform2) {
    value2 = transform2(value2, userValue);
  }
  return value2;
}
function style$1(options) {
  const {
    prop,
    cssProperty = options.prop,
    themeKey,
    transform: transform2
  } = options;
  const fn = (props) => {
    if (props[prop] == null) {
      return null;
    }
    const propValue = props[prop];
    const theme = props.theme;
    const themeMapping = getPath(theme, themeKey) || {};
    const styleFromPropValue = (propValueFinal) => {
      let value2 = getValue$1(themeMapping, transform2, propValueFinal);
      if (propValueFinal === value2 && typeof propValueFinal === "string") {
        value2 = getValue$1(themeMapping, transform2, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value2;
      }
      return {
        [cssProperty]: value2
      };
    };
    return handleBreakpoints(props, propValue, styleFromPropValue);
  };
  fn.propTypes = {};
  fn.filterProps = [prop];
  return fn;
}
function compose(...styles) {
  const handlers = styles.reduce((acc, style2) => {
    style2.filterProps.forEach((prop) => {
      acc[prop] = style2;
    });
    return acc;
  }, {});
  const fn = (props) => {
    return Object.keys(props).reduce((acc, prop) => {
      if (handlers[prop]) {
        return merge$2(acc, handlers[prop](props));
      }
      return acc;
    }, {});
  };
  fn.propTypes = {};
  fn.filterProps = styles.reduce((acc, style2) => acc.concat(style2.filterProps), []);
  return fn;
}
function memoize$2(fn) {
  const cache = {};
  return (arg) => {
    if (cache[arg] === void 0) {
      cache[arg] = fn(arg);
    }
    return cache[arg];
  };
}
const properties = {
  m: "margin",
  p: "padding"
};
const directions = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
};
const aliases = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
};
const getCssProperties = memoize$2((prop) => {
  if (prop.length > 2) {
    if (aliases[prop]) {
      prop = aliases[prop];
    } else {
      return [prop];
    }
  }
  const [a, b2] = prop.split("");
  const property = properties[a];
  const direction = directions[b2] || "";
  return Array.isArray(direction) ? direction.map((dir) => property + dir) : [property + direction];
});
const marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"];
const paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
const spacingKeys = [...marginKeys, ...paddingKeys];
function createUnaryUnit(theme, themeKey, defaultValue, propName) {
  var _getPath;
  const themeSpacing = (_getPath = getPath(theme, themeKey, false)) != null ? _getPath : defaultValue;
  if (typeof themeSpacing === "number") {
    return (abs2) => {
      if (typeof abs2 === "string") {
        return abs2;
      }
      return themeSpacing * abs2;
    };
  }
  if (Array.isArray(themeSpacing)) {
    return (abs2) => {
      if (typeof abs2 === "string") {
        return abs2;
      }
      return themeSpacing[abs2];
    };
  }
  if (typeof themeSpacing === "function") {
    return themeSpacing;
  }
  return () => void 0;
}
function createUnarySpacing(theme) {
  return createUnaryUnit(theme, "spacing", 8);
}
function getValue(transformer, propValue) {
  if (typeof propValue === "string" || propValue == null) {
    return propValue;
  }
  const abs2 = Math.abs(propValue);
  const transformed = transformer(abs2);
  if (propValue >= 0) {
    return transformed;
  }
  if (typeof transformed === "number") {
    return -transformed;
  }
  return `-${transformed}`;
}
function getStyleFromPropValue(cssProperties, transformer) {
  return (propValue) => cssProperties.reduce((acc, cssProperty) => {
    acc[cssProperty] = getValue(transformer, propValue);
    return acc;
  }, {});
}
function resolveCssProperty(props, keys, prop, transformer) {
  if (keys.indexOf(prop) === -1) {
    return null;
  }
  const cssProperties = getCssProperties(prop);
  const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
  const propValue = props[prop];
  return handleBreakpoints(props, propValue, styleFromPropValue);
}
function style(props, keys) {
  const transformer = createUnarySpacing(props.theme);
  return Object.keys(props).map((prop) => resolveCssProperty(props, keys, prop, transformer)).reduce(merge$2, {});
}
function spacing(props) {
  return style(props, spacingKeys);
}
spacing.propTypes = {};
spacing.filterProps = spacingKeys;
function getBorder(value2) {
  if (typeof value2 !== "number") {
    return value2;
  }
  return `${value2}px solid`;
}
const border = style$1({
  prop: "border",
  themeKey: "borders",
  transform: getBorder
});
const borderTop = style$1({
  prop: "borderTop",
  themeKey: "borders",
  transform: getBorder
});
const borderRight = style$1({
  prop: "borderRight",
  themeKey: "borders",
  transform: getBorder
});
const borderBottom = style$1({
  prop: "borderBottom",
  themeKey: "borders",
  transform: getBorder
});
const borderLeft = style$1({
  prop: "borderLeft",
  themeKey: "borders",
  transform: getBorder
});
const borderColor = style$1({
  prop: "borderColor",
  themeKey: "palette"
});
const borderTopColor = style$1({
  prop: "borderTopColor",
  themeKey: "palette"
});
const borderRightColor = style$1({
  prop: "borderRightColor",
  themeKey: "palette"
});
const borderBottomColor = style$1({
  prop: "borderBottomColor",
  themeKey: "palette"
});
const borderLeftColor = style$1({
  prop: "borderLeftColor",
  themeKey: "palette"
});
const borderRadius = (props) => {
  if (props.borderRadius !== void 0 && props.borderRadius !== null) {
    const transformer = createUnaryUnit(props.theme, "shape.borderRadius", 4);
    const styleFromPropValue = (propValue) => ({
      borderRadius: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
  }
  return null;
};
borderRadius.propTypes = {};
borderRadius.filterProps = ["borderRadius"];
const borders = compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius);
const borders$1 = borders;
const displayPrint = style$1({
  prop: "displayPrint",
  cssProperty: false,
  transform: (value2) => ({
    "@media print": {
      display: value2
    }
  })
});
const displayRaw = style$1({
  prop: "display"
});
const overflow = style$1({
  prop: "overflow"
});
const textOverflow = style$1({
  prop: "textOverflow"
});
const visibility = style$1({
  prop: "visibility"
});
const whiteSpace = style$1({
  prop: "whiteSpace"
});
const display = compose(displayPrint, displayRaw, overflow, textOverflow, visibility, whiteSpace);
const flexBasis = style$1({
  prop: "flexBasis"
});
const flexDirection = style$1({
  prop: "flexDirection"
});
const flexWrap = style$1({
  prop: "flexWrap"
});
const justifyContent = style$1({
  prop: "justifyContent"
});
const alignItems = style$1({
  prop: "alignItems"
});
const alignContent = style$1({
  prop: "alignContent"
});
const order = style$1({
  prop: "order"
});
const flex = style$1({
  prop: "flex"
});
const flexGrow = style$1({
  prop: "flexGrow"
});
const flexShrink = style$1({
  prop: "flexShrink"
});
const alignSelf = style$1({
  prop: "alignSelf"
});
const justifyItems = style$1({
  prop: "justifyItems"
});
const justifySelf = style$1({
  prop: "justifySelf"
});
const flexbox = compose(flexBasis, flexDirection, flexWrap, justifyContent, alignItems, alignContent, order, flex, flexGrow, flexShrink, alignSelf, justifyItems, justifySelf);
const flexbox$1 = flexbox;
const gap = (props) => {
  if (props.gap !== void 0 && props.gap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      gap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.gap, styleFromPropValue);
  }
  return null;
};
gap.propTypes = {};
gap.filterProps = ["gap"];
const columnGap = (props) => {
  if (props.columnGap !== void 0 && props.columnGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      columnGap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.columnGap, styleFromPropValue);
  }
  return null;
};
columnGap.propTypes = {};
columnGap.filterProps = ["columnGap"];
const rowGap = (props) => {
  if (props.rowGap !== void 0 && props.rowGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      rowGap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.rowGap, styleFromPropValue);
  }
  return null;
};
rowGap.propTypes = {};
rowGap.filterProps = ["rowGap"];
const gridColumn = style$1({
  prop: "gridColumn"
});
const gridRow = style$1({
  prop: "gridRow"
});
const gridAutoFlow = style$1({
  prop: "gridAutoFlow"
});
const gridAutoColumns = style$1({
  prop: "gridAutoColumns"
});
const gridAutoRows = style$1({
  prop: "gridAutoRows"
});
const gridTemplateColumns = style$1({
  prop: "gridTemplateColumns"
});
const gridTemplateRows = style$1({
  prop: "gridTemplateRows"
});
const gridTemplateAreas = style$1({
  prop: "gridTemplateAreas"
});
const gridArea = style$1({
  prop: "gridArea"
});
const grid = compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
const grid$1 = grid;
function transform$1(value2, userValue) {
  if (userValue === "grey") {
    return userValue;
  }
  return value2;
}
const color = style$1({
  prop: "color",
  themeKey: "palette",
  transform: transform$1
});
const bgcolor = style$1({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: transform$1
});
const backgroundColor = style$1({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: transform$1
});
const palette = compose(color, bgcolor, backgroundColor);
const palette$1 = palette;
const position = style$1({
  prop: "position"
});
const zIndex$2 = style$1({
  prop: "zIndex",
  themeKey: "zIndex"
});
const top = style$1({
  prop: "top"
});
const right = style$1({
  prop: "right"
});
const bottom = style$1({
  prop: "bottom"
});
const left = style$1({
  prop: "left"
});
const positions = compose(position, zIndex$2, top, right, bottom, left);
const boxShadow = style$1({
  prop: "boxShadow",
  themeKey: "shadows"
});
const shadows$2 = boxShadow;
function transform(value2) {
  return value2 <= 1 && value2 !== 0 ? `${value2 * 100}%` : value2;
}
const width = style$1({
  prop: "width",
  transform
});
const maxWidth = (props) => {
  if (props.maxWidth !== void 0 && props.maxWidth !== null) {
    const styleFromPropValue = (propValue) => {
      var _props$theme, _props$theme$breakpoi, _props$theme$breakpoi2;
      const breakpoint = ((_props$theme = props.theme) == null ? void 0 : (_props$theme$breakpoi = _props$theme.breakpoints) == null ? void 0 : (_props$theme$breakpoi2 = _props$theme$breakpoi.values) == null ? void 0 : _props$theme$breakpoi2[propValue]) || values$1[propValue];
      return {
        maxWidth: breakpoint || transform(propValue)
      };
    };
    return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
  }
  return null;
};
maxWidth.filterProps = ["maxWidth"];
const minWidth = style$1({
  prop: "minWidth",
  transform
});
const height = style$1({
  prop: "height",
  transform
});
const maxHeight = style$1({
  prop: "maxHeight",
  transform
});
const minHeight = style$1({
  prop: "minHeight",
  transform
});
style$1({
  prop: "size",
  cssProperty: "width",
  transform
});
style$1({
  prop: "size",
  cssProperty: "height",
  transform
});
const boxSizing = style$1({
  prop: "boxSizing"
});
const sizing = compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
const sizing$1 = sizing;
const fontFamily = style$1({
  prop: "fontFamily",
  themeKey: "typography"
});
const fontSize = style$1({
  prop: "fontSize",
  themeKey: "typography"
});
const fontStyle = style$1({
  prop: "fontStyle",
  themeKey: "typography"
});
const fontWeight = style$1({
  prop: "fontWeight",
  themeKey: "typography"
});
const letterSpacing = style$1({
  prop: "letterSpacing"
});
const textTransform = style$1({
  prop: "textTransform"
});
const lineHeight = style$1({
  prop: "lineHeight"
});
const textAlign = style$1({
  prop: "textAlign"
});
const typographyVariant = style$1({
  prop: "typography",
  cssProperty: false,
  themeKey: "typography"
});
const typography = compose(typographyVariant, fontFamily, fontSize, fontStyle, fontWeight, letterSpacing, lineHeight, textAlign, textTransform);
const typography$1 = typography;
const filterPropsMapping = {
  borders: borders$1.filterProps,
  display: display.filterProps,
  flexbox: flexbox$1.filterProps,
  grid: grid$1.filterProps,
  positions: positions.filterProps,
  palette: palette$1.filterProps,
  shadows: shadows$2.filterProps,
  sizing: sizing$1.filterProps,
  spacing: spacing.filterProps,
  typography: typography$1.filterProps
};
const styleFunctionMapping = {
  borders: borders$1,
  display,
  flexbox: flexbox$1,
  grid: grid$1,
  positions,
  palette: palette$1,
  shadows: shadows$2,
  sizing: sizing$1,
  spacing,
  typography: typography$1
};
Object.keys(filterPropsMapping).reduce((acc, styleFnName) => {
  filterPropsMapping[styleFnName].forEach((propName) => {
    acc[propName] = styleFunctionMapping[styleFnName];
  });
  return acc;
}, {});
function objectsHaveSameKeys(...objects) {
  const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);
  const union2 = new Set(allKeys);
  return objects.every((object) => union2.size === Object.keys(object).length);
}
function callIfFn(maybeFn, arg) {
  return typeof maybeFn === "function" ? maybeFn(arg) : maybeFn;
}
function unstable_createStyleFunctionSx(styleFunctionMapping$1 = styleFunctionMapping) {
  const propToStyleFunction = Object.keys(styleFunctionMapping$1).reduce((acc, styleFnName) => {
    styleFunctionMapping$1[styleFnName].filterProps.forEach((propName) => {
      acc[propName] = styleFunctionMapping$1[styleFnName];
    });
    return acc;
  }, {});
  function getThemeValue(prop, value2, theme) {
    const inputProps = {
      [prop]: value2,
      theme
    };
    const styleFunction = propToStyleFunction[prop];
    return styleFunction ? styleFunction(inputProps) : {
      [prop]: value2
    };
  }
  function styleFunctionSx2(props) {
    const {
      sx,
      theme = {}
    } = props || {};
    if (!sx) {
      return null;
    }
    function traverse(sxInput) {
      let sxObject = sxInput;
      if (typeof sxInput === "function") {
        sxObject = sxInput(theme);
      } else if (typeof sxInput !== "object") {
        return sxInput;
      }
      if (!sxObject) {
        return null;
      }
      const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
      const breakpointsKeys = Object.keys(emptyBreakpoints);
      let css2 = emptyBreakpoints;
      Object.keys(sxObject).forEach((styleKey) => {
        const value2 = callIfFn(sxObject[styleKey], theme);
        if (value2 !== null && value2 !== void 0) {
          if (typeof value2 === "object") {
            if (propToStyleFunction[styleKey]) {
              css2 = merge$2(css2, getThemeValue(styleKey, value2, theme));
            } else {
              const breakpointsValues = handleBreakpoints({
                theme
              }, value2, (x2) => ({
                [styleKey]: x2
              }));
              if (objectsHaveSameKeys(breakpointsValues, value2)) {
                css2[styleKey] = styleFunctionSx2({
                  sx: value2,
                  theme
                });
              } else {
                css2 = merge$2(css2, breakpointsValues);
              }
            }
          } else {
            css2 = merge$2(css2, getThemeValue(styleKey, value2, theme));
          }
        }
      });
      return removeUnusedBreakpoints(breakpointsKeys, css2);
    }
    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
  }
  return styleFunctionSx2;
}
const styleFunctionSx = unstable_createStyleFunctionSx();
styleFunctionSx.filterProps = ["sx"];
const defaultStyleFunctionSx = styleFunctionSx;
function r$3(e2) {
  var t2, f2, n2 = "";
  if ("string" == typeof e2 || "number" == typeof e2)
    n2 += e2;
  else if ("object" == typeof e2)
    if (Array.isArray(e2))
      for (t2 = 0; t2 < e2.length; t2++)
        e2[t2] && (f2 = r$3(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
    else
      for (t2 in e2)
        e2[t2] && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
function clsx() {
  for (var e2, t2, f2 = 0, n2 = ""; f2 < arguments.length; )
    (e2 = arguments[f2++]) && (t2 = r$3(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
const _excluded$a = ["values", "unit", "step"];
const sortBreakpointsValues = (values2) => {
  const breakpointsAsArray = Object.keys(values2).map((key) => ({
    key,
    val: values2[key]
  })) || [];
  breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
  return breakpointsAsArray.reduce((acc, obj) => {
    return _extends$1({}, acc, {
      [obj.key]: obj.val
    });
  }, {});
};
function createBreakpoints(breakpoints) {
  const {
    values: values2 = {
      xs: 0,
      sm: 600,
      md: 900,
      lg: 1200,
      xl: 1536
    },
    unit = "px",
    step = 5
  } = breakpoints, other = _objectWithoutPropertiesLoose$1(breakpoints, _excluded$a);
  const sortedValues = sortBreakpointsValues(values2);
  const keys = Object.keys(sortedValues);
  function up(key) {
    const value2 = typeof values2[key] === "number" ? values2[key] : key;
    return `@media (min-width:${value2}${unit})`;
  }
  function down(key) {
    const value2 = typeof values2[key] === "number" ? values2[key] : key;
    return `@media (max-width:${value2 - step / 100}${unit})`;
  }
  function between(start, end) {
    const endIndex = keys.indexOf(end);
    return `@media (min-width:${typeof values2[start] === "number" ? values2[start] : start}${unit}) and (max-width:${(endIndex !== -1 && typeof values2[keys[endIndex]] === "number" ? values2[keys[endIndex]] : end) - step / 100}${unit})`;
  }
  function only(key) {
    if (keys.indexOf(key) + 1 < keys.length) {
      return between(key, keys[keys.indexOf(key) + 1]);
    }
    return up(key);
  }
  function not(key) {
    const keyIndex = keys.indexOf(key);
    if (keyIndex === 0) {
      return up(keys[1]);
    }
    if (keyIndex === keys.length - 1) {
      return down(keys[keyIndex]);
    }
    return between(key, keys[keys.indexOf(key) + 1]).replace("@media", "@media not all and");
  }
  return _extends$1({
    keys,
    values: sortedValues,
    up,
    down,
    between,
    only,
    not,
    unit
  }, other);
}
const shape = {
  borderRadius: 4
};
const shape$1 = shape;
function createSpacing(spacingInput = 8) {
  if (spacingInput.mui) {
    return spacingInput;
  }
  const transform2 = createUnarySpacing({
    spacing: spacingInput
  });
  const spacing2 = (...argsInput) => {
    const args = argsInput.length === 0 ? [1] : argsInput;
    return args.map((argument) => {
      const output = transform2(argument);
      return typeof output === "number" ? `${output}px` : output;
    }).join(" ");
  };
  spacing2.mui = true;
  return spacing2;
}
const _excluded$9 = ["breakpoints", "palette", "spacing", "shape"];
function createTheme$1(options = {}, ...args) {
  const {
    breakpoints: breakpointsInput = {},
    palette: paletteInput = {},
    spacing: spacingInput,
    shape: shapeInput = {}
  } = options, other = _objectWithoutPropertiesLoose$1(options, _excluded$9);
  const breakpoints = createBreakpoints(breakpointsInput);
  const spacing2 = createSpacing(spacingInput);
  let muiTheme = deepmerge({
    breakpoints,
    direction: "ltr",
    components: {},
    palette: _extends$1({
      mode: "light"
    }, paletteInput),
    spacing: spacing2,
    shape: _extends$1({}, shape$1, shapeInput)
  }, other);
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  return muiTheme;
}
const ThemeContext$1 = /* @__PURE__ */ react.exports.createContext(null);
const ThemeContext$2 = ThemeContext$1;
function useTheme$2() {
  const theme = react.exports.useContext(ThemeContext$2);
  return theme;
}
function isObjectEmpty(obj) {
  return Object.keys(obj).length === 0;
}
function useTheme$1(defaultTheme2 = null) {
  const contextTheme = useTheme$2();
  return !contextTheme || isObjectEmpty(contextTheme) ? defaultTheme2 : contextTheme;
}
const systemDefaultTheme$1 = createTheme$1();
function useTheme(defaultTheme2 = systemDefaultTheme$1) {
  return useTheme$1(defaultTheme2);
}
const _excluded$8 = ["variant"];
function isEmpty$1(string2) {
  return string2.length === 0;
}
function propsToClassKey(props) {
  const {
    variant
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$8);
  let classKey = variant || "";
  Object.keys(other).sort().forEach((key) => {
    if (key === "color") {
      classKey += isEmpty$1(classKey) ? props[key] : capitalize(props[key]);
    } else {
      classKey += `${isEmpty$1(classKey) ? key : capitalize(key)}${capitalize(props[key].toString())}`;
    }
  });
  return classKey;
}
const _excluded$7 = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"], _excluded2 = ["theme"], _excluded3 = ["theme"];
function isEmpty(obj) {
  return Object.keys(obj).length === 0;
}
function isStringTag(tag) {
  return typeof tag === "string" && tag.charCodeAt(0) > 96;
}
const getStyleOverrides = (name, theme) => {
  if (theme.components && theme.components[name] && theme.components[name].styleOverrides) {
    return theme.components[name].styleOverrides;
  }
  return null;
};
const getVariantStyles = (name, theme) => {
  let variants = [];
  if (theme && theme.components && theme.components[name] && theme.components[name].variants) {
    variants = theme.components[name].variants;
  }
  const variantsStyles = {};
  variants.forEach((definition) => {
    const key = propsToClassKey(definition.props);
    variantsStyles[key] = definition.style;
  });
  return variantsStyles;
};
const variantsResolver = (props, styles, theme, name) => {
  var _theme$components, _theme$components$nam;
  const {
    ownerState = {}
  } = props;
  const variantsStyles = [];
  const themeVariants = theme == null ? void 0 : (_theme$components = theme.components) == null ? void 0 : (_theme$components$nam = _theme$components[name]) == null ? void 0 : _theme$components$nam.variants;
  if (themeVariants) {
    themeVariants.forEach((themeVariant) => {
      let isMatch = true;
      Object.keys(themeVariant.props).forEach((key) => {
        if (ownerState[key] !== themeVariant.props[key] && props[key] !== themeVariant.props[key]) {
          isMatch = false;
        }
      });
      if (isMatch) {
        variantsStyles.push(styles[propsToClassKey(themeVariant.props)]);
      }
    });
  }
  return variantsStyles;
};
function shouldForwardProp(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
const systemDefaultTheme = createTheme$1();
function createStyled(input = {}) {
  const {
    defaultTheme: defaultTheme2 = systemDefaultTheme,
    rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp,
    slotShouldForwardProp = shouldForwardProp,
    styleFunctionSx: styleFunctionSx2 = defaultStyleFunctionSx
  } = input;
  const systemSx = (props) => {
    const theme = isEmpty(props.theme) ? defaultTheme2 : props.theme;
    return styleFunctionSx2(_extends$1({}, props, {
      theme
    }));
  };
  systemSx.__mui_systemSx = true;
  return (tag, inputOptions = {}) => {
    internal_processStyles(tag, (styles) => styles.filter((style2) => !(style2 != null && style2.__mui_systemSx)));
    const {
      name: componentName,
      slot: componentSlot,
      skipVariantsResolver: inputSkipVariantsResolver,
      skipSx: inputSkipSx,
      overridesResolver
    } = inputOptions, options = _objectWithoutPropertiesLoose$1(inputOptions, _excluded$7);
    const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : componentSlot && componentSlot !== "Root" || false;
    const skipSx = inputSkipSx || false;
    let label;
    let shouldForwardPropOption = shouldForwardProp;
    if (componentSlot === "Root") {
      shouldForwardPropOption = rootShouldForwardProp2;
    } else if (componentSlot) {
      shouldForwardPropOption = slotShouldForwardProp;
    } else if (isStringTag(tag)) {
      shouldForwardPropOption = void 0;
    }
    const defaultStyledResolver = styled$4(tag, _extends$1({
      shouldForwardProp: shouldForwardPropOption,
      label
    }, options));
    const muiStyledResolver = (styleArg, ...expressions) => {
      const expressionsWithDefaultTheme = expressions ? expressions.map((stylesArg) => {
        return typeof stylesArg === "function" && stylesArg.__emotion_real !== stylesArg ? (_ref) => {
          let {
            theme: themeInput
          } = _ref, other = _objectWithoutPropertiesLoose$1(_ref, _excluded2);
          return stylesArg(_extends$1({
            theme: isEmpty(themeInput) ? defaultTheme2 : themeInput
          }, other));
        } : stylesArg;
      }) : [];
      let transformedStyleArg = styleArg;
      if (componentName && overridesResolver) {
        expressionsWithDefaultTheme.push((props) => {
          const theme = isEmpty(props.theme) ? defaultTheme2 : props.theme;
          const styleOverrides = getStyleOverrides(componentName, theme);
          if (styleOverrides) {
            const resolvedStyleOverrides = {};
            Object.entries(styleOverrides).forEach(([slotKey, slotStyle]) => {
              resolvedStyleOverrides[slotKey] = typeof slotStyle === "function" ? slotStyle(_extends$1({}, props, {
                theme
              })) : slotStyle;
            });
            return overridesResolver(props, resolvedStyleOverrides);
          }
          return null;
        });
      }
      if (componentName && !skipVariantsResolver) {
        expressionsWithDefaultTheme.push((props) => {
          const theme = isEmpty(props.theme) ? defaultTheme2 : props.theme;
          return variantsResolver(props, getVariantStyles(componentName, theme), theme, componentName);
        });
      }
      if (!skipSx) {
        expressionsWithDefaultTheme.push(systemSx);
      }
      const numOfCustomFnsApplied = expressionsWithDefaultTheme.length - expressions.length;
      if (Array.isArray(styleArg) && numOfCustomFnsApplied > 0) {
        const placeholders = new Array(numOfCustomFnsApplied).fill("");
        transformedStyleArg = [...styleArg, ...placeholders];
        transformedStyleArg.raw = [...styleArg.raw, ...placeholders];
      } else if (typeof styleArg === "function" && styleArg.__emotion_real !== styleArg) {
        transformedStyleArg = (_ref2) => {
          let {
            theme: themeInput
          } = _ref2, other = _objectWithoutPropertiesLoose$1(_ref2, _excluded3);
          return styleArg(_extends$1({
            theme: isEmpty(themeInput) ? defaultTheme2 : themeInput
          }, other));
        };
      }
      const Component = defaultStyledResolver(transformedStyleArg, ...expressionsWithDefaultTheme);
      return Component;
    };
    if (defaultStyledResolver.withConfig) {
      muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
    }
    return muiStyledResolver;
  };
}
function getThemeProps(params) {
  const {
    theme,
    name,
    props
  } = params;
  if (!theme || !theme.components || !theme.components[name] || !theme.components[name].defaultProps) {
    return props;
  }
  return resolveProps(theme.components[name].defaultProps, props);
}
function useThemeProps$1({
  props,
  name,
  defaultTheme: defaultTheme2
}) {
  const theme = useTheme(defaultTheme2);
  const mergedProps = getThemeProps({
    theme,
    name,
    props
  });
  return mergedProps;
}
function clamp(value2, min = 0, max = 1) {
  return Math.min(Math.max(min, value2), max);
}
function hexToRgb(color2) {
  color2 = color2.slice(1);
  const re2 = new RegExp(`.{1,${color2.length >= 6 ? 2 : 1}}`, "g");
  let colors = color2.match(re2);
  if (colors && colors[0].length === 1) {
    colors = colors.map((n2) => n2 + n2);
  }
  return colors ? `rgb${colors.length === 4 ? "a" : ""}(${colors.map((n2, index2) => {
    return index2 < 3 ? parseInt(n2, 16) : Math.round(parseInt(n2, 16) / 255 * 1e3) / 1e3;
  }).join(", ")})` : "";
}
function decomposeColor(color2) {
  if (color2.type) {
    return color2;
  }
  if (color2.charAt(0) === "#") {
    return decomposeColor(hexToRgb(color2));
  }
  const marker = color2.indexOf("(");
  const type = color2.substring(0, marker);
  if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(type) === -1) {
    throw new Error(formatMuiErrorMessage(9, color2));
  }
  let values2 = color2.substring(marker + 1, color2.length - 1);
  let colorSpace;
  if (type === "color") {
    values2 = values2.split(" ");
    colorSpace = values2.shift();
    if (values2.length === 4 && values2[3].charAt(0) === "/") {
      values2[3] = values2[3].slice(1);
    }
    if (["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(colorSpace) === -1) {
      throw new Error(formatMuiErrorMessage(10, colorSpace));
    }
  } else {
    values2 = values2.split(",");
  }
  values2 = values2.map((value2) => parseFloat(value2));
  return {
    type,
    values: values2,
    colorSpace
  };
}
function recomposeColor(color2) {
  const {
    type,
    colorSpace
  } = color2;
  let {
    values: values2
  } = color2;
  if (type.indexOf("rgb") !== -1) {
    values2 = values2.map((n2, i2) => i2 < 3 ? parseInt(n2, 10) : n2);
  } else if (type.indexOf("hsl") !== -1) {
    values2[1] = `${values2[1]}%`;
    values2[2] = `${values2[2]}%`;
  }
  if (type.indexOf("color") !== -1) {
    values2 = `${colorSpace} ${values2.join(" ")}`;
  } else {
    values2 = `${values2.join(", ")}`;
  }
  return `${type}(${values2})`;
}
function hslToRgb(color2) {
  color2 = decomposeColor(color2);
  const {
    values: values2
  } = color2;
  const h2 = values2[0];
  const s = values2[1] / 100;
  const l2 = values2[2] / 100;
  const a = s * Math.min(l2, 1 - l2);
  const f2 = (n2, k2 = (n2 + h2 / 30) % 12) => l2 - a * Math.max(Math.min(k2 - 3, 9 - k2, 1), -1);
  let type = "rgb";
  const rgb = [Math.round(f2(0) * 255), Math.round(f2(8) * 255), Math.round(f2(4) * 255)];
  if (color2.type === "hsla") {
    type += "a";
    rgb.push(values2[3]);
  }
  return recomposeColor({
    type,
    values: rgb
  });
}
function getLuminance(color2) {
  color2 = decomposeColor(color2);
  let rgb = color2.type === "hsl" || color2.type === "hsla" ? decomposeColor(hslToRgb(color2)).values : color2.values;
  rgb = rgb.map((val) => {
    if (color2.type !== "color") {
      val /= 255;
    }
    return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
  });
  return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
}
function getContrastRatio(foreground, background) {
  const lumA = getLuminance(foreground);
  const lumB = getLuminance(background);
  return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
}
function alpha(color2, value2) {
  color2 = decomposeColor(color2);
  value2 = clamp(value2);
  if (color2.type === "rgb" || color2.type === "hsl") {
    color2.type += "a";
  }
  if (color2.type === "color") {
    color2.values[3] = `/${value2}`;
  } else {
    color2.values[3] = value2;
  }
  return recomposeColor(color2);
}
function darken(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clamp(coefficient);
  if (color2.type.indexOf("hsl") !== -1) {
    color2.values[2] *= 1 - coefficient;
  } else if (color2.type.indexOf("rgb") !== -1 || color2.type.indexOf("color") !== -1) {
    for (let i2 = 0; i2 < 3; i2 += 1) {
      color2.values[i2] *= 1 - coefficient;
    }
  }
  return recomposeColor(color2);
}
function lighten(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clamp(coefficient);
  if (color2.type.indexOf("hsl") !== -1) {
    color2.values[2] += (100 - color2.values[2]) * coefficient;
  } else if (color2.type.indexOf("rgb") !== -1) {
    for (let i2 = 0; i2 < 3; i2 += 1) {
      color2.values[i2] += (255 - color2.values[i2]) * coefficient;
    }
  } else if (color2.type.indexOf("color") !== -1) {
    for (let i2 = 0; i2 < 3; i2 += 1) {
      color2.values[i2] += (1 - color2.values[i2]) * coefficient;
    }
  }
  return recomposeColor(color2);
}
function createMixins(breakpoints, mixins) {
  return _extends$1({
    toolbar: {
      minHeight: 56,
      [breakpoints.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [breakpoints.up("sm")]: {
        minHeight: 64
      }
    }
  }, mixins);
}
const _excluded$6 = ["mode", "contrastThreshold", "tonalOffset"];
const light = {
  text: {
    primary: "rgba(0, 0, 0, 0.87)",
    secondary: "rgba(0, 0, 0, 0.6)",
    disabled: "rgba(0, 0, 0, 0.38)"
  },
  divider: "rgba(0, 0, 0, 0.12)",
  background: {
    paper: common$1.white,
    default: common$1.white
  },
  action: {
    active: "rgba(0, 0, 0, 0.54)",
    hover: "rgba(0, 0, 0, 0.04)",
    hoverOpacity: 0.04,
    selected: "rgba(0, 0, 0, 0.08)",
    selectedOpacity: 0.08,
    disabled: "rgba(0, 0, 0, 0.26)",
    disabledBackground: "rgba(0, 0, 0, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(0, 0, 0, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.12
  }
};
const dark = {
  text: {
    primary: common$1.white,
    secondary: "rgba(255, 255, 255, 0.7)",
    disabled: "rgba(255, 255, 255, 0.5)",
    icon: "rgba(255, 255, 255, 0.5)"
  },
  divider: "rgba(255, 255, 255, 0.12)",
  background: {
    paper: "#121212",
    default: "#121212"
  },
  action: {
    active: common$1.white,
    hover: "rgba(255, 255, 255, 0.08)",
    hoverOpacity: 0.08,
    selected: "rgba(255, 255, 255, 0.16)",
    selectedOpacity: 0.16,
    disabled: "rgba(255, 255, 255, 0.3)",
    disabledBackground: "rgba(255, 255, 255, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(255, 255, 255, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.24
  }
};
function addLightOrDark(intent, direction, shade, tonalOffset) {
  const tonalOffsetLight = tonalOffset.light || tonalOffset;
  const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
  if (!intent[direction]) {
    if (intent.hasOwnProperty(shade)) {
      intent[direction] = intent[shade];
    } else if (direction === "light") {
      intent.light = lighten(intent.main, tonalOffsetLight);
    } else if (direction === "dark") {
      intent.dark = darken(intent.main, tonalOffsetDark);
    }
  }
}
function getDefaultPrimary(mode = "light") {
  if (mode === "dark") {
    return {
      main: blue$1[200],
      light: blue$1[50],
      dark: blue$1[400]
    };
  }
  return {
    main: blue$1[700],
    light: blue$1[400],
    dark: blue$1[800]
  };
}
function getDefaultSecondary(mode = "light") {
  if (mode === "dark") {
    return {
      main: purple$1[200],
      light: purple$1[50],
      dark: purple$1[400]
    };
  }
  return {
    main: purple$1[500],
    light: purple$1[300],
    dark: purple$1[700]
  };
}
function getDefaultError(mode = "light") {
  if (mode === "dark") {
    return {
      main: red$1[500],
      light: red$1[300],
      dark: red$1[700]
    };
  }
  return {
    main: red$1[700],
    light: red$1[400],
    dark: red$1[800]
  };
}
function getDefaultInfo(mode = "light") {
  if (mode === "dark") {
    return {
      main: lightBlue$1[400],
      light: lightBlue$1[300],
      dark: lightBlue$1[700]
    };
  }
  return {
    main: lightBlue$1[700],
    light: lightBlue$1[500],
    dark: lightBlue$1[900]
  };
}
function getDefaultSuccess(mode = "light") {
  if (mode === "dark") {
    return {
      main: green$1[400],
      light: green$1[300],
      dark: green$1[700]
    };
  }
  return {
    main: green$1[800],
    light: green$1[500],
    dark: green$1[900]
  };
}
function getDefaultWarning(mode = "light") {
  if (mode === "dark") {
    return {
      main: orange$1[400],
      light: orange$1[300],
      dark: orange$1[700]
    };
  }
  return {
    main: "#ed6c02",
    light: orange$1[500],
    dark: orange$1[900]
  };
}
function createPalette(palette2) {
  const {
    mode = "light",
    contrastThreshold = 3,
    tonalOffset = 0.2
  } = palette2, other = _objectWithoutPropertiesLoose$1(palette2, _excluded$6);
  const primary = palette2.primary || getDefaultPrimary(mode);
  const secondary = palette2.secondary || getDefaultSecondary(mode);
  const error = palette2.error || getDefaultError(mode);
  const info = palette2.info || getDefaultInfo(mode);
  const success = palette2.success || getDefaultSuccess(mode);
  const warning = palette2.warning || getDefaultWarning(mode);
  function getContrastText(background) {
    const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
    return contrastText;
  }
  const augmentColor = ({
    color: color2,
    name,
    mainShade = 500,
    lightShade = 300,
    darkShade = 700
  }) => {
    color2 = _extends$1({}, color2);
    if (!color2.main && color2[mainShade]) {
      color2.main = color2[mainShade];
    }
    if (!color2.hasOwnProperty("main")) {
      throw new Error(formatMuiErrorMessage(11, name ? ` (${name})` : "", mainShade));
    }
    if (typeof color2.main !== "string") {
      throw new Error(formatMuiErrorMessage(12, name ? ` (${name})` : "", JSON.stringify(color2.main)));
    }
    addLightOrDark(color2, "light", lightShade, tonalOffset);
    addLightOrDark(color2, "dark", darkShade, tonalOffset);
    if (!color2.contrastText) {
      color2.contrastText = getContrastText(color2.main);
    }
    return color2;
  };
  const modes = {
    dark,
    light
  };
  const paletteOutput = deepmerge(_extends$1({
    common: _extends$1({}, common$1),
    mode,
    primary: augmentColor({
      color: primary,
      name: "primary"
    }),
    secondary: augmentColor({
      color: secondary,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    error: augmentColor({
      color: error,
      name: "error"
    }),
    warning: augmentColor({
      color: warning,
      name: "warning"
    }),
    info: augmentColor({
      color: info,
      name: "info"
    }),
    success: augmentColor({
      color: success,
      name: "success"
    }),
    grey: grey$1,
    contrastThreshold,
    getContrastText,
    augmentColor,
    tonalOffset
  }, modes[mode]), other);
  return paletteOutput;
}
const _excluded$5 = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
function round(value2) {
  return Math.round(value2 * 1e5) / 1e5;
}
const caseAllCaps = {
  textTransform: "uppercase"
};
const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
function createTypography(palette2, typography2) {
  const _ref = typeof typography2 === "function" ? typography2(palette2) : typography2, {
    fontFamily: fontFamily2 = defaultFontFamily,
    fontSize: fontSize2 = 14,
    fontWeightLight = 300,
    fontWeightRegular = 400,
    fontWeightMedium = 500,
    fontWeightBold = 700,
    htmlFontSize = 16,
    allVariants,
    pxToRem: pxToRem2
  } = _ref, other = _objectWithoutPropertiesLoose$1(_ref, _excluded$5);
  const coef = fontSize2 / 14;
  const pxToRem = pxToRem2 || ((size) => `${size / htmlFontSize * coef}rem`);
  const buildVariant = (fontWeight2, size, lineHeight2, letterSpacing2, casing) => _extends$1({
    fontFamily: fontFamily2,
    fontWeight: fontWeight2,
    fontSize: pxToRem(size),
    lineHeight: lineHeight2
  }, fontFamily2 === defaultFontFamily ? {
    letterSpacing: `${round(letterSpacing2 / size)}em`
  } : {}, casing, allVariants);
  const variants = {
    h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
    h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
    h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
    h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
    h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
    h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
    subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
    subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
    body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
    body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
    button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
    caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
    overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps)
  };
  return deepmerge(_extends$1({
    htmlFontSize,
    pxToRem,
    fontFamily: fontFamily2,
    fontSize: fontSize2,
    fontWeightLight,
    fontWeightRegular,
    fontWeightMedium,
    fontWeightBold
  }, variants), other, {
    clone: false
  });
}
const shadowKeyUmbraOpacity = 0.2;
const shadowKeyPenumbraOpacity = 0.14;
const shadowAmbientShadowOpacity = 0.12;
function createShadow(...px) {
  return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
}
const shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
const shadows$1 = shadows;
const _excluded$4 = ["duration", "easing", "delay"];
const easing = {
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
};
const duration = {
  shortest: 150,
  shorter: 200,
  short: 250,
  standard: 300,
  complex: 375,
  enteringScreen: 225,
  leavingScreen: 195
};
function formatMs(milliseconds) {
  return `${Math.round(milliseconds)}ms`;
}
function getAutoHeightDuration(height2) {
  if (!height2) {
    return 0;
  }
  const constant = height2 / 36;
  return Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10);
}
function createTransitions(inputTransitions) {
  const mergedEasing = _extends$1({}, easing, inputTransitions.easing);
  const mergedDuration = _extends$1({}, duration, inputTransitions.duration);
  const create2 = (props = ["all"], options = {}) => {
    const {
      duration: durationOption = mergedDuration.standard,
      easing: easingOption = mergedEasing.easeInOut,
      delay = 0
    } = options;
    _objectWithoutPropertiesLoose$1(options, _excluded$4);
    return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === "string" ? delay : formatMs(delay)}`).join(",");
  };
  return _extends$1({
    getAutoHeightDuration,
    create: create2
  }, inputTransitions, {
    easing: mergedEasing,
    duration: mergedDuration
  });
}
const zIndex = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
const zIndex$1 = zIndex;
const _excluded$3 = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
function createTheme(options = {}, ...args) {
  const {
    mixins: mixinsInput = {},
    palette: paletteInput = {},
    transitions: transitionsInput = {},
    typography: typographyInput = {}
  } = options, other = _objectWithoutPropertiesLoose$1(options, _excluded$3);
  if (options.vars) {
    throw new Error(formatMuiErrorMessage(18));
  }
  const palette2 = createPalette(paletteInput);
  const systemTheme = createTheme$1(options);
  let muiTheme = deepmerge(systemTheme, {
    mixins: createMixins(systemTheme.breakpoints, mixinsInput),
    palette: palette2,
    shadows: shadows$1.slice(),
    typography: createTypography(palette2, typographyInput),
    transitions: createTransitions(transitionsInput),
    zIndex: _extends$1({}, zIndex$1)
  });
  muiTheme = deepmerge(muiTheme, other);
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  return muiTheme;
}
const defaultTheme = createTheme();
const defaultTheme$1 = defaultTheme;
function useThemeProps({
  props,
  name
}) {
  return useThemeProps$1({
    props,
    name,
    defaultTheme: defaultTheme$1
  });
}
const rootShouldForwardProp = (prop) => shouldForwardProp(prop) && prop !== "classes";
const styled$2 = createStyled({
  defaultTheme: defaultTheme$1,
  rootShouldForwardProp
});
const styled$3 = styled$2;
function _setPrototypeOf(o, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf(o, p2);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
const TransitionGroupContext = React.createContext(null);
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function getChildMapping(children, mapFn) {
  var mapper = function mapper2(child) {
    return mapFn && react.exports.isValidElement(child) ? mapFn(child) : child;
  };
  var result = /* @__PURE__ */ Object.create(null);
  if (children)
    react.exports.Children.map(children, function(c2) {
      return c2;
    }).forEach(function(child) {
      result[child.key] = mapper(child);
    });
  return result;
}
function mergeChildMappings(prev2, next2) {
  prev2 = prev2 || {};
  next2 = next2 || {};
  function getValueForKey(key) {
    return key in next2 ? next2[key] : prev2[key];
  }
  var nextKeysPending = /* @__PURE__ */ Object.create(null);
  var pendingKeys = [];
  for (var prevKey in prev2) {
    if (prevKey in next2) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }
  var i2;
  var childMapping = {};
  for (var nextKey in next2) {
    if (nextKeysPending[nextKey]) {
      for (i2 = 0; i2 < nextKeysPending[nextKey].length; i2++) {
        var pendingNextKey = nextKeysPending[nextKey][i2];
        childMapping[nextKeysPending[nextKey][i2]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (i2 = 0; i2 < pendingKeys.length; i2++) {
    childMapping[pendingKeys[i2]] = getValueForKey(pendingKeys[i2]);
  }
  return childMapping;
}
function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}
function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function(child) {
    return react.exports.cloneElement(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, "appear", props),
      enter: getProp(child, "enter", props),
      exit: getProp(child, "exit", props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function(key) {
    var child = children[key];
    if (!react.exports.isValidElement(child))
      return;
    var hasPrev = key in prevChildMapping;
    var hasNext = key in nextChildMapping;
    var prevChild = prevChildMapping[key];
    var isLeaving = react.exports.isValidElement(prevChild) && !prevChild.props.in;
    if (hasNext && (!hasPrev || isLeaving)) {
      children[key] = react.exports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      children[key] = react.exports.cloneElement(child, {
        in: false
      });
    } else if (hasNext && hasPrev && react.exports.isValidElement(prevChild)) {
      children[key] = react.exports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    }
  });
  return children;
}
var values = Object.values || function(obj) {
  return Object.keys(obj).map(function(k2) {
    return obj[k2];
  });
};
var defaultProps = {
  component: "div",
  childFactory: function childFactory(child) {
    return child;
  }
};
var TransitionGroup = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(TransitionGroup2, _React$Component);
  function TransitionGroup2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited,
      firstRender: true
    };
    return _this;
  }
  var _proto = TransitionGroup2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };
  TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  };
  _proto.handleExited = function handleExited(child, node2) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping)
      return;
    if (child.props.onExited) {
      child.props.onExited(node2);
    }
    if (this.mounted) {
      this.setState(function(state) {
        var children = _extends$1({}, state.children);
        delete children[child.key];
        return {
          children
        };
      });
    }
  };
  _proto.render = function render() {
    var _this$props = this.props, Component = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose$1(_this$props, ["component", "childFactory"]);
    var contextValue = this.state.contextValue;
    var children = values(this.state.children).map(childFactory2);
    delete props.appear;
    delete props.enter;
    delete props.exit;
    if (Component === null) {
      return /* @__PURE__ */ jsx(TransitionGroupContext.Provider, {
        value: contextValue,
        children
      });
    }
    return /* @__PURE__ */ jsx(TransitionGroupContext.Provider, {
      value: contextValue,
      children: /* @__PURE__ */ jsx(Component, {
        ...props,
        children
      })
    });
  };
  return TransitionGroup2;
}(React.Component);
TransitionGroup.propTypes = {};
TransitionGroup.defaultProps = defaultProps;
const TransitionGroup$1 = TransitionGroup;
function Ripple(props) {
  const {
    className,
    classes,
    pulsate = false,
    rippleX,
    rippleY,
    rippleSize,
    in: inProp,
    onExited,
    timeout: timeout2
  } = props;
  const [leaving, setLeaving] = react.exports.useState(false);
  const rippleClassName = clsx(className, classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
  const rippleStyles = {
    width: rippleSize,
    height: rippleSize,
    top: -(rippleSize / 2) + rippleY,
    left: -(rippleSize / 2) + rippleX
  };
  const childClassName = clsx(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
  if (!inProp && !leaving) {
    setLeaving(true);
  }
  react.exports.useEffect(() => {
    if (!inProp && onExited != null) {
      const timeoutId = setTimeout(onExited, timeout2);
      return () => {
        clearTimeout(timeoutId);
      };
    }
    return void 0;
  }, [onExited, inProp, timeout2]);
  return /* @__PURE__ */ jsx("span", {
    className: rippleClassName,
    style: rippleStyles,
    children: /* @__PURE__ */ jsx("span", {
      className: childClassName
    })
  });
}
const touchRippleClasses = generateUtilityClasses("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]);
const touchRippleClasses$1 = touchRippleClasses;
const _excluded$2 = ["center", "classes", "className"];
let _ = (t2) => t2, _t, _t2, _t3, _t4;
const DURATION = 550;
const DELAY_RIPPLE = 80;
const enterKeyframe = keyframes(_t || (_t = _`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`));
const exitKeyframe = keyframes(_t2 || (_t2 = _`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`));
const pulsateKeyframe = keyframes(_t3 || (_t3 = _`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`));
const TouchRippleRoot = styled$3("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
});
const TouchRippleRipple = styled$3(Ripple, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})(_t4 || (_t4 = _`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`), touchRippleClasses$1.rippleVisible, enterKeyframe, DURATION, ({
  theme
}) => theme.transitions.easing.easeInOut, touchRippleClasses$1.ripplePulsate, ({
  theme
}) => theme.transitions.duration.shorter, touchRippleClasses$1.child, touchRippleClasses$1.childLeaving, exitKeyframe, DURATION, ({
  theme
}) => theme.transitions.easing.easeInOut, touchRippleClasses$1.childPulsate, pulsateKeyframe, ({
  theme
}) => theme.transitions.easing.easeInOut);
const TouchRipple = /* @__PURE__ */ react.exports.forwardRef(function TouchRipple2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTouchRipple"
  });
  const {
    center: centerProp = false,
    classes = {},
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2);
  const [ripples, setRipples] = react.exports.useState([]);
  const nextKey = react.exports.useRef(0);
  const rippleCallback = react.exports.useRef(null);
  react.exports.useEffect(() => {
    if (rippleCallback.current) {
      rippleCallback.current();
      rippleCallback.current = null;
    }
  }, [ripples]);
  const ignoringMouseDown = react.exports.useRef(false);
  const startTimer = react.exports.useRef(null);
  const startTimerCommit = react.exports.useRef(null);
  const container = react.exports.useRef(null);
  react.exports.useEffect(() => {
    return () => {
      clearTimeout(startTimer.current);
    };
  }, []);
  const startCommit = react.exports.useCallback((params) => {
    const {
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize,
      cb: cb2
    } = params;
    setRipples((oldRipples) => [...oldRipples, /* @__PURE__ */ jsx(TouchRippleRipple, {
      classes: {
        ripple: clsx(classes.ripple, touchRippleClasses$1.ripple),
        rippleVisible: clsx(classes.rippleVisible, touchRippleClasses$1.rippleVisible),
        ripplePulsate: clsx(classes.ripplePulsate, touchRippleClasses$1.ripplePulsate),
        child: clsx(classes.child, touchRippleClasses$1.child),
        childLeaving: clsx(classes.childLeaving, touchRippleClasses$1.childLeaving),
        childPulsate: clsx(classes.childPulsate, touchRippleClasses$1.childPulsate)
      },
      timeout: DURATION,
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize
    }, nextKey.current)]);
    nextKey.current += 1;
    rippleCallback.current = cb2;
  }, [classes]);
  const start = react.exports.useCallback((event = {}, options = {}, cb2 = () => {
  }) => {
    const {
      pulsate: pulsate2 = false,
      center = centerProp || options.pulsate,
      fakeElement = false
    } = options;
    if ((event == null ? void 0 : event.type) === "mousedown" && ignoringMouseDown.current) {
      ignoringMouseDown.current = false;
      return;
    }
    if ((event == null ? void 0 : event.type) === "touchstart") {
      ignoringMouseDown.current = true;
    }
    const element = fakeElement ? null : container.current;
    const rect = element ? element.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let rippleX;
    let rippleY;
    let rippleSize;
    if (center || event === void 0 || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
      rippleX = Math.round(rect.width / 2);
      rippleY = Math.round(rect.height / 2);
    } else {
      const {
        clientX,
        clientY
      } = event.touches && event.touches.length > 0 ? event.touches[0] : event;
      rippleX = Math.round(clientX - rect.left);
      rippleY = Math.round(clientY - rect.top);
    }
    if (center) {
      rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);
      if (rippleSize % 2 === 0) {
        rippleSize += 1;
      }
    } else {
      const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
      const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
      rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);
    }
    if (event != null && event.touches) {
      if (startTimerCommit.current === null) {
        startTimerCommit.current = () => {
          startCommit({
            pulsate: pulsate2,
            rippleX,
            rippleY,
            rippleSize,
            cb: cb2
          });
        };
        startTimer.current = setTimeout(() => {
          if (startTimerCommit.current) {
            startTimerCommit.current();
            startTimerCommit.current = null;
          }
        }, DELAY_RIPPLE);
      }
    } else {
      startCommit({
        pulsate: pulsate2,
        rippleX,
        rippleY,
        rippleSize,
        cb: cb2
      });
    }
  }, [centerProp, startCommit]);
  const pulsate = react.exports.useCallback(() => {
    start({}, {
      pulsate: true
    });
  }, [start]);
  const stop = react.exports.useCallback((event, cb2) => {
    clearTimeout(startTimer.current);
    if ((event == null ? void 0 : event.type) === "touchend" && startTimerCommit.current) {
      startTimerCommit.current();
      startTimerCommit.current = null;
      startTimer.current = setTimeout(() => {
        stop(event, cb2);
      });
      return;
    }
    startTimerCommit.current = null;
    setRipples((oldRipples) => {
      if (oldRipples.length > 0) {
        return oldRipples.slice(1);
      }
      return oldRipples;
    });
    rippleCallback.current = cb2;
  }, []);
  react.exports.useImperativeHandle(ref, () => ({
    pulsate,
    start,
    stop
  }), [pulsate, start, stop]);
  return /* @__PURE__ */ jsx(TouchRippleRoot, _extends$1({
    className: clsx(touchRippleClasses$1.root, classes.root, className),
    ref: container
  }, other, {
    children: /* @__PURE__ */ jsx(TransitionGroup$1, {
      component: null,
      exit: true,
      children: ripples
    })
  }));
});
const TouchRipple$1 = TouchRipple;
function getButtonBaseUtilityClass(slot) {
  return generateUtilityClass("MuiButtonBase", slot);
}
const buttonBaseClasses = generateUtilityClasses("MuiButtonBase", ["root", "disabled", "focusVisible"]);
const buttonBaseClasses$1 = buttonBaseClasses;
const _excluded$1 = ["action", "centerRipple", "children", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "LinkComponent", "onBlur", "onClick", "onContextMenu", "onDragLeave", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "tabIndex", "TouchRippleProps", "touchRippleRef", "type"];
const useUtilityClasses$1 = (ownerState) => {
  const {
    disabled,
    focusVisible,
    focusVisibleClassName,
    classes
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", focusVisible && "focusVisible"]
  };
  const composedClasses = composeClasses(slots, getButtonBaseUtilityClass, classes);
  if (focusVisible && focusVisibleClassName) {
    composedClasses.root += ` ${focusVisibleClassName}`;
  }
  return composedClasses;
};
const ButtonBaseRoot = styled$3("button", {
  name: "MuiButtonBase",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  outline: 0,
  border: 0,
  margin: 0,
  borderRadius: 0,
  padding: 0,
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  WebkitAppearance: "none",
  textDecoration: "none",
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
  },
  [`&.${buttonBaseClasses$1.disabled}`]: {
    pointerEvents: "none",
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
});
const ButtonBase = /* @__PURE__ */ react.exports.forwardRef(function ButtonBase2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiButtonBase"
  });
  const {
    action,
    centerRipple = false,
    children,
    className,
    component = "button",
    disabled = false,
    disableRipple = false,
    disableTouchRipple = false,
    focusRipple = false,
    LinkComponent = "a",
    onBlur,
    onClick,
    onContextMenu,
    onDragLeave,
    onFocus,
    onFocusVisible,
    onKeyDown,
    onKeyUp,
    onMouseDown,
    onMouseLeave,
    onMouseUp,
    onTouchEnd,
    onTouchMove,
    onTouchStart,
    tabIndex = 0,
    TouchRippleProps,
    touchRippleRef,
    type
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1);
  const buttonRef = react.exports.useRef(null);
  const rippleRef = react.exports.useRef(null);
  const handleRippleRef = useForkRef(rippleRef, touchRippleRef);
  const {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const [focusVisible, setFocusVisible] = react.exports.useState(false);
  if (disabled && focusVisible) {
    setFocusVisible(false);
  }
  react.exports.useImperativeHandle(action, () => ({
    focusVisible: () => {
      setFocusVisible(true);
      buttonRef.current.focus();
    }
  }), []);
  const [mountedState, setMountedState] = react.exports.useState(false);
  react.exports.useEffect(() => {
    setMountedState(true);
  }, []);
  const enableTouchRipple = mountedState && !disableRipple && !disabled;
  react.exports.useEffect(() => {
    if (focusVisible && focusRipple && !disableRipple && mountedState) {
      rippleRef.current.pulsate();
    }
  }, [disableRipple, focusRipple, focusVisible, mountedState]);
  function useRippleHandler(rippleAction, eventCallback, skipRippleAction = disableTouchRipple) {
    return useEventCallback((event) => {
      if (eventCallback) {
        eventCallback(event);
      }
      const ignore = skipRippleAction;
      if (!ignore && rippleRef.current) {
        rippleRef.current[rippleAction](event);
      }
      return true;
    });
  }
  const handleMouseDown = useRippleHandler("start", onMouseDown);
  const handleContextMenu = useRippleHandler("stop", onContextMenu);
  const handleDragLeave = useRippleHandler("stop", onDragLeave);
  const handleMouseUp = useRippleHandler("stop", onMouseUp);
  const handleMouseLeave = useRippleHandler("stop", (event) => {
    if (focusVisible) {
      event.preventDefault();
    }
    if (onMouseLeave) {
      onMouseLeave(event);
    }
  });
  const handleTouchStart = useRippleHandler("start", onTouchStart);
  const handleTouchEnd = useRippleHandler("stop", onTouchEnd);
  const handleTouchMove = useRippleHandler("stop", onTouchMove);
  const handleBlur = useRippleHandler("stop", (event) => {
    handleBlurVisible(event);
    if (isFocusVisibleRef.current === false) {
      setFocusVisible(false);
    }
    if (onBlur) {
      onBlur(event);
    }
  }, false);
  const handleFocus = useEventCallback((event) => {
    if (!buttonRef.current) {
      buttonRef.current = event.currentTarget;
    }
    handleFocusVisible(event);
    if (isFocusVisibleRef.current === true) {
      setFocusVisible(true);
      if (onFocusVisible) {
        onFocusVisible(event);
      }
    }
    if (onFocus) {
      onFocus(event);
    }
  });
  const isNonNativeButton = () => {
    const button = buttonRef.current;
    return component && component !== "button" && !(button.tagName === "A" && button.href);
  };
  const keydownRef = react.exports.useRef(false);
  const handleKeyDown2 = useEventCallback((event) => {
    if (focusRipple && !keydownRef.current && focusVisible && rippleRef.current && event.key === " ") {
      keydownRef.current = true;
      rippleRef.current.stop(event, () => {
        rippleRef.current.start(event);
      });
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === " ") {
      event.preventDefault();
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === "Enter" && !disabled) {
      event.preventDefault();
      if (onClick) {
        onClick(event);
      }
    }
  });
  const handleKeyUp = useEventCallback((event) => {
    if (focusRipple && event.key === " " && rippleRef.current && focusVisible && !event.defaultPrevented) {
      keydownRef.current = false;
      rippleRef.current.stop(event, () => {
        rippleRef.current.pulsate(event);
      });
    }
    if (onKeyUp) {
      onKeyUp(event);
    }
    if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === " " && !event.defaultPrevented) {
      onClick(event);
    }
  });
  let ComponentProp = component;
  if (ComponentProp === "button" && (other.href || other.to)) {
    ComponentProp = LinkComponent;
  }
  const buttonProps = {};
  if (ComponentProp === "button") {
    buttonProps.type = type === void 0 ? "button" : type;
    buttonProps.disabled = disabled;
  } else {
    if (!other.href && !other.to) {
      buttonProps.role = "button";
    }
    if (disabled) {
      buttonProps["aria-disabled"] = disabled;
    }
  }
  const handleRef = useForkRef(ref, focusVisibleRef, buttonRef);
  const ownerState = _extends$1({}, props, {
    centerRipple,
    component,
    disabled,
    disableRipple,
    disableTouchRipple,
    focusRipple,
    tabIndex,
    focusVisible
  });
  const classes = useUtilityClasses$1(ownerState);
  return /* @__PURE__ */ jsxs(ButtonBaseRoot, _extends$1({
    as: ComponentProp,
    className: clsx(classes.root, className),
    ownerState,
    onBlur: handleBlur,
    onClick,
    onContextMenu: handleContextMenu,
    onFocus: handleFocus,
    onKeyDown: handleKeyDown2,
    onKeyUp: handleKeyUp,
    onMouseDown: handleMouseDown,
    onMouseLeave: handleMouseLeave,
    onMouseUp: handleMouseUp,
    onDragLeave: handleDragLeave,
    onTouchEnd: handleTouchEnd,
    onTouchMove: handleTouchMove,
    onTouchStart: handleTouchStart,
    ref: handleRef,
    tabIndex: disabled ? -1 : tabIndex,
    type
  }, buttonProps, other, {
    children: [children, enableTouchRipple ? /* @__PURE__ */ jsx(TouchRipple$1, _extends$1({
      ref: handleRippleRef,
      center: centerRipple
    }, TouchRippleProps)) : null]
  }));
});
const ButtonBase$1 = ButtonBase;
function getButtonUtilityClass(slot) {
  return generateUtilityClass("MuiButton", slot);
}
const buttonClasses = generateUtilityClasses("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge"]);
const buttonClasses$1 = buttonClasses;
const ButtonGroupContext = /* @__PURE__ */ react.exports.createContext({});
const ButtonGroupContext$1 = ButtonGroupContext;
const _excluded = ["children", "color", "component", "className", "disabled", "disableElevation", "disableFocusRipple", "endIcon", "focusVisibleClassName", "fullWidth", "size", "startIcon", "type", "variant"];
const useUtilityClasses = (ownerState) => {
  const {
    color: color2,
    disableElevation,
    fullWidth,
    size,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ["root", variant, `${variant}${capitalize(color2)}`, `size${capitalize(size)}`, `${variant}Size${capitalize(size)}`, color2 === "inherit" && "colorInherit", disableElevation && "disableElevation", fullWidth && "fullWidth"],
    label: ["label"],
    startIcon: ["startIcon", `iconSize${capitalize(size)}`],
    endIcon: ["endIcon", `iconSize${capitalize(size)}`]
  };
  const composedClasses = composeClasses(slots, getButtonUtilityClass, classes);
  return _extends$1({}, classes, composedClasses);
};
const commonIconStyles = (ownerState) => _extends$1({}, ownerState.size === "small" && {
  "& > *:nth-of-type(1)": {
    fontSize: 18
  }
}, ownerState.size === "medium" && {
  "& > *:nth-of-type(1)": {
    fontSize: 20
  }
}, ownerState.size === "large" && {
  "& > *:nth-of-type(1)": {
    fontSize: 22
  }
});
const ButtonRoot = styled$3(ButtonBase$1, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiButton",
  slot: "Root",
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, styles[ownerState.variant], styles[`${ownerState.variant}${capitalize(ownerState.color)}`], styles[`size${capitalize(ownerState.size)}`], styles[`${ownerState.variant}Size${capitalize(ownerState.size)}`], ownerState.color === "inherit" && styles.colorInherit, ownerState.disableElevation && styles.disableElevation, ownerState.fullWidth && styles.fullWidth];
  }
})(({
  theme,
  ownerState
}) => {
  var _theme$palette$getCon, _theme$palette;
  return _extends$1({}, theme.typography.button, {
    minWidth: 64,
    padding: "6px 16px",
    borderRadius: (theme.vars || theme).shape.borderRadius,
    transition: theme.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
      duration: theme.transitions.duration.short
    }),
    "&:hover": _extends$1({
      textDecoration: "none",
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.text.primary, theme.palette.action.hoverOpacity),
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, ownerState.variant === "outlined" && ownerState.color !== "inherit" && {
      border: `1px solid ${(theme.vars || theme).palette[ownerState.color].main}`,
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, ownerState.variant === "contained" && {
      backgroundColor: (theme.vars || theme).palette.grey.A100,
      boxShadow: (theme.vars || theme).shadows[4],
      "@media (hover: none)": {
        boxShadow: (theme.vars || theme).shadows[2],
        backgroundColor: (theme.vars || theme).palette.grey[300]
      }
    }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
      backgroundColor: (theme.vars || theme).palette[ownerState.color].dark,
      "@media (hover: none)": {
        backgroundColor: (theme.vars || theme).palette[ownerState.color].main
      }
    }),
    "&:active": _extends$1({}, ownerState.variant === "contained" && {
      boxShadow: (theme.vars || theme).shadows[8]
    }),
    [`&.${buttonClasses$1.focusVisible}`]: _extends$1({}, ownerState.variant === "contained" && {
      boxShadow: (theme.vars || theme).shadows[6]
    }),
    [`&.${buttonClasses$1.disabled}`]: _extends$1({
      color: (theme.vars || theme).palette.action.disabled
    }, ownerState.variant === "outlined" && {
      border: `1px solid ${(theme.vars || theme).palette.action.disabledBackground}`
    }, ownerState.variant === "outlined" && ownerState.color === "secondary" && {
      border: `1px solid ${(theme.vars || theme).palette.action.disabled}`
    }, ownerState.variant === "contained" && {
      color: (theme.vars || theme).palette.action.disabled,
      boxShadow: (theme.vars || theme).shadows[0],
      backgroundColor: (theme.vars || theme).palette.action.disabledBackground
    })
  }, ownerState.variant === "text" && {
    padding: "6px 8px"
  }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
    color: (theme.vars || theme).palette[ownerState.color].main
  }, ownerState.variant === "outlined" && {
    padding: "5px 15px",
    border: "1px solid currentColor"
  }, ownerState.variant === "outlined" && ownerState.color !== "inherit" && {
    color: (theme.vars || theme).palette[ownerState.color].main,
    border: theme.vars ? `1px solid rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.5)` : `1px solid ${alpha(theme.palette[ownerState.color].main, 0.5)}`
  }, ownerState.variant === "contained" && {
    color: theme.vars ? theme.vars.palette.text.primary : (_theme$palette$getCon = (_theme$palette = theme.palette).getContrastText) == null ? void 0 : _theme$palette$getCon.call(_theme$palette, theme.palette.grey[300]),
    backgroundColor: (theme.vars || theme).palette.grey[300],
    boxShadow: (theme.vars || theme).shadows[2]
  }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
    color: (theme.vars || theme).palette[ownerState.color].contrastText,
    backgroundColor: (theme.vars || theme).palette[ownerState.color].main
  }, ownerState.color === "inherit" && {
    color: "inherit",
    borderColor: "currentColor"
  }, ownerState.size === "small" && ownerState.variant === "text" && {
    padding: "4px 5px",
    fontSize: theme.typography.pxToRem(13)
  }, ownerState.size === "large" && ownerState.variant === "text" && {
    padding: "8px 11px",
    fontSize: theme.typography.pxToRem(15)
  }, ownerState.size === "small" && ownerState.variant === "outlined" && {
    padding: "3px 9px",
    fontSize: theme.typography.pxToRem(13)
  }, ownerState.size === "large" && ownerState.variant === "outlined" && {
    padding: "7px 21px",
    fontSize: theme.typography.pxToRem(15)
  }, ownerState.size === "small" && ownerState.variant === "contained" && {
    padding: "4px 10px",
    fontSize: theme.typography.pxToRem(13)
  }, ownerState.size === "large" && ownerState.variant === "contained" && {
    padding: "8px 22px",
    fontSize: theme.typography.pxToRem(15)
  }, ownerState.fullWidth && {
    width: "100%"
  });
}, ({
  ownerState
}) => ownerState.disableElevation && {
  boxShadow: "none",
  "&:hover": {
    boxShadow: "none"
  },
  [`&.${buttonClasses$1.focusVisible}`]: {
    boxShadow: "none"
  },
  "&:active": {
    boxShadow: "none"
  },
  [`&.${buttonClasses$1.disabled}`]: {
    boxShadow: "none"
  }
});
const ButtonStartIcon = styled$3("span", {
  name: "MuiButton",
  slot: "StartIcon",
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.startIcon, styles[`iconSize${capitalize(ownerState.size)}`]];
  }
})(({
  ownerState
}) => _extends$1({
  display: "inherit",
  marginRight: 8,
  marginLeft: -4
}, ownerState.size === "small" && {
  marginLeft: -2
}, commonIconStyles(ownerState)));
const ButtonEndIcon = styled$3("span", {
  name: "MuiButton",
  slot: "EndIcon",
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.endIcon, styles[`iconSize${capitalize(ownerState.size)}`]];
  }
})(({
  ownerState
}) => _extends$1({
  display: "inherit",
  marginRight: -4,
  marginLeft: 8
}, ownerState.size === "small" && {
  marginRight: -2
}, commonIconStyles(ownerState)));
const Button = /* @__PURE__ */ react.exports.forwardRef(function Button2(inProps, ref) {
  const contextProps = react.exports.useContext(ButtonGroupContext$1);
  const resolvedProps = resolveProps(contextProps, inProps);
  const props = useThemeProps({
    props: resolvedProps,
    name: "MuiButton"
  });
  const {
    children,
    color: color2 = "primary",
    component = "button",
    className,
    disabled = false,
    disableElevation = false,
    disableFocusRipple = false,
    endIcon: endIconProp,
    focusVisibleClassName,
    fullWidth = false,
    size = "medium",
    startIcon: startIconProp,
    type,
    variant = "text"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded);
  const ownerState = _extends$1({}, props, {
    color: color2,
    component,
    disabled,
    disableElevation,
    disableFocusRipple,
    fullWidth,
    size,
    type,
    variant
  });
  const classes = useUtilityClasses(ownerState);
  const startIcon = startIconProp && /* @__PURE__ */ jsx(ButtonStartIcon, {
    className: classes.startIcon,
    ownerState,
    children: startIconProp
  });
  const endIcon = endIconProp && /* @__PURE__ */ jsx(ButtonEndIcon, {
    className: classes.endIcon,
    ownerState,
    children: endIconProp
  });
  return /* @__PURE__ */ jsxs(ButtonRoot, _extends$1({
    ownerState,
    className: clsx(contextProps.className, classes.root, className),
    component,
    disabled,
    focusRipple: !disableFocusRipple,
    focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
    ref,
    type
  }, other, {
    classes,
    children: [startIcon, children, endIcon]
  }));
});
const Button$1 = Button;
const DndContext = react.exports.createContext({
  dragDropManager: void 0
});
function formatProdErrorMessage(code2) {
  return "Minified Redux error #" + code2 + "; visit https://redux.js.org/Errors?code=" + code2 + " for the full message or use the non-minified dev environment for full errors. ";
}
var $$observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
var randomString = function randomString2() {
  return Math.random().toString(36).substring(7).split("").join(".");
};
var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};
function isPlainObject$3(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  var proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto;
}
function createStore$1(reducer, preloadedState, enhancer) {
  var _ref2;
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(formatProdErrorMessage(0));
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(formatProdErrorMessage(1));
    }
    return enhancer(createStore$1)(reducer, preloadedState);
  }
  if (typeof reducer !== "function") {
    throw new Error(formatProdErrorMessage(2));
  }
  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(3));
    }
    return currentState;
  }
  function subscribe(listener) {
    if (typeof listener !== "function") {
      throw new Error(formatProdErrorMessage(4));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(5));
    }
    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(formatProdErrorMessage(6));
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index2 = nextListeners.indexOf(listener);
      nextListeners.splice(index2, 1);
      currentListeners = null;
    };
  }
  function dispatch(action) {
    if (!isPlainObject$3(action)) {
      throw new Error(formatProdErrorMessage(7));
    }
    if (typeof action.type === "undefined") {
      throw new Error(formatProdErrorMessage(8));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(9));
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    var listeners = currentListeners = nextListeners;
    for (var i2 = 0; i2 < listeners.length; i2++) {
      var listener = listeners[i2];
      listener();
    }
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(formatProdErrorMessage(10));
    }
    currentReducer = nextReducer;
    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  function observable() {
    var _ref;
    var outerSubscribe = subscribe;
    return _ref = {
      subscribe: function subscribe2(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(formatProdErrorMessage(11));
        }
        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }
        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      }
    }, _ref[$$observable] = function() {
      return this;
    }, _ref;
  }
  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch,
    subscribe,
    getState,
    replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
}
function invariant(condition, format2, ...args) {
  if (isProduction()) {
    if (format2 === void 0) {
      throw new Error("invariant requires an error message argument");
    }
  }
  if (!condition) {
    let error;
    if (format2 === void 0) {
      error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
    } else {
      let argIndex = 0;
      error = new Error(format2.replace(/%s/g, function() {
        return args[argIndex++];
      }));
      error.name = "Invariant Violation";
    }
    error.framesToPop = 1;
    throw error;
  }
}
function isProduction() {
  return typeof process !== "undefined" && process.env["NODE_ENV"] === "production";
}
function get(obj, path, defaultValue) {
  return path.split(".").reduce(
    (a, c2) => a && a[c2] ? a[c2] : defaultValue || null,
    obj
  );
}
function without$1(items, item) {
  return items.filter(
    (i2) => i2 !== item
  );
}
function isObject$1(input) {
  return typeof input === "object";
}
function xor(itemsA, itemsB) {
  const map2 = /* @__PURE__ */ new Map();
  const insertItem = (item) => {
    map2.set(item, map2.has(item) ? map2.get(item) + 1 : 1);
  };
  itemsA.forEach(insertItem);
  itemsB.forEach(insertItem);
  const result = [];
  map2.forEach((count, key) => {
    if (count === 1) {
      result.push(key);
    }
  });
  return result;
}
function intersection(itemsA, itemsB) {
  return itemsA.filter(
    (t2) => itemsB.indexOf(t2) > -1
  );
}
const INIT_COORDS = "dnd-core/INIT_COORDS";
const BEGIN_DRAG = "dnd-core/BEGIN_DRAG";
const PUBLISH_DRAG_SOURCE = "dnd-core/PUBLISH_DRAG_SOURCE";
const HOVER = "dnd-core/HOVER";
const DROP = "dnd-core/DROP";
const END_DRAG = "dnd-core/END_DRAG";
function setClientOffset(clientOffset, sourceClientOffset) {
  return {
    type: INIT_COORDS,
    payload: {
      sourceClientOffset: sourceClientOffset || null,
      clientOffset: clientOffset || null
    }
  };
}
const ResetCoordinatesAction = {
  type: INIT_COORDS,
  payload: {
    clientOffset: null,
    sourceClientOffset: null
  }
};
function createBeginDrag(manager) {
  return function beginDrag(sourceIds = [], options = {
    publishSource: true
  }) {
    const { publishSource = true, clientOffset, getSourceClientOffset: getSourceClientOffset2 } = options;
    const monitor = manager.getMonitor();
    const registry2 = manager.getRegistry();
    manager.dispatch(setClientOffset(clientOffset));
    verifyInvariants$1(sourceIds, monitor, registry2);
    const sourceId = getDraggableSource(sourceIds, monitor);
    if (sourceId == null) {
      manager.dispatch(ResetCoordinatesAction);
      return;
    }
    let sourceClientOffset = null;
    if (clientOffset) {
      if (!getSourceClientOffset2) {
        throw new Error("getSourceClientOffset must be defined");
      }
      verifyGetSourceClientOffsetIsFunction(getSourceClientOffset2);
      sourceClientOffset = getSourceClientOffset2(sourceId);
    }
    manager.dispatch(setClientOffset(clientOffset, sourceClientOffset));
    const source = registry2.getSource(sourceId);
    const item = source.beginDrag(monitor, sourceId);
    if (item == null) {
      return void 0;
    }
    verifyItemIsObject(item);
    registry2.pinSource(sourceId);
    const itemType = registry2.getSourceType(sourceId);
    return {
      type: BEGIN_DRAG,
      payload: {
        itemType,
        item,
        sourceId,
        clientOffset: clientOffset || null,
        sourceClientOffset: sourceClientOffset || null,
        isSourcePublic: !!publishSource
      }
    };
  };
}
function verifyInvariants$1(sourceIds, monitor, registry2) {
  invariant(!monitor.isDragging(), "Cannot call beginDrag while dragging.");
  sourceIds.forEach(function(sourceId) {
    invariant(registry2.getSource(sourceId), "Expected sourceIds to be registered.");
  });
}
function verifyGetSourceClientOffsetIsFunction(getSourceClientOffset2) {
  invariant(typeof getSourceClientOffset2 === "function", "When clientOffset is provided, getSourceClientOffset must be a function.");
}
function verifyItemIsObject(item) {
  invariant(isObject$1(item), "Item must be an object.");
}
function getDraggableSource(sourceIds, monitor) {
  let sourceId = null;
  for (let i2 = sourceIds.length - 1; i2 >= 0; i2--) {
    if (monitor.canDragSource(sourceIds[i2])) {
      sourceId = sourceIds[i2];
      break;
    }
  }
  return sourceId;
}
function _defineProperty$4(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value2;
  }
  return obj;
}
function _objectSpread$4(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    var ownKeys = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys.forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    });
  }
  return target;
}
function createDrop(manager) {
  return function drop(options = {}) {
    const monitor = manager.getMonitor();
    const registry2 = manager.getRegistry();
    verifyInvariants(monitor);
    const targetIds = getDroppableTargets(monitor);
    targetIds.forEach((targetId, index2) => {
      const dropResult = determineDropResult(targetId, index2, registry2, monitor);
      const action = {
        type: DROP,
        payload: {
          dropResult: _objectSpread$4({}, options, dropResult)
        }
      };
      manager.dispatch(action);
    });
  };
}
function verifyInvariants(monitor) {
  invariant(monitor.isDragging(), "Cannot call drop while not dragging.");
  invariant(!monitor.didDrop(), "Cannot call drop twice during one drag operation.");
}
function determineDropResult(targetId, index2, registry2, monitor) {
  const target = registry2.getTarget(targetId);
  let dropResult = target ? target.drop(monitor, targetId) : void 0;
  verifyDropResultType(dropResult);
  if (typeof dropResult === "undefined") {
    dropResult = index2 === 0 ? {} : monitor.getDropResult();
  }
  return dropResult;
}
function verifyDropResultType(dropResult) {
  invariant(typeof dropResult === "undefined" || isObject$1(dropResult), "Drop result must either be an object or undefined.");
}
function getDroppableTargets(monitor) {
  const targetIds = monitor.getTargetIds().filter(monitor.canDropOnTarget, monitor);
  targetIds.reverse();
  return targetIds;
}
function createEndDrag(manager) {
  return function endDrag() {
    const monitor = manager.getMonitor();
    const registry2 = manager.getRegistry();
    verifyIsDragging(monitor);
    const sourceId = monitor.getSourceId();
    if (sourceId != null) {
      const source = registry2.getSource(sourceId, true);
      source.endDrag(monitor, sourceId);
      registry2.unpinSource();
    }
    return {
      type: END_DRAG
    };
  };
}
function verifyIsDragging(monitor) {
  invariant(monitor.isDragging(), "Cannot call endDrag while not dragging.");
}
function matchesType(targetType, draggedItemType) {
  if (draggedItemType === null) {
    return targetType === null;
  }
  return Array.isArray(targetType) ? targetType.some(
    (t2) => t2 === draggedItemType
  ) : targetType === draggedItemType;
}
function createHover(manager) {
  return function hover(targetIdsArg, { clientOffset } = {}) {
    verifyTargetIdsIsArray(targetIdsArg);
    const targetIds = targetIdsArg.slice(0);
    const monitor = manager.getMonitor();
    const registry2 = manager.getRegistry();
    const draggedItemType = monitor.getItemType();
    removeNonMatchingTargetIds(targetIds, registry2, draggedItemType);
    checkInvariants(targetIds, monitor, registry2);
    hoverAllTargets(targetIds, monitor, registry2);
    return {
      type: HOVER,
      payload: {
        targetIds,
        clientOffset: clientOffset || null
      }
    };
  };
}
function verifyTargetIdsIsArray(targetIdsArg) {
  invariant(Array.isArray(targetIdsArg), "Expected targetIds to be an array.");
}
function checkInvariants(targetIds, monitor, registry2) {
  invariant(monitor.isDragging(), "Cannot call hover while not dragging.");
  invariant(!monitor.didDrop(), "Cannot call hover after drop.");
  for (let i2 = 0; i2 < targetIds.length; i2++) {
    const targetId = targetIds[i2];
    invariant(targetIds.lastIndexOf(targetId) === i2, "Expected targetIds to be unique in the passed array.");
    const target = registry2.getTarget(targetId);
    invariant(target, "Expected targetIds to be registered.");
  }
}
function removeNonMatchingTargetIds(targetIds, registry2, draggedItemType) {
  for (let i2 = targetIds.length - 1; i2 >= 0; i2--) {
    const targetId = targetIds[i2];
    const targetType = registry2.getTargetType(targetId);
    if (!matchesType(targetType, draggedItemType)) {
      targetIds.splice(i2, 1);
    }
  }
}
function hoverAllTargets(targetIds, monitor, registry2) {
  targetIds.forEach(function(targetId) {
    const target = registry2.getTarget(targetId);
    target.hover(monitor, targetId);
  });
}
function createPublishDragSource(manager) {
  return function publishDragSource() {
    const monitor = manager.getMonitor();
    if (monitor.isDragging()) {
      return {
        type: PUBLISH_DRAG_SOURCE
      };
    }
    return;
  };
}
function createDragDropActions(manager) {
  return {
    beginDrag: createBeginDrag(manager),
    publishDragSource: createPublishDragSource(manager),
    hover: createHover(manager),
    drop: createDrop(manager),
    endDrag: createEndDrag(manager)
  };
}
class DragDropManagerImpl {
  receiveBackend(backend) {
    this.backend = backend;
  }
  getMonitor() {
    return this.monitor;
  }
  getBackend() {
    return this.backend;
  }
  getRegistry() {
    return this.monitor.registry;
  }
  getActions() {
    const manager = this;
    const { dispatch } = this.store;
    function bindActionCreator(actionCreator) {
      return (...args) => {
        const action = actionCreator.apply(manager, args);
        if (typeof action !== "undefined") {
          dispatch(action);
        }
      };
    }
    const actions = createDragDropActions(this);
    return Object.keys(actions).reduce((boundActions, key) => {
      const action = actions[key];
      boundActions[key] = bindActionCreator(action);
      return boundActions;
    }, {});
  }
  dispatch(action) {
    this.store.dispatch(action);
  }
  constructor(store, monitor) {
    this.isSetUp = false;
    this.handleRefCountChange = () => {
      const shouldSetUp = this.store.getState().refCount > 0;
      if (this.backend) {
        if (shouldSetUp && !this.isSetUp) {
          this.backend.setup();
          this.isSetUp = true;
        } else if (!shouldSetUp && this.isSetUp) {
          this.backend.teardown();
          this.isSetUp = false;
        }
      }
    };
    this.store = store;
    this.monitor = monitor;
    store.subscribe(this.handleRefCountChange);
  }
}
function add(a, b2) {
  return {
    x: a.x + b2.x,
    y: a.y + b2.y
  };
}
function subtract(a, b2) {
  return {
    x: a.x - b2.x,
    y: a.y - b2.y
  };
}
function getSourceClientOffset(state) {
  const { clientOffset, initialClientOffset, initialSourceClientOffset } = state;
  if (!clientOffset || !initialClientOffset || !initialSourceClientOffset) {
    return null;
  }
  return subtract(add(clientOffset, initialSourceClientOffset), initialClientOffset);
}
function getDifferenceFromInitialOffset(state) {
  const { clientOffset, initialClientOffset } = state;
  if (!clientOffset || !initialClientOffset) {
    return null;
  }
  return subtract(clientOffset, initialClientOffset);
}
const NONE = [];
const ALL = [];
NONE.__IS_NONE__ = true;
ALL.__IS_ALL__ = true;
function areDirty(dirtyIds, handlerIds) {
  if (dirtyIds === NONE) {
    return false;
  }
  if (dirtyIds === ALL || typeof handlerIds === "undefined") {
    return true;
  }
  const commonIds = intersection(handlerIds, dirtyIds);
  return commonIds.length > 0;
}
class DragDropMonitorImpl {
  subscribeToStateChange(listener, options = {}) {
    const { handlerIds } = options;
    invariant(typeof listener === "function", "listener must be a function.");
    invariant(typeof handlerIds === "undefined" || Array.isArray(handlerIds), "handlerIds, when specified, must be an array of strings.");
    let prevStateId = this.store.getState().stateId;
    const handleChange = () => {
      const state = this.store.getState();
      const currentStateId = state.stateId;
      try {
        const canSkipListener = currentStateId === prevStateId || currentStateId === prevStateId + 1 && !areDirty(state.dirtyHandlerIds, handlerIds);
        if (!canSkipListener) {
          listener();
        }
      } finally {
        prevStateId = currentStateId;
      }
    };
    return this.store.subscribe(handleChange);
  }
  subscribeToOffsetChange(listener) {
    invariant(typeof listener === "function", "listener must be a function.");
    let previousState = this.store.getState().dragOffset;
    const handleChange = () => {
      const nextState = this.store.getState().dragOffset;
      if (nextState === previousState) {
        return;
      }
      previousState = nextState;
      listener();
    };
    return this.store.subscribe(handleChange);
  }
  canDragSource(sourceId) {
    if (!sourceId) {
      return false;
    }
    const source = this.registry.getSource(sourceId);
    invariant(source, `Expected to find a valid source. sourceId=${sourceId}`);
    if (this.isDragging()) {
      return false;
    }
    return source.canDrag(this, sourceId);
  }
  canDropOnTarget(targetId) {
    if (!targetId) {
      return false;
    }
    const target = this.registry.getTarget(targetId);
    invariant(target, `Expected to find a valid target. targetId=${targetId}`);
    if (!this.isDragging() || this.didDrop()) {
      return false;
    }
    const targetType = this.registry.getTargetType(targetId);
    const draggedItemType = this.getItemType();
    return matchesType(targetType, draggedItemType) && target.canDrop(this, targetId);
  }
  isDragging() {
    return Boolean(this.getItemType());
  }
  isDraggingSource(sourceId) {
    if (!sourceId) {
      return false;
    }
    const source = this.registry.getSource(sourceId, true);
    invariant(source, `Expected to find a valid source. sourceId=${sourceId}`);
    if (!this.isDragging() || !this.isSourcePublic()) {
      return false;
    }
    const sourceType = this.registry.getSourceType(sourceId);
    const draggedItemType = this.getItemType();
    if (sourceType !== draggedItemType) {
      return false;
    }
    return source.isDragging(this, sourceId);
  }
  isOverTarget(targetId, options = {
    shallow: false
  }) {
    if (!targetId) {
      return false;
    }
    const { shallow } = options;
    if (!this.isDragging()) {
      return false;
    }
    const targetType = this.registry.getTargetType(targetId);
    const draggedItemType = this.getItemType();
    if (draggedItemType && !matchesType(targetType, draggedItemType)) {
      return false;
    }
    const targetIds = this.getTargetIds();
    if (!targetIds.length) {
      return false;
    }
    const index2 = targetIds.indexOf(targetId);
    if (shallow) {
      return index2 === targetIds.length - 1;
    } else {
      return index2 > -1;
    }
  }
  getItemType() {
    return this.store.getState().dragOperation.itemType;
  }
  getItem() {
    return this.store.getState().dragOperation.item;
  }
  getSourceId() {
    return this.store.getState().dragOperation.sourceId;
  }
  getTargetIds() {
    return this.store.getState().dragOperation.targetIds;
  }
  getDropResult() {
    return this.store.getState().dragOperation.dropResult;
  }
  didDrop() {
    return this.store.getState().dragOperation.didDrop;
  }
  isSourcePublic() {
    return Boolean(this.store.getState().dragOperation.isSourcePublic);
  }
  getInitialClientOffset() {
    return this.store.getState().dragOffset.initialClientOffset;
  }
  getInitialSourceClientOffset() {
    return this.store.getState().dragOffset.initialSourceClientOffset;
  }
  getClientOffset() {
    return this.store.getState().dragOffset.clientOffset;
  }
  getSourceClientOffset() {
    return getSourceClientOffset(this.store.getState().dragOffset);
  }
  getDifferenceFromInitialOffset() {
    return getDifferenceFromInitialOffset(this.store.getState().dragOffset);
  }
  constructor(store, registry2) {
    this.store = store;
    this.registry = registry2;
  }
}
const scope = typeof global !== "undefined" ? global : self;
const BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;
function makeRequestCallFromTimer(callback) {
  return function requestCall() {
    const timeoutHandle = setTimeout(handleTimer, 0);
    const intervalHandle = setInterval(handleTimer, 50);
    function handleTimer() {
      clearTimeout(timeoutHandle);
      clearInterval(intervalHandle);
      callback();
    }
  };
}
function makeRequestCallFromMutationObserver(callback) {
  let toggle = 1;
  const observer = new BrowserMutationObserver(callback);
  const node2 = document.createTextNode("");
  observer.observe(node2, {
    characterData: true
  });
  return function requestCall() {
    toggle = -toggle;
    node2.data = toggle;
  };
}
const makeRequestCall = typeof BrowserMutationObserver === "function" ? makeRequestCallFromMutationObserver : makeRequestCallFromTimer;
class AsapQueue {
  enqueueTask(task) {
    const { queue: q2, requestFlush } = this;
    if (!q2.length) {
      requestFlush();
      this.flushing = true;
    }
    q2[q2.length] = task;
  }
  constructor() {
    this.queue = [];
    this.pendingErrors = [];
    this.flushing = false;
    this.index = 0;
    this.capacity = 1024;
    this.flush = () => {
      const { queue: q2 } = this;
      while (this.index < q2.length) {
        const currentIndex = this.index;
        this.index++;
        q2[currentIndex].call();
        if (this.index > this.capacity) {
          for (let scan = 0, newLength = q2.length - this.index; scan < newLength; scan++) {
            q2[scan] = q2[scan + this.index];
          }
          q2.length -= this.index;
          this.index = 0;
        }
      }
      q2.length = 0;
      this.index = 0;
      this.flushing = false;
    };
    this.registerPendingError = (err) => {
      this.pendingErrors.push(err);
      this.requestErrorThrow();
    };
    this.requestFlush = makeRequestCall(this.flush);
    this.requestErrorThrow = makeRequestCallFromTimer(() => {
      if (this.pendingErrors.length) {
        throw this.pendingErrors.shift();
      }
    });
  }
}
class RawTask {
  call() {
    try {
      this.task && this.task();
    } catch (error) {
      this.onError(error);
    } finally {
      this.task = null;
      this.release(this);
    }
  }
  constructor(onError, release) {
    this.onError = onError;
    this.release = release;
    this.task = null;
  }
}
class TaskFactory {
  create(task) {
    const tasks = this.freeTasks;
    const t1 = tasks.length ? tasks.pop() : new RawTask(
      this.onError,
      (t2) => tasks[tasks.length] = t2
    );
    t1.task = task;
    return t1;
  }
  constructor(onError) {
    this.onError = onError;
    this.freeTasks = [];
  }
}
const asapQueue = new AsapQueue();
const taskFactory = new TaskFactory(asapQueue.registerPendingError);
function asap(task) {
  asapQueue.enqueueTask(taskFactory.create(task));
}
const ADD_SOURCE = "dnd-core/ADD_SOURCE";
const ADD_TARGET = "dnd-core/ADD_TARGET";
const REMOVE_SOURCE = "dnd-core/REMOVE_SOURCE";
const REMOVE_TARGET = "dnd-core/REMOVE_TARGET";
function addSource(sourceId) {
  return {
    type: ADD_SOURCE,
    payload: {
      sourceId
    }
  };
}
function addTarget(targetId) {
  return {
    type: ADD_TARGET,
    payload: {
      targetId
    }
  };
}
function removeSource(sourceId) {
  return {
    type: REMOVE_SOURCE,
    payload: {
      sourceId
    }
  };
}
function removeTarget(targetId) {
  return {
    type: REMOVE_TARGET,
    payload: {
      targetId
    }
  };
}
function validateSourceContract(source) {
  invariant(typeof source.canDrag === "function", "Expected canDrag to be a function.");
  invariant(typeof source.beginDrag === "function", "Expected beginDrag to be a function.");
  invariant(typeof source.endDrag === "function", "Expected endDrag to be a function.");
}
function validateTargetContract(target) {
  invariant(typeof target.canDrop === "function", "Expected canDrop to be a function.");
  invariant(typeof target.hover === "function", "Expected hover to be a function.");
  invariant(typeof target.drop === "function", "Expected beginDrag to be a function.");
}
function validateType(type, allowArray) {
  if (allowArray && Array.isArray(type)) {
    type.forEach(
      (t2) => validateType(t2, false)
    );
    return;
  }
  invariant(typeof type === "string" || typeof type === "symbol", allowArray ? "Type can only be a string, a symbol, or an array of either." : "Type can only be a string or a symbol.");
}
var HandlerRole;
(function(HandlerRole2) {
  HandlerRole2["SOURCE"] = "SOURCE";
  HandlerRole2["TARGET"] = "TARGET";
})(HandlerRole || (HandlerRole = {}));
let nextUniqueId = 0;
function getNextUniqueId() {
  return nextUniqueId++;
}
function getNextHandlerId(role) {
  const id2 = getNextUniqueId().toString();
  switch (role) {
    case HandlerRole.SOURCE:
      return `S${id2}`;
    case HandlerRole.TARGET:
      return `T${id2}`;
    default:
      throw new Error(`Unknown Handler Role: ${role}`);
  }
}
function parseRoleFromHandlerId(handlerId) {
  switch (handlerId[0]) {
    case "S":
      return HandlerRole.SOURCE;
    case "T":
      return HandlerRole.TARGET;
    default:
      throw new Error(`Cannot parse handler ID: ${handlerId}`);
  }
}
function mapContainsValue(map2, searchValue) {
  const entries = map2.entries();
  let isDone = false;
  do {
    const { done, value: [, value2] } = entries.next();
    if (value2 === searchValue) {
      return true;
    }
    isDone = !!done;
  } while (!isDone);
  return false;
}
class HandlerRegistryImpl {
  addSource(type, source) {
    validateType(type);
    validateSourceContract(source);
    const sourceId = this.addHandler(HandlerRole.SOURCE, type, source);
    this.store.dispatch(addSource(sourceId));
    return sourceId;
  }
  addTarget(type, target) {
    validateType(type, true);
    validateTargetContract(target);
    const targetId = this.addHandler(HandlerRole.TARGET, type, target);
    this.store.dispatch(addTarget(targetId));
    return targetId;
  }
  containsHandler(handler) {
    return mapContainsValue(this.dragSources, handler) || mapContainsValue(this.dropTargets, handler);
  }
  getSource(sourceId, includePinned = false) {
    invariant(this.isSourceId(sourceId), "Expected a valid source ID.");
    const isPinned = includePinned && sourceId === this.pinnedSourceId;
    const source = isPinned ? this.pinnedSource : this.dragSources.get(sourceId);
    return source;
  }
  getTarget(targetId) {
    invariant(this.isTargetId(targetId), "Expected a valid target ID.");
    return this.dropTargets.get(targetId);
  }
  getSourceType(sourceId) {
    invariant(this.isSourceId(sourceId), "Expected a valid source ID.");
    return this.types.get(sourceId);
  }
  getTargetType(targetId) {
    invariant(this.isTargetId(targetId), "Expected a valid target ID.");
    return this.types.get(targetId);
  }
  isSourceId(handlerId) {
    const role = parseRoleFromHandlerId(handlerId);
    return role === HandlerRole.SOURCE;
  }
  isTargetId(handlerId) {
    const role = parseRoleFromHandlerId(handlerId);
    return role === HandlerRole.TARGET;
  }
  removeSource(sourceId) {
    invariant(this.getSource(sourceId), "Expected an existing source.");
    this.store.dispatch(removeSource(sourceId));
    asap(() => {
      this.dragSources.delete(sourceId);
      this.types.delete(sourceId);
    });
  }
  removeTarget(targetId) {
    invariant(this.getTarget(targetId), "Expected an existing target.");
    this.store.dispatch(removeTarget(targetId));
    this.dropTargets.delete(targetId);
    this.types.delete(targetId);
  }
  pinSource(sourceId) {
    const source = this.getSource(sourceId);
    invariant(source, "Expected an existing source.");
    this.pinnedSourceId = sourceId;
    this.pinnedSource = source;
  }
  unpinSource() {
    invariant(this.pinnedSource, "No source is pinned at the time.");
    this.pinnedSourceId = null;
    this.pinnedSource = null;
  }
  addHandler(role, type, handler) {
    const id2 = getNextHandlerId(role);
    this.types.set(id2, type);
    if (role === HandlerRole.SOURCE) {
      this.dragSources.set(id2, handler);
    } else if (role === HandlerRole.TARGET) {
      this.dropTargets.set(id2, handler);
    }
    return id2;
  }
  constructor(store) {
    this.types = /* @__PURE__ */ new Map();
    this.dragSources = /* @__PURE__ */ new Map();
    this.dropTargets = /* @__PURE__ */ new Map();
    this.pinnedSourceId = null;
    this.pinnedSource = null;
    this.store = store;
  }
}
const strictEquality = (a, b2) => a === b2;
function areCoordsEqual(offsetA, offsetB) {
  if (!offsetA && !offsetB) {
    return true;
  } else if (!offsetA || !offsetB) {
    return false;
  } else {
    return offsetA.x === offsetB.x && offsetA.y === offsetB.y;
  }
}
function areArraysEqual(a, b2, isEqual2 = strictEquality) {
  if (a.length !== b2.length) {
    return false;
  }
  for (let i2 = 0; i2 < a.length; ++i2) {
    if (!isEqual2(a[i2], b2[i2])) {
      return false;
    }
  }
  return true;
}
function reduce$5(_state = NONE, action) {
  switch (action.type) {
    case HOVER:
      break;
    case ADD_SOURCE:
    case ADD_TARGET:
    case REMOVE_TARGET:
    case REMOVE_SOURCE:
      return NONE;
    case BEGIN_DRAG:
    case PUBLISH_DRAG_SOURCE:
    case END_DRAG:
    case DROP:
    default:
      return ALL;
  }
  const { targetIds = [], prevTargetIds = [] } = action.payload;
  const result = xor(targetIds, prevTargetIds);
  const didChange = result.length > 0 || !areArraysEqual(targetIds, prevTargetIds);
  if (!didChange) {
    return NONE;
  }
  const prevInnermostTargetId = prevTargetIds[prevTargetIds.length - 1];
  const innermostTargetId = targetIds[targetIds.length - 1];
  if (prevInnermostTargetId !== innermostTargetId) {
    if (prevInnermostTargetId) {
      result.push(prevInnermostTargetId);
    }
    if (innermostTargetId) {
      result.push(innermostTargetId);
    }
  }
  return result;
}
function _defineProperty$3(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value2;
  }
  return obj;
}
function _objectSpread$3(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    var ownKeys = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys.forEach(function(key) {
      _defineProperty$3(target, key, source[key]);
    });
  }
  return target;
}
const initialState$1 = {
  initialSourceClientOffset: null,
  initialClientOffset: null,
  clientOffset: null
};
function reduce$4(state = initialState$1, action) {
  const { payload } = action;
  switch (action.type) {
    case INIT_COORDS:
    case BEGIN_DRAG:
      return {
        initialSourceClientOffset: payload.sourceClientOffset,
        initialClientOffset: payload.clientOffset,
        clientOffset: payload.clientOffset
      };
    case HOVER:
      if (areCoordsEqual(state.clientOffset, payload.clientOffset)) {
        return state;
      }
      return _objectSpread$3({}, state, {
        clientOffset: payload.clientOffset
      });
    case END_DRAG:
    case DROP:
      return initialState$1;
    default:
      return state;
  }
}
function _defineProperty$2(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value2;
  }
  return obj;
}
function _objectSpread$2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    var ownKeys = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys.forEach(function(key) {
      _defineProperty$2(target, key, source[key]);
    });
  }
  return target;
}
const initialState = {
  itemType: null,
  item: null,
  sourceId: null,
  targetIds: [],
  dropResult: null,
  didDrop: false,
  isSourcePublic: null
};
function reduce$3(state = initialState, action) {
  const { payload } = action;
  switch (action.type) {
    case BEGIN_DRAG:
      return _objectSpread$2({}, state, {
        itemType: payload.itemType,
        item: payload.item,
        sourceId: payload.sourceId,
        isSourcePublic: payload.isSourcePublic,
        dropResult: null,
        didDrop: false
      });
    case PUBLISH_DRAG_SOURCE:
      return _objectSpread$2({}, state, {
        isSourcePublic: true
      });
    case HOVER:
      return _objectSpread$2({}, state, {
        targetIds: payload.targetIds
      });
    case REMOVE_TARGET:
      if (state.targetIds.indexOf(payload.targetId) === -1) {
        return state;
      }
      return _objectSpread$2({}, state, {
        targetIds: without$1(state.targetIds, payload.targetId)
      });
    case DROP:
      return _objectSpread$2({}, state, {
        dropResult: payload.dropResult,
        didDrop: true,
        targetIds: []
      });
    case END_DRAG:
      return _objectSpread$2({}, state, {
        itemType: null,
        item: null,
        sourceId: null,
        dropResult: null,
        didDrop: false,
        isSourcePublic: null,
        targetIds: []
      });
    default:
      return state;
  }
}
function reduce$2(state = 0, action) {
  switch (action.type) {
    case ADD_SOURCE:
    case ADD_TARGET:
      return state + 1;
    case REMOVE_SOURCE:
    case REMOVE_TARGET:
      return state - 1;
    default:
      return state;
  }
}
function reduce$1(state = 0) {
  return state + 1;
}
function _defineProperty$1(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value2;
  }
  return obj;
}
function _objectSpread$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    var ownKeys = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys.forEach(function(key) {
      _defineProperty$1(target, key, source[key]);
    });
  }
  return target;
}
function reduce(state = {}, action) {
  return {
    dirtyHandlerIds: reduce$5(state.dirtyHandlerIds, {
      type: action.type,
      payload: _objectSpread$1({}, action.payload, {
        prevTargetIds: get(state, "dragOperation.targetIds", [])
      })
    }),
    dragOffset: reduce$4(state.dragOffset, action),
    refCount: reduce$2(state.refCount, action),
    dragOperation: reduce$3(state.dragOperation, action),
    stateId: reduce$1(state.stateId)
  };
}
function createDragDropManager(backendFactory, globalContext = void 0, backendOptions = {}, debugMode = false) {
  const store = makeStoreInstance(debugMode);
  const monitor = new DragDropMonitorImpl(store, new HandlerRegistryImpl(store));
  const manager = new DragDropManagerImpl(store, monitor);
  const backend = backendFactory(manager, globalContext, backendOptions);
  manager.receiveBackend(backend);
  return manager;
}
function makeStoreInstance(debugMode) {
  const reduxDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__;
  return createStore$1(reduce, debugMode && reduxDevTools && reduxDevTools({
    name: "dnd-core",
    instanceId: "dnd-core"
  }));
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
let refCount = 0;
const INSTANCE_SYM = Symbol.for("__REACT_DND_CONTEXT_INSTANCE__");
var DndProvider = /* @__PURE__ */ react.exports.memo(function DndProvider2(_param) {
  var { children } = _param, props = _objectWithoutProperties(_param, [
    "children"
  ]);
  const [manager, isGlobalInstance] = getDndContextValue(props);
  react.exports.useEffect(() => {
    if (isGlobalInstance) {
      const context = getGlobalContext();
      ++refCount;
      return () => {
        if (--refCount === 0) {
          context[INSTANCE_SYM] = null;
        }
      };
    }
    return;
  }, []);
  return /* @__PURE__ */ jsx(DndContext.Provider, {
    value: manager,
    children
  });
});
function getDndContextValue(props) {
  if ("manager" in props) {
    const manager2 = {
      dragDropManager: props.manager
    };
    return [
      manager2,
      false
    ];
  }
  const manager = createSingletonDndContext(props.backend, props.context, props.options, props.debugMode);
  const isGlobalInstance = !props.context;
  return [
    manager,
    isGlobalInstance
  ];
}
function createSingletonDndContext(backend, context = getGlobalContext(), options, debugMode) {
  const ctx = context;
  if (!ctx[INSTANCE_SYM]) {
    ctx[INSTANCE_SYM] = {
      dragDropManager: createDragDropManager(backend, context, options, debugMode)
    };
  }
  return ctx[INSTANCE_SYM];
}
function getGlobalContext() {
  return typeof global !== "undefined" ? global : window;
}
var fastDeepEqual = function equal(a, b2) {
  if (a === b2)
    return true;
  if (a && b2 && typeof a == "object" && typeof b2 == "object") {
    if (a.constructor !== b2.constructor)
      return false;
    var length2, i2, keys;
    if (Array.isArray(a)) {
      length2 = a.length;
      if (length2 != b2.length)
        return false;
      for (i2 = length2; i2-- !== 0; )
        if (!equal(a[i2], b2[i2]))
          return false;
      return true;
    }
    if (a.constructor === RegExp)
      return a.source === b2.source && a.flags === b2.flags;
    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b2.valueOf();
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b2.toString();
    keys = Object.keys(a);
    length2 = keys.length;
    if (length2 !== Object.keys(b2).length)
      return false;
    for (i2 = length2; i2-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b2, keys[i2]))
        return false;
    for (i2 = length2; i2-- !== 0; ) {
      var key = keys[i2];
      if (!equal(a[key], b2[key]))
        return false;
    }
    return true;
  }
  return a !== a && b2 !== b2;
};
const useIsomorphicLayoutEffect = typeof window !== "undefined" ? react.exports.useLayoutEffect : react.exports.useEffect;
function useCollector(monitor, collect, onUpdate) {
  const [collected, setCollected] = react.exports.useState(
    () => collect(monitor)
  );
  const updateCollected = react.exports.useCallback(() => {
    const nextValue = collect(monitor);
    if (!fastDeepEqual(collected, nextValue)) {
      setCollected(nextValue);
      if (onUpdate) {
        onUpdate();
      }
    }
  }, [
    collected,
    monitor,
    onUpdate
  ]);
  useIsomorphicLayoutEffect(updateCollected);
  return [
    collected,
    updateCollected
  ];
}
function useMonitorOutput(monitor, collect, onCollect) {
  const [collected, updateCollected] = useCollector(monitor, collect, onCollect);
  useIsomorphicLayoutEffect(function subscribeToMonitorStateChange() {
    const handlerId = monitor.getHandlerId();
    if (handlerId == null) {
      return;
    }
    return monitor.subscribeToStateChange(updateCollected, {
      handlerIds: [
        handlerId
      ]
    });
  }, [
    monitor,
    updateCollected
  ]);
  return collected;
}
function useCollectedProps(collector, monitor, connector) {
  return useMonitorOutput(
    monitor,
    collector || (() => ({})),
    () => connector.reconnect()
  );
}
function useOptionalFactory(arg, deps) {
  const memoDeps = [
    ...deps || []
  ];
  if (deps == null && typeof arg !== "function") {
    memoDeps.push(arg);
  }
  return react.exports.useMemo(() => {
    return typeof arg === "function" ? arg() : arg;
  }, memoDeps);
}
function useConnectDragSource(connector) {
  return react.exports.useMemo(
    () => connector.hooks.dragSource(),
    [
      connector
    ]
  );
}
function useConnectDragPreview(connector) {
  return react.exports.useMemo(
    () => connector.hooks.dragPreview(),
    [
      connector
    ]
  );
}
let isCallingCanDrag = false;
let isCallingIsDragging = false;
class DragSourceMonitorImpl {
  receiveHandlerId(sourceId) {
    this.sourceId = sourceId;
  }
  getHandlerId() {
    return this.sourceId;
  }
  canDrag() {
    invariant(!isCallingCanDrag, "You may not call monitor.canDrag() inside your canDrag() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");
    try {
      isCallingCanDrag = true;
      return this.internalMonitor.canDragSource(this.sourceId);
    } finally {
      isCallingCanDrag = false;
    }
  }
  isDragging() {
    if (!this.sourceId) {
      return false;
    }
    invariant(!isCallingIsDragging, "You may not call monitor.isDragging() inside your isDragging() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");
    try {
      isCallingIsDragging = true;
      return this.internalMonitor.isDraggingSource(this.sourceId);
    } finally {
      isCallingIsDragging = false;
    }
  }
  subscribeToStateChange(listener, options) {
    return this.internalMonitor.subscribeToStateChange(listener, options);
  }
  isDraggingSource(sourceId) {
    return this.internalMonitor.isDraggingSource(sourceId);
  }
  isOverTarget(targetId, options) {
    return this.internalMonitor.isOverTarget(targetId, options);
  }
  getTargetIds() {
    return this.internalMonitor.getTargetIds();
  }
  isSourcePublic() {
    return this.internalMonitor.isSourcePublic();
  }
  getSourceId() {
    return this.internalMonitor.getSourceId();
  }
  subscribeToOffsetChange(listener) {
    return this.internalMonitor.subscribeToOffsetChange(listener);
  }
  canDragSource(sourceId) {
    return this.internalMonitor.canDragSource(sourceId);
  }
  canDropOnTarget(targetId) {
    return this.internalMonitor.canDropOnTarget(targetId);
  }
  getItemType() {
    return this.internalMonitor.getItemType();
  }
  getItem() {
    return this.internalMonitor.getItem();
  }
  getDropResult() {
    return this.internalMonitor.getDropResult();
  }
  didDrop() {
    return this.internalMonitor.didDrop();
  }
  getInitialClientOffset() {
    return this.internalMonitor.getInitialClientOffset();
  }
  getInitialSourceClientOffset() {
    return this.internalMonitor.getInitialSourceClientOffset();
  }
  getSourceClientOffset() {
    return this.internalMonitor.getSourceClientOffset();
  }
  getClientOffset() {
    return this.internalMonitor.getClientOffset();
  }
  getDifferenceFromInitialOffset() {
    return this.internalMonitor.getDifferenceFromInitialOffset();
  }
  constructor(manager) {
    this.sourceId = null;
    this.internalMonitor = manager.getMonitor();
  }
}
let isCallingCanDrop = false;
class DropTargetMonitorImpl {
  receiveHandlerId(targetId) {
    this.targetId = targetId;
  }
  getHandlerId() {
    return this.targetId;
  }
  subscribeToStateChange(listener, options) {
    return this.internalMonitor.subscribeToStateChange(listener, options);
  }
  canDrop() {
    if (!this.targetId) {
      return false;
    }
    invariant(!isCallingCanDrop, "You may not call monitor.canDrop() inside your canDrop() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor");
    try {
      isCallingCanDrop = true;
      return this.internalMonitor.canDropOnTarget(this.targetId);
    } finally {
      isCallingCanDrop = false;
    }
  }
  isOver(options) {
    if (!this.targetId) {
      return false;
    }
    return this.internalMonitor.isOverTarget(this.targetId, options);
  }
  getItemType() {
    return this.internalMonitor.getItemType();
  }
  getItem() {
    return this.internalMonitor.getItem();
  }
  getDropResult() {
    return this.internalMonitor.getDropResult();
  }
  didDrop() {
    return this.internalMonitor.didDrop();
  }
  getInitialClientOffset() {
    return this.internalMonitor.getInitialClientOffset();
  }
  getInitialSourceClientOffset() {
    return this.internalMonitor.getInitialSourceClientOffset();
  }
  getSourceClientOffset() {
    return this.internalMonitor.getSourceClientOffset();
  }
  getClientOffset() {
    return this.internalMonitor.getClientOffset();
  }
  getDifferenceFromInitialOffset() {
    return this.internalMonitor.getDifferenceFromInitialOffset();
  }
  constructor(manager) {
    this.targetId = null;
    this.internalMonitor = manager.getMonitor();
  }
}
function registerTarget(type, target, manager) {
  const registry2 = manager.getRegistry();
  const targetId = registry2.addTarget(type, target);
  return [
    targetId,
    () => registry2.removeTarget(targetId)
  ];
}
function registerSource(type, source, manager) {
  const registry2 = manager.getRegistry();
  const sourceId = registry2.addSource(type, source);
  return [
    sourceId,
    () => registry2.removeSource(sourceId)
  ];
}
function shallowEqual(objA, objB, compare2, compareContext) {
  let compareResult = compare2 ? compare2.call(compareContext, objA, objB) : void 0;
  if (compareResult !== void 0) {
    return !!compareResult;
  }
  if (objA === objB) {
    return true;
  }
  if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
    return false;
  }
  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  const bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
  for (let idx = 0; idx < keysA.length; idx++) {
    const key = keysA[idx];
    if (!bHasOwnProperty(key)) {
      return false;
    }
    const valueA = objA[key];
    const valueB = objB[key];
    compareResult = compare2 ? compare2.call(compareContext, valueA, valueB, key) : void 0;
    if (compareResult === false || compareResult === void 0 && valueA !== valueB) {
      return false;
    }
  }
  return true;
}
function isRef(obj) {
  return obj !== null && typeof obj === "object" && Object.prototype.hasOwnProperty.call(obj, "current");
}
function throwIfCompositeComponentElement(element) {
  if (typeof element.type === "string") {
    return;
  }
  const displayName = element.type.displayName || element.type.name || "the component";
  throw new Error(`Only native element nodes can now be passed to React DnD connectors.You can either wrap ${displayName} into a <div>, or turn it into a drag source or a drop target itself.`);
}
function wrapHookToRecognizeElement(hook) {
  return (elementOrNode = null, options = null) => {
    if (!react.exports.isValidElement(elementOrNode)) {
      const node2 = elementOrNode;
      hook(node2, options);
      return node2;
    }
    const element = elementOrNode;
    throwIfCompositeComponentElement(element);
    const ref = options ? (node2) => hook(node2, options) : hook;
    return cloneWithRef(element, ref);
  };
}
function wrapConnectorHooks(hooks) {
  const wrappedHooks = {};
  Object.keys(hooks).forEach((key) => {
    const hook = hooks[key];
    if (key.endsWith("Ref")) {
      wrappedHooks[key] = hooks[key];
    } else {
      const wrappedHook = wrapHookToRecognizeElement(hook);
      wrappedHooks[key] = () => wrappedHook;
    }
  });
  return wrappedHooks;
}
function setRef(ref, node2) {
  if (typeof ref === "function") {
    ref(node2);
  } else {
    ref.current = node2;
  }
}
function cloneWithRef(element, newRef) {
  const previousRef = element.ref;
  invariant(typeof previousRef !== "string", "Cannot connect React DnD to an element with an existing string ref. Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs");
  if (!previousRef) {
    return react.exports.cloneElement(element, {
      ref: newRef
    });
  } else {
    return react.exports.cloneElement(element, {
      ref: (node2) => {
        setRef(previousRef, node2);
        setRef(newRef, node2);
      }
    });
  }
}
class SourceConnector {
  receiveHandlerId(newHandlerId) {
    if (this.handlerId === newHandlerId) {
      return;
    }
    this.handlerId = newHandlerId;
    this.reconnect();
  }
  get connectTarget() {
    return this.dragSource;
  }
  get dragSourceOptions() {
    return this.dragSourceOptionsInternal;
  }
  set dragSourceOptions(options) {
    this.dragSourceOptionsInternal = options;
  }
  get dragPreviewOptions() {
    return this.dragPreviewOptionsInternal;
  }
  set dragPreviewOptions(options) {
    this.dragPreviewOptionsInternal = options;
  }
  reconnect() {
    const didChange = this.reconnectDragSource();
    this.reconnectDragPreview(didChange);
  }
  reconnectDragSource() {
    const dragSource = this.dragSource;
    const didChange = this.didHandlerIdChange() || this.didConnectedDragSourceChange() || this.didDragSourceOptionsChange();
    if (didChange) {
      this.disconnectDragSource();
    }
    if (!this.handlerId) {
      return didChange;
    }
    if (!dragSource) {
      this.lastConnectedDragSource = dragSource;
      return didChange;
    }
    if (didChange) {
      this.lastConnectedHandlerId = this.handlerId;
      this.lastConnectedDragSource = dragSource;
      this.lastConnectedDragSourceOptions = this.dragSourceOptions;
      this.dragSourceUnsubscribe = this.backend.connectDragSource(this.handlerId, dragSource, this.dragSourceOptions);
    }
    return didChange;
  }
  reconnectDragPreview(forceDidChange = false) {
    const dragPreview = this.dragPreview;
    const didChange = forceDidChange || this.didHandlerIdChange() || this.didConnectedDragPreviewChange() || this.didDragPreviewOptionsChange();
    if (didChange) {
      this.disconnectDragPreview();
    }
    if (!this.handlerId) {
      return;
    }
    if (!dragPreview) {
      this.lastConnectedDragPreview = dragPreview;
      return;
    }
    if (didChange) {
      this.lastConnectedHandlerId = this.handlerId;
      this.lastConnectedDragPreview = dragPreview;
      this.lastConnectedDragPreviewOptions = this.dragPreviewOptions;
      this.dragPreviewUnsubscribe = this.backend.connectDragPreview(this.handlerId, dragPreview, this.dragPreviewOptions);
    }
  }
  didHandlerIdChange() {
    return this.lastConnectedHandlerId !== this.handlerId;
  }
  didConnectedDragSourceChange() {
    return this.lastConnectedDragSource !== this.dragSource;
  }
  didConnectedDragPreviewChange() {
    return this.lastConnectedDragPreview !== this.dragPreview;
  }
  didDragSourceOptionsChange() {
    return !shallowEqual(this.lastConnectedDragSourceOptions, this.dragSourceOptions);
  }
  didDragPreviewOptionsChange() {
    return !shallowEqual(this.lastConnectedDragPreviewOptions, this.dragPreviewOptions);
  }
  disconnectDragSource() {
    if (this.dragSourceUnsubscribe) {
      this.dragSourceUnsubscribe();
      this.dragSourceUnsubscribe = void 0;
    }
  }
  disconnectDragPreview() {
    if (this.dragPreviewUnsubscribe) {
      this.dragPreviewUnsubscribe();
      this.dragPreviewUnsubscribe = void 0;
      this.dragPreviewNode = null;
      this.dragPreviewRef = null;
    }
  }
  get dragSource() {
    return this.dragSourceNode || this.dragSourceRef && this.dragSourceRef.current;
  }
  get dragPreview() {
    return this.dragPreviewNode || this.dragPreviewRef && this.dragPreviewRef.current;
  }
  clearDragSource() {
    this.dragSourceNode = null;
    this.dragSourceRef = null;
  }
  clearDragPreview() {
    this.dragPreviewNode = null;
    this.dragPreviewRef = null;
  }
  constructor(backend) {
    this.hooks = wrapConnectorHooks({
      dragSource: (node2, options) => {
        this.clearDragSource();
        this.dragSourceOptions = options || null;
        if (isRef(node2)) {
          this.dragSourceRef = node2;
        } else {
          this.dragSourceNode = node2;
        }
        this.reconnectDragSource();
      },
      dragPreview: (node2, options) => {
        this.clearDragPreview();
        this.dragPreviewOptions = options || null;
        if (isRef(node2)) {
          this.dragPreviewRef = node2;
        } else {
          this.dragPreviewNode = node2;
        }
        this.reconnectDragPreview();
      }
    });
    this.handlerId = null;
    this.dragSourceRef = null;
    this.dragSourceOptionsInternal = null;
    this.dragPreviewRef = null;
    this.dragPreviewOptionsInternal = null;
    this.lastConnectedHandlerId = null;
    this.lastConnectedDragSource = null;
    this.lastConnectedDragSourceOptions = null;
    this.lastConnectedDragPreview = null;
    this.lastConnectedDragPreviewOptions = null;
    this.backend = backend;
  }
}
class TargetConnector {
  get connectTarget() {
    return this.dropTarget;
  }
  reconnect() {
    const didChange = this.didHandlerIdChange() || this.didDropTargetChange() || this.didOptionsChange();
    if (didChange) {
      this.disconnectDropTarget();
    }
    const dropTarget = this.dropTarget;
    if (!this.handlerId) {
      return;
    }
    if (!dropTarget) {
      this.lastConnectedDropTarget = dropTarget;
      return;
    }
    if (didChange) {
      this.lastConnectedHandlerId = this.handlerId;
      this.lastConnectedDropTarget = dropTarget;
      this.lastConnectedDropTargetOptions = this.dropTargetOptions;
      this.unsubscribeDropTarget = this.backend.connectDropTarget(this.handlerId, dropTarget, this.dropTargetOptions);
    }
  }
  receiveHandlerId(newHandlerId) {
    if (newHandlerId === this.handlerId) {
      return;
    }
    this.handlerId = newHandlerId;
    this.reconnect();
  }
  get dropTargetOptions() {
    return this.dropTargetOptionsInternal;
  }
  set dropTargetOptions(options) {
    this.dropTargetOptionsInternal = options;
  }
  didHandlerIdChange() {
    return this.lastConnectedHandlerId !== this.handlerId;
  }
  didDropTargetChange() {
    return this.lastConnectedDropTarget !== this.dropTarget;
  }
  didOptionsChange() {
    return !shallowEqual(this.lastConnectedDropTargetOptions, this.dropTargetOptions);
  }
  disconnectDropTarget() {
    if (this.unsubscribeDropTarget) {
      this.unsubscribeDropTarget();
      this.unsubscribeDropTarget = void 0;
    }
  }
  get dropTarget() {
    return this.dropTargetNode || this.dropTargetRef && this.dropTargetRef.current;
  }
  clearDropTarget() {
    this.dropTargetRef = null;
    this.dropTargetNode = null;
  }
  constructor(backend) {
    this.hooks = wrapConnectorHooks({
      dropTarget: (node2, options) => {
        this.clearDropTarget();
        this.dropTargetOptions = options;
        if (isRef(node2)) {
          this.dropTargetRef = node2;
        } else {
          this.dropTargetNode = node2;
        }
        this.reconnect();
      }
    });
    this.handlerId = null;
    this.dropTargetRef = null;
    this.dropTargetOptionsInternal = null;
    this.lastConnectedHandlerId = null;
    this.lastConnectedDropTarget = null;
    this.lastConnectedDropTargetOptions = null;
    this.backend = backend;
  }
}
function useDragDropManager() {
  const { dragDropManager } = react.exports.useContext(DndContext);
  invariant(dragDropManager != null, "Expected drag drop context");
  return dragDropManager;
}
function useDragSourceConnector(dragSourceOptions, dragPreviewOptions) {
  const manager = useDragDropManager();
  const connector = react.exports.useMemo(
    () => new SourceConnector(manager.getBackend()),
    [
      manager
    ]
  );
  useIsomorphicLayoutEffect(() => {
    connector.dragSourceOptions = dragSourceOptions || null;
    connector.reconnect();
    return () => connector.disconnectDragSource();
  }, [
    connector,
    dragSourceOptions
  ]);
  useIsomorphicLayoutEffect(() => {
    connector.dragPreviewOptions = dragPreviewOptions || null;
    connector.reconnect();
    return () => connector.disconnectDragPreview();
  }, [
    connector,
    dragPreviewOptions
  ]);
  return connector;
}
function useDragSourceMonitor() {
  const manager = useDragDropManager();
  return react.exports.useMemo(
    () => new DragSourceMonitorImpl(manager),
    [
      manager
    ]
  );
}
class DragSourceImpl {
  beginDrag() {
    const spec = this.spec;
    const monitor = this.monitor;
    let result = null;
    if (typeof spec.item === "object") {
      result = spec.item;
    } else if (typeof spec.item === "function") {
      result = spec.item(monitor);
    } else {
      result = {};
    }
    return result !== null && result !== void 0 ? result : null;
  }
  canDrag() {
    const spec = this.spec;
    const monitor = this.monitor;
    if (typeof spec.canDrag === "boolean") {
      return spec.canDrag;
    } else if (typeof spec.canDrag === "function") {
      return spec.canDrag(monitor);
    } else {
      return true;
    }
  }
  isDragging(globalMonitor, target) {
    const spec = this.spec;
    const monitor = this.monitor;
    const { isDragging } = spec;
    return isDragging ? isDragging(monitor) : target === globalMonitor.getSourceId();
  }
  endDrag() {
    const spec = this.spec;
    const monitor = this.monitor;
    const connector = this.connector;
    const { end } = spec;
    if (end) {
      end(monitor.getItem(), monitor);
    }
    connector.reconnect();
  }
  constructor(spec, monitor, connector) {
    this.spec = spec;
    this.monitor = monitor;
    this.connector = connector;
  }
}
function useDragSource(spec, monitor, connector) {
  const handler = react.exports.useMemo(
    () => new DragSourceImpl(spec, monitor, connector),
    [
      monitor,
      connector
    ]
  );
  react.exports.useEffect(() => {
    handler.spec = spec;
  }, [
    spec
  ]);
  return handler;
}
function useDragType(spec) {
  return react.exports.useMemo(() => {
    const result = spec.type;
    invariant(result != null, "spec.type must be defined");
    return result;
  }, [
    spec
  ]);
}
function useRegisteredDragSource(spec, monitor, connector) {
  const manager = useDragDropManager();
  const handler = useDragSource(spec, monitor, connector);
  const itemType = useDragType(spec);
  useIsomorphicLayoutEffect(function registerDragSource() {
    if (itemType != null) {
      const [handlerId, unregister] = registerSource(itemType, handler, manager);
      monitor.receiveHandlerId(handlerId);
      connector.receiveHandlerId(handlerId);
      return unregister;
    }
    return;
  }, [
    manager,
    monitor,
    connector,
    handler,
    itemType
  ]);
}
function useDrag(specArg, deps) {
  const spec = useOptionalFactory(specArg, deps);
  invariant(!spec.begin, `useDrag::spec.begin was deprecated in v14. Replace spec.begin() with spec.item(). (see more here - https://react-dnd.github.io/react-dnd/docs/api/use-drag)`);
  const monitor = useDragSourceMonitor();
  const connector = useDragSourceConnector(spec.options, spec.previewOptions);
  useRegisteredDragSource(spec, monitor, connector);
  return [
    useCollectedProps(spec.collect, monitor, connector),
    useConnectDragSource(connector),
    useConnectDragPreview(connector)
  ];
}
function useConnectDropTarget(connector) {
  return react.exports.useMemo(
    () => connector.hooks.dropTarget(),
    [
      connector
    ]
  );
}
function useDropTargetConnector(options) {
  const manager = useDragDropManager();
  const connector = react.exports.useMemo(
    () => new TargetConnector(manager.getBackend()),
    [
      manager
    ]
  );
  useIsomorphicLayoutEffect(() => {
    connector.dropTargetOptions = options || null;
    connector.reconnect();
    return () => connector.disconnectDropTarget();
  }, [
    options
  ]);
  return connector;
}
function useDropTargetMonitor() {
  const manager = useDragDropManager();
  return react.exports.useMemo(
    () => new DropTargetMonitorImpl(manager),
    [
      manager
    ]
  );
}
function useAccept(spec) {
  const { accept } = spec;
  return react.exports.useMemo(() => {
    invariant(spec.accept != null, "accept must be defined");
    return Array.isArray(accept) ? accept : [
      accept
    ];
  }, [
    accept
  ]);
}
class DropTargetImpl {
  canDrop() {
    const spec = this.spec;
    const monitor = this.monitor;
    return spec.canDrop ? spec.canDrop(monitor.getItem(), monitor) : true;
  }
  hover() {
    const spec = this.spec;
    const monitor = this.monitor;
    if (spec.hover) {
      spec.hover(monitor.getItem(), monitor);
    }
  }
  drop() {
    const spec = this.spec;
    const monitor = this.monitor;
    if (spec.drop) {
      return spec.drop(monitor.getItem(), monitor);
    }
    return;
  }
  constructor(spec, monitor) {
    this.spec = spec;
    this.monitor = monitor;
  }
}
function useDropTarget(spec, monitor) {
  const dropTarget = react.exports.useMemo(
    () => new DropTargetImpl(spec, monitor),
    [
      monitor
    ]
  );
  react.exports.useEffect(() => {
    dropTarget.spec = spec;
  }, [
    spec
  ]);
  return dropTarget;
}
function useRegisteredDropTarget(spec, monitor, connector) {
  const manager = useDragDropManager();
  const dropTarget = useDropTarget(spec, monitor);
  const accept = useAccept(spec);
  useIsomorphicLayoutEffect(function registerDropTarget() {
    const [handlerId, unregister] = registerTarget(accept, dropTarget, manager);
    monitor.receiveHandlerId(handlerId);
    connector.receiveHandlerId(handlerId);
    return unregister;
  }, [
    manager,
    monitor,
    dropTarget,
    connector,
    accept.map(
      (a) => a.toString()
    ).join("|")
  ]);
}
function useDrop(specArg, deps) {
  const spec = useOptionalFactory(specArg, deps);
  const monitor = useDropTargetMonitor();
  const connector = useDropTargetConnector(spec.options);
  useRegisteredDropTarget(spec, monitor, connector);
  return [
    useCollectedProps(spec.collect, monitor, connector),
    useConnectDropTarget(connector)
  ];
}
function memoize$1(fn) {
  let result = null;
  const memoized = () => {
    if (result == null) {
      result = fn();
    }
    return result;
  };
  return memoized;
}
function without(items, item) {
  return items.filter(
    (i2) => i2 !== item
  );
}
function union(itemsA, itemsB) {
  const set = /* @__PURE__ */ new Set();
  const insertItem = (item) => set.add(item);
  itemsA.forEach(insertItem);
  itemsB.forEach(insertItem);
  const result = [];
  set.forEach(
    (key) => result.push(key)
  );
  return result;
}
class EnterLeaveCounter {
  enter(enteringNode) {
    const previousLength = this.entered.length;
    const isNodeEntered = (node2) => this.isNodeInDocument(node2) && (!node2.contains || node2.contains(enteringNode));
    this.entered = union(this.entered.filter(isNodeEntered), [
      enteringNode
    ]);
    return previousLength === 0 && this.entered.length > 0;
  }
  leave(leavingNode) {
    const previousLength = this.entered.length;
    this.entered = without(this.entered.filter(this.isNodeInDocument), leavingNode);
    return previousLength > 0 && this.entered.length === 0;
  }
  reset() {
    this.entered = [];
  }
  constructor(isNodeInDocument) {
    this.entered = [];
    this.isNodeInDocument = isNodeInDocument;
  }
}
class NativeDragSource {
  initializeExposedProperties() {
    Object.keys(this.config.exposeProperties).forEach((property) => {
      Object.defineProperty(this.item, property, {
        configurable: true,
        enumerable: true,
        get() {
          console.warn(`Browser doesn't allow reading "${property}" until the drop event.`);
          return null;
        }
      });
    });
  }
  loadDataTransfer(dataTransfer) {
    if (dataTransfer) {
      const newProperties = {};
      Object.keys(this.config.exposeProperties).forEach((property) => {
        const propertyFn = this.config.exposeProperties[property];
        if (propertyFn != null) {
          newProperties[property] = {
            value: propertyFn(dataTransfer, this.config.matchesTypes),
            configurable: true,
            enumerable: true
          };
        }
      });
      Object.defineProperties(this.item, newProperties);
    }
  }
  canDrag() {
    return true;
  }
  beginDrag() {
    return this.item;
  }
  isDragging(monitor, handle) {
    return handle === monitor.getSourceId();
  }
  endDrag() {
  }
  constructor(config) {
    this.config = config;
    this.item = {};
    this.initializeExposedProperties();
  }
}
const FILE = "__NATIVE_FILE__";
const URL$4 = "__NATIVE_URL__";
const TEXT = "__NATIVE_TEXT__";
const HTML = "__NATIVE_HTML__";
const NativeTypes = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  FILE,
  URL: URL$4,
  TEXT,
  HTML
}, Symbol.toStringTag, { value: "Module" }));
function getDataFromDataTransfer(dataTransfer, typesToTry, defaultValue) {
  const result = typesToTry.reduce(
    (resultSoFar, typeToTry) => resultSoFar || dataTransfer.getData(typeToTry),
    ""
  );
  return result != null ? result : defaultValue;
}
const nativeTypesConfig = {
  [FILE]: {
    exposeProperties: {
      files: (dataTransfer) => Array.prototype.slice.call(dataTransfer.files),
      items: (dataTransfer) => dataTransfer.items,
      dataTransfer: (dataTransfer) => dataTransfer
    },
    matchesTypes: [
      "Files"
    ]
  },
  [HTML]: {
    exposeProperties: {
      html: (dataTransfer, matchesTypes) => getDataFromDataTransfer(dataTransfer, matchesTypes, ""),
      dataTransfer: (dataTransfer) => dataTransfer
    },
    matchesTypes: [
      "Html",
      "text/html"
    ]
  },
  [URL$4]: {
    exposeProperties: {
      urls: (dataTransfer, matchesTypes) => getDataFromDataTransfer(dataTransfer, matchesTypes, "").split("\n"),
      dataTransfer: (dataTransfer) => dataTransfer
    },
    matchesTypes: [
      "Url",
      "text/uri-list"
    ]
  },
  [TEXT]: {
    exposeProperties: {
      text: (dataTransfer, matchesTypes) => getDataFromDataTransfer(dataTransfer, matchesTypes, ""),
      dataTransfer: (dataTransfer) => dataTransfer
    },
    matchesTypes: [
      "Text",
      "text/plain"
    ]
  }
};
function createNativeDragSource(type, dataTransfer) {
  const config = nativeTypesConfig[type];
  if (!config) {
    throw new Error(`native type ${type} has no configuration`);
  }
  const result = new NativeDragSource(config);
  result.loadDataTransfer(dataTransfer);
  return result;
}
function matchNativeItemType(dataTransfer) {
  if (!dataTransfer) {
    return null;
  }
  const dataTransferTypes = Array.prototype.slice.call(dataTransfer.types || []);
  return Object.keys(nativeTypesConfig).filter((nativeItemType) => {
    const typeConfig = nativeTypesConfig[nativeItemType];
    if (!(typeConfig === null || typeConfig === void 0 ? void 0 : typeConfig.matchesTypes)) {
      return false;
    }
    return typeConfig.matchesTypes.some(
      (t2) => dataTransferTypes.indexOf(t2) > -1
    );
  })[0] || null;
}
const isFirefox = memoize$1(
  () => /firefox/i.test(navigator.userAgent)
);
const isSafari = memoize$1(
  () => Boolean(window.safari)
);
class MonotonicInterpolant {
  interpolate(x2) {
    const { xs, ys, c1s, c2s, c3s } = this;
    let i2 = xs.length - 1;
    if (x2 === xs[i2]) {
      return ys[i2];
    }
    let low = 0;
    let high = c3s.length - 1;
    let mid;
    while (low <= high) {
      mid = Math.floor(0.5 * (low + high));
      const xHere = xs[mid];
      if (xHere < x2) {
        low = mid + 1;
      } else if (xHere > x2) {
        high = mid - 1;
      } else {
        return ys[mid];
      }
    }
    i2 = Math.max(0, high);
    const diff = x2 - xs[i2];
    const diffSq = diff * diff;
    return ys[i2] + c1s[i2] * diff + c2s[i2] * diffSq + c3s[i2] * diff * diffSq;
  }
  constructor(xs, ys) {
    const { length: length2 } = xs;
    const indexes = [];
    for (let i2 = 0; i2 < length2; i2++) {
      indexes.push(i2);
    }
    indexes.sort(
      (a, b2) => xs[a] < xs[b2] ? -1 : 1
    );
    const dxs = [];
    const ms = [];
    let dx;
    let dy;
    for (let i1 = 0; i1 < length2 - 1; i1++) {
      dx = xs[i1 + 1] - xs[i1];
      dy = ys[i1 + 1] - ys[i1];
      dxs.push(dx);
      ms.push(dy / dx);
    }
    const c1s = [
      ms[0]
    ];
    for (let i2 = 0; i2 < dxs.length - 1; i2++) {
      const m22 = ms[i2];
      const mNext = ms[i2 + 1];
      if (m22 * mNext <= 0) {
        c1s.push(0);
      } else {
        dx = dxs[i2];
        const dxNext = dxs[i2 + 1];
        const common2 = dx + dxNext;
        c1s.push(3 * common2 / ((common2 + dxNext) / m22 + (common2 + dx) / mNext));
      }
    }
    c1s.push(ms[ms.length - 1]);
    const c2s = [];
    const c3s = [];
    let m2;
    for (let i3 = 0; i3 < c1s.length - 1; i3++) {
      m2 = ms[i3];
      const c1 = c1s[i3];
      const invDx = 1 / dxs[i3];
      const common2 = c1 + c1s[i3 + 1] - m2 - m2;
      c2s.push((m2 - c1 - common2) * invDx);
      c3s.push(common2 * invDx * invDx);
    }
    this.xs = xs;
    this.ys = ys;
    this.c1s = c1s;
    this.c2s = c2s;
    this.c3s = c3s;
  }
}
const ELEMENT_NODE = 1;
function getNodeClientOffset(node2) {
  const el2 = node2.nodeType === ELEMENT_NODE ? node2 : node2.parentElement;
  if (!el2) {
    return null;
  }
  const { top: top2, left: left2 } = el2.getBoundingClientRect();
  return {
    x: left2,
    y: top2
  };
}
function getEventClientOffset(e2) {
  return {
    x: e2.clientX,
    y: e2.clientY
  };
}
function isImageNode(node2) {
  var ref;
  return node2.nodeName === "IMG" && (isFirefox() || !((ref = document.documentElement) === null || ref === void 0 ? void 0 : ref.contains(node2)));
}
function getDragPreviewSize(isImage2, dragPreview, sourceWidth, sourceHeight) {
  let dragPreviewWidth = isImage2 ? dragPreview.width : sourceWidth;
  let dragPreviewHeight = isImage2 ? dragPreview.height : sourceHeight;
  if (isSafari() && isImage2) {
    dragPreviewHeight /= window.devicePixelRatio;
    dragPreviewWidth /= window.devicePixelRatio;
  }
  return {
    dragPreviewWidth,
    dragPreviewHeight
  };
}
function getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint) {
  const isImage2 = isImageNode(dragPreview);
  const dragPreviewNode = isImage2 ? sourceNode : dragPreview;
  const dragPreviewNodeOffsetFromClient = getNodeClientOffset(dragPreviewNode);
  const offsetFromDragPreview = {
    x: clientOffset.x - dragPreviewNodeOffsetFromClient.x,
    y: clientOffset.y - dragPreviewNodeOffsetFromClient.y
  };
  const { offsetWidth: sourceWidth, offsetHeight: sourceHeight } = sourceNode;
  const { anchorX, anchorY } = anchorPoint;
  const { dragPreviewWidth, dragPreviewHeight } = getDragPreviewSize(isImage2, dragPreview, sourceWidth, sourceHeight);
  const calculateYOffset = () => {
    const interpolantY = new MonotonicInterpolant([
      0,
      0.5,
      1
    ], [
      offsetFromDragPreview.y,
      offsetFromDragPreview.y / sourceHeight * dragPreviewHeight,
      offsetFromDragPreview.y + dragPreviewHeight - sourceHeight
    ]);
    let y2 = interpolantY.interpolate(anchorY);
    if (isSafari() && isImage2) {
      y2 += (window.devicePixelRatio - 1) * dragPreviewHeight;
    }
    return y2;
  };
  const calculateXOffset = () => {
    const interpolantX = new MonotonicInterpolant([
      0,
      0.5,
      1
    ], [
      offsetFromDragPreview.x,
      offsetFromDragPreview.x / sourceWidth * dragPreviewWidth,
      offsetFromDragPreview.x + dragPreviewWidth - sourceWidth
    ]);
    return interpolantX.interpolate(anchorX);
  };
  const { offsetX, offsetY } = offsetPoint;
  const isManualOffsetX = offsetX === 0 || offsetX;
  const isManualOffsetY = offsetY === 0 || offsetY;
  return {
    x: isManualOffsetX ? offsetX : calculateXOffset(),
    y: isManualOffsetY ? offsetY : calculateYOffset()
  };
}
class OptionsReader {
  get window() {
    if (this.globalContext) {
      return this.globalContext;
    } else if (typeof window !== "undefined") {
      return window;
    }
    return void 0;
  }
  get document() {
    var ref;
    if ((ref = this.globalContext) === null || ref === void 0 ? void 0 : ref.document) {
      return this.globalContext.document;
    } else if (this.window) {
      return this.window.document;
    } else {
      return void 0;
    }
  }
  get rootElement() {
    var ref;
    return ((ref = this.optionsArgs) === null || ref === void 0 ? void 0 : ref.rootElement) || this.window;
  }
  constructor(globalContext, options) {
    this.ownerDocument = null;
    this.globalContext = globalContext;
    this.optionsArgs = options;
  }
}
function _defineProperty(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value2;
  }
  return obj;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    var ownKeys = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys.forEach(function(key) {
      _defineProperty(target, key, source[key]);
    });
  }
  return target;
}
class HTML5BackendImpl {
  profile() {
    var ref, ref1;
    return {
      sourcePreviewNodes: this.sourcePreviewNodes.size,
      sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,
      sourceNodeOptions: this.sourceNodeOptions.size,
      sourceNodes: this.sourceNodes.size,
      dragStartSourceIds: ((ref = this.dragStartSourceIds) === null || ref === void 0 ? void 0 : ref.length) || 0,
      dropTargetIds: this.dropTargetIds.length,
      dragEnterTargetIds: this.dragEnterTargetIds.length,
      dragOverTargetIds: ((ref1 = this.dragOverTargetIds) === null || ref1 === void 0 ? void 0 : ref1.length) || 0
    };
  }
  get window() {
    return this.options.window;
  }
  get document() {
    return this.options.document;
  }
  get rootElement() {
    return this.options.rootElement;
  }
  setup() {
    const root2 = this.rootElement;
    if (root2 === void 0) {
      return;
    }
    if (root2.__isReactDndBackendSetUp) {
      throw new Error("Cannot have two HTML5 backends at the same time.");
    }
    root2.__isReactDndBackendSetUp = true;
    this.addEventListeners(root2);
  }
  teardown() {
    const root2 = this.rootElement;
    if (root2 === void 0) {
      return;
    }
    root2.__isReactDndBackendSetUp = false;
    this.removeEventListeners(this.rootElement);
    this.clearCurrentDragSourceNode();
    if (this.asyncEndDragFrameId) {
      var ref;
      (ref = this.window) === null || ref === void 0 ? void 0 : ref.cancelAnimationFrame(this.asyncEndDragFrameId);
    }
  }
  connectDragPreview(sourceId, node2, options) {
    this.sourcePreviewNodeOptions.set(sourceId, options);
    this.sourcePreviewNodes.set(sourceId, node2);
    return () => {
      this.sourcePreviewNodes.delete(sourceId);
      this.sourcePreviewNodeOptions.delete(sourceId);
    };
  }
  connectDragSource(sourceId, node2, options) {
    this.sourceNodes.set(sourceId, node2);
    this.sourceNodeOptions.set(sourceId, options);
    const handleDragStart = (e2) => this.handleDragStart(e2, sourceId);
    const handleSelectStart = (e2) => this.handleSelectStart(e2);
    node2.setAttribute("draggable", "true");
    node2.addEventListener("dragstart", handleDragStart);
    node2.addEventListener("selectstart", handleSelectStart);
    return () => {
      this.sourceNodes.delete(sourceId);
      this.sourceNodeOptions.delete(sourceId);
      node2.removeEventListener("dragstart", handleDragStart);
      node2.removeEventListener("selectstart", handleSelectStart);
      node2.setAttribute("draggable", "false");
    };
  }
  connectDropTarget(targetId, node2) {
    const handleDragEnter = (e2) => this.handleDragEnter(e2, targetId);
    const handleDragOver = (e2) => this.handleDragOver(e2, targetId);
    const handleDrop = (e2) => this.handleDrop(e2, targetId);
    node2.addEventListener("dragenter", handleDragEnter);
    node2.addEventListener("dragover", handleDragOver);
    node2.addEventListener("drop", handleDrop);
    return () => {
      node2.removeEventListener("dragenter", handleDragEnter);
      node2.removeEventListener("dragover", handleDragOver);
      node2.removeEventListener("drop", handleDrop);
    };
  }
  addEventListeners(target) {
    if (!target.addEventListener) {
      return;
    }
    target.addEventListener("dragstart", this.handleTopDragStart);
    target.addEventListener("dragstart", this.handleTopDragStartCapture, true);
    target.addEventListener("dragend", this.handleTopDragEndCapture, true);
    target.addEventListener("dragenter", this.handleTopDragEnter);
    target.addEventListener("dragenter", this.handleTopDragEnterCapture, true);
    target.addEventListener("dragleave", this.handleTopDragLeaveCapture, true);
    target.addEventListener("dragover", this.handleTopDragOver);
    target.addEventListener("dragover", this.handleTopDragOverCapture, true);
    target.addEventListener("drop", this.handleTopDrop);
    target.addEventListener("drop", this.handleTopDropCapture, true);
  }
  removeEventListeners(target) {
    if (!target.removeEventListener) {
      return;
    }
    target.removeEventListener("dragstart", this.handleTopDragStart);
    target.removeEventListener("dragstart", this.handleTopDragStartCapture, true);
    target.removeEventListener("dragend", this.handleTopDragEndCapture, true);
    target.removeEventListener("dragenter", this.handleTopDragEnter);
    target.removeEventListener("dragenter", this.handleTopDragEnterCapture, true);
    target.removeEventListener("dragleave", this.handleTopDragLeaveCapture, true);
    target.removeEventListener("dragover", this.handleTopDragOver);
    target.removeEventListener("dragover", this.handleTopDragOverCapture, true);
    target.removeEventListener("drop", this.handleTopDrop);
    target.removeEventListener("drop", this.handleTopDropCapture, true);
  }
  getCurrentSourceNodeOptions() {
    const sourceId = this.monitor.getSourceId();
    const sourceNodeOptions = this.sourceNodeOptions.get(sourceId);
    return _objectSpread({
      dropEffect: this.altKeyPressed ? "copy" : "move"
    }, sourceNodeOptions || {});
  }
  getCurrentDropEffect() {
    if (this.isDraggingNativeItem()) {
      return "copy";
    }
    return this.getCurrentSourceNodeOptions().dropEffect;
  }
  getCurrentSourcePreviewNodeOptions() {
    const sourceId = this.monitor.getSourceId();
    const sourcePreviewNodeOptions = this.sourcePreviewNodeOptions.get(sourceId);
    return _objectSpread({
      anchorX: 0.5,
      anchorY: 0.5,
      captureDraggingState: false
    }, sourcePreviewNodeOptions || {});
  }
  isDraggingNativeItem() {
    const itemType = this.monitor.getItemType();
    return Object.keys(NativeTypes).some(
      (key) => NativeTypes[key] === itemType
    );
  }
  beginDragNativeItem(type, dataTransfer) {
    this.clearCurrentDragSourceNode();
    this.currentNativeSource = createNativeDragSource(type, dataTransfer);
    this.currentNativeHandle = this.registry.addSource(type, this.currentNativeSource);
    this.actions.beginDrag([
      this.currentNativeHandle
    ]);
  }
  setCurrentDragSourceNode(node2) {
    this.clearCurrentDragSourceNode();
    this.currentDragSourceNode = node2;
    const MOUSE_MOVE_TIMEOUT = 1e3;
    this.mouseMoveTimeoutTimer = setTimeout(() => {
      var ref;
      return (ref = this.rootElement) === null || ref === void 0 ? void 0 : ref.addEventListener("mousemove", this.endDragIfSourceWasRemovedFromDOM, true);
    }, MOUSE_MOVE_TIMEOUT);
  }
  clearCurrentDragSourceNode() {
    if (this.currentDragSourceNode) {
      this.currentDragSourceNode = null;
      if (this.rootElement) {
        var ref;
        (ref = this.window) === null || ref === void 0 ? void 0 : ref.clearTimeout(this.mouseMoveTimeoutTimer || void 0);
        this.rootElement.removeEventListener("mousemove", this.endDragIfSourceWasRemovedFromDOM, true);
      }
      this.mouseMoveTimeoutTimer = null;
      return true;
    }
    return false;
  }
  handleDragStart(e2, sourceId) {
    if (e2.defaultPrevented) {
      return;
    }
    if (!this.dragStartSourceIds) {
      this.dragStartSourceIds = [];
    }
    this.dragStartSourceIds.unshift(sourceId);
  }
  handleDragEnter(_e, targetId) {
    this.dragEnterTargetIds.unshift(targetId);
  }
  handleDragOver(_e, targetId) {
    if (this.dragOverTargetIds === null) {
      this.dragOverTargetIds = [];
    }
    this.dragOverTargetIds.unshift(targetId);
  }
  handleDrop(_e, targetId) {
    this.dropTargetIds.unshift(targetId);
  }
  constructor(manager, globalContext, options) {
    this.sourcePreviewNodes = /* @__PURE__ */ new Map();
    this.sourcePreviewNodeOptions = /* @__PURE__ */ new Map();
    this.sourceNodes = /* @__PURE__ */ new Map();
    this.sourceNodeOptions = /* @__PURE__ */ new Map();
    this.dragStartSourceIds = null;
    this.dropTargetIds = [];
    this.dragEnterTargetIds = [];
    this.currentNativeSource = null;
    this.currentNativeHandle = null;
    this.currentDragSourceNode = null;
    this.altKeyPressed = false;
    this.mouseMoveTimeoutTimer = null;
    this.asyncEndDragFrameId = null;
    this.dragOverTargetIds = null;
    this.lastClientOffset = null;
    this.hoverRafId = null;
    this.getSourceClientOffset = (sourceId) => {
      const source = this.sourceNodes.get(sourceId);
      return source && getNodeClientOffset(source) || null;
    };
    this.endDragNativeItem = () => {
      if (!this.isDraggingNativeItem()) {
        return;
      }
      this.actions.endDrag();
      if (this.currentNativeHandle) {
        this.registry.removeSource(this.currentNativeHandle);
      }
      this.currentNativeHandle = null;
      this.currentNativeSource = null;
    };
    this.isNodeInDocument = (node2) => {
      return Boolean(node2 && this.document && this.document.body && this.document.body.contains(node2));
    };
    this.endDragIfSourceWasRemovedFromDOM = () => {
      const node2 = this.currentDragSourceNode;
      if (node2 == null || this.isNodeInDocument(node2)) {
        return;
      }
      if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {
        this.actions.endDrag();
      }
      this.cancelHover();
    };
    this.scheduleHover = (dragOverTargetIds) => {
      if (this.hoverRafId === null && typeof requestAnimationFrame !== "undefined") {
        this.hoverRafId = requestAnimationFrame(() => {
          if (this.monitor.isDragging()) {
            this.actions.hover(dragOverTargetIds || [], {
              clientOffset: this.lastClientOffset
            });
          }
          this.hoverRafId = null;
        });
      }
    };
    this.cancelHover = () => {
      if (this.hoverRafId !== null && typeof cancelAnimationFrame !== "undefined") {
        cancelAnimationFrame(this.hoverRafId);
        this.hoverRafId = null;
      }
    };
    this.handleTopDragStartCapture = () => {
      this.clearCurrentDragSourceNode();
      this.dragStartSourceIds = [];
    };
    this.handleTopDragStart = (e2) => {
      if (e2.defaultPrevented) {
        return;
      }
      const { dragStartSourceIds } = this;
      this.dragStartSourceIds = null;
      const clientOffset = getEventClientOffset(e2);
      if (this.monitor.isDragging()) {
        this.actions.endDrag();
        this.cancelHover();
      }
      this.actions.beginDrag(dragStartSourceIds || [], {
        publishSource: false,
        getSourceClientOffset: this.getSourceClientOffset,
        clientOffset
      });
      const { dataTransfer } = e2;
      const nativeType = matchNativeItemType(dataTransfer);
      if (this.monitor.isDragging()) {
        if (dataTransfer && typeof dataTransfer.setDragImage === "function") {
          const sourceId = this.monitor.getSourceId();
          const sourceNode = this.sourceNodes.get(sourceId);
          const dragPreview = this.sourcePreviewNodes.get(sourceId) || sourceNode;
          if (dragPreview) {
            const { anchorX, anchorY, offsetX, offsetY } = this.getCurrentSourcePreviewNodeOptions();
            const anchorPoint = {
              anchorX,
              anchorY
            };
            const offsetPoint = {
              offsetX,
              offsetY
            };
            const dragPreviewOffset = getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint);
            dataTransfer.setDragImage(dragPreview, dragPreviewOffset.x, dragPreviewOffset.y);
          }
        }
        try {
          dataTransfer === null || dataTransfer === void 0 ? void 0 : dataTransfer.setData("application/json", {});
        } catch (err) {
        }
        this.setCurrentDragSourceNode(e2.target);
        const { captureDraggingState } = this.getCurrentSourcePreviewNodeOptions();
        if (!captureDraggingState) {
          setTimeout(
            () => this.actions.publishDragSource(),
            0
          );
        } else {
          this.actions.publishDragSource();
        }
      } else if (nativeType) {
        this.beginDragNativeItem(nativeType);
      } else if (dataTransfer && !dataTransfer.types && (e2.target && !e2.target.hasAttribute || !e2.target.hasAttribute("draggable"))) {
        return;
      } else {
        e2.preventDefault();
      }
    };
    this.handleTopDragEndCapture = () => {
      if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {
        this.actions.endDrag();
      }
      this.cancelHover();
    };
    this.handleTopDragEnterCapture = (e2) => {
      this.dragEnterTargetIds = [];
      if (this.isDraggingNativeItem()) {
        var ref;
        (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e2.dataTransfer);
      }
      const isFirstEnter = this.enterLeaveCounter.enter(e2.target);
      if (!isFirstEnter || this.monitor.isDragging()) {
        return;
      }
      const { dataTransfer } = e2;
      const nativeType = matchNativeItemType(dataTransfer);
      if (nativeType) {
        this.beginDragNativeItem(nativeType, dataTransfer);
      }
    };
    this.handleTopDragEnter = (e2) => {
      const { dragEnterTargetIds } = this;
      this.dragEnterTargetIds = [];
      if (!this.monitor.isDragging()) {
        return;
      }
      this.altKeyPressed = e2.altKey;
      if (dragEnterTargetIds.length > 0) {
        this.actions.hover(dragEnterTargetIds, {
          clientOffset: getEventClientOffset(e2)
        });
      }
      const canDrop = dragEnterTargetIds.some(
        (targetId) => this.monitor.canDropOnTarget(targetId)
      );
      if (canDrop) {
        e2.preventDefault();
        if (e2.dataTransfer) {
          e2.dataTransfer.dropEffect = this.getCurrentDropEffect();
        }
      }
    };
    this.handleTopDragOverCapture = (e2) => {
      this.dragOverTargetIds = [];
      if (this.isDraggingNativeItem()) {
        var ref;
        (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e2.dataTransfer);
      }
    };
    this.handleTopDragOver = (e2) => {
      const { dragOverTargetIds } = this;
      this.dragOverTargetIds = [];
      if (!this.monitor.isDragging()) {
        e2.preventDefault();
        if (e2.dataTransfer) {
          e2.dataTransfer.dropEffect = "none";
        }
        return;
      }
      this.altKeyPressed = e2.altKey;
      this.lastClientOffset = getEventClientOffset(e2);
      this.scheduleHover(dragOverTargetIds);
      const canDrop = (dragOverTargetIds || []).some(
        (targetId) => this.monitor.canDropOnTarget(targetId)
      );
      if (canDrop) {
        e2.preventDefault();
        if (e2.dataTransfer) {
          e2.dataTransfer.dropEffect = this.getCurrentDropEffect();
        }
      } else if (this.isDraggingNativeItem()) {
        e2.preventDefault();
      } else {
        e2.preventDefault();
        if (e2.dataTransfer) {
          e2.dataTransfer.dropEffect = "none";
        }
      }
    };
    this.handleTopDragLeaveCapture = (e2) => {
      if (this.isDraggingNativeItem()) {
        e2.preventDefault();
      }
      const isLastLeave = this.enterLeaveCounter.leave(e2.target);
      if (!isLastLeave) {
        return;
      }
      if (this.isDraggingNativeItem()) {
        setTimeout(
          () => this.endDragNativeItem(),
          0
        );
      }
      this.cancelHover();
    };
    this.handleTopDropCapture = (e2) => {
      this.dropTargetIds = [];
      if (this.isDraggingNativeItem()) {
        var ref;
        e2.preventDefault();
        (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e2.dataTransfer);
      } else if (matchNativeItemType(e2.dataTransfer)) {
        e2.preventDefault();
      }
      this.enterLeaveCounter.reset();
    };
    this.handleTopDrop = (e2) => {
      const { dropTargetIds } = this;
      this.dropTargetIds = [];
      this.actions.hover(dropTargetIds, {
        clientOffset: getEventClientOffset(e2)
      });
      this.actions.drop({
        dropEffect: this.getCurrentDropEffect()
      });
      if (this.isDraggingNativeItem()) {
        this.endDragNativeItem();
      } else if (this.monitor.isDragging()) {
        this.actions.endDrag();
      }
      this.cancelHover();
    };
    this.handleSelectStart = (e2) => {
      const target = e2.target;
      if (typeof target.dragDrop !== "function") {
        return;
      }
      if (target.tagName === "INPUT" || target.tagName === "SELECT" || target.tagName === "TEXTAREA" || target.isContentEditable) {
        return;
      }
      e2.preventDefault();
      target.dragDrop();
    };
    this.options = new OptionsReader(globalContext, options);
    this.actions = manager.getActions();
    this.monitor = manager.getMonitor();
    this.registry = manager.getRegistry();
    this.enterLeaveCounter = new EnterLeaveCounter(this.isNodeInDocument);
  }
}
const HTML5Backend = function createBackend(manager, context, options) {
  return new HTML5BackendImpl(manager, context, options);
};
const alphabet$1 = "abcdefghijklmnopqrstuvwxyz234567";
const lookupTable$1 = /* @__PURE__ */ Object.create(null);
for (let i2 = 0; i2 < alphabet$1.length; i2++) {
  lookupTable$1[alphabet$1[i2]] = i2;
}
lookupTable$1["0"] = lookupTable$1.o;
lookupTable$1["1"] = lookupTable$1.i;
function encode$6(input) {
  let skip = 0;
  let bits = 0;
  let output = "";
  function encodeByte(byte) {
    if (skip < 0) {
      bits |= byte >> -skip;
    } else {
      bits = byte << skip & 248;
    }
    if (skip > 3) {
      skip -= 8;
      return 1;
    }
    if (skip < 4) {
      output += alphabet$1[bits >> 3];
      skip += 5;
    }
    return 0;
  }
  for (let i2 = 0; i2 < input.length; ) {
    i2 += encodeByte(input[i2]);
  }
  return output + (skip < 0 ? alphabet$1[bits >> 3] : "");
}
function decode$6(input) {
  let skip = 0;
  let byte = 0;
  const output = new Uint8Array(input.length * 4 / 3 | 0);
  let o = 0;
  function decodeChar(char2) {
    let val = lookupTable$1[char2.toLowerCase()];
    if (val === void 0) {
      throw new Error(`Invalid character: ${JSON.stringify(char2)}`);
    }
    val <<= 3;
    byte |= val >>> skip;
    skip += 5;
    if (skip >= 8) {
      output[o++] = byte;
      skip -= 8;
      if (skip > 0) {
        byte = val << 5 - skip & 255;
      } else {
        byte = 0;
      }
    }
  }
  for (const c2 of input) {
    decodeChar(c2);
  }
  return output.slice(0, o);
}
const lookUpTable$1 = new Uint32Array([
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918e3,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
]);
function getCrc32$1(buf) {
  const b2 = new Uint8Array(buf);
  let crc = -1;
  for (let i2 = 0; i2 < b2.length; i2++) {
    const byte = b2[i2];
    const t2 = (byte ^ crc) & 255;
    crc = lookUpTable$1[t2] ^ crc >>> 8;
  }
  return (crc ^ -1) >>> 0;
}
var sha256$1 = { exports: {} };
/**
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.9.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
(function(module) {
  (function() {
    var ERROR = "input is invalid type";
    var WINDOW = typeof window === "object";
    var root = WINDOW ? window : {};
    if (root.JS_SHA256_NO_WINDOW) {
      WINDOW = false;
    }
    var WEB_WORKER = !WINDOW && typeof self === "object";
    var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
    if (NODE_JS) {
      root = commonjsGlobal;
    } else if (WEB_WORKER) {
      root = self;
    }
    var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && true && module.exports;
    var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
    var HEX_CHARS = "0123456789abcdef".split("");
    var EXTRA = [-2147483648, 8388608, 32768, 128];
    var SHIFT = [24, 16, 8, 0];
    var K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
    var blocks = [];
    if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
      Array.isArray = function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
    }
    if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
      ArrayBuffer.isView = function(obj) {
        return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
      };
    }
    var createOutputMethod = function(outputType, is2242) {
      return function(message) {
        return new Sha256(is2242, true).update(message)[outputType]();
      };
    };
    var createMethod = function(is2242) {
      var method2 = createOutputMethod("hex", is2242);
      if (NODE_JS) {
        method2 = nodeWrap(method2, is2242);
      }
      method2.create = function() {
        return new Sha256(is2242);
      };
      method2.update = function(message) {
        return method2.create().update(message);
      };
      for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
        var type = OUTPUT_TYPES[i2];
        method2[type] = createOutputMethod(type, is2242);
      }
      return method2;
    };
    var nodeWrap = function(method, is224) {
      var crypto = eval("require('crypto')");
      var Buffer = eval("require('buffer').Buffer");
      var algorithm = is224 ? "sha224" : "sha256";
      var nodeMethod = function(message) {
        if (typeof message === "string") {
          return crypto.createHash(algorithm).update(message, "utf8").digest("hex");
        } else {
          if (message === null || message === void 0) {
            throw new Error(ERROR);
          } else if (message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          }
        }
        if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) {
          return crypto.createHash(algorithm).update(new Buffer(message)).digest("hex");
        } else {
          return method(message);
        }
      };
      return nodeMethod;
    };
    var createHmacOutputMethod = function(outputType, is2242) {
      return function(key, message) {
        return new HmacSha256(key, is2242, true).update(message)[outputType]();
      };
    };
    var createHmacMethod = function(is2242) {
      var method2 = createHmacOutputMethod("hex", is2242);
      method2.create = function(key) {
        return new HmacSha256(key, is2242);
      };
      method2.update = function(key, message) {
        return method2.create(key).update(message);
      };
      for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
        var type = OUTPUT_TYPES[i2];
        method2[type] = createHmacOutputMethod(type, is2242);
      }
      return method2;
    };
    function Sha256(is2242, sharedMemory) {
      if (sharedMemory) {
        blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
        this.blocks = blocks;
      } else {
        this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      }
      if (is2242) {
        this.h0 = 3238371032;
        this.h1 = 914150663;
        this.h2 = 812702999;
        this.h3 = 4144912697;
        this.h4 = 4290775857;
        this.h5 = 1750603025;
        this.h6 = 1694076839;
        this.h7 = 3204075428;
      } else {
        this.h0 = 1779033703;
        this.h1 = 3144134277;
        this.h2 = 1013904242;
        this.h3 = 2773480762;
        this.h4 = 1359893119;
        this.h5 = 2600822924;
        this.h6 = 528734635;
        this.h7 = 1541459225;
      }
      this.block = this.start = this.bytes = this.hBytes = 0;
      this.finalized = this.hashed = false;
      this.first = true;
      this.is224 = is2242;
    }
    Sha256.prototype.update = function(message) {
      if (this.finalized) {
        return;
      }
      var notString, type = typeof message;
      if (type !== "string") {
        if (type === "object") {
          if (message === null) {
            throw new Error(ERROR);
          } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (!Array.isArray(message)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
              throw new Error(ERROR);
            }
          }
        } else {
          throw new Error(ERROR);
        }
        notString = true;
      }
      var code2, index2 = 0, i2, length2 = message.length, blocks2 = this.blocks;
      while (index2 < length2) {
        if (this.hashed) {
          this.hashed = false;
          blocks2[0] = this.block;
          blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
        }
        if (notString) {
          for (i2 = this.start; index2 < length2 && i2 < 64; ++index2) {
            blocks2[i2 >> 2] |= message[index2] << SHIFT[i2++ & 3];
          }
        } else {
          for (i2 = this.start; index2 < length2 && i2 < 64; ++index2) {
            code2 = message.charCodeAt(index2);
            if (code2 < 128) {
              blocks2[i2 >> 2] |= code2 << SHIFT[i2++ & 3];
            } else if (code2 < 2048) {
              blocks2[i2 >> 2] |= (192 | code2 >> 6) << SHIFT[i2++ & 3];
              blocks2[i2 >> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
            } else if (code2 < 55296 || code2 >= 57344) {
              blocks2[i2 >> 2] |= (224 | code2 >> 12) << SHIFT[i2++ & 3];
              blocks2[i2 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i2++ & 3];
              blocks2[i2 >> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
            } else {
              code2 = 65536 + ((code2 & 1023) << 10 | message.charCodeAt(++index2) & 1023);
              blocks2[i2 >> 2] |= (240 | code2 >> 18) << SHIFT[i2++ & 3];
              blocks2[i2 >> 2] |= (128 | code2 >> 12 & 63) << SHIFT[i2++ & 3];
              blocks2[i2 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i2++ & 3];
              blocks2[i2 >> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
            }
          }
        }
        this.lastByteIndex = i2;
        this.bytes += i2 - this.start;
        if (i2 >= 64) {
          this.block = blocks2[16];
          this.start = i2 - 64;
          this.hash();
          this.hashed = true;
        } else {
          this.start = i2;
        }
      }
      if (this.bytes > 4294967295) {
        this.hBytes += this.bytes / 4294967296 << 0;
        this.bytes = this.bytes % 4294967296;
      }
      return this;
    };
    Sha256.prototype.finalize = function() {
      if (this.finalized) {
        return;
      }
      this.finalized = true;
      var blocks2 = this.blocks, i2 = this.lastByteIndex;
      blocks2[16] = this.block;
      blocks2[i2 >> 2] |= EXTRA[i2 & 3];
      this.block = blocks2[16];
      if (i2 >= 56) {
        if (!this.hashed) {
          this.hash();
        }
        blocks2[0] = this.block;
        blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
      }
      blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
      blocks2[15] = this.bytes << 3;
      this.hash();
    };
    Sha256.prototype.hash = function() {
      var a = this.h0, b2 = this.h1, c2 = this.h2, d2 = this.h3, e2 = this.h4, f2 = this.h5, g2 = this.h6, h2 = this.h7, blocks2 = this.blocks, j, s0, s1, maj, t1, t2, ch2, ab2, da2, cd2, bc2;
      for (j = 16; j < 64; ++j) {
        t1 = blocks2[j - 15];
        s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
        t1 = blocks2[j - 2];
        s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
        blocks2[j] = blocks2[j - 16] + s0 + blocks2[j - 7] + s1 << 0;
      }
      bc2 = b2 & c2;
      for (j = 0; j < 64; j += 4) {
        if (this.first) {
          if (this.is224) {
            ab2 = 300032;
            t1 = blocks2[0] - 1413257819;
            h2 = t1 - 150054599 << 0;
            d2 = t1 + 24177077 << 0;
          } else {
            ab2 = 704751109;
            t1 = blocks2[0] - 210244248;
            h2 = t1 - 1521486534 << 0;
            d2 = t1 + 143694565 << 0;
          }
          this.first = false;
        } else {
          s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
          s1 = (e2 >>> 6 | e2 << 26) ^ (e2 >>> 11 | e2 << 21) ^ (e2 >>> 25 | e2 << 7);
          ab2 = a & b2;
          maj = ab2 ^ a & c2 ^ bc2;
          ch2 = e2 & f2 ^ ~e2 & g2;
          t1 = h2 + s1 + ch2 + K[j] + blocks2[j];
          t2 = s0 + maj;
          h2 = d2 + t1 << 0;
          d2 = t1 + t2 << 0;
        }
        s0 = (d2 >>> 2 | d2 << 30) ^ (d2 >>> 13 | d2 << 19) ^ (d2 >>> 22 | d2 << 10);
        s1 = (h2 >>> 6 | h2 << 26) ^ (h2 >>> 11 | h2 << 21) ^ (h2 >>> 25 | h2 << 7);
        da2 = d2 & a;
        maj = da2 ^ d2 & b2 ^ ab2;
        ch2 = h2 & e2 ^ ~h2 & f2;
        t1 = g2 + s1 + ch2 + K[j + 1] + blocks2[j + 1];
        t2 = s0 + maj;
        g2 = c2 + t1 << 0;
        c2 = t1 + t2 << 0;
        s0 = (c2 >>> 2 | c2 << 30) ^ (c2 >>> 13 | c2 << 19) ^ (c2 >>> 22 | c2 << 10);
        s1 = (g2 >>> 6 | g2 << 26) ^ (g2 >>> 11 | g2 << 21) ^ (g2 >>> 25 | g2 << 7);
        cd2 = c2 & d2;
        maj = cd2 ^ c2 & a ^ da2;
        ch2 = g2 & h2 ^ ~g2 & e2;
        t1 = f2 + s1 + ch2 + K[j + 2] + blocks2[j + 2];
        t2 = s0 + maj;
        f2 = b2 + t1 << 0;
        b2 = t1 + t2 << 0;
        s0 = (b2 >>> 2 | b2 << 30) ^ (b2 >>> 13 | b2 << 19) ^ (b2 >>> 22 | b2 << 10);
        s1 = (f2 >>> 6 | f2 << 26) ^ (f2 >>> 11 | f2 << 21) ^ (f2 >>> 25 | f2 << 7);
        bc2 = b2 & c2;
        maj = bc2 ^ b2 & d2 ^ cd2;
        ch2 = f2 & g2 ^ ~f2 & h2;
        t1 = e2 + s1 + ch2 + K[j + 3] + blocks2[j + 3];
        t2 = s0 + maj;
        e2 = a + t1 << 0;
        a = t1 + t2 << 0;
      }
      this.h0 = this.h0 + a << 0;
      this.h1 = this.h1 + b2 << 0;
      this.h2 = this.h2 + c2 << 0;
      this.h3 = this.h3 + d2 << 0;
      this.h4 = this.h4 + e2 << 0;
      this.h5 = this.h5 + f2 << 0;
      this.h6 = this.h6 + g2 << 0;
      this.h7 = this.h7 + h2 << 0;
    };
    Sha256.prototype.hex = function() {
      this.finalize();
      var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
      var hex = HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >> 28 & 15] + HEX_CHARS[h5 >> 24 & 15] + HEX_CHARS[h5 >> 20 & 15] + HEX_CHARS[h5 >> 16 & 15] + HEX_CHARS[h5 >> 12 & 15] + HEX_CHARS[h5 >> 8 & 15] + HEX_CHARS[h5 >> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >> 28 & 15] + HEX_CHARS[h6 >> 24 & 15] + HEX_CHARS[h6 >> 20 & 15] + HEX_CHARS[h6 >> 16 & 15] + HEX_CHARS[h6 >> 12 & 15] + HEX_CHARS[h6 >> 8 & 15] + HEX_CHARS[h6 >> 4 & 15] + HEX_CHARS[h6 & 15];
      if (!this.is224) {
        hex += HEX_CHARS[h7 >> 28 & 15] + HEX_CHARS[h7 >> 24 & 15] + HEX_CHARS[h7 >> 20 & 15] + HEX_CHARS[h7 >> 16 & 15] + HEX_CHARS[h7 >> 12 & 15] + HEX_CHARS[h7 >> 8 & 15] + HEX_CHARS[h7 >> 4 & 15] + HEX_CHARS[h7 & 15];
      }
      return hex;
    };
    Sha256.prototype.toString = Sha256.prototype.hex;
    Sha256.prototype.digest = function() {
      this.finalize();
      var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
      var arr = [
        h0 >> 24 & 255,
        h0 >> 16 & 255,
        h0 >> 8 & 255,
        h0 & 255,
        h1 >> 24 & 255,
        h1 >> 16 & 255,
        h1 >> 8 & 255,
        h1 & 255,
        h2 >> 24 & 255,
        h2 >> 16 & 255,
        h2 >> 8 & 255,
        h2 & 255,
        h3 >> 24 & 255,
        h3 >> 16 & 255,
        h3 >> 8 & 255,
        h3 & 255,
        h4 >> 24 & 255,
        h4 >> 16 & 255,
        h4 >> 8 & 255,
        h4 & 255,
        h5 >> 24 & 255,
        h5 >> 16 & 255,
        h5 >> 8 & 255,
        h5 & 255,
        h6 >> 24 & 255,
        h6 >> 16 & 255,
        h6 >> 8 & 255,
        h6 & 255
      ];
      if (!this.is224) {
        arr.push(h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255);
      }
      return arr;
    };
    Sha256.prototype.array = Sha256.prototype.digest;
    Sha256.prototype.arrayBuffer = function() {
      this.finalize();
      var buffer2 = new ArrayBuffer(this.is224 ? 28 : 32);
      var dataView = new DataView(buffer2);
      dataView.setUint32(0, this.h0);
      dataView.setUint32(4, this.h1);
      dataView.setUint32(8, this.h2);
      dataView.setUint32(12, this.h3);
      dataView.setUint32(16, this.h4);
      dataView.setUint32(20, this.h5);
      dataView.setUint32(24, this.h6);
      if (!this.is224) {
        dataView.setUint32(28, this.h7);
      }
      return buffer2;
    };
    function HmacSha256(key, is2242, sharedMemory) {
      var i2, type = typeof key;
      if (type === "string") {
        var bytes2 = [], length2 = key.length, index2 = 0, code2;
        for (i2 = 0; i2 < length2; ++i2) {
          code2 = key.charCodeAt(i2);
          if (code2 < 128) {
            bytes2[index2++] = code2;
          } else if (code2 < 2048) {
            bytes2[index2++] = 192 | code2 >> 6;
            bytes2[index2++] = 128 | code2 & 63;
          } else if (code2 < 55296 || code2 >= 57344) {
            bytes2[index2++] = 224 | code2 >> 12;
            bytes2[index2++] = 128 | code2 >> 6 & 63;
            bytes2[index2++] = 128 | code2 & 63;
          } else {
            code2 = 65536 + ((code2 & 1023) << 10 | key.charCodeAt(++i2) & 1023);
            bytes2[index2++] = 240 | code2 >> 18;
            bytes2[index2++] = 128 | code2 >> 12 & 63;
            bytes2[index2++] = 128 | code2 >> 6 & 63;
            bytes2[index2++] = 128 | code2 & 63;
          }
        }
        key = bytes2;
      } else {
        if (type === "object") {
          if (key === null) {
            throw new Error(ERROR);
          } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
            key = new Uint8Array(key);
          } else if (!Array.isArray(key)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
              throw new Error(ERROR);
            }
          }
        } else {
          throw new Error(ERROR);
        }
      }
      if (key.length > 64) {
        key = new Sha256(is2242, true).update(key).array();
      }
      var oKeyPad = [], iKeyPad = [];
      for (i2 = 0; i2 < 64; ++i2) {
        var b2 = key[i2] || 0;
        oKeyPad[i2] = 92 ^ b2;
        iKeyPad[i2] = 54 ^ b2;
      }
      Sha256.call(this, is2242, sharedMemory);
      this.update(iKeyPad);
      this.oKeyPad = oKeyPad;
      this.inner = true;
      this.sharedMemory = sharedMemory;
    }
    HmacSha256.prototype = new Sha256();
    HmacSha256.prototype.finalize = function() {
      Sha256.prototype.finalize.call(this);
      if (this.inner) {
        this.inner = false;
        var innerHash = this.array();
        Sha256.call(this, this.is224, this.sharedMemory);
        this.update(this.oKeyPad);
        this.update(innerHash);
        Sha256.prototype.finalize.call(this);
      }
    };
    var exports = createMethod();
    exports.sha256 = exports;
    exports.sha224 = createMethod(true);
    exports.sha256.hmac = createHmacMethod();
    exports.sha224.hmac = createHmacMethod(true);
    if (COMMON_JS) {
      module.exports = exports;
    } else {
      root.sha256 = exports.sha256;
      root.sha224 = exports.sha224;
    }
  })();
})(sha256$1);
function sha224$2(data2) {
  const shaObj = sha256$1.exports.sha224.create();
  shaObj.update(data2);
  return new Uint8Array(shaObj.array());
}
const SELF_AUTHENTICATING_SUFFIX$1 = 2;
const ANONYMOUS_SUFFIX$1 = 4;
const MANAGEMENT_CANISTER_PRINCIPAL_HEX_STR = "aaaaa-aa";
const fromHexString$1 = (hexString) => {
  var _a;
  return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== void 0 ? _a : []).map((byte) => parseInt(byte, 16)));
};
const toHexString$1 = (bytes2) => bytes2.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
class Principal$3 {
  constructor(_arr) {
    this._arr = _arr;
    this._isPrincipal = true;
  }
  static anonymous() {
    return new this(new Uint8Array([ANONYMOUS_SUFFIX$1]));
  }
  static managementCanister() {
    return this.fromHex(MANAGEMENT_CANISTER_PRINCIPAL_HEX_STR);
  }
  static selfAuthenticating(publicKey) {
    const sha = sha224$2(publicKey);
    return new this(new Uint8Array([...sha, SELF_AUTHENTICATING_SUFFIX$1]));
  }
  static from(other) {
    if (typeof other === "string") {
      return Principal$3.fromText(other);
    } else if (typeof other === "object" && other !== null && other._isPrincipal === true) {
      return new Principal$3(other._arr);
    }
    throw new Error(`Impossible to convert ${JSON.stringify(other)} to Principal.`);
  }
  static fromHex(hex) {
    return new this(fromHexString$1(hex));
  }
  static fromText(text) {
    const canisterIdNoDash = text.toLowerCase().replace(/-/g, "");
    let arr = decode$6(canisterIdNoDash);
    arr = arr.slice(4, arr.length);
    const principal = new this(arr);
    if (principal.toText() !== text) {
      throw new Error(`Principal "${principal.toText()}" does not have a valid checksum (original value "${text}" may not be a valid Principal ID).`);
    }
    return principal;
  }
  static fromUint8Array(arr) {
    return new this(arr);
  }
  isAnonymous() {
    return this._arr.byteLength === 1 && this._arr[0] === ANONYMOUS_SUFFIX$1;
  }
  toUint8Array() {
    return this._arr;
  }
  toHex() {
    return toHexString$1(this._arr).toUpperCase();
  }
  toText() {
    const checksumArrayBuf = new ArrayBuffer(4);
    const view = new DataView(checksumArrayBuf);
    view.setUint32(0, getCrc32$1(this._arr));
    const checksum = new Uint8Array(checksumArrayBuf);
    const bytes2 = Uint8Array.from(this._arr);
    const array2 = new Uint8Array([...checksum, ...bytes2]);
    const result = encode$6(array2);
    const matches = result.match(/.{1,5}/g);
    if (!matches) {
      throw new Error();
    }
    return matches.join("-");
  }
  toString() {
    return this.toText();
  }
  compareTo(other) {
    for (let i2 = 0; i2 < Math.min(this._arr.length, other._arr.length); i2++) {
      if (this._arr[i2] < other._arr[i2])
        return "lt";
      else if (this._arr[i2] > other._arr[i2])
        return "gt";
    }
    if (this._arr.length < other._arr.length)
      return "lt";
    if (this._arr.length > other._arr.length)
      return "gt";
    return "eq";
  }
  ltEq(other) {
    const cmp = this.compareTo(other);
    return cmp == "lt" || cmp == "eq";
  }
  gtEq(other) {
    const cmp = this.compareTo(other);
    return cmp == "gt" || cmp == "eq";
  }
}
const tradeBoxNum = 6;
const inventoryBoxNum = 45;
const pageBoxNum = 18;
const itemTypes = {
  LAYER1: "layer1"
};
const nullPrincipalId = Principal$3.fromText("rrkah-fqaaa-aaaaa-aaaaq-cai");
var dist = {};
var registries = {};
var nfts_registry = {};
var axios$2 = { exports: {} };
var axios$1 = { exports: {} };
var bind$2 = function bind2(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i2 = 0; i2 < args.length; i2++) {
      args[i2] = arguments[i2];
    }
    return fn.apply(thisArg, args);
  };
};
var bind$1 = bind$2;
var toString = Object.prototype.toString;
function isArray$1(val) {
  return toString.call(val) === "[object Array]";
}
function isUndefined(val) {
  return typeof val === "undefined";
}
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
}
function isArrayBuffer(val) {
  return toString.call(val) === "[object ArrayBuffer]";
}
function isFormData(val) {
  return typeof FormData !== "undefined" && val instanceof FormData;
}
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }
  return result;
}
function isString(val) {
  return typeof val === "string";
}
function isNumber(val) {
  return typeof val === "number";
}
function isObject(val) {
  return val !== null && typeof val === "object";
}
function isPlainObject$2(val) {
  if (toString.call(val) !== "[object Object]") {
    return false;
  }
  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}
function isDate(val) {
  return toString.call(val) === "[object Date]";
}
function isFile(val) {
  return toString.call(val) === "[object File]";
}
function isBlob(val) {
  return toString.call(val) === "[object Blob]";
}
function isFunction$1(val) {
  return toString.call(val) === "[object Function]";
}
function isStream(val) {
  return isObject(val) && isFunction$1(val.pipe);
}
function isURLSearchParams(val) {
  return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
}
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv() {
  if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function forEach(obj, fn) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$1(obj)) {
    for (var i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      fn.call(null, obj[i2], i2, obj);
    }
  } else {
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}
function merge$1() {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject$2(result[key]) && isPlainObject$2(val)) {
      result[key] = merge$1(result[key], val);
    } else if (isPlainObject$2(val)) {
      result[key] = merge$1({}, val);
    } else if (isArray$1(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }
  for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
    forEach(arguments[i2], assignValue);
  }
  return result;
}
function extend(a, b2, thisArg) {
  forEach(b2, function assignValue(val, key) {
    if (thisArg && typeof val === "function") {
      a[key] = bind$1(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}
function stripBOM(content) {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
}
var utils$c = {
  isArray: isArray$1,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isObject,
  isPlainObject: isPlainObject$2,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isFunction: isFunction$1,
  isStream,
  isURLSearchParams,
  isStandardBrowserEnv,
  forEach,
  merge: merge$1,
  extend,
  trim,
  stripBOM
};
var utils$b = utils$c;
function encode$5(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$1 = function buildURL2(url2, params, paramsSerializer) {
  if (!params) {
    return url2;
  }
  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils$b.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils$b.forEach(params, function serialize2(val, key) {
      if (val === null || typeof val === "undefined") {
        return;
      }
      if (utils$b.isArray(val)) {
        key = key + "[]";
      } else {
        val = [val];
      }
      utils$b.forEach(val, function parseValue(v2) {
        if (utils$b.isDate(v2)) {
          v2 = v2.toISOString();
        } else if (utils$b.isObject(v2)) {
          v2 = JSON.stringify(v2);
        }
        parts.push(encode$5(key) + "=" + encode$5(v2));
      });
    });
    serializedParams = parts.join("&");
  }
  if (serializedParams) {
    var hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
};
var utils$a = utils$c;
function InterceptorManager$1() {
  this.handlers = [];
}
InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled,
    rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};
InterceptorManager$1.prototype.eject = function eject(id2) {
  if (this.handlers[id2]) {
    this.handlers[id2] = null;
  }
};
InterceptorManager$1.prototype.forEach = function forEach2(fn) {
  utils$a.forEach(this.handlers, function forEachHandler(h2) {
    if (h2 !== null) {
      fn(h2);
    }
  });
};
var InterceptorManager_1 = InterceptorManager$1;
var utils$9 = utils$c;
var normalizeHeaderName = function normalizeHeaderName2(headers, normalizedName) {
  utils$9.forEach(headers, function processHeader(value2, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value2;
      delete headers[name];
    }
  });
};
var enhanceError = function enhanceError2(error, config, code2, request2, response) {
  error.config = config;
  if (code2) {
    error.code = code2;
  }
  error.request = request2;
  error.response = response;
  error.isAxiosError = true;
  error.toJSON = function toJSON() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  };
  return error;
};
var createError;
var hasRequiredCreateError;
function requireCreateError() {
  if (hasRequiredCreateError)
    return createError;
  hasRequiredCreateError = 1;
  var enhanceError$1 = enhanceError;
  createError = function createError2(message, config, code2, request2, response) {
    var error = new Error(message);
    return enhanceError$1(error, config, code2, request2, response);
  };
  return createError;
}
var settle;
var hasRequiredSettle;
function requireSettle() {
  if (hasRequiredSettle)
    return settle;
  hasRequiredSettle = 1;
  var createError2 = requireCreateError();
  settle = function settle2(resolve, reject, response) {
    var validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(createError2(
        "Request failed with status code " + response.status,
        response.config,
        null,
        response.request,
        response
      ));
    }
  };
  return settle;
}
var cookies;
var hasRequiredCookies;
function requireCookies() {
  if (hasRequiredCookies)
    return cookies;
  hasRequiredCookies = 1;
  var utils2 = utils$c;
  cookies = utils2.isStandardBrowserEnv() ? function standardBrowserEnv() {
    return {
      write: function write(name, value2, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name + "=" + encodeURIComponent(value2));
        if (utils2.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils2.isString(path)) {
          cookie.push("path=" + path);
        }
        if (utils2.isString(domain)) {
          cookie.push("domain=" + domain);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read(name) {
        var match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match2 ? decodeURIComponent(match2[3]) : null;
      },
      remove: function remove(name) {
        this.write(name, "", Date.now() - 864e5);
      }
    };
  }() : function nonStandardBrowserEnv() {
    return {
      write: function write() {
      },
      read: function read() {
        return null;
      },
      remove: function remove() {
      }
    };
  }();
  return cookies;
}
var isAbsoluteURL;
var hasRequiredIsAbsoluteURL;
function requireIsAbsoluteURL() {
  if (hasRequiredIsAbsoluteURL)
    return isAbsoluteURL;
  hasRequiredIsAbsoluteURL = 1;
  isAbsoluteURL = function isAbsoluteURL2(url2) {
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url2);
  };
  return isAbsoluteURL;
}
var combineURLs;
var hasRequiredCombineURLs;
function requireCombineURLs() {
  if (hasRequiredCombineURLs)
    return combineURLs;
  hasRequiredCombineURLs = 1;
  combineURLs = function combineURLs2(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  };
  return combineURLs;
}
var buildFullPath;
var hasRequiredBuildFullPath;
function requireBuildFullPath() {
  if (hasRequiredBuildFullPath)
    return buildFullPath;
  hasRequiredBuildFullPath = 1;
  var isAbsoluteURL2 = requireIsAbsoluteURL();
  var combineURLs2 = requireCombineURLs();
  buildFullPath = function buildFullPath2(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL2(requestedURL)) {
      return combineURLs2(baseURL, requestedURL);
    }
    return requestedURL;
  };
  return buildFullPath;
}
var parseHeaders;
var hasRequiredParseHeaders;
function requireParseHeaders() {
  if (hasRequiredParseHeaders)
    return parseHeaders;
  hasRequiredParseHeaders = 1;
  var utils2 = utils$c;
  var ignoreDuplicateOf = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  parseHeaders = function parseHeaders2(headers) {
    var parsed = {};
    var key;
    var val;
    var i2;
    if (!headers) {
      return parsed;
    }
    utils2.forEach(headers.split("\n"), function parser2(line2) {
      i2 = line2.indexOf(":");
      key = utils2.trim(line2.substr(0, i2)).toLowerCase();
      val = utils2.trim(line2.substr(i2 + 1));
      if (key) {
        if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
          return;
        }
        if (key === "set-cookie") {
          parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      }
    });
    return parsed;
  };
  return parseHeaders;
}
var isURLSameOrigin;
var hasRequiredIsURLSameOrigin;
function requireIsURLSameOrigin() {
  if (hasRequiredIsURLSameOrigin)
    return isURLSameOrigin;
  hasRequiredIsURLSameOrigin = 1;
  var utils2 = utils$c;
  isURLSameOrigin = utils2.isStandardBrowserEnv() ? function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement("a");
    var originURL;
    function resolveURL(url2) {
      var href = url2;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      var parsed = utils2.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }() : function nonStandardBrowserEnv() {
    return function isURLSameOrigin2() {
      return true;
    };
  }();
  return isURLSameOrigin;
}
var Cancel_1;
var hasRequiredCancel;
function requireCancel() {
  if (hasRequiredCancel)
    return Cancel_1;
  hasRequiredCancel = 1;
  function Cancel2(message) {
    this.message = message;
  }
  Cancel2.prototype.toString = function toString2() {
    return "Cancel" + (this.message ? ": " + this.message : "");
  };
  Cancel2.prototype.__CANCEL__ = true;
  Cancel_1 = Cancel2;
  return Cancel_1;
}
var xhr;
var hasRequiredXhr;
function requireXhr() {
  if (hasRequiredXhr)
    return xhr;
  hasRequiredXhr = 1;
  var utils2 = utils$c;
  var settle2 = requireSettle();
  var cookies2 = requireCookies();
  var buildURL3 = buildURL$1;
  var buildFullPath2 = requireBuildFullPath();
  var parseHeaders2 = requireParseHeaders();
  var isURLSameOrigin2 = requireIsURLSameOrigin();
  var createError2 = requireCreateError();
  var defaults2 = requireDefaults();
  var Cancel2 = requireCancel();
  xhr = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      var requestData = config.data;
      var requestHeaders = config.headers;
      var responseType = config.responseType;
      var onCanceled;
      function done() {
        if (config.cancelToken) {
          config.cancelToken.unsubscribe(onCanceled);
        }
        if (config.signal) {
          config.signal.removeEventListener("abort", onCanceled);
        }
      }
      if (utils2.isFormData(requestData)) {
        delete requestHeaders["Content-Type"];
      }
      var request2 = new XMLHttpRequest();
      if (config.auth) {
        var username = config.auth.username || "";
        var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
        requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
      }
      var fullPath = buildFullPath2(config.baseURL, config.url);
      request2.open(config.method.toUpperCase(), buildURL3(fullPath, config.params, config.paramsSerializer), true);
      request2.timeout = config.timeout;
      function onloadend() {
        if (!request2) {
          return;
        }
        var responseHeaders = "getAllResponseHeaders" in request2 ? parseHeaders2(request2.getAllResponseHeaders()) : null;
        var responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
        var response = {
          data: responseData,
          status: request2.status,
          statusText: request2.statusText,
          headers: responseHeaders,
          config,
          request: request2
        };
        settle2(function _resolve(value2) {
          resolve(value2);
          done();
        }, function _reject(err) {
          reject(err);
          done();
        }, response);
        request2 = null;
      }
      if ("onloadend" in request2) {
        request2.onloadend = onloadend;
      } else {
        request2.onreadystatechange = function handleLoad() {
          if (!request2 || request2.readyState !== 4) {
            return;
          }
          if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request2.onabort = function handleAbort() {
        if (!request2) {
          return;
        }
        reject(createError2("Request aborted", config, "ECONNABORTED", request2));
        request2 = null;
      };
      request2.onerror = function handleError() {
        reject(createError2("Network Error", config, null, request2));
        request2 = null;
      };
      request2.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
        var transitional2 = config.transitional || defaults2.transitional;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(createError2(
          timeoutErrorMessage,
          config,
          transitional2.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
          request2
        ));
        request2 = null;
      };
      if (utils2.isStandardBrowserEnv()) {
        var xsrfValue = (config.withCredentials || isURLSameOrigin2(fullPath)) && config.xsrfCookieName ? cookies2.read(config.xsrfCookieName) : void 0;
        if (xsrfValue) {
          requestHeaders[config.xsrfHeaderName] = xsrfValue;
        }
      }
      if ("setRequestHeader" in request2) {
        utils2.forEach(requestHeaders, function setRequestHeader(val, key) {
          if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
            delete requestHeaders[key];
          } else {
            request2.setRequestHeader(key, val);
          }
        });
      }
      if (!utils2.isUndefined(config.withCredentials)) {
        request2.withCredentials = !!config.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request2.responseType = config.responseType;
      }
      if (typeof config.onDownloadProgress === "function") {
        request2.addEventListener("progress", config.onDownloadProgress);
      }
      if (typeof config.onUploadProgress === "function" && request2.upload) {
        request2.upload.addEventListener("progress", config.onUploadProgress);
      }
      if (config.cancelToken || config.signal) {
        onCanceled = function(cancel) {
          if (!request2) {
            return;
          }
          reject(!cancel || cancel && cancel.type ? new Cancel2("canceled") : cancel);
          request2.abort();
          request2 = null;
        };
        config.cancelToken && config.cancelToken.subscribe(onCanceled);
        if (config.signal) {
          config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
        }
      }
      if (!requestData) {
        requestData = null;
      }
      request2.send(requestData);
    });
  };
  return xhr;
}
var defaults_1;
var hasRequiredDefaults;
function requireDefaults() {
  if (hasRequiredDefaults)
    return defaults_1;
  hasRequiredDefaults = 1;
  var utils2 = utils$c;
  var normalizeHeaderName$1 = normalizeHeaderName;
  var enhanceError$1 = enhanceError;
  var DEFAULT_CONTENT_TYPE = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  function setContentTypeIfUnset(headers, value2) {
    if (!utils2.isUndefined(headers) && utils2.isUndefined(headers["Content-Type"])) {
      headers["Content-Type"] = value2;
    }
  }
  function getDefaultAdapter() {
    var adapter;
    if (typeof XMLHttpRequest !== "undefined") {
      adapter = requireXhr();
    } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
      adapter = requireXhr();
    }
    return adapter;
  }
  function stringifySafely(rawValue, parser2, encoder2) {
    if (utils2.isString(rawValue)) {
      try {
        (parser2 || JSON.parse)(rawValue);
        return utils2.trim(rawValue);
      } catch (e2) {
        if (e2.name !== "SyntaxError") {
          throw e2;
        }
      }
    }
    return (encoder2 || JSON.stringify)(rawValue);
  }
  var defaults2 = {
    transitional: {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    },
    adapter: getDefaultAdapter(),
    transformRequest: [function transformRequest(data2, headers) {
      normalizeHeaderName$1(headers, "Accept");
      normalizeHeaderName$1(headers, "Content-Type");
      if (utils2.isFormData(data2) || utils2.isArrayBuffer(data2) || utils2.isBuffer(data2) || utils2.isStream(data2) || utils2.isFile(data2) || utils2.isBlob(data2)) {
        return data2;
      }
      if (utils2.isArrayBufferView(data2)) {
        return data2.buffer;
      }
      if (utils2.isURLSearchParams(data2)) {
        setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
        return data2.toString();
      }
      if (utils2.isObject(data2) || headers && headers["Content-Type"] === "application/json") {
        setContentTypeIfUnset(headers, "application/json");
        return stringifySafely(data2);
      }
      return data2;
    }],
    transformResponse: [function transformResponse(data2) {
      var transitional2 = this.transitional || defaults2.transitional;
      var silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      var forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
      var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
      if (strictJSONParsing || forcedJSONParsing && utils2.isString(data2) && data2.length) {
        try {
          return JSON.parse(data2);
        } catch (e2) {
          if (strictJSONParsing) {
            if (e2.name === "SyntaxError") {
              throw enhanceError$1(e2, this, "E_JSON_PARSE");
            }
            throw e2;
          }
        }
      }
      return data2;
    }],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      common: {
        "Accept": "application/json, text/plain, */*"
      }
    }
  };
  utils2.forEach(["delete", "get", "head"], function forEachMethodNoData2(method2) {
    defaults2.headers[method2] = {};
  });
  utils2.forEach(["post", "put", "patch"], function forEachMethodWithData2(method2) {
    defaults2.headers[method2] = utils2.merge(DEFAULT_CONTENT_TYPE);
  });
  defaults_1 = defaults2;
  return defaults_1;
}
var utils$8 = utils$c;
var defaults$2 = requireDefaults();
var transformData$1 = function transformData2(data2, headers, fns) {
  var context = this || defaults$2;
  utils$8.forEach(fns, function transform2(fn) {
    data2 = fn.call(context, data2, headers);
  });
  return data2;
};
var isCancel$1;
var hasRequiredIsCancel;
function requireIsCancel() {
  if (hasRequiredIsCancel)
    return isCancel$1;
  hasRequiredIsCancel = 1;
  isCancel$1 = function isCancel2(value2) {
    return !!(value2 && value2.__CANCEL__);
  };
  return isCancel$1;
}
var utils$7 = utils$c;
var transformData = transformData$1;
var isCancel = requireIsCancel();
var defaults$1 = requireDefaults();
var Cancel = requireCancel();
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new Cancel("canceled");
  }
}
var dispatchRequest$1 = function dispatchRequest2(config) {
  throwIfCancellationRequested(config);
  config.headers = config.headers || {};
  config.data = transformData.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );
  config.headers = utils$7.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );
  utils$7.forEach(
    ["delete", "get", "head", "post", "put", "patch", "common"],
    function cleanHeaderConfig(method2) {
      delete config.headers[method2];
    }
  );
  var adapter = config.adapter || defaults$1.adapter;
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }
    return Promise.reject(reason);
  });
};
var utils$6 = utils$c;
var mergeConfig$2 = function mergeConfig2(config1, config2) {
  config2 = config2 || {};
  var config = {};
  function getMergedValue(target, source) {
    if (utils$6.isPlainObject(target) && utils$6.isPlainObject(source)) {
      return utils$6.merge(target, source);
    } else if (utils$6.isPlainObject(source)) {
      return utils$6.merge({}, source);
    } else if (utils$6.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(prop) {
    if (!utils$6.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils$6.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function valueFromConfig2(prop) {
    if (!utils$6.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    }
  }
  function defaultToConfig2(prop) {
    if (!utils$6.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    } else if (!utils$6.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  var mergeMap = {
    "url": valueFromConfig2,
    "method": valueFromConfig2,
    "data": valueFromConfig2,
    "baseURL": defaultToConfig2,
    "transformRequest": defaultToConfig2,
    "transformResponse": defaultToConfig2,
    "paramsSerializer": defaultToConfig2,
    "timeout": defaultToConfig2,
    "timeoutMessage": defaultToConfig2,
    "withCredentials": defaultToConfig2,
    "adapter": defaultToConfig2,
    "responseType": defaultToConfig2,
    "xsrfCookieName": defaultToConfig2,
    "xsrfHeaderName": defaultToConfig2,
    "onUploadProgress": defaultToConfig2,
    "onDownloadProgress": defaultToConfig2,
    "decompress": defaultToConfig2,
    "maxContentLength": defaultToConfig2,
    "maxBodyLength": defaultToConfig2,
    "transport": defaultToConfig2,
    "httpAgent": defaultToConfig2,
    "httpsAgent": defaultToConfig2,
    "cancelToken": defaultToConfig2,
    "socketPath": defaultToConfig2,
    "responseEncoding": defaultToConfig2,
    "validateStatus": mergeDirectKeys
  };
  utils$6.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge2 = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge2(prop);
    utils$6.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
};
var data;
var hasRequiredData;
function requireData() {
  if (hasRequiredData)
    return data;
  hasRequiredData = 1;
  data = {
    "version": "0.24.0"
  };
  return data;
}
var VERSION = requireData().version;
var validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i2) {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return function(value2, opt, opts) {
    if (validator2 === false) {
      throw new Error(formatMessage(opt, " has been removed" + (version ? " in " + version : "")));
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value2, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new TypeError("options must be an object");
  }
  var keys = Object.keys(options);
  var i2 = keys.length;
  while (i2-- > 0) {
    var opt = keys[i2];
    var validator2 = schema[opt];
    if (validator2) {
      var value2 = options[opt];
      var result = value2 === void 0 || validator2(value2, opt, options);
      if (result !== true) {
        throw new TypeError("option " + opt + " must be " + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error("Unknown option " + opt);
    }
  }
}
var validator$1 = {
  assertOptions,
  validators: validators$1
};
var utils$5 = utils$c;
var buildURL = buildURL$1;
var InterceptorManager = InterceptorManager_1;
var dispatchRequest = dispatchRequest$1;
var mergeConfig$1 = mergeConfig$2;
var validator = validator$1;
var validators = validator.validators;
function Axios$1(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
Axios$1.prototype.request = function request(config) {
  if (typeof config === "string") {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }
  config = mergeConfig$1(this.defaults, config);
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = "get";
  }
  var transitional2 = config.transitional;
  if (transitional2 !== void 0) {
    validator.assertOptions(transitional2, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
      return;
    }
    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });
  var promise;
  if (!synchronousRequestInterceptors) {
    var chain2 = [dispatchRequest, void 0];
    Array.prototype.unshift.apply(chain2, requestInterceptorChain);
    chain2 = chain2.concat(responseInterceptorChain);
    promise = Promise.resolve(config);
    while (chain2.length) {
      promise = promise.then(chain2.shift(), chain2.shift());
    }
    return promise;
  }
  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }
  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }
  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }
  return promise;
};
Axios$1.prototype.getUri = function getUri(config) {
  config = mergeConfig$1(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
};
utils$5.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method2) {
  Axios$1.prototype[method2] = function(url2, config) {
    return this.request(mergeConfig$1(config || {}, {
      method: method2,
      url: url2,
      data: (config || {}).data
    }));
  };
});
utils$5.forEach(["post", "put", "patch"], function forEachMethodWithData(method2) {
  Axios$1.prototype[method2] = function(url2, data2, config) {
    return this.request(mergeConfig$1(config || {}, {
      method: method2,
      url: url2,
      data: data2
    }));
  };
});
var Axios_1 = Axios$1;
var CancelToken_1;
var hasRequiredCancelToken;
function requireCancelToken() {
  if (hasRequiredCancelToken)
    return CancelToken_1;
  hasRequiredCancelToken = 1;
  var Cancel2 = requireCancel();
  function CancelToken(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    var token2 = this;
    this.promise.then(function(cancel) {
      if (!token2._listeners)
        return;
      var i2;
      var l2 = token2._listeners.length;
      for (i2 = 0; i2 < l2; i2++) {
        token2._listeners[i2](cancel);
      }
      token2._listeners = null;
    });
    this.promise.then = function(onfulfilled) {
      var _resolve;
      var promise = new Promise(function(resolve) {
        token2.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token2.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message) {
      if (token2.reason) {
        return;
      }
      token2.reason = new Cancel2(message);
      resolvePromise(token2.reason);
    });
  }
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  CancelToken.prototype.subscribe = function subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  };
  CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    var index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  };
  CancelToken.source = function source() {
    var cancel;
    var token2 = new CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token: token2,
      cancel
    };
  };
  CancelToken_1 = CancelToken;
  return CancelToken_1;
}
var spread;
var hasRequiredSpread;
function requireSpread() {
  if (hasRequiredSpread)
    return spread;
  hasRequiredSpread = 1;
  spread = function spread2(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  };
  return spread;
}
var isAxiosError;
var hasRequiredIsAxiosError;
function requireIsAxiosError() {
  if (hasRequiredIsAxiosError)
    return isAxiosError;
  hasRequiredIsAxiosError = 1;
  isAxiosError = function isAxiosError2(payload) {
    return typeof payload === "object" && payload.isAxiosError === true;
  };
  return isAxiosError;
}
var utils$4 = utils$c;
var bind = bind$2;
var Axios = Axios_1;
var mergeConfig = mergeConfig$2;
var defaults = requireDefaults();
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);
  utils$4.extend(instance, Axios.prototype, context);
  utils$4.extend(instance, context);
  instance.create = function create2(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults);
axios.Axios = Axios;
axios.Cancel = requireCancel();
axios.CancelToken = requireCancelToken();
axios.isCancel = requireIsCancel();
axios.VERSION = requireData().version;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = requireSpread();
axios.isAxiosError = requireIsAxiosError();
axios$1.exports = axios;
axios$1.exports.default = axios;
(function(module2) {
  module2.exports = axios$1.exports;
})(axios$2);
var buffer$1 = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len2 = b64.length;
  if (len2 % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len2;
  var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i2;
  for (i2 = 0; i2 < len2; i2 += 4) {
    tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i2 = start; i2 < end; i2 += 3) {
    tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len2 = uint8.length;
  var extraBytes = len2 % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
    parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len2 - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
var ieee754$1 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754$1.read = function(buffer2, offset, isLE, mLen, nBytes) {
  var e2, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s = buffer2[offset + i2];
  i2 += d2;
  e2 = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e2 = e2 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
  }
  m2 = e2 & (1 << -nBits) - 1;
  e2 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
  }
  if (e2 === 0) {
    e2 = 1 - eBias;
  } else if (e2 === eMax) {
    return m2 ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e2 = e2 - eBias;
  }
  return (s ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
};
ieee754$1.write = function(buffer2, value2, offset, isLE, mLen, nBytes) {
  var e2, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
  value2 = Math.abs(value2);
  if (isNaN(value2) || value2 === Infinity) {
    m2 = isNaN(value2) ? 1 : 0;
    e2 = eMax;
  } else {
    e2 = Math.floor(Math.log(value2) / Math.LN2);
    if (value2 * (c2 = Math.pow(2, -e2)) < 1) {
      e2--;
      c2 *= 2;
    }
    if (e2 + eBias >= 1) {
      value2 += rt / c2;
    } else {
      value2 += rt * Math.pow(2, 1 - eBias);
    }
    if (value2 * c2 >= 2) {
      e2++;
      c2 /= 2;
    }
    if (e2 + eBias >= eMax) {
      m2 = 0;
      e2 = eMax;
    } else if (e2 + eBias >= 1) {
      m2 = (value2 * c2 - 1) * Math.pow(2, mLen);
      e2 = e2 + eBias;
    } else {
      m2 = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e2 = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
  }
  e2 = e2 << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i2] = e2 & 255, i2 += d2, e2 /= 256, eLen -= 8) {
  }
  buffer2[offset + i2 - d2] |= s * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports2) {
  const base64 = base64Js;
  const ieee7542 = ieee754$1;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports2.Buffer = Buffer2;
  exports2.SlowBuffer = SlowBuffer;
  exports2.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports2.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e2) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length2) {
    if (length2 > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length2 + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length2);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length2) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe(arg);
    }
    return from2(arg, encodingOrOffset, length2);
  }
  Buffer2.poolSize = 8192;
  function from2(value2, encodingOrOffset, length2) {
    if (typeof value2 === "string") {
      return fromString(value2, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value2)) {
      return fromArrayView(value2);
    }
    if (value2 == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
      );
    }
    if (isInstance(value2, ArrayBuffer) || value2 && isInstance(value2.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value2, encodingOrOffset, length2);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value2, SharedArrayBuffer) || value2 && isInstance(value2.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value2, encodingOrOffset, length2);
    }
    if (typeof value2 === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value2.valueOf && value2.valueOf();
    if (valueOf != null && valueOf !== value2) {
      return Buffer2.from(valueOf, encodingOrOffset, length2);
    }
    const b2 = fromObject(value2);
    if (b2)
      return b2;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value2[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value2[Symbol.toPrimitive]("string"), encodingOrOffset, length2);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
    );
  }
  Buffer2.from = function(value2, encodingOrOffset, length2) {
    return from2(value2, encodingOrOffset, length2);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc2(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer2.alloc = function(size, fill, encoding) {
    return alloc2(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer2.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer2.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string2, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length2 = byteLength2(string2, encoding) | 0;
    let buf = createBuffer(length2);
    const actual = buf.write(string2, encoding);
    if (actual !== length2) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array2) {
    const length2 = array2.length < 0 ? 0 : checked(array2.length) | 0;
    const buf = createBuffer(length2);
    for (let i2 = 0; i2 < length2; i2 += 1) {
      buf[i2] = array2[i2] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy2 = new Uint8Array(arrayView);
      return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array2, byteOffset, length2) {
    if (byteOffset < 0 || array2.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array2.byteLength < byteOffset + (length2 || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length2 === void 0) {
      buf = new Uint8Array(array2);
    } else if (length2 === void 0) {
      buf = new Uint8Array(array2, byteOffset);
    } else {
      buf = new Uint8Array(array2, byteOffset, length2);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len2 = checked(obj.length) | 0;
      const buf = createBuffer(len2);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len2);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length2) {
    if (length2 >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length2 | 0;
  }
  function SlowBuffer(length2) {
    if (+length2 != length2) {
      length2 = 0;
    }
    return Buffer2.alloc(+length2);
  }
  Buffer2.isBuffer = function isBuffer2(b2) {
    return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
  };
  Buffer2.compare = function compare2(a, b2) {
    if (isInstance(a, Uint8Array))
      a = Buffer2.from(a, a.offset, a.byteLength);
    if (isInstance(b2, Uint8Array))
      b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b2)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a === b2)
      return 0;
    let x2 = a.length;
    let y2 = b2.length;
    for (let i2 = 0, len2 = Math.min(x2, y2); i2 < len2; ++i2) {
      if (a[i2] !== b2[i2]) {
        x2 = a[i2];
        y2 = b2[i2];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat2(list, length2) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    let i2;
    if (length2 === void 0) {
      length2 = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        length2 += list[i2].length;
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length2);
    let pos = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      let buf = list[i2];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf))
            buf = Buffer2.from(buf);
          buf.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(
            buffer2,
            buf,
            pos
          );
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string2, encoding) {
    if (Buffer2.isBuffer(string2)) {
      return string2.length;
    }
    if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
      return string2.byteLength;
    }
    if (typeof string2 !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
      );
    }
    const len2 = string2.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len2 === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len2;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len2 * 2;
        case "hex":
          return len2 >>> 1;
        case "base64":
          return base64ToBytes(string2).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string2).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b2, n2, m2) {
    const i2 = b2[n2];
    b2[n2] = b2[m2];
    b2[m2] = i2;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len2 = this.length;
    if (len2 % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i2 = 0; i2 < len2; i2 += 2) {
      swap(this, i2, i2 + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len2 = this.length;
    if (len2 % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i2 = 0; i2 < len2; i2 += 4) {
      swap(this, i2, i2 + 3);
      swap(this, i2 + 1, i2 + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len2 = this.length;
    if (len2 % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i2 = 0; i2 < len2; i2 += 8) {
      swap(this, i2, i2 + 7);
      swap(this, i2 + 1, i2 + 6);
      swap(this, i2 + 2, i2 + 5);
      swap(this, i2 + 3, i2 + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString2() {
    const length2 = this.length;
    if (length2 === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length2);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b2) {
    if (!Buffer2.isBuffer(b2))
      throw new TypeError("Argument must be a Buffer");
    if (this === b2)
      return true;
    return Buffer2.compare(this, b2) === 0;
  };
  Buffer2.prototype.inspect = function inspect() {
    let str = "";
    const max = exports2.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x2 = thisEnd - thisStart;
    let y2 = end - start;
    const len2 = Math.min(x2, y2);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i2 = 0; i2 < len2; ++i2) {
      if (thisCopy[i2] !== targetCopy[i2]) {
        x2 = thisCopy[i2];
        y2 = targetCopy[i2];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i3) {
      if (indexSize === 1) {
        return buf[i3];
      } else {
        return buf.readUInt16BE(i3 * indexSize);
      }
    }
    let i2;
    if (dir) {
      let foundIndex = -1;
      for (i2 = byteOffset; i2 < arrLength; i2++) {
        if (read(arr, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i2;
          if (i2 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i2 -= i2 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i2 = byteOffset; i2 >= 0; i2--) {
        let found = true;
        for (let j = 0; j < valLength; j++) {
          if (read(arr, i2 + j) !== read(val, j)) {
            found = false;
            break;
          }
        }
        if (found)
          return i2;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string2, offset, length2) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length2) {
      length2 = remaining;
    } else {
      length2 = Number(length2);
      if (length2 > remaining) {
        length2 = remaining;
      }
    }
    const strLen = string2.length;
    if (length2 > strLen / 2) {
      length2 = strLen / 2;
    }
    let i2;
    for (i2 = 0; i2 < length2; ++i2) {
      const parsed = parseInt(string2.substr(i2 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i2;
      buf[offset + i2] = parsed;
    }
    return i2;
  }
  function utf8Write(buf, string2, offset, length2) {
    return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length2);
  }
  function asciiWrite(buf, string2, offset, length2) {
    return blitBuffer(asciiToBytes(string2), buf, offset, length2);
  }
  function base64Write(buf, string2, offset, length2) {
    return blitBuffer(base64ToBytes(string2), buf, offset, length2);
  }
  function ucs2Write(buf, string2, offset, length2) {
    return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length2);
  }
  Buffer2.prototype.write = function write(string2, offset, length2, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length2 = this.length;
      offset = 0;
    } else if (length2 === void 0 && typeof offset === "string") {
      encoding = offset;
      length2 = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length2)) {
        length2 = length2 >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length2;
        length2 = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset;
    if (length2 === void 0 || length2 > remaining)
      length2 = remaining;
    if (string2.length > 0 && (length2 < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string2, offset, length2);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string2, offset, length2);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string2, offset, length2);
        case "base64":
          return base64Write(this, string2, offset, length2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string2, offset, length2);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i2 = start;
    while (i2 < end) {
      const firstByte = buf[i2];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i2 + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i2 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            fourthByte = buf[i2 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i2 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len2 = codePoints.length;
    if (len2 <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i2 = 0;
    while (i2 < len2) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len2 = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len2)
      end = len2;
    let out = "";
    for (let i2 = start; i2 < end; ++i2) {
      out += hexSliceLookupTable[buf[i2]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes2 = buf.slice(start, end);
    let res = "";
    for (let i2 = 0; i2 < bytes2.length - 1; i2 += 2) {
      res += String.fromCharCode(bytes2[i2] + bytes2[i2 + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice2(start, end) {
    const len2 = this.length;
    start = ~~start;
    end = end === void 0 ? len2 : ~~end;
    if (start < 0) {
      start += len2;
      if (start < 0)
        start = 0;
    } else if (start > len2) {
      start = len2;
    }
    if (end < 0) {
      end += len2;
      if (end < 0)
        end = 0;
    } else if (end > len2) {
      end = len2;
    }
    if (end < start)
      end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext2, length2) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext2 > length2)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE2(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i2 = 0;
    while (++i2 < byteLength3 && (mul *= 256)) {
      val += this[offset + i2] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    let val = this[offset + --byteLength3];
    let mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength3] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi2 = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi2) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi2 = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi2) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE2(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i2 = 0;
    while (++i2 < byteLength3 && (mul *= 256)) {
      val += this[offset + i2] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let i2 = byteLength3;
    let mul = 1;
    let val = this[offset + --i2];
    while (i2 > 0 && (mul *= 256)) {
      val += this[offset + --i2] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee7542.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee7542.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee7542.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee7542.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value2, offset, ext2, max, min) {
    if (!Buffer2.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value2 > max || value2 < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext2 > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE2(value2, offset, byteLength3, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value2, offset, byteLength3, maxBytes, 0);
    }
    let mul = 1;
    let i2 = 0;
    this[offset] = value2 & 255;
    while (++i2 < byteLength3 && (mul *= 256)) {
      this[offset + i2] = value2 / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value2, offset, byteLength3, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value2, offset, byteLength3, maxBytes, 0);
    }
    let i2 = byteLength3 - 1;
    let mul = 1;
    this[offset + i2] = value2 & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      this[offset + i2] = value2 / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 1, 255, 0);
    this[offset] = value2 & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 2, 65535, 0);
    this[offset] = value2 & 255;
    this[offset + 1] = value2 >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 2, 65535, 0);
    this[offset] = value2 >>> 8;
    this[offset + 1] = value2 & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 4, 4294967295, 0);
    this[offset + 3] = value2 >>> 24;
    this[offset + 2] = value2 >>> 16;
    this[offset + 1] = value2 >>> 8;
    this[offset] = value2 & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 4, 4294967295, 0);
    this[offset] = value2 >>> 24;
    this[offset + 1] = value2 >>> 16;
    this[offset + 2] = value2 >>> 8;
    this[offset + 3] = value2 & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value2, offset, min, max) {
    checkIntBI(value2, min, max, buf, offset, 7);
    let lo = Number(value2 & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi2 = Number(value2 >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset++] = hi2;
    return offset;
  }
  function wrtBigUInt64BE(buf, value2, offset, min, max) {
    checkIntBI(value2, min, max, buf, offset, 7);
    let lo = Number(value2 & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi2 = Number(value2 >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi2;
    hi2 = hi2 >> 8;
    buf[offset + 2] = hi2;
    hi2 = hi2 >> 8;
    buf[offset + 1] = hi2;
    hi2 = hi2 >> 8;
    buf[offset] = hi2;
    return offset + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value2, offset = 0) {
    return wrtBigUInt64LE(this, value2, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value2, offset = 0) {
    return wrtBigUInt64BE(this, value2, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE2(value2, offset, byteLength3, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value2, offset, byteLength3, limit - 1, -limit);
    }
    let i2 = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value2 & 255;
    while (++i2 < byteLength3 && (mul *= 256)) {
      if (value2 < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value2 / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value2, offset, byteLength3, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value2, offset, byteLength3, limit - 1, -limit);
    }
    let i2 = byteLength3 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i2] = value2 & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      if (value2 < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value2 / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 1, 127, -128);
    if (value2 < 0)
      value2 = 255 + value2 + 1;
    this[offset] = value2 & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 2, 32767, -32768);
    this[offset] = value2 & 255;
    this[offset + 1] = value2 >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 2, 32767, -32768);
    this[offset] = value2 >>> 8;
    this[offset + 1] = value2 & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 4, 2147483647, -2147483648);
    this[offset] = value2 & 255;
    this[offset + 1] = value2 >>> 8;
    this[offset + 2] = value2 >>> 16;
    this[offset + 3] = value2 >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 4, 2147483647, -2147483648);
    if (value2 < 0)
      value2 = 4294967295 + value2 + 1;
    this[offset] = value2 >>> 24;
    this[offset + 1] = value2 >>> 16;
    this[offset + 2] = value2 >>> 8;
    this[offset + 3] = value2 & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value2, offset = 0) {
    return wrtBigUInt64LE(this, value2, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value2, offset = 0) {
    return wrtBigUInt64BE(this, value2, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value2, offset, ext2, max, min) {
    if (offset + ext2 > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value2, offset, littleEndian, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value2, offset, 4);
    }
    ieee7542.write(buf, value2, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value2, offset, noAssert) {
    return writeFloat(this, value2, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value2, offset, noAssert) {
    return writeFloat(this, value2, offset, false, noAssert);
  };
  function writeDouble(buf, value2, offset, littleEndian, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value2, offset, 8);
    }
    ieee7542.write(buf, value2, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value2, offset, noAssert) {
    return writeDouble(this, value2, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value2, offset, noAssert) {
    return writeDouble(this, value2, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy2(target, targetStart, start, end) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len2 = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, end),
        targetStart
      );
    }
    return len2;
  };
  Buffer2.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    let i2;
    if (typeof val === "number") {
      for (i2 = start; i2 < end; ++i2) {
        this[i2] = val;
      }
    } else {
      const bytes2 = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      const len2 = bytes2.length;
      if (len2 === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i2 = 0; i2 < end - start; ++i2) {
        this[i2 + start] = bytes2[i2 % len2];
      }
    }
    return this;
  };
  const errors = {};
  function E2(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value2) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value: value2,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E2(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name) {
      if (name) {
        return `${name} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E2(
    "ERR_INVALID_ARG_TYPE",
    function(name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E2(
    "ERR_OUT_OF_RANGE",
    function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i2 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i2 >= start + 4; i2 -= 3) {
      res = `_${val.slice(i2 - 3, i2)}${res}`;
    }
    return `${val.slice(0, i2)}${res}`;
  }
  function checkBounds(buf, offset, byteLength3) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
      boundsError(offset, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value2, min, max, buf, offset, byteLength3) {
    if (value2 > max || value2 < min) {
      const n2 = typeof min === "bigint" ? "n" : "";
      let range;
      if (byteLength3 > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n2} and < 2${n2} ** ${(byteLength3 + 1) * 8}${n2}`;
        } else {
          range = `>= -(2${n2} ** ${(byteLength3 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n2}`;
        }
      } else {
        range = `>= ${min}${n2} and <= ${max}${n2}`;
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range, value2);
    }
    checkBounds(buf, offset, byteLength3);
  }
  function validateNumber(value2, name) {
    if (typeof value2 !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value2);
    }
  }
  function boundsError(value2, length2, type) {
    if (Math.floor(value2) !== value2) {
      validateNumber(value2, type);
      throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value2);
    }
    if (length2 < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(
      type || "offset",
      `>= ${type ? 1 : 0} and <= ${length2}`,
      value2
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string2, units) {
    units = units || Infinity;
    let codePoint;
    const length2 = string2.length;
    let leadSurrogate = null;
    const bytes2 = [];
    for (let i2 = 0; i2 < length2; ++i2) {
      codePoint = string2.charCodeAt(i2);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            continue;
          } else if (i2 + 1 === length2) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes2.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes2.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes2.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes2.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes2.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes2;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i2 = 0; i2 < str.length; ++i2) {
      byteArray.push(str.charCodeAt(i2) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c2, hi2, lo;
    const byteArray = [];
    for (let i2 = 0; i2 < str.length; ++i2) {
      if ((units -= 2) < 0)
        break;
      c2 = str.charCodeAt(i2);
      hi2 = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi2);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src2, dst, offset, length2) {
    let i2;
    for (i2 = 0; i2 < length2; ++i2) {
      if (i2 + offset >= dst.length || i2 >= src2.length)
        break;
      dst[i2 + offset] = src2[i2];
    }
    return i2;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet2 = "0123456789abcdef";
    const table = new Array(256);
    for (let i2 = 0; i2 < 16; ++i2) {
      const i162 = i2 * 16;
      for (let j = 0; j < 16; ++j) {
        table[i162 + j] = alphabet2[i2] + alphabet2[j];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer$1);
var ReplicaRejectCode$1;
(function(ReplicaRejectCode2) {
  ReplicaRejectCode2[ReplicaRejectCode2["SysFatal"] = 1] = "SysFatal";
  ReplicaRejectCode2[ReplicaRejectCode2["SysTransient"] = 2] = "SysTransient";
  ReplicaRejectCode2[ReplicaRejectCode2["DestinationInvalid"] = 3] = "DestinationInvalid";
  ReplicaRejectCode2[ReplicaRejectCode2["CanisterReject"] = 4] = "CanisterReject";
  ReplicaRejectCode2[ReplicaRejectCode2["CanisterError"] = 5] = "CanisterError";
})(ReplicaRejectCode$1 || (ReplicaRejectCode$1 = {}));
const alphabet = "abcdefghijklmnopqrstuvwxyz234567";
const lookupTable = /* @__PURE__ */ Object.create(null);
for (let i2 = 0; i2 < alphabet.length; i2++) {
  lookupTable[alphabet[i2]] = i2;
}
lookupTable["0"] = lookupTable.o;
lookupTable["1"] = lookupTable.i;
function encode$4(input) {
  let skip = 0;
  let bits = 0;
  let output = "";
  function encodeByte(byte) {
    if (skip < 0) {
      bits |= byte >> -skip;
    } else {
      bits = byte << skip & 248;
    }
    if (skip > 3) {
      skip -= 8;
      return 1;
    }
    if (skip < 4) {
      output += alphabet[bits >> 3];
      skip += 5;
    }
    return 0;
  }
  for (let i2 = 0; i2 < input.length; ) {
    i2 += encodeByte(input[i2]);
  }
  return output + (skip < 0 ? alphabet[bits >> 3] : "");
}
function decode$5(input) {
  let skip = 0;
  let byte = 0;
  const output = new Uint8Array(input.length * 4 / 3 | 0);
  let o = 0;
  function decodeChar(char2) {
    let val = lookupTable[char2.toLowerCase()];
    if (val === void 0) {
      throw new Error(`Invalid character: ${JSON.stringify(char2)}`);
    }
    val <<= 3;
    byte |= val >>> skip;
    skip += 5;
    if (skip >= 8) {
      output[o++] = byte;
      skip -= 8;
      if (skip > 0) {
        byte = val << 5 - skip & 255;
      } else {
        byte = 0;
      }
    }
  }
  for (const c2 of input) {
    decodeChar(c2);
  }
  return output.slice(0, o);
}
const lookUpTable = new Uint32Array([
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918e3,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
]);
function getCrc32(buf) {
  const b2 = new Uint8Array(buf);
  let crc = -1;
  for (let i2 = 0; i2 < b2.length; i2++) {
    const byte = b2[i2];
    const t2 = (byte ^ crc) & 255;
    crc = lookUpTable[t2] ^ crc >>> 8;
  }
  return (crc ^ -1) >>> 0;
}
function sha224$1(data2) {
  const shaObj = sha256$1.exports.sha224.create();
  shaObj.update(data2);
  return new Uint8Array(shaObj.array());
}
const SELF_AUTHENTICATING_SUFFIX = 2;
const ANONYMOUS_SUFFIX = 4;
const fromHexString = (hexString) => {
  var _a;
  return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== void 0 ? _a : []).map((byte) => parseInt(byte, 16)));
};
const toHexString = (bytes2) => bytes2.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
class Principal$2 {
  constructor(_arr) {
    this._arr = _arr;
    this._isPrincipal = true;
  }
  static anonymous() {
    return new this(new Uint8Array([ANONYMOUS_SUFFIX]));
  }
  static selfAuthenticating(publicKey) {
    const sha = sha224$1(publicKey);
    return new this(new Uint8Array([...sha, SELF_AUTHENTICATING_SUFFIX]));
  }
  static from(other) {
    if (typeof other === "string") {
      return Principal$2.fromText(other);
    } else if (typeof other === "object" && other !== null && other._isPrincipal === true) {
      return new Principal$2(other._arr);
    }
    throw new Error(`Impossible to convert ${JSON.stringify(other)} to Principal.`);
  }
  static fromHex(hex) {
    return new this(fromHexString(hex));
  }
  static fromText(text) {
    const canisterIdNoDash = text.toLowerCase().replace(/-/g, "");
    let arr = decode$5(canisterIdNoDash);
    arr = arr.slice(4, arr.length);
    const principal = new this(arr);
    if (principal.toText() !== text) {
      throw new Error(`Principal "${principal.toText()}" does not have a valid checksum.`);
    }
    return principal;
  }
  static fromUint8Array(arr) {
    return new this(arr);
  }
  isAnonymous() {
    return this._arr.byteLength === 1 && this._arr[0] === ANONYMOUS_SUFFIX;
  }
  toUint8Array() {
    return this._arr;
  }
  toHex() {
    return toHexString(this._arr).toUpperCase();
  }
  toText() {
    const checksumArrayBuf = new ArrayBuffer(4);
    const view = new DataView(checksumArrayBuf);
    view.setUint32(0, getCrc32(this._arr));
    const checksum = Uint8Array.from(buffer$1.Buffer.from(checksumArrayBuf));
    const bytes2 = Uint8Array.from(this._arr);
    const array2 = new Uint8Array([...checksum, ...bytes2]);
    const result = encode$4(array2);
    const matches = result.match(/.{1,5}/g);
    if (!matches) {
      throw new Error();
    }
    return matches.join("-");
  }
  toString() {
    return this.toText();
  }
}
const esm$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Principal: Principal$2
}, Symbol.toStringTag, { value: "Module" }));
var src$1 = {};
var buffer = {};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports2) {
  var base64 = base64Js;
  var ieee7542 = ieee754$1;
  var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports2.Buffer = Buffer2;
  exports2.SlowBuffer = SlowBuffer;
  exports2.INSPECT_MAX_BYTES = 50;
  var K_MAX_LENGTH = 2147483647;
  exports2.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      var arr = new Uint8Array(1);
      var proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e2) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length2) {
    if (length2 > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length2 + '" is invalid for option "size"');
    }
    var buf = new Uint8Array(length2);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length2) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe(arg);
    }
    return from2(arg, encodingOrOffset, length2);
  }
  Buffer2.poolSize = 8192;
  function from2(value2, encodingOrOffset, length2) {
    if (typeof value2 === "string") {
      return fromString(value2, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value2)) {
      return fromArrayView(value2);
    }
    if (value2 == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
      );
    }
    if (isInstance(value2, ArrayBuffer) || value2 && isInstance(value2.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value2, encodingOrOffset, length2);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value2, SharedArrayBuffer) || value2 && isInstance(value2.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value2, encodingOrOffset, length2);
    }
    if (typeof value2 === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    var valueOf = value2.valueOf && value2.valueOf();
    if (valueOf != null && valueOf !== value2) {
      return Buffer2.from(valueOf, encodingOrOffset, length2);
    }
    var b2 = fromObject(value2);
    if (b2)
      return b2;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value2[Symbol.toPrimitive] === "function") {
      return Buffer2.from(
        value2[Symbol.toPrimitive]("string"),
        encodingOrOffset,
        length2
      );
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
    );
  }
  Buffer2.from = function(value2, encodingOrOffset, length2) {
    return from2(value2, encodingOrOffset, length2);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc2(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer2.alloc = function(size, fill, encoding) {
    return alloc2(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer2.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer2.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string2, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    var length2 = byteLength2(string2, encoding) | 0;
    var buf = createBuffer(length2);
    var actual = buf.write(string2, encoding);
    if (actual !== length2) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array2) {
    var length2 = array2.length < 0 ? 0 : checked(array2.length) | 0;
    var buf = createBuffer(length2);
    for (var i2 = 0; i2 < length2; i2 += 1) {
      buf[i2] = array2[i2] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      var copy2 = new Uint8Array(arrayView);
      return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array2, byteOffset, length2) {
    if (byteOffset < 0 || array2.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array2.byteLength < byteOffset + (length2 || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    var buf;
    if (byteOffset === void 0 && length2 === void 0) {
      buf = new Uint8Array(array2);
    } else if (length2 === void 0) {
      buf = new Uint8Array(array2, byteOffset);
    } else {
      buf = new Uint8Array(array2, byteOffset, length2);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      var len2 = checked(obj.length) | 0;
      var buf = createBuffer(len2);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len2);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length2) {
    if (length2 >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length2 | 0;
  }
  function SlowBuffer(length2) {
    if (+length2 != length2) {
      length2 = 0;
    }
    return Buffer2.alloc(+length2);
  }
  Buffer2.isBuffer = function isBuffer2(b2) {
    return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
  };
  Buffer2.compare = function compare2(a, b2) {
    if (isInstance(a, Uint8Array))
      a = Buffer2.from(a, a.offset, a.byteLength);
    if (isInstance(b2, Uint8Array))
      b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b2)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a === b2)
      return 0;
    var x2 = a.length;
    var y2 = b2.length;
    for (var i2 = 0, len2 = Math.min(x2, y2); i2 < len2; ++i2) {
      if (a[i2] !== b2[i2]) {
        x2 = a[i2];
        y2 = b2[i2];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat2(list, length2) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    var i2;
    if (length2 === void 0) {
      length2 = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        length2 += list[i2].length;
      }
    }
    var buffer2 = Buffer2.allocUnsafe(length2);
    var pos = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      var buf = list[i2];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          Buffer2.from(buf).copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(
            buffer2,
            buf,
            pos
          );
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string2, encoding) {
    if (Buffer2.isBuffer(string2)) {
      return string2.length;
    }
    if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
      return string2.byteLength;
    }
    if (typeof string2 !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
      );
    }
    var len2 = string2.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len2 === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len2;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len2 * 2;
        case "hex":
          return len2 >>> 1;
        case "base64":
          return base64ToBytes(string2).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string2).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    var loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b2, n2, m2) {
    var i2 = b2[n2];
    b2[n2] = b2[m2];
    b2[m2] = i2;
  }
  Buffer2.prototype.swap16 = function swap16() {
    var len2 = this.length;
    if (len2 % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (var i2 = 0; i2 < len2; i2 += 2) {
      swap(this, i2, i2 + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    var len2 = this.length;
    if (len2 % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (var i2 = 0; i2 < len2; i2 += 4) {
      swap(this, i2, i2 + 3);
      swap(this, i2 + 1, i2 + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    var len2 = this.length;
    if (len2 % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (var i2 = 0; i2 < len2; i2 += 8) {
      swap(this, i2, i2 + 7);
      swap(this, i2 + 1, i2 + 6);
      swap(this, i2 + 2, i2 + 5);
      swap(this, i2 + 3, i2 + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString2() {
    var length2 = this.length;
    if (length2 === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length2);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b2) {
    if (!Buffer2.isBuffer(b2))
      throw new TypeError("Argument must be a Buffer");
    if (this === b2)
      return true;
    return Buffer2.compare(this, b2) === 0;
  };
  Buffer2.prototype.inspect = function inspect() {
    var str = "";
    var max = exports2.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    var x2 = thisEnd - thisStart;
    var y2 = end - start;
    var len2 = Math.min(x2, y2);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for (var i2 = 0; i2 < len2; ++i2) {
      if (thisCopy[i2] !== targetCopy[i2]) {
        x2 = thisCopy[i2];
        y2 = targetCopy[i2];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i3) {
      if (indexSize === 1) {
        return buf[i3];
      } else {
        return buf.readUInt16BE(i3 * indexSize);
      }
    }
    var i2;
    if (dir) {
      var foundIndex = -1;
      for (i2 = byteOffset; i2 < arrLength; i2++) {
        if (read(arr, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i2;
          if (i2 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i2 -= i2 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i2 = byteOffset; i2 >= 0; i2--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read(arr, i2 + j) !== read(val, j)) {
            found = false;
            break;
          }
        }
        if (found)
          return i2;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string2, offset, length2) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length2) {
      length2 = remaining;
    } else {
      length2 = Number(length2);
      if (length2 > remaining) {
        length2 = remaining;
      }
    }
    var strLen = string2.length;
    if (length2 > strLen / 2) {
      length2 = strLen / 2;
    }
    for (var i2 = 0; i2 < length2; ++i2) {
      var parsed = parseInt(string2.substr(i2 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i2;
      buf[offset + i2] = parsed;
    }
    return i2;
  }
  function utf8Write(buf, string2, offset, length2) {
    return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length2);
  }
  function asciiWrite(buf, string2, offset, length2) {
    return blitBuffer(asciiToBytes(string2), buf, offset, length2);
  }
  function base64Write(buf, string2, offset, length2) {
    return blitBuffer(base64ToBytes(string2), buf, offset, length2);
  }
  function ucs2Write(buf, string2, offset, length2) {
    return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length2);
  }
  Buffer2.prototype.write = function write(string2, offset, length2, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length2 = this.length;
      offset = 0;
    } else if (length2 === void 0 && typeof offset === "string") {
      encoding = offset;
      length2 = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length2)) {
        length2 = length2 >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length2;
        length2 = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    var remaining = this.length - offset;
    if (length2 === void 0 || length2 > remaining)
      length2 = remaining;
    if (string2.length > 0 && (length2 < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string2, offset, length2);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string2, offset, length2);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string2, offset, length2);
        case "base64":
          return base64Write(this, string2, offset, length2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string2, offset, length2);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i2 = start;
    while (i2 < end) {
      var firstByte = buf[i2];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i2 + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i2 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            fourthByte = buf[i2 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i2 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  var MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    var len2 = codePoints.length;
    if (len2 <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = "";
    var i2 = 0;
    while (i2 < len2) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    var len2 = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len2)
      end = len2;
    var out = "";
    for (var i2 = start; i2 < end; ++i2) {
      out += hexSliceLookupTable[buf[i2]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    var bytes2 = buf.slice(start, end);
    var res = "";
    for (var i2 = 0; i2 < bytes2.length - 1; i2 += 2) {
      res += String.fromCharCode(bytes2[i2] + bytes2[i2 + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice2(start, end) {
    var len2 = this.length;
    start = ~~start;
    end = end === void 0 ? len2 : ~~end;
    if (start < 0) {
      start += len2;
      if (start < 0)
        start = 0;
    } else if (start > len2) {
      start = len2;
    }
    if (end < 0) {
      end += len2;
      if (end < 0)
        end = 0;
    } else if (end > len2) {
      end = len2;
    }
    if (end < start)
      end = start;
    var newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext2, length2) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext2 > length2)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE2(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    var val = this[offset];
    var mul = 1;
    var i2 = 0;
    while (++i2 < byteLength3 && (mul *= 256)) {
      val += this[offset + i2] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    var val = this[offset + --byteLength3];
    var mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength3] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readIntLE = function readIntLE2(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    var val = this[offset];
    var mul = 1;
    var i2 = 0;
    while (++i2 < byteLength3 && (mul *= 256)) {
      val += this[offset + i2] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    var i2 = byteLength3;
    var mul = 1;
    var val = this[offset + --i2];
    while (i2 > 0 && (mul *= 256)) {
      val += this[offset + --i2] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee7542.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee7542.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee7542.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee7542.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value2, offset, ext2, max, min) {
    if (!Buffer2.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value2 > max || value2 < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext2 > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE2(value2, offset, byteLength3, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value2, offset, byteLength3, maxBytes, 0);
    }
    var mul = 1;
    var i2 = 0;
    this[offset] = value2 & 255;
    while (++i2 < byteLength3 && (mul *= 256)) {
      this[offset + i2] = value2 / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value2, offset, byteLength3, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value2, offset, byteLength3, maxBytes, 0);
    }
    var i2 = byteLength3 - 1;
    var mul = 1;
    this[offset + i2] = value2 & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      this[offset + i2] = value2 / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 1, 255, 0);
    this[offset] = value2 & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 2, 65535, 0);
    this[offset] = value2 & 255;
    this[offset + 1] = value2 >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 2, 65535, 0);
    this[offset] = value2 >>> 8;
    this[offset + 1] = value2 & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 4, 4294967295, 0);
    this[offset + 3] = value2 >>> 24;
    this[offset + 2] = value2 >>> 16;
    this[offset + 1] = value2 >>> 8;
    this[offset] = value2 & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 4, 4294967295, 0);
    this[offset] = value2 >>> 24;
    this[offset + 1] = value2 >>> 16;
    this[offset + 2] = value2 >>> 8;
    this[offset + 3] = value2 & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeIntLE = function writeIntLE2(value2, offset, byteLength3, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value2, offset, byteLength3, limit - 1, -limit);
    }
    var i2 = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value2 & 255;
    while (++i2 < byteLength3 && (mul *= 256)) {
      if (value2 < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value2 / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value2, offset, byteLength3, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value2, offset, byteLength3, limit - 1, -limit);
    }
    var i2 = byteLength3 - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i2] = value2 & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      if (value2 < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value2 / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 1, 127, -128);
    if (value2 < 0)
      value2 = 255 + value2 + 1;
    this[offset] = value2 & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 2, 32767, -32768);
    this[offset] = value2 & 255;
    this[offset + 1] = value2 >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 2, 32767, -32768);
    this[offset] = value2 >>> 8;
    this[offset + 1] = value2 & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 4, 2147483647, -2147483648);
    this[offset] = value2 & 255;
    this[offset + 1] = value2 >>> 8;
    this[offset + 2] = value2 >>> 16;
    this[offset + 3] = value2 >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 4, 2147483647, -2147483648);
    if (value2 < 0)
      value2 = 4294967295 + value2 + 1;
    this[offset] = value2 >>> 24;
    this[offset + 1] = value2 >>> 16;
    this[offset + 2] = value2 >>> 8;
    this[offset + 3] = value2 & 255;
    return offset + 4;
  };
  function checkIEEE754(buf, value2, offset, ext2, max, min) {
    if (offset + ext2 > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value2, offset, littleEndian, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value2, offset, 4);
    }
    ieee7542.write(buf, value2, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value2, offset, noAssert) {
    return writeFloat(this, value2, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value2, offset, noAssert) {
    return writeFloat(this, value2, offset, false, noAssert);
  };
  function writeDouble(buf, value2, offset, littleEndian, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value2, offset, 8);
    }
    ieee7542.write(buf, value2, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value2, offset, noAssert) {
    return writeDouble(this, value2, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value2, offset, noAssert) {
    return writeDouble(this, value2, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy2(target, targetStart, start, end) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    var len2 = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, end),
        targetStart
      );
    }
    return len2;
  };
  Buffer2.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        var code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    var i2;
    if (typeof val === "number") {
      for (i2 = start; i2 < end; ++i2) {
        this[i2] = val;
      }
    } else {
      var bytes2 = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      var len2 = bytes2.length;
      if (len2 === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i2 = 0; i2 < end - start; ++i2) {
        this[i2 + start] = bytes2[i2 % len2];
      }
    }
    return this;
  };
  var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string2, units) {
    units = units || Infinity;
    var codePoint;
    var length2 = string2.length;
    var leadSurrogate = null;
    var bytes2 = [];
    for (var i2 = 0; i2 < length2; ++i2) {
      codePoint = string2.charCodeAt(i2);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            continue;
          } else if (i2 + 1 === length2) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes2.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes2.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes2.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes2.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes2.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes2;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i2 = 0; i2 < str.length; ++i2) {
      byteArray.push(str.charCodeAt(i2) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c2, hi2, lo;
    var byteArray = [];
    for (var i2 = 0; i2 < str.length; ++i2) {
      if ((units -= 2) < 0)
        break;
      c2 = str.charCodeAt(i2);
      hi2 = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi2);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src2, dst, offset, length2) {
    for (var i2 = 0; i2 < length2; ++i2) {
      if (i2 + offset >= dst.length || i2 >= src2.length)
        break;
      dst[i2 + offset] = src2[i2];
    }
    return i2;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  var hexSliceLookupTable = function() {
    var alphabet2 = "0123456789abcdef";
    var table = new Array(256);
    for (var i2 = 0; i2 < 16; ++i2) {
      var i162 = i2 * 16;
      for (var j = 0; j < 16; ++j) {
        table[i162 + j] = alphabet2[i2] + alphabet2[j];
      }
    }
    return table;
  }();
})(buffer);
var bignumber = { exports: {} };
(function(module2) {
  (function(globalObject) {
    var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
    function clone2(configObject) {
      var div, convertBase, parseNumeric, P2 = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
        prefix: "",
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ",",
        decimalSeparator: ".",
        fractionGroupSize: 0,
        fractionGroupSeparator: "\xA0",
        suffix: ""
      }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
      function BigNumber2(v2, b2) {
        var alphabet2, c2, caseChanged, e2, i2, isNum, len2, str, x2 = this;
        if (!(x2 instanceof BigNumber2))
          return new BigNumber2(v2, b2);
        if (b2 == null) {
          if (v2 && v2._isBigNumber === true) {
            x2.s = v2.s;
            if (!v2.c || v2.e > MAX_EXP) {
              x2.c = x2.e = null;
            } else if (v2.e < MIN_EXP) {
              x2.c = [x2.e = 0];
            } else {
              x2.e = v2.e;
              x2.c = v2.c.slice();
            }
            return;
          }
          if ((isNum = typeof v2 == "number") && v2 * 0 == 0) {
            x2.s = 1 / v2 < 0 ? (v2 = -v2, -1) : 1;
            if (v2 === ~~v2) {
              for (e2 = 0, i2 = v2; i2 >= 10; i2 /= 10, e2++)
                ;
              if (e2 > MAX_EXP) {
                x2.c = x2.e = null;
              } else {
                x2.e = e2;
                x2.c = [v2];
              }
              return;
            }
            str = String(v2);
          } else {
            if (!isNumeric.test(str = String(v2)))
              return parseNumeric(x2, str, isNum);
            x2.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
          }
          if ((e2 = str.indexOf(".")) > -1)
            str = str.replace(".", "");
          if ((i2 = str.search(/e/i)) > 0) {
            if (e2 < 0)
              e2 = i2;
            e2 += +str.slice(i2 + 1);
            str = str.substring(0, i2);
          } else if (e2 < 0) {
            e2 = str.length;
          }
        } else {
          intCheck(b2, 2, ALPHABET.length, "Base");
          if (b2 == 10 && alphabetHasNormalDecimalDigits) {
            x2 = new BigNumber2(v2);
            return round2(x2, DECIMAL_PLACES + x2.e + 1, ROUNDING_MODE);
          }
          str = String(v2);
          if (isNum = typeof v2 == "number") {
            if (v2 * 0 != 0)
              return parseNumeric(x2, str, isNum, b2);
            x2.s = 1 / v2 < 0 ? (str = str.slice(1), -1) : 1;
            if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
              throw Error(tooManyDigits + v2);
            }
          } else {
            x2.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
          }
          alphabet2 = ALPHABET.slice(0, b2);
          e2 = i2 = 0;
          for (len2 = str.length; i2 < len2; i2++) {
            if (alphabet2.indexOf(c2 = str.charAt(i2)) < 0) {
              if (c2 == ".") {
                if (i2 > e2) {
                  e2 = len2;
                  continue;
                }
              } else if (!caseChanged) {
                if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                  caseChanged = true;
                  i2 = -1;
                  e2 = 0;
                  continue;
                }
              }
              return parseNumeric(x2, String(v2), isNum, b2);
            }
          }
          isNum = false;
          str = convertBase(str, b2, 10, x2.s);
          if ((e2 = str.indexOf(".")) > -1)
            str = str.replace(".", "");
          else
            e2 = str.length;
        }
        for (i2 = 0; str.charCodeAt(i2) === 48; i2++)
          ;
        for (len2 = str.length; str.charCodeAt(--len2) === 48; )
          ;
        if (str = str.slice(i2, ++len2)) {
          len2 -= i2;
          if (isNum && BigNumber2.DEBUG && len2 > 15 && (v2 > MAX_SAFE_INTEGER || v2 !== mathfloor(v2))) {
            throw Error(tooManyDigits + x2.s * v2);
          }
          if ((e2 = e2 - i2 - 1) > MAX_EXP) {
            x2.c = x2.e = null;
          } else if (e2 < MIN_EXP) {
            x2.c = [x2.e = 0];
          } else {
            x2.e = e2;
            x2.c = [];
            i2 = (e2 + 1) % LOG_BASE;
            if (e2 < 0)
              i2 += LOG_BASE;
            if (i2 < len2) {
              if (i2)
                x2.c.push(+str.slice(0, i2));
              for (len2 -= LOG_BASE; i2 < len2; ) {
                x2.c.push(+str.slice(i2, i2 += LOG_BASE));
              }
              i2 = LOG_BASE - (str = str.slice(i2)).length;
            } else {
              i2 -= len2;
            }
            for (; i2--; str += "0")
              ;
            x2.c.push(+str);
          }
        } else {
          x2.c = [x2.e = 0];
        }
      }
      BigNumber2.clone = clone2;
      BigNumber2.ROUND_UP = 0;
      BigNumber2.ROUND_DOWN = 1;
      BigNumber2.ROUND_CEIL = 2;
      BigNumber2.ROUND_FLOOR = 3;
      BigNumber2.ROUND_HALF_UP = 4;
      BigNumber2.ROUND_HALF_DOWN = 5;
      BigNumber2.ROUND_HALF_EVEN = 6;
      BigNumber2.ROUND_HALF_CEIL = 7;
      BigNumber2.ROUND_HALF_FLOOR = 8;
      BigNumber2.EUCLID = 9;
      BigNumber2.config = BigNumber2.set = function(obj) {
        var p2, v2;
        if (obj != null) {
          if (typeof obj == "object") {
            if (obj.hasOwnProperty(p2 = "DECIMAL_PLACES")) {
              v2 = obj[p2];
              intCheck(v2, 0, MAX, p2);
              DECIMAL_PLACES = v2;
            }
            if (obj.hasOwnProperty(p2 = "ROUNDING_MODE")) {
              v2 = obj[p2];
              intCheck(v2, 0, 8, p2);
              ROUNDING_MODE = v2;
            }
            if (obj.hasOwnProperty(p2 = "EXPONENTIAL_AT")) {
              v2 = obj[p2];
              if (v2 && v2.pop) {
                intCheck(v2[0], -MAX, 0, p2);
                intCheck(v2[1], 0, MAX, p2);
                TO_EXP_NEG = v2[0];
                TO_EXP_POS = v2[1];
              } else {
                intCheck(v2, -MAX, MAX, p2);
                TO_EXP_NEG = -(TO_EXP_POS = v2 < 0 ? -v2 : v2);
              }
            }
            if (obj.hasOwnProperty(p2 = "RANGE")) {
              v2 = obj[p2];
              if (v2 && v2.pop) {
                intCheck(v2[0], -MAX, -1, p2);
                intCheck(v2[1], 1, MAX, p2);
                MIN_EXP = v2[0];
                MAX_EXP = v2[1];
              } else {
                intCheck(v2, -MAX, MAX, p2);
                if (v2) {
                  MIN_EXP = -(MAX_EXP = v2 < 0 ? -v2 : v2);
                } else {
                  throw Error(bignumberError + p2 + " cannot be zero: " + v2);
                }
              }
            }
            if (obj.hasOwnProperty(p2 = "CRYPTO")) {
              v2 = obj[p2];
              if (v2 === !!v2) {
                if (v2) {
                  if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                    CRYPTO = v2;
                  } else {
                    CRYPTO = !v2;
                    throw Error(bignumberError + "crypto unavailable");
                  }
                } else {
                  CRYPTO = v2;
                }
              } else {
                throw Error(bignumberError + p2 + " not true or false: " + v2);
              }
            }
            if (obj.hasOwnProperty(p2 = "MODULO_MODE")) {
              v2 = obj[p2];
              intCheck(v2, 0, 9, p2);
              MODULO_MODE = v2;
            }
            if (obj.hasOwnProperty(p2 = "POW_PRECISION")) {
              v2 = obj[p2];
              intCheck(v2, 0, MAX, p2);
              POW_PRECISION = v2;
            }
            if (obj.hasOwnProperty(p2 = "FORMAT")) {
              v2 = obj[p2];
              if (typeof v2 == "object")
                FORMAT = v2;
              else
                throw Error(bignumberError + p2 + " not an object: " + v2);
            }
            if (obj.hasOwnProperty(p2 = "ALPHABET")) {
              v2 = obj[p2];
              if (typeof v2 == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v2)) {
                alphabetHasNormalDecimalDigits = v2.slice(0, 10) == "0123456789";
                ALPHABET = v2;
              } else {
                throw Error(bignumberError + p2 + " invalid: " + v2);
              }
            }
          } else {
            throw Error(bignumberError + "Object expected: " + obj);
          }
        }
        return {
          DECIMAL_PLACES,
          ROUNDING_MODE,
          EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
          RANGE: [MIN_EXP, MAX_EXP],
          CRYPTO,
          MODULO_MODE,
          POW_PRECISION,
          FORMAT,
          ALPHABET
        };
      };
      BigNumber2.isBigNumber = function(v2) {
        if (!v2 || v2._isBigNumber !== true)
          return false;
        if (!BigNumber2.DEBUG)
          return true;
        var i2, n2, c2 = v2.c, e2 = v2.e, s = v2.s;
        out:
          if ({}.toString.call(c2) == "[object Array]") {
            if ((s === 1 || s === -1) && e2 >= -MAX && e2 <= MAX && e2 === mathfloor(e2)) {
              if (c2[0] === 0) {
                if (e2 === 0 && c2.length === 1)
                  return true;
                break out;
              }
              i2 = (e2 + 1) % LOG_BASE;
              if (i2 < 1)
                i2 += LOG_BASE;
              if (String(c2[0]).length == i2) {
                for (i2 = 0; i2 < c2.length; i2++) {
                  n2 = c2[i2];
                  if (n2 < 0 || n2 >= BASE || n2 !== mathfloor(n2))
                    break out;
                }
                if (n2 !== 0)
                  return true;
              }
            }
          } else if (c2 === null && e2 === null && (s === null || s === 1 || s === -1)) {
            return true;
          }
        throw Error(bignumberError + "Invalid BigNumber: " + v2);
      };
      BigNumber2.maximum = BigNumber2.max = function() {
        return maxOrMin(arguments, P2.lt);
      };
      BigNumber2.minimum = BigNumber2.min = function() {
        return maxOrMin(arguments, P2.gt);
      };
      BigNumber2.random = function() {
        var pow2_53 = 9007199254740992;
        var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
          return mathfloor(Math.random() * pow2_53);
        } : function() {
          return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
        };
        return function(dp) {
          var a, b2, e2, k2, v2, i2 = 0, c2 = [], rand = new BigNumber2(ONE);
          if (dp == null)
            dp = DECIMAL_PLACES;
          else
            intCheck(dp, 0, MAX);
          k2 = mathceil(dp / LOG_BASE);
          if (CRYPTO) {
            if (crypto.getRandomValues) {
              a = crypto.getRandomValues(new Uint32Array(k2 *= 2));
              for (; i2 < k2; ) {
                v2 = a[i2] * 131072 + (a[i2 + 1] >>> 11);
                if (v2 >= 9e15) {
                  b2 = crypto.getRandomValues(new Uint32Array(2));
                  a[i2] = b2[0];
                  a[i2 + 1] = b2[1];
                } else {
                  c2.push(v2 % 1e14);
                  i2 += 2;
                }
              }
              i2 = k2 / 2;
            } else if (crypto.randomBytes) {
              a = crypto.randomBytes(k2 *= 7);
              for (; i2 < k2; ) {
                v2 = (a[i2] & 31) * 281474976710656 + a[i2 + 1] * 1099511627776 + a[i2 + 2] * 4294967296 + a[i2 + 3] * 16777216 + (a[i2 + 4] << 16) + (a[i2 + 5] << 8) + a[i2 + 6];
                if (v2 >= 9e15) {
                  crypto.randomBytes(7).copy(a, i2);
                } else {
                  c2.push(v2 % 1e14);
                  i2 += 7;
                }
              }
              i2 = k2 / 7;
            } else {
              CRYPTO = false;
              throw Error(bignumberError + "crypto unavailable");
            }
          }
          if (!CRYPTO) {
            for (; i2 < k2; ) {
              v2 = random53bitInt();
              if (v2 < 9e15)
                c2[i2++] = v2 % 1e14;
            }
          }
          k2 = c2[--i2];
          dp %= LOG_BASE;
          if (k2 && dp) {
            v2 = POWS_TEN[LOG_BASE - dp];
            c2[i2] = mathfloor(k2 / v2) * v2;
          }
          for (; c2[i2] === 0; c2.pop(), i2--)
            ;
          if (i2 < 0) {
            c2 = [e2 = 0];
          } else {
            for (e2 = -1; c2[0] === 0; c2.splice(0, 1), e2 -= LOG_BASE)
              ;
            for (i2 = 1, v2 = c2[0]; v2 >= 10; v2 /= 10, i2++)
              ;
            if (i2 < LOG_BASE)
              e2 -= LOG_BASE - i2;
          }
          rand.e = e2;
          rand.c = c2;
          return rand;
        };
      }();
      BigNumber2.sum = function() {
        var i2 = 1, args = arguments, sum = new BigNumber2(args[0]);
        for (; i2 < args.length; )
          sum = sum.plus(args[i2++]);
        return sum;
      };
      convertBase = function() {
        var decimal = "0123456789";
        function toBaseOut(str, baseIn, baseOut, alphabet2) {
          var j, arr = [0], arrL, i2 = 0, len2 = str.length;
          for (; i2 < len2; ) {
            for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
              ;
            arr[0] += alphabet2.indexOf(str.charAt(i2++));
            for (j = 0; j < arr.length; j++) {
              if (arr[j] > baseOut - 1) {
                if (arr[j + 1] == null)
                  arr[j + 1] = 0;
                arr[j + 1] += arr[j] / baseOut | 0;
                arr[j] %= baseOut;
              }
            }
          }
          return arr.reverse();
        }
        return function(str, baseIn, baseOut, sign, callerIsToString) {
          var alphabet2, d2, e2, k2, r2, x2, xc2, y2, i2 = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
          if (i2 >= 0) {
            k2 = POW_PRECISION;
            POW_PRECISION = 0;
            str = str.replace(".", "");
            y2 = new BigNumber2(baseIn);
            x2 = y2.pow(str.length - i2);
            POW_PRECISION = k2;
            y2.c = toBaseOut(
              toFixedPoint(coeffToString(x2.c), x2.e, "0"),
              10,
              baseOut,
              decimal
            );
            y2.e = y2.c.length;
          }
          xc2 = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet2 = ALPHABET, decimal) : (alphabet2 = decimal, ALPHABET));
          e2 = k2 = xc2.length;
          for (; xc2[--k2] == 0; xc2.pop())
            ;
          if (!xc2[0])
            return alphabet2.charAt(0);
          if (i2 < 0) {
            --e2;
          } else {
            x2.c = xc2;
            x2.e = e2;
            x2.s = sign;
            x2 = div(x2, y2, dp, rm, baseOut);
            xc2 = x2.c;
            r2 = x2.r;
            e2 = x2.e;
          }
          d2 = e2 + dp + 1;
          i2 = xc2[d2];
          k2 = baseOut / 2;
          r2 = r2 || d2 < 0 || xc2[d2 + 1] != null;
          r2 = rm < 4 ? (i2 != null || r2) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : i2 > k2 || i2 == k2 && (rm == 4 || r2 || rm == 6 && xc2[d2 - 1] & 1 || rm == (x2.s < 0 ? 8 : 7));
          if (d2 < 1 || !xc2[0]) {
            str = r2 ? toFixedPoint(alphabet2.charAt(1), -dp, alphabet2.charAt(0)) : alphabet2.charAt(0);
          } else {
            xc2.length = d2;
            if (r2) {
              for (--baseOut; ++xc2[--d2] > baseOut; ) {
                xc2[d2] = 0;
                if (!d2) {
                  ++e2;
                  xc2 = [1].concat(xc2);
                }
              }
            }
            for (k2 = xc2.length; !xc2[--k2]; )
              ;
            for (i2 = 0, str = ""; i2 <= k2; str += alphabet2.charAt(xc2[i2++]))
              ;
            str = toFixedPoint(str, e2, alphabet2.charAt(0));
          }
          return str;
        };
      }();
      div = function() {
        function multiply(x2, k2, base) {
          var m2, temp, xlo, xhi, carry = 0, i2 = x2.length, klo = k2 % SQRT_BASE, khi = k2 / SQRT_BASE | 0;
          for (x2 = x2.slice(); i2--; ) {
            xlo = x2[i2] % SQRT_BASE;
            xhi = x2[i2] / SQRT_BASE | 0;
            m2 = khi * xlo + xhi * klo;
            temp = klo * xlo + m2 % SQRT_BASE * SQRT_BASE + carry;
            carry = (temp / base | 0) + (m2 / SQRT_BASE | 0) + khi * xhi;
            x2[i2] = temp % base;
          }
          if (carry)
            x2 = [carry].concat(x2);
          return x2;
        }
        function compare3(a, b2, aL, bL) {
          var i2, cmp;
          if (aL != bL) {
            cmp = aL > bL ? 1 : -1;
          } else {
            for (i2 = cmp = 0; i2 < aL; i2++) {
              if (a[i2] != b2[i2]) {
                cmp = a[i2] > b2[i2] ? 1 : -1;
                break;
              }
            }
          }
          return cmp;
        }
        function subtract2(a, b2, aL, base) {
          var i2 = 0;
          for (; aL--; ) {
            a[aL] -= i2;
            i2 = a[aL] < b2[aL] ? 1 : 0;
            a[aL] = i2 * base + a[aL] - b2[aL];
          }
          for (; !a[0] && a.length > 1; a.splice(0, 1))
            ;
        }
        return function(x2, y2, dp, rm, base) {
          var cmp, e2, i2, more, n2, prod, prodL, q2, qc2, rem, remL, rem0, xi2, xL, yc0, yL, yz, s = x2.s == y2.s ? 1 : -1, xc2 = x2.c, yc2 = y2.c;
          if (!xc2 || !xc2[0] || !yc2 || !yc2[0]) {
            return new BigNumber2(
              !x2.s || !y2.s || (xc2 ? yc2 && xc2[0] == yc2[0] : !yc2) ? NaN : xc2 && xc2[0] == 0 || !yc2 ? s * 0 : s / 0
            );
          }
          q2 = new BigNumber2(s);
          qc2 = q2.c = [];
          e2 = x2.e - y2.e;
          s = dp + e2 + 1;
          if (!base) {
            base = BASE;
            e2 = bitFloor(x2.e / LOG_BASE) - bitFloor(y2.e / LOG_BASE);
            s = s / LOG_BASE | 0;
          }
          for (i2 = 0; yc2[i2] == (xc2[i2] || 0); i2++)
            ;
          if (yc2[i2] > (xc2[i2] || 0))
            e2--;
          if (s < 0) {
            qc2.push(1);
            more = true;
          } else {
            xL = xc2.length;
            yL = yc2.length;
            i2 = 0;
            s += 2;
            n2 = mathfloor(base / (yc2[0] + 1));
            if (n2 > 1) {
              yc2 = multiply(yc2, n2, base);
              xc2 = multiply(xc2, n2, base);
              yL = yc2.length;
              xL = xc2.length;
            }
            xi2 = yL;
            rem = xc2.slice(0, yL);
            remL = rem.length;
            for (; remL < yL; rem[remL++] = 0)
              ;
            yz = yc2.slice();
            yz = [0].concat(yz);
            yc0 = yc2[0];
            if (yc2[1] >= base / 2)
              yc0++;
            do {
              n2 = 0;
              cmp = compare3(yc2, rem, yL, remL);
              if (cmp < 0) {
                rem0 = rem[0];
                if (yL != remL)
                  rem0 = rem0 * base + (rem[1] || 0);
                n2 = mathfloor(rem0 / yc0);
                if (n2 > 1) {
                  if (n2 >= base)
                    n2 = base - 1;
                  prod = multiply(yc2, n2, base);
                  prodL = prod.length;
                  remL = rem.length;
                  while (compare3(prod, rem, prodL, remL) == 1) {
                    n2--;
                    subtract2(prod, yL < prodL ? yz : yc2, prodL, base);
                    prodL = prod.length;
                    cmp = 1;
                  }
                } else {
                  if (n2 == 0) {
                    cmp = n2 = 1;
                  }
                  prod = yc2.slice();
                  prodL = prod.length;
                }
                if (prodL < remL)
                  prod = [0].concat(prod);
                subtract2(rem, prod, remL, base);
                remL = rem.length;
                if (cmp == -1) {
                  while (compare3(yc2, rem, yL, remL) < 1) {
                    n2++;
                    subtract2(rem, yL < remL ? yz : yc2, remL, base);
                    remL = rem.length;
                  }
                }
              } else if (cmp === 0) {
                n2++;
                rem = [0];
              }
              qc2[i2++] = n2;
              if (rem[0]) {
                rem[remL++] = xc2[xi2] || 0;
              } else {
                rem = [xc2[xi2]];
                remL = 1;
              }
            } while ((xi2++ < xL || rem[0] != null) && s--);
            more = rem[0] != null;
            if (!qc2[0])
              qc2.splice(0, 1);
          }
          if (base == BASE) {
            for (i2 = 1, s = qc2[0]; s >= 10; s /= 10, i2++)
              ;
            round2(q2, dp + (q2.e = i2 + e2 * LOG_BASE - 1) + 1, rm, more);
          } else {
            q2.e = e2;
            q2.r = +more;
          }
          return q2;
        };
      }();
      function format2(n2, i2, rm, id2) {
        var c0, e2, ne2, len2, str;
        if (rm == null)
          rm = ROUNDING_MODE;
        else
          intCheck(rm, 0, 8);
        if (!n2.c)
          return n2.toString();
        c0 = n2.c[0];
        ne2 = n2.e;
        if (i2 == null) {
          str = coeffToString(n2.c);
          str = id2 == 1 || id2 == 2 && (ne2 <= TO_EXP_NEG || ne2 >= TO_EXP_POS) ? toExponential(str, ne2) : toFixedPoint(str, ne2, "0");
        } else {
          n2 = round2(new BigNumber2(n2), i2, rm);
          e2 = n2.e;
          str = coeffToString(n2.c);
          len2 = str.length;
          if (id2 == 1 || id2 == 2 && (i2 <= e2 || e2 <= TO_EXP_NEG)) {
            for (; len2 < i2; str += "0", len2++)
              ;
            str = toExponential(str, e2);
          } else {
            i2 -= ne2;
            str = toFixedPoint(str, e2, "0");
            if (e2 + 1 > len2) {
              if (--i2 > 0)
                for (str += "."; i2--; str += "0")
                  ;
            } else {
              i2 += e2 - len2;
              if (i2 > 0) {
                if (e2 + 1 == len2)
                  str += ".";
                for (; i2--; str += "0")
                  ;
              }
            }
          }
        }
        return n2.s < 0 && c0 ? "-" + str : str;
      }
      function maxOrMin(args, method2) {
        var n2, i2 = 1, m2 = new BigNumber2(args[0]);
        for (; i2 < args.length; i2++) {
          n2 = new BigNumber2(args[i2]);
          if (!n2.s) {
            m2 = n2;
            break;
          } else if (method2.call(m2, n2)) {
            m2 = n2;
          }
        }
        return m2;
      }
      function normalise(n2, c2, e2) {
        var i2 = 1, j = c2.length;
        for (; !c2[--j]; c2.pop())
          ;
        for (j = c2[0]; j >= 10; j /= 10, i2++)
          ;
        if ((e2 = i2 + e2 * LOG_BASE - 1) > MAX_EXP) {
          n2.c = n2.e = null;
        } else if (e2 < MIN_EXP) {
          n2.c = [n2.e = 0];
        } else {
          n2.e = e2;
          n2.c = c2;
        }
        return n2;
      }
      parseNumeric = function() {
        var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function(x2, str, isNum, b2) {
          var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
          if (isInfinityOrNaN.test(s)) {
            x2.s = isNaN(s) ? null : s < 0 ? -1 : 1;
          } else {
            if (!isNum) {
              s = s.replace(basePrefix, function(m2, p1, p2) {
                base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                return !b2 || b2 == base ? p1 : m2;
              });
              if (b2) {
                base = b2;
                s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
              }
              if (str != s)
                return new BigNumber2(s, base);
            }
            if (BigNumber2.DEBUG) {
              throw Error(bignumberError + "Not a" + (b2 ? " base " + b2 : "") + " number: " + str);
            }
            x2.s = null;
          }
          x2.c = x2.e = null;
        };
      }();
      function round2(x2, sd2, rm, r2) {
        var d2, i2, j, k2, n2, ni2, rd2, xc2 = x2.c, pows10 = POWS_TEN;
        if (xc2) {
          out: {
            for (d2 = 1, k2 = xc2[0]; k2 >= 10; k2 /= 10, d2++)
              ;
            i2 = sd2 - d2;
            if (i2 < 0) {
              i2 += LOG_BASE;
              j = sd2;
              n2 = xc2[ni2 = 0];
              rd2 = n2 / pows10[d2 - j - 1] % 10 | 0;
            } else {
              ni2 = mathceil((i2 + 1) / LOG_BASE);
              if (ni2 >= xc2.length) {
                if (r2) {
                  for (; xc2.length <= ni2; xc2.push(0))
                    ;
                  n2 = rd2 = 0;
                  d2 = 1;
                  i2 %= LOG_BASE;
                  j = i2 - LOG_BASE + 1;
                } else {
                  break out;
                }
              } else {
                n2 = k2 = xc2[ni2];
                for (d2 = 1; k2 >= 10; k2 /= 10, d2++)
                  ;
                i2 %= LOG_BASE;
                j = i2 - LOG_BASE + d2;
                rd2 = j < 0 ? 0 : n2 / pows10[d2 - j - 1] % 10 | 0;
              }
            }
            r2 = r2 || sd2 < 0 || xc2[ni2 + 1] != null || (j < 0 ? n2 : n2 % pows10[d2 - j - 1]);
            r2 = rm < 4 ? (rd2 || r2) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : rd2 > 5 || rd2 == 5 && (rm == 4 || r2 || rm == 6 && (i2 > 0 ? j > 0 ? n2 / pows10[d2 - j] : 0 : xc2[ni2 - 1]) % 10 & 1 || rm == (x2.s < 0 ? 8 : 7));
            if (sd2 < 1 || !xc2[0]) {
              xc2.length = 0;
              if (r2) {
                sd2 -= x2.e + 1;
                xc2[0] = pows10[(LOG_BASE - sd2 % LOG_BASE) % LOG_BASE];
                x2.e = -sd2 || 0;
              } else {
                xc2[0] = x2.e = 0;
              }
              return x2;
            }
            if (i2 == 0) {
              xc2.length = ni2;
              k2 = 1;
              ni2--;
            } else {
              xc2.length = ni2 + 1;
              k2 = pows10[LOG_BASE - i2];
              xc2[ni2] = j > 0 ? mathfloor(n2 / pows10[d2 - j] % pows10[j]) * k2 : 0;
            }
            if (r2) {
              for (; ; ) {
                if (ni2 == 0) {
                  for (i2 = 1, j = xc2[0]; j >= 10; j /= 10, i2++)
                    ;
                  j = xc2[0] += k2;
                  for (k2 = 1; j >= 10; j /= 10, k2++)
                    ;
                  if (i2 != k2) {
                    x2.e++;
                    if (xc2[0] == BASE)
                      xc2[0] = 1;
                  }
                  break;
                } else {
                  xc2[ni2] += k2;
                  if (xc2[ni2] != BASE)
                    break;
                  xc2[ni2--] = 0;
                  k2 = 1;
                }
              }
            }
            for (i2 = xc2.length; xc2[--i2] === 0; xc2.pop())
              ;
          }
          if (x2.e > MAX_EXP) {
            x2.c = x2.e = null;
          } else if (x2.e < MIN_EXP) {
            x2.c = [x2.e = 0];
          }
        }
        return x2;
      }
      function valueOf(n2) {
        var str, e2 = n2.e;
        if (e2 === null)
          return n2.toString();
        str = coeffToString(n2.c);
        str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(str, e2) : toFixedPoint(str, e2, "0");
        return n2.s < 0 ? "-" + str : str;
      }
      P2.absoluteValue = P2.abs = function() {
        var x2 = new BigNumber2(this);
        if (x2.s < 0)
          x2.s = 1;
        return x2;
      };
      P2.comparedTo = function(y2, b2) {
        return compare2(this, new BigNumber2(y2, b2));
      };
      P2.decimalPlaces = P2.dp = function(dp, rm) {
        var c2, n2, v2, x2 = this;
        if (dp != null) {
          intCheck(dp, 0, MAX);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round2(new BigNumber2(x2), dp + x2.e + 1, rm);
        }
        if (!(c2 = x2.c))
          return null;
        n2 = ((v2 = c2.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
        if (v2 = c2[v2])
          for (; v2 % 10 == 0; v2 /= 10, n2--)
            ;
        if (n2 < 0)
          n2 = 0;
        return n2;
      };
      P2.dividedBy = P2.div = function(y2, b2) {
        return div(this, new BigNumber2(y2, b2), DECIMAL_PLACES, ROUNDING_MODE);
      };
      P2.dividedToIntegerBy = P2.idiv = function(y2, b2) {
        return div(this, new BigNumber2(y2, b2), 0, 1);
      };
      P2.exponentiatedBy = P2.pow = function(n2, m2) {
        var half, isModExp, i2, k2, more, nIsBig, nIsNeg, nIsOdd, y2, x2 = this;
        n2 = new BigNumber2(n2);
        if (n2.c && !n2.isInteger()) {
          throw Error(bignumberError + "Exponent not an integer: " + valueOf(n2));
        }
        if (m2 != null)
          m2 = new BigNumber2(m2);
        nIsBig = n2.e > 14;
        if (!x2.c || !x2.c[0] || x2.c[0] == 1 && !x2.e && x2.c.length == 1 || !n2.c || !n2.c[0]) {
          y2 = new BigNumber2(Math.pow(+valueOf(x2), nIsBig ? 2 - isOdd(n2) : +valueOf(n2)));
          return m2 ? y2.mod(m2) : y2;
        }
        nIsNeg = n2.s < 0;
        if (m2) {
          if (m2.c ? !m2.c[0] : !m2.s)
            return new BigNumber2(NaN);
          isModExp = !nIsNeg && x2.isInteger() && m2.isInteger();
          if (isModExp)
            x2 = x2.mod(m2);
        } else if (n2.e > 9 && (x2.e > 0 || x2.e < -1 || (x2.e == 0 ? x2.c[0] > 1 || nIsBig && x2.c[1] >= 24e7 : x2.c[0] < 8e13 || nIsBig && x2.c[0] <= 9999975e7))) {
          k2 = x2.s < 0 && isOdd(n2) ? -0 : 0;
          if (x2.e > -1)
            k2 = 1 / k2;
          return new BigNumber2(nIsNeg ? 1 / k2 : k2);
        } else if (POW_PRECISION) {
          k2 = mathceil(POW_PRECISION / LOG_BASE + 2);
        }
        if (nIsBig) {
          half = new BigNumber2(0.5);
          if (nIsNeg)
            n2.s = 1;
          nIsOdd = isOdd(n2);
        } else {
          i2 = Math.abs(+valueOf(n2));
          nIsOdd = i2 % 2;
        }
        y2 = new BigNumber2(ONE);
        for (; ; ) {
          if (nIsOdd) {
            y2 = y2.times(x2);
            if (!y2.c)
              break;
            if (k2) {
              if (y2.c.length > k2)
                y2.c.length = k2;
            } else if (isModExp) {
              y2 = y2.mod(m2);
            }
          }
          if (i2) {
            i2 = mathfloor(i2 / 2);
            if (i2 === 0)
              break;
            nIsOdd = i2 % 2;
          } else {
            n2 = n2.times(half);
            round2(n2, n2.e + 1, 1);
            if (n2.e > 14) {
              nIsOdd = isOdd(n2);
            } else {
              i2 = +valueOf(n2);
              if (i2 === 0)
                break;
              nIsOdd = i2 % 2;
            }
          }
          x2 = x2.times(x2);
          if (k2) {
            if (x2.c && x2.c.length > k2)
              x2.c.length = k2;
          } else if (isModExp) {
            x2 = x2.mod(m2);
          }
        }
        if (isModExp)
          return y2;
        if (nIsNeg)
          y2 = ONE.div(y2);
        return m2 ? y2.mod(m2) : k2 ? round2(y2, POW_PRECISION, ROUNDING_MODE, more) : y2;
      };
      P2.integerValue = function(rm) {
        var n2 = new BigNumber2(this);
        if (rm == null)
          rm = ROUNDING_MODE;
        else
          intCheck(rm, 0, 8);
        return round2(n2, n2.e + 1, rm);
      };
      P2.isEqualTo = P2.eq = function(y2, b2) {
        return compare2(this, new BigNumber2(y2, b2)) === 0;
      };
      P2.isFinite = function() {
        return !!this.c;
      };
      P2.isGreaterThan = P2.gt = function(y2, b2) {
        return compare2(this, new BigNumber2(y2, b2)) > 0;
      };
      P2.isGreaterThanOrEqualTo = P2.gte = function(y2, b2) {
        return (b2 = compare2(this, new BigNumber2(y2, b2))) === 1 || b2 === 0;
      };
      P2.isInteger = function() {
        return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
      };
      P2.isLessThan = P2.lt = function(y2, b2) {
        return compare2(this, new BigNumber2(y2, b2)) < 0;
      };
      P2.isLessThanOrEqualTo = P2.lte = function(y2, b2) {
        return (b2 = compare2(this, new BigNumber2(y2, b2))) === -1 || b2 === 0;
      };
      P2.isNaN = function() {
        return !this.s;
      };
      P2.isNegative = function() {
        return this.s < 0;
      };
      P2.isPositive = function() {
        return this.s > 0;
      };
      P2.isZero = function() {
        return !!this.c && this.c[0] == 0;
      };
      P2.minus = function(y2, b2) {
        var i2, j, t2, xLTy, x2 = this, a = x2.s;
        y2 = new BigNumber2(y2, b2);
        b2 = y2.s;
        if (!a || !b2)
          return new BigNumber2(NaN);
        if (a != b2) {
          y2.s = -b2;
          return x2.plus(y2);
        }
        var xe2 = x2.e / LOG_BASE, ye2 = y2.e / LOG_BASE, xc2 = x2.c, yc2 = y2.c;
        if (!xe2 || !ye2) {
          if (!xc2 || !yc2)
            return xc2 ? (y2.s = -b2, y2) : new BigNumber2(yc2 ? x2 : NaN);
          if (!xc2[0] || !yc2[0]) {
            return yc2[0] ? (y2.s = -b2, y2) : new BigNumber2(xc2[0] ? x2 : ROUNDING_MODE == 3 ? -0 : 0);
          }
        }
        xe2 = bitFloor(xe2);
        ye2 = bitFloor(ye2);
        xc2 = xc2.slice();
        if (a = xe2 - ye2) {
          if (xLTy = a < 0) {
            a = -a;
            t2 = xc2;
          } else {
            ye2 = xe2;
            t2 = yc2;
          }
          t2.reverse();
          for (b2 = a; b2--; t2.push(0))
            ;
          t2.reverse();
        } else {
          j = (xLTy = (a = xc2.length) < (b2 = yc2.length)) ? a : b2;
          for (a = b2 = 0; b2 < j; b2++) {
            if (xc2[b2] != yc2[b2]) {
              xLTy = xc2[b2] < yc2[b2];
              break;
            }
          }
        }
        if (xLTy) {
          t2 = xc2;
          xc2 = yc2;
          yc2 = t2;
          y2.s = -y2.s;
        }
        b2 = (j = yc2.length) - (i2 = xc2.length);
        if (b2 > 0)
          for (; b2--; xc2[i2++] = 0)
            ;
        b2 = BASE - 1;
        for (; j > a; ) {
          if (xc2[--j] < yc2[j]) {
            for (i2 = j; i2 && !xc2[--i2]; xc2[i2] = b2)
              ;
            --xc2[i2];
            xc2[j] += BASE;
          }
          xc2[j] -= yc2[j];
        }
        for (; xc2[0] == 0; xc2.splice(0, 1), --ye2)
          ;
        if (!xc2[0]) {
          y2.s = ROUNDING_MODE == 3 ? -1 : 1;
          y2.c = [y2.e = 0];
          return y2;
        }
        return normalise(y2, xc2, ye2);
      };
      P2.modulo = P2.mod = function(y2, b2) {
        var q2, s, x2 = this;
        y2 = new BigNumber2(y2, b2);
        if (!x2.c || !y2.s || y2.c && !y2.c[0]) {
          return new BigNumber2(NaN);
        } else if (!y2.c || x2.c && !x2.c[0]) {
          return new BigNumber2(x2);
        }
        if (MODULO_MODE == 9) {
          s = y2.s;
          y2.s = 1;
          q2 = div(x2, y2, 0, 3);
          y2.s = s;
          q2.s *= s;
        } else {
          q2 = div(x2, y2, 0, MODULO_MODE);
        }
        y2 = x2.minus(q2.times(y2));
        if (!y2.c[0] && MODULO_MODE == 1)
          y2.s = x2.s;
        return y2;
      };
      P2.multipliedBy = P2.times = function(y2, b2) {
        var c2, e2, i2, j, k2, m2, xcL, xlo, xhi, ycL, ylo, yhi, zc2, base, sqrtBase, x2 = this, xc2 = x2.c, yc2 = (y2 = new BigNumber2(y2, b2)).c;
        if (!xc2 || !yc2 || !xc2[0] || !yc2[0]) {
          if (!x2.s || !y2.s || xc2 && !xc2[0] && !yc2 || yc2 && !yc2[0] && !xc2) {
            y2.c = y2.e = y2.s = null;
          } else {
            y2.s *= x2.s;
            if (!xc2 || !yc2) {
              y2.c = y2.e = null;
            } else {
              y2.c = [0];
              y2.e = 0;
            }
          }
          return y2;
        }
        e2 = bitFloor(x2.e / LOG_BASE) + bitFloor(y2.e / LOG_BASE);
        y2.s *= x2.s;
        xcL = xc2.length;
        ycL = yc2.length;
        if (xcL < ycL) {
          zc2 = xc2;
          xc2 = yc2;
          yc2 = zc2;
          i2 = xcL;
          xcL = ycL;
          ycL = i2;
        }
        for (i2 = xcL + ycL, zc2 = []; i2--; zc2.push(0))
          ;
        base = BASE;
        sqrtBase = SQRT_BASE;
        for (i2 = ycL; --i2 >= 0; ) {
          c2 = 0;
          ylo = yc2[i2] % sqrtBase;
          yhi = yc2[i2] / sqrtBase | 0;
          for (k2 = xcL, j = i2 + k2; j > i2; ) {
            xlo = xc2[--k2] % sqrtBase;
            xhi = xc2[k2] / sqrtBase | 0;
            m2 = yhi * xlo + xhi * ylo;
            xlo = ylo * xlo + m2 % sqrtBase * sqrtBase + zc2[j] + c2;
            c2 = (xlo / base | 0) + (m2 / sqrtBase | 0) + yhi * xhi;
            zc2[j--] = xlo % base;
          }
          zc2[j] = c2;
        }
        if (c2) {
          ++e2;
        } else {
          zc2.splice(0, 1);
        }
        return normalise(y2, zc2, e2);
      };
      P2.negated = function() {
        var x2 = new BigNumber2(this);
        x2.s = -x2.s || null;
        return x2;
      };
      P2.plus = function(y2, b2) {
        var t2, x2 = this, a = x2.s;
        y2 = new BigNumber2(y2, b2);
        b2 = y2.s;
        if (!a || !b2)
          return new BigNumber2(NaN);
        if (a != b2) {
          y2.s = -b2;
          return x2.minus(y2);
        }
        var xe2 = x2.e / LOG_BASE, ye2 = y2.e / LOG_BASE, xc2 = x2.c, yc2 = y2.c;
        if (!xe2 || !ye2) {
          if (!xc2 || !yc2)
            return new BigNumber2(a / 0);
          if (!xc2[0] || !yc2[0])
            return yc2[0] ? y2 : new BigNumber2(xc2[0] ? x2 : a * 0);
        }
        xe2 = bitFloor(xe2);
        ye2 = bitFloor(ye2);
        xc2 = xc2.slice();
        if (a = xe2 - ye2) {
          if (a > 0) {
            ye2 = xe2;
            t2 = yc2;
          } else {
            a = -a;
            t2 = xc2;
          }
          t2.reverse();
          for (; a--; t2.push(0))
            ;
          t2.reverse();
        }
        a = xc2.length;
        b2 = yc2.length;
        if (a - b2 < 0) {
          t2 = yc2;
          yc2 = xc2;
          xc2 = t2;
          b2 = a;
        }
        for (a = 0; b2; ) {
          a = (xc2[--b2] = xc2[b2] + yc2[b2] + a) / BASE | 0;
          xc2[b2] = BASE === xc2[b2] ? 0 : xc2[b2] % BASE;
        }
        if (a) {
          xc2 = [a].concat(xc2);
          ++ye2;
        }
        return normalise(y2, xc2, ye2);
      };
      P2.precision = P2.sd = function(sd2, rm) {
        var c2, n2, v2, x2 = this;
        if (sd2 != null && sd2 !== !!sd2) {
          intCheck(sd2, 1, MAX);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round2(new BigNumber2(x2), sd2, rm);
        }
        if (!(c2 = x2.c))
          return null;
        v2 = c2.length - 1;
        n2 = v2 * LOG_BASE + 1;
        if (v2 = c2[v2]) {
          for (; v2 % 10 == 0; v2 /= 10, n2--)
            ;
          for (v2 = c2[0]; v2 >= 10; v2 /= 10, n2++)
            ;
        }
        if (sd2 && x2.e + 1 > n2)
          n2 = x2.e + 1;
        return n2;
      };
      P2.shiftedBy = function(k2) {
        intCheck(k2, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
        return this.times("1e" + k2);
      };
      P2.squareRoot = P2.sqrt = function() {
        var m2, n2, r2, rep, t2, x2 = this, c2 = x2.c, s = x2.s, e2 = x2.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
        if (s !== 1 || !c2 || !c2[0]) {
          return new BigNumber2(!s || s < 0 && (!c2 || c2[0]) ? NaN : c2 ? x2 : 1 / 0);
        }
        s = Math.sqrt(+valueOf(x2));
        if (s == 0 || s == 1 / 0) {
          n2 = coeffToString(c2);
          if ((n2.length + e2) % 2 == 0)
            n2 += "0";
          s = Math.sqrt(+n2);
          e2 = bitFloor((e2 + 1) / 2) - (e2 < 0 || e2 % 2);
          if (s == 1 / 0) {
            n2 = "5e" + e2;
          } else {
            n2 = s.toExponential();
            n2 = n2.slice(0, n2.indexOf("e") + 1) + e2;
          }
          r2 = new BigNumber2(n2);
        } else {
          r2 = new BigNumber2(s + "");
        }
        if (r2.c[0]) {
          e2 = r2.e;
          s = e2 + dp;
          if (s < 3)
            s = 0;
          for (; ; ) {
            t2 = r2;
            r2 = half.times(t2.plus(div(x2, t2, dp, 1)));
            if (coeffToString(t2.c).slice(0, s) === (n2 = coeffToString(r2.c)).slice(0, s)) {
              if (r2.e < e2)
                --s;
              n2 = n2.slice(s - 3, s + 1);
              if (n2 == "9999" || !rep && n2 == "4999") {
                if (!rep) {
                  round2(t2, t2.e + DECIMAL_PLACES + 2, 0);
                  if (t2.times(t2).eq(x2)) {
                    r2 = t2;
                    break;
                  }
                }
                dp += 4;
                s += 4;
                rep = 1;
              } else {
                if (!+n2 || !+n2.slice(1) && n2.charAt(0) == "5") {
                  round2(r2, r2.e + DECIMAL_PLACES + 2, 1);
                  m2 = !r2.times(r2).eq(x2);
                }
                break;
              }
            }
          }
        }
        return round2(r2, r2.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m2);
      };
      P2.toExponential = function(dp, rm) {
        if (dp != null) {
          intCheck(dp, 0, MAX);
          dp++;
        }
        return format2(this, dp, rm, 1);
      };
      P2.toFixed = function(dp, rm) {
        if (dp != null) {
          intCheck(dp, 0, MAX);
          dp = dp + this.e + 1;
        }
        return format2(this, dp, rm);
      };
      P2.toFormat = function(dp, rm, format3) {
        var str, x2 = this;
        if (format3 == null) {
          if (dp != null && rm && typeof rm == "object") {
            format3 = rm;
            rm = null;
          } else if (dp && typeof dp == "object") {
            format3 = dp;
            dp = rm = null;
          } else {
            format3 = FORMAT;
          }
        } else if (typeof format3 != "object") {
          throw Error(bignumberError + "Argument not an object: " + format3);
        }
        str = x2.toFixed(dp, rm);
        if (x2.c) {
          var i2, arr = str.split("."), g1 = +format3.groupSize, g2 = +format3.secondaryGroupSize, groupSeparator = format3.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x2.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len2 = intDigits.length;
          if (g2) {
            i2 = g1;
            g1 = g2;
            g2 = i2;
            len2 -= i2;
          }
          if (g1 > 0 && len2 > 0) {
            i2 = len2 % g1 || g1;
            intPart = intDigits.substr(0, i2);
            for (; i2 < len2; i2 += g1)
              intPart += groupSeparator + intDigits.substr(i2, g1);
            if (g2 > 0)
              intPart += groupSeparator + intDigits.slice(i2);
            if (isNeg)
              intPart = "-" + intPart;
          }
          str = fractionPart ? intPart + (format3.decimalSeparator || "") + ((g2 = +format3.fractionGroupSize) ? fractionPart.replace(
            new RegExp("\\d{" + g2 + "}\\B", "g"),
            "$&" + (format3.fractionGroupSeparator || "")
          ) : fractionPart) : intPart;
        }
        return (format3.prefix || "") + str + (format3.suffix || "");
      };
      P2.toFraction = function(md2) {
        var d2, d0, d1, d22, e2, exp, n2, n0, n1, q2, r2, s, x2 = this, xc2 = x2.c;
        if (md2 != null) {
          n2 = new BigNumber2(md2);
          if (!n2.isInteger() && (n2.c || n2.s !== 1) || n2.lt(ONE)) {
            throw Error(bignumberError + "Argument " + (n2.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n2));
          }
        }
        if (!xc2)
          return new BigNumber2(x2);
        d2 = new BigNumber2(ONE);
        n1 = d0 = new BigNumber2(ONE);
        d1 = n0 = new BigNumber2(ONE);
        s = coeffToString(xc2);
        e2 = d2.e = s.length - x2.e - 1;
        d2.c[0] = POWS_TEN[(exp = e2 % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
        md2 = !md2 || n2.comparedTo(d2) > 0 ? e2 > 0 ? d2 : n1 : n2;
        exp = MAX_EXP;
        MAX_EXP = 1 / 0;
        n2 = new BigNumber2(s);
        n0.c[0] = 0;
        for (; ; ) {
          q2 = div(n2, d2, 0, 1);
          d22 = d0.plus(q2.times(d1));
          if (d22.comparedTo(md2) == 1)
            break;
          d0 = d1;
          d1 = d22;
          n1 = n0.plus(q2.times(d22 = n1));
          n0 = d22;
          d2 = n2.minus(q2.times(d22 = d2));
          n2 = d22;
        }
        d22 = div(md2.minus(d0), d1, 0, 1);
        n0 = n0.plus(d22.times(n1));
        d0 = d0.plus(d22.times(d1));
        n0.s = n1.s = x2.s;
        e2 = e2 * 2;
        r2 = div(n1, d1, e2, ROUNDING_MODE).minus(x2).abs().comparedTo(
          div(n0, d0, e2, ROUNDING_MODE).minus(x2).abs()
        ) < 1 ? [n1, d1] : [n0, d0];
        MAX_EXP = exp;
        return r2;
      };
      P2.toNumber = function() {
        return +valueOf(this);
      };
      P2.toPrecision = function(sd2, rm) {
        if (sd2 != null)
          intCheck(sd2, 1, MAX);
        return format2(this, sd2, rm, 2);
      };
      P2.toString = function(b2) {
        var str, n2 = this, s = n2.s, e2 = n2.e;
        if (e2 === null) {
          if (s) {
            str = "Infinity";
            if (s < 0)
              str = "-" + str;
          } else {
            str = "NaN";
          }
        } else {
          if (b2 == null) {
            str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(coeffToString(n2.c), e2) : toFixedPoint(coeffToString(n2.c), e2, "0");
          } else if (b2 === 10 && alphabetHasNormalDecimalDigits) {
            n2 = round2(new BigNumber2(n2), DECIMAL_PLACES + e2 + 1, ROUNDING_MODE);
            str = toFixedPoint(coeffToString(n2.c), n2.e, "0");
          } else {
            intCheck(b2, 2, ALPHABET.length, "Base");
            str = convertBase(toFixedPoint(coeffToString(n2.c), e2, "0"), 10, b2, s, true);
          }
          if (s < 0 && n2.c[0])
            str = "-" + str;
        }
        return str;
      };
      P2.valueOf = P2.toJSON = function() {
        return valueOf(this);
      };
      P2._isBigNumber = true;
      if (configObject != null)
        BigNumber2.set(configObject);
      return BigNumber2;
    }
    function bitFloor(n2) {
      var i2 = n2 | 0;
      return n2 > 0 || n2 === i2 ? i2 : i2 - 1;
    }
    function coeffToString(a) {
      var s, z2, i2 = 1, j = a.length, r2 = a[0] + "";
      for (; i2 < j; ) {
        s = a[i2++] + "";
        z2 = LOG_BASE - s.length;
        for (; z2--; s = "0" + s)
          ;
        r2 += s;
      }
      for (j = r2.length; r2.charCodeAt(--j) === 48; )
        ;
      return r2.slice(0, j + 1 || 1);
    }
    function compare2(x2, y2) {
      var a, b2, xc2 = x2.c, yc2 = y2.c, i2 = x2.s, j = y2.s, k2 = x2.e, l2 = y2.e;
      if (!i2 || !j)
        return null;
      a = xc2 && !xc2[0];
      b2 = yc2 && !yc2[0];
      if (a || b2)
        return a ? b2 ? 0 : -j : i2;
      if (i2 != j)
        return i2;
      a = i2 < 0;
      b2 = k2 == l2;
      if (!xc2 || !yc2)
        return b2 ? 0 : !xc2 ^ a ? 1 : -1;
      if (!b2)
        return k2 > l2 ^ a ? 1 : -1;
      j = (k2 = xc2.length) < (l2 = yc2.length) ? k2 : l2;
      for (i2 = 0; i2 < j; i2++)
        if (xc2[i2] != yc2[i2])
          return xc2[i2] > yc2[i2] ^ a ? 1 : -1;
      return k2 == l2 ? 0 : k2 > l2 ^ a ? 1 : -1;
    }
    function intCheck(n2, min, max, name) {
      if (n2 < min || n2 > max || n2 !== mathfloor(n2)) {
        throw Error(bignumberError + (name || "Argument") + (typeof n2 == "number" ? n2 < min || n2 > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n2));
      }
    }
    function isOdd(n2) {
      var k2 = n2.c.length - 1;
      return bitFloor(n2.e / LOG_BASE) == k2 && n2.c[k2] % 2 != 0;
    }
    function toExponential(str, e2) {
      return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e2 < 0 ? "e" : "e+") + e2;
    }
    function toFixedPoint(str, e2, z2) {
      var len2, zs;
      if (e2 < 0) {
        for (zs = z2 + "."; ++e2; zs += z2)
          ;
        str = zs + str;
      } else {
        len2 = str.length;
        if (++e2 > len2) {
          for (zs = z2, e2 -= len2; --e2; zs += z2)
            ;
          str += zs;
        } else if (e2 < len2) {
          str = str.slice(0, e2) + "." + str.slice(e2);
        }
      }
      return str;
    }
    BigNumber = clone2();
    BigNumber["default"] = BigNumber.BigNumber = BigNumber;
    if (module2.exports) {
      module2.exports = BigNumber;
    } else {
      if (!globalObject) {
        globalObject = typeof self != "undefined" && self ? self : window;
      }
      globalObject.BigNumber = BigNumber;
    }
  })(commonjsGlobal);
})(bignumber);
var decoder_asm = function decodeAsm(stdlib, foreign, buffer2) {
  ;
  var heap = new stdlib.Uint8Array(buffer2);
  var pushInt = foreign.pushInt;
  var pushInt32 = foreign.pushInt32;
  var pushInt32Neg = foreign.pushInt32Neg;
  var pushInt64 = foreign.pushInt64;
  var pushInt64Neg = foreign.pushInt64Neg;
  var pushFloat = foreign.pushFloat;
  var pushFloatSingle = foreign.pushFloatSingle;
  var pushFloatDouble = foreign.pushFloatDouble;
  var pushTrue = foreign.pushTrue;
  var pushFalse = foreign.pushFalse;
  var pushUndefined = foreign.pushUndefined;
  var pushNull = foreign.pushNull;
  var pushInfinity = foreign.pushInfinity;
  var pushInfinityNeg = foreign.pushInfinityNeg;
  var pushNaN = foreign.pushNaN;
  var pushNaNNeg = foreign.pushNaNNeg;
  var pushArrayStart = foreign.pushArrayStart;
  var pushArrayStartFixed = foreign.pushArrayStartFixed;
  var pushArrayStartFixed32 = foreign.pushArrayStartFixed32;
  var pushArrayStartFixed64 = foreign.pushArrayStartFixed64;
  var pushObjectStart = foreign.pushObjectStart;
  var pushObjectStartFixed = foreign.pushObjectStartFixed;
  var pushObjectStartFixed32 = foreign.pushObjectStartFixed32;
  var pushObjectStartFixed64 = foreign.pushObjectStartFixed64;
  var pushByteString = foreign.pushByteString;
  var pushByteStringStart = foreign.pushByteStringStart;
  var pushUtf8String = foreign.pushUtf8String;
  var pushUtf8StringStart = foreign.pushUtf8StringStart;
  var pushSimpleUnassigned = foreign.pushSimpleUnassigned;
  var pushTagStart = foreign.pushTagStart;
  var pushTagStart4 = foreign.pushTagStart4;
  var pushTagStart8 = foreign.pushTagStart8;
  var pushTagUnassigned = foreign.pushTagUnassigned;
  var pushBreak = foreign.pushBreak;
  var pow = stdlib.Math.pow;
  var offset = 0;
  var inputLength = 0;
  var code2 = 0;
  function parse2(input) {
    input = input | 0;
    offset = 0;
    inputLength = input;
    while ((offset | 0) < (inputLength | 0)) {
      code2 = jumpTable[heap[offset] & 255](heap[offset] | 0) | 0;
      if ((code2 | 0) > 0) {
        break;
      }
    }
    return code2 | 0;
  }
  function checkOffset(n2) {
    n2 = n2 | 0;
    if (((offset | 0) + (n2 | 0) | 0) < (inputLength | 0)) {
      return 0;
    }
    return 1;
  }
  function readUInt16(n2) {
    n2 = n2 | 0;
    return heap[n2 | 0] << 8 | heap[n2 + 1 | 0] | 0;
  }
  function readUInt32(n2) {
    n2 = n2 | 0;
    return heap[n2 | 0] << 24 | heap[n2 + 1 | 0] << 16 | heap[n2 + 2 | 0] << 8 | heap[n2 + 3 | 0] | 0;
  }
  function INT_P(octet) {
    octet = octet | 0;
    pushInt(octet | 0);
    offset = offset + 1 | 0;
    return 0;
  }
  function UINT_P_8(octet) {
    octet = octet | 0;
    if (checkOffset(1) | 0) {
      return 1;
    }
    pushInt(heap[offset + 1 | 0] | 0);
    offset = offset + 2 | 0;
    return 0;
  }
  function UINT_P_16(octet) {
    octet = octet | 0;
    if (checkOffset(2) | 0) {
      return 1;
    }
    pushInt(
      readUInt16(offset + 1 | 0) | 0
    );
    offset = offset + 3 | 0;
    return 0;
  }
  function UINT_P_32(octet) {
    octet = octet | 0;
    if (checkOffset(4) | 0) {
      return 1;
    }
    pushInt32(
      readUInt16(offset + 1 | 0) | 0,
      readUInt16(offset + 3 | 0) | 0
    );
    offset = offset + 5 | 0;
    return 0;
  }
  function UINT_P_64(octet) {
    octet = octet | 0;
    if (checkOffset(8) | 0) {
      return 1;
    }
    pushInt64(
      readUInt16(offset + 1 | 0) | 0,
      readUInt16(offset + 3 | 0) | 0,
      readUInt16(offset + 5 | 0) | 0,
      readUInt16(offset + 7 | 0) | 0
    );
    offset = offset + 9 | 0;
    return 0;
  }
  function INT_N(octet) {
    octet = octet | 0;
    pushInt(-1 - (octet - 32 | 0) | 0);
    offset = offset + 1 | 0;
    return 0;
  }
  function UINT_N_8(octet) {
    octet = octet | 0;
    if (checkOffset(1) | 0) {
      return 1;
    }
    pushInt(
      -1 - (heap[offset + 1 | 0] | 0) | 0
    );
    offset = offset + 2 | 0;
    return 0;
  }
  function UINT_N_16(octet) {
    octet = octet | 0;
    var val = 0;
    if (checkOffset(2) | 0) {
      return 1;
    }
    val = readUInt16(offset + 1 | 0) | 0;
    pushInt(-1 - (val | 0) | 0);
    offset = offset + 3 | 0;
    return 0;
  }
  function UINT_N_32(octet) {
    octet = octet | 0;
    if (checkOffset(4) | 0) {
      return 1;
    }
    pushInt32Neg(
      readUInt16(offset + 1 | 0) | 0,
      readUInt16(offset + 3 | 0) | 0
    );
    offset = offset + 5 | 0;
    return 0;
  }
  function UINT_N_64(octet) {
    octet = octet | 0;
    if (checkOffset(8) | 0) {
      return 1;
    }
    pushInt64Neg(
      readUInt16(offset + 1 | 0) | 0,
      readUInt16(offset + 3 | 0) | 0,
      readUInt16(offset + 5 | 0) | 0,
      readUInt16(offset + 7 | 0) | 0
    );
    offset = offset + 9 | 0;
    return 0;
  }
  function BYTE_STRING(octet) {
    octet = octet | 0;
    var start = 0;
    var end = 0;
    var step = 0;
    step = octet - 64 | 0;
    if (checkOffset(step | 0) | 0) {
      return 1;
    }
    start = offset + 1 | 0;
    end = (offset + 1 | 0) + (step | 0) | 0;
    pushByteString(start | 0, end | 0);
    offset = end | 0;
    return 0;
  }
  function BYTE_STRING_8(octet) {
    octet = octet | 0;
    var start = 0;
    var end = 0;
    var length2 = 0;
    if (checkOffset(1) | 0) {
      return 1;
    }
    length2 = heap[offset + 1 | 0] | 0;
    start = offset + 2 | 0;
    end = (offset + 2 | 0) + (length2 | 0) | 0;
    if (checkOffset(length2 + 1 | 0) | 0) {
      return 1;
    }
    pushByteString(start | 0, end | 0);
    offset = end | 0;
    return 0;
  }
  function BYTE_STRING_16(octet) {
    octet = octet | 0;
    var start = 0;
    var end = 0;
    var length2 = 0;
    if (checkOffset(2) | 0) {
      return 1;
    }
    length2 = readUInt16(offset + 1 | 0) | 0;
    start = offset + 3 | 0;
    end = (offset + 3 | 0) + (length2 | 0) | 0;
    if (checkOffset(length2 + 2 | 0) | 0) {
      return 1;
    }
    pushByteString(start | 0, end | 0);
    offset = end | 0;
    return 0;
  }
  function BYTE_STRING_32(octet) {
    octet = octet | 0;
    var start = 0;
    var end = 0;
    var length2 = 0;
    if (checkOffset(4) | 0) {
      return 1;
    }
    length2 = readUInt32(offset + 1 | 0) | 0;
    start = offset + 5 | 0;
    end = (offset + 5 | 0) + (length2 | 0) | 0;
    if (checkOffset(length2 + 4 | 0) | 0) {
      return 1;
    }
    pushByteString(start | 0, end | 0);
    offset = end | 0;
    return 0;
  }
  function BYTE_STRING_64(octet) {
    octet = octet | 0;
    return 1;
  }
  function BYTE_STRING_BREAK(octet) {
    octet = octet | 0;
    pushByteStringStart();
    offset = offset + 1 | 0;
    return 0;
  }
  function UTF8_STRING(octet) {
    octet = octet | 0;
    var start = 0;
    var end = 0;
    var step = 0;
    step = octet - 96 | 0;
    if (checkOffset(step | 0) | 0) {
      return 1;
    }
    start = offset + 1 | 0;
    end = (offset + 1 | 0) + (step | 0) | 0;
    pushUtf8String(start | 0, end | 0);
    offset = end | 0;
    return 0;
  }
  function UTF8_STRING_8(octet) {
    octet = octet | 0;
    var start = 0;
    var end = 0;
    var length2 = 0;
    if (checkOffset(1) | 0) {
      return 1;
    }
    length2 = heap[offset + 1 | 0] | 0;
    start = offset + 2 | 0;
    end = (offset + 2 | 0) + (length2 | 0) | 0;
    if (checkOffset(length2 + 1 | 0) | 0) {
      return 1;
    }
    pushUtf8String(start | 0, end | 0);
    offset = end | 0;
    return 0;
  }
  function UTF8_STRING_16(octet) {
    octet = octet | 0;
    var start = 0;
    var end = 0;
    var length2 = 0;
    if (checkOffset(2) | 0) {
      return 1;
    }
    length2 = readUInt16(offset + 1 | 0) | 0;
    start = offset + 3 | 0;
    end = (offset + 3 | 0) + (length2 | 0) | 0;
    if (checkOffset(length2 + 2 | 0) | 0) {
      return 1;
    }
    pushUtf8String(start | 0, end | 0);
    offset = end | 0;
    return 0;
  }
  function UTF8_STRING_32(octet) {
    octet = octet | 0;
    var start = 0;
    var end = 0;
    var length2 = 0;
    if (checkOffset(4) | 0) {
      return 1;
    }
    length2 = readUInt32(offset + 1 | 0) | 0;
    start = offset + 5 | 0;
    end = (offset + 5 | 0) + (length2 | 0) | 0;
    if (checkOffset(length2 + 4 | 0) | 0) {
      return 1;
    }
    pushUtf8String(start | 0, end | 0);
    offset = end | 0;
    return 0;
  }
  function UTF8_STRING_64(octet) {
    octet = octet | 0;
    return 1;
  }
  function UTF8_STRING_BREAK(octet) {
    octet = octet | 0;
    pushUtf8StringStart();
    offset = offset + 1 | 0;
    return 0;
  }
  function ARRAY(octet) {
    octet = octet | 0;
    pushArrayStartFixed(octet - 128 | 0);
    offset = offset + 1 | 0;
    return 0;
  }
  function ARRAY_8(octet) {
    octet = octet | 0;
    if (checkOffset(1) | 0) {
      return 1;
    }
    pushArrayStartFixed(heap[offset + 1 | 0] | 0);
    offset = offset + 2 | 0;
    return 0;
  }
  function ARRAY_16(octet) {
    octet = octet | 0;
    if (checkOffset(2) | 0) {
      return 1;
    }
    pushArrayStartFixed(
      readUInt16(offset + 1 | 0) | 0
    );
    offset = offset + 3 | 0;
    return 0;
  }
  function ARRAY_32(octet) {
    octet = octet | 0;
    if (checkOffset(4) | 0) {
      return 1;
    }
    pushArrayStartFixed32(
      readUInt16(offset + 1 | 0) | 0,
      readUInt16(offset + 3 | 0) | 0
    );
    offset = offset + 5 | 0;
    return 0;
  }
  function ARRAY_64(octet) {
    octet = octet | 0;
    if (checkOffset(8) | 0) {
      return 1;
    }
    pushArrayStartFixed64(
      readUInt16(offset + 1 | 0) | 0,
      readUInt16(offset + 3 | 0) | 0,
      readUInt16(offset + 5 | 0) | 0,
      readUInt16(offset + 7 | 0) | 0
    );
    offset = offset + 9 | 0;
    return 0;
  }
  function ARRAY_BREAK(octet) {
    octet = octet | 0;
    pushArrayStart();
    offset = offset + 1 | 0;
    return 0;
  }
  function MAP(octet) {
    octet = octet | 0;
    var step = 0;
    step = octet - 160 | 0;
    if (checkOffset(step | 0) | 0) {
      return 1;
    }
    pushObjectStartFixed(step | 0);
    offset = offset + 1 | 0;
    return 0;
  }
  function MAP_8(octet) {
    octet = octet | 0;
    if (checkOffset(1) | 0) {
      return 1;
    }
    pushObjectStartFixed(heap[offset + 1 | 0] | 0);
    offset = offset + 2 | 0;
    return 0;
  }
  function MAP_16(octet) {
    octet = octet | 0;
    if (checkOffset(2) | 0) {
      return 1;
    }
    pushObjectStartFixed(
      readUInt16(offset + 1 | 0) | 0
    );
    offset = offset + 3 | 0;
    return 0;
  }
  function MAP_32(octet) {
    octet = octet | 0;
    if (checkOffset(4) | 0) {
      return 1;
    }
    pushObjectStartFixed32(
      readUInt16(offset + 1 | 0) | 0,
      readUInt16(offset + 3 | 0) | 0
    );
    offset = offset + 5 | 0;
    return 0;
  }
  function MAP_64(octet) {
    octet = octet | 0;
    if (checkOffset(8) | 0) {
      return 1;
    }
    pushObjectStartFixed64(
      readUInt16(offset + 1 | 0) | 0,
      readUInt16(offset + 3 | 0) | 0,
      readUInt16(offset + 5 | 0) | 0,
      readUInt16(offset + 7 | 0) | 0
    );
    offset = offset + 9 | 0;
    return 0;
  }
  function MAP_BREAK(octet) {
    octet = octet | 0;
    pushObjectStart();
    offset = offset + 1 | 0;
    return 0;
  }
  function TAG_KNOWN(octet) {
    octet = octet | 0;
    pushTagStart(octet - 192 | 0 | 0);
    offset = offset + 1 | 0;
    return 0;
  }
  function TAG_BIGNUM_POS(octet) {
    octet = octet | 0;
    pushTagStart(octet | 0);
    offset = offset + 1 | 0;
    return 0;
  }
  function TAG_BIGNUM_NEG(octet) {
    octet = octet | 0;
    pushTagStart(octet | 0);
    offset = offset + 1 | 0;
    return 0;
  }
  function TAG_FRAC(octet) {
    octet = octet | 0;
    pushTagStart(octet | 0);
    offset = offset + 1 | 0;
    return 0;
  }
  function TAG_BIGNUM_FLOAT(octet) {
    octet = octet | 0;
    pushTagStart(octet | 0);
    offset = offset + 1 | 0;
    return 0;
  }
  function TAG_UNASSIGNED(octet) {
    octet = octet | 0;
    pushTagStart(octet - 192 | 0 | 0);
    offset = offset + 1 | 0;
    return 0;
  }
  function TAG_BASE64_URL(octet) {
    octet = octet | 0;
    pushTagStart(octet | 0);
    offset = offset + 1 | 0;
    return 0;
  }
  function TAG_BASE64(octet) {
    octet = octet | 0;
    pushTagStart(octet | 0);
    offset = offset + 1 | 0;
    return 0;
  }
  function TAG_BASE16(octet) {
    octet = octet | 0;
    pushTagStart(octet | 0);
    offset = offset + 1 | 0;
    return 0;
  }
  function TAG_MORE_1(octet) {
    octet = octet | 0;
    if (checkOffset(1) | 0) {
      return 1;
    }
    pushTagStart(heap[offset + 1 | 0] | 0);
    offset = offset + 2 | 0;
    return 0;
  }
  function TAG_MORE_2(octet) {
    octet = octet | 0;
    if (checkOffset(2) | 0) {
      return 1;
    }
    pushTagStart(
      readUInt16(offset + 1 | 0) | 0
    );
    offset = offset + 3 | 0;
    return 0;
  }
  function TAG_MORE_4(octet) {
    octet = octet | 0;
    if (checkOffset(4) | 0) {
      return 1;
    }
    pushTagStart4(
      readUInt16(offset + 1 | 0) | 0,
      readUInt16(offset + 3 | 0) | 0
    );
    offset = offset + 5 | 0;
    return 0;
  }
  function TAG_MORE_8(octet) {
    octet = octet | 0;
    if (checkOffset(8) | 0) {
      return 1;
    }
    pushTagStart8(
      readUInt16(offset + 1 | 0) | 0,
      readUInt16(offset + 3 | 0) | 0,
      readUInt16(offset + 5 | 0) | 0,
      readUInt16(offset + 7 | 0) | 0
    );
    offset = offset + 9 | 0;
    return 0;
  }
  function SIMPLE_UNASSIGNED(octet) {
    octet = octet | 0;
    pushSimpleUnassigned((octet | 0) - 224 | 0);
    offset = offset + 1 | 0;
    return 0;
  }
  function SIMPLE_FALSE(octet) {
    octet = octet | 0;
    pushFalse();
    offset = offset + 1 | 0;
    return 0;
  }
  function SIMPLE_TRUE(octet) {
    octet = octet | 0;
    pushTrue();
    offset = offset + 1 | 0;
    return 0;
  }
  function SIMPLE_NULL(octet) {
    octet = octet | 0;
    pushNull();
    offset = offset + 1 | 0;
    return 0;
  }
  function SIMPLE_UNDEFINED(octet) {
    octet = octet | 0;
    pushUndefined();
    offset = offset + 1 | 0;
    return 0;
  }
  function SIMPLE_BYTE(octet) {
    octet = octet | 0;
    if (checkOffset(1) | 0) {
      return 1;
    }
    pushSimpleUnassigned(heap[offset + 1 | 0] | 0);
    offset = offset + 2 | 0;
    return 0;
  }
  function SIMPLE_FLOAT_HALF(octet) {
    octet = octet | 0;
    var f2 = 0;
    var g2 = 0;
    var sign = 1;
    var exp = 0;
    var mant = 0;
    var r2 = 0;
    if (checkOffset(2) | 0) {
      return 1;
    }
    f2 = heap[offset + 1 | 0] | 0;
    g2 = heap[offset + 2 | 0] | 0;
    if ((f2 | 0) & 128) {
      sign = -1;
    }
    exp = +(((f2 | 0) & 124) >> 2);
    mant = +(((f2 | 0) & 3) << 8 | g2);
    if (+exp == 0) {
      pushFloat(+(+sign * 5960464477539063e-23 * +mant));
    } else if (+exp == 31) {
      if (+sign == 1) {
        if (+mant > 0) {
          pushNaN();
        } else {
          pushInfinity();
        }
      } else {
        if (+mant > 0) {
          pushNaNNeg();
        } else {
          pushInfinityNeg();
        }
      }
    } else {
      pushFloat(+(+sign * pow(2, +(+exp - 25)) * +(1024 + mant)));
    }
    offset = offset + 3 | 0;
    return 0;
  }
  function SIMPLE_FLOAT_SINGLE(octet) {
    octet = octet | 0;
    if (checkOffset(4) | 0) {
      return 1;
    }
    pushFloatSingle(
      heap[offset + 1 | 0] | 0,
      heap[offset + 2 | 0] | 0,
      heap[offset + 3 | 0] | 0,
      heap[offset + 4 | 0] | 0
    );
    offset = offset + 5 | 0;
    return 0;
  }
  function SIMPLE_FLOAT_DOUBLE(octet) {
    octet = octet | 0;
    if (checkOffset(8) | 0) {
      return 1;
    }
    pushFloatDouble(
      heap[offset + 1 | 0] | 0,
      heap[offset + 2 | 0] | 0,
      heap[offset + 3 | 0] | 0,
      heap[offset + 4 | 0] | 0,
      heap[offset + 5 | 0] | 0,
      heap[offset + 6 | 0] | 0,
      heap[offset + 7 | 0] | 0,
      heap[offset + 8 | 0] | 0
    );
    offset = offset + 9 | 0;
    return 0;
  }
  function ERROR2(octet) {
    octet = octet | 0;
    return 1;
  }
  function BREAK(octet) {
    octet = octet | 0;
    pushBreak();
    offset = offset + 1 | 0;
    return 0;
  }
  var jumpTable = [
    INT_P,
    INT_P,
    INT_P,
    INT_P,
    INT_P,
    INT_P,
    INT_P,
    INT_P,
    INT_P,
    INT_P,
    INT_P,
    INT_P,
    INT_P,
    INT_P,
    INT_P,
    INT_P,
    INT_P,
    INT_P,
    INT_P,
    INT_P,
    INT_P,
    INT_P,
    INT_P,
    INT_P,
    UINT_P_8,
    UINT_P_16,
    UINT_P_32,
    UINT_P_64,
    ERROR2,
    ERROR2,
    ERROR2,
    ERROR2,
    INT_N,
    INT_N,
    INT_N,
    INT_N,
    INT_N,
    INT_N,
    INT_N,
    INT_N,
    INT_N,
    INT_N,
    INT_N,
    INT_N,
    INT_N,
    INT_N,
    INT_N,
    INT_N,
    INT_N,
    INT_N,
    INT_N,
    INT_N,
    INT_N,
    INT_N,
    INT_N,
    INT_N,
    UINT_N_8,
    UINT_N_16,
    UINT_N_32,
    UINT_N_64,
    ERROR2,
    ERROR2,
    ERROR2,
    ERROR2,
    BYTE_STRING,
    BYTE_STRING,
    BYTE_STRING,
    BYTE_STRING,
    BYTE_STRING,
    BYTE_STRING,
    BYTE_STRING,
    BYTE_STRING,
    BYTE_STRING,
    BYTE_STRING,
    BYTE_STRING,
    BYTE_STRING,
    BYTE_STRING,
    BYTE_STRING,
    BYTE_STRING,
    BYTE_STRING,
    BYTE_STRING,
    BYTE_STRING,
    BYTE_STRING,
    BYTE_STRING,
    BYTE_STRING,
    BYTE_STRING,
    BYTE_STRING,
    BYTE_STRING,
    BYTE_STRING_8,
    BYTE_STRING_16,
    BYTE_STRING_32,
    BYTE_STRING_64,
    ERROR2,
    ERROR2,
    ERROR2,
    BYTE_STRING_BREAK,
    UTF8_STRING,
    UTF8_STRING,
    UTF8_STRING,
    UTF8_STRING,
    UTF8_STRING,
    UTF8_STRING,
    UTF8_STRING,
    UTF8_STRING,
    UTF8_STRING,
    UTF8_STRING,
    UTF8_STRING,
    UTF8_STRING,
    UTF8_STRING,
    UTF8_STRING,
    UTF8_STRING,
    UTF8_STRING,
    UTF8_STRING,
    UTF8_STRING,
    UTF8_STRING,
    UTF8_STRING,
    UTF8_STRING,
    UTF8_STRING,
    UTF8_STRING,
    UTF8_STRING,
    UTF8_STRING_8,
    UTF8_STRING_16,
    UTF8_STRING_32,
    UTF8_STRING_64,
    ERROR2,
    ERROR2,
    ERROR2,
    UTF8_STRING_BREAK,
    ARRAY,
    ARRAY,
    ARRAY,
    ARRAY,
    ARRAY,
    ARRAY,
    ARRAY,
    ARRAY,
    ARRAY,
    ARRAY,
    ARRAY,
    ARRAY,
    ARRAY,
    ARRAY,
    ARRAY,
    ARRAY,
    ARRAY,
    ARRAY,
    ARRAY,
    ARRAY,
    ARRAY,
    ARRAY,
    ARRAY,
    ARRAY,
    ARRAY_8,
    ARRAY_16,
    ARRAY_32,
    ARRAY_64,
    ERROR2,
    ERROR2,
    ERROR2,
    ARRAY_BREAK,
    MAP,
    MAP,
    MAP,
    MAP,
    MAP,
    MAP,
    MAP,
    MAP,
    MAP,
    MAP,
    MAP,
    MAP,
    MAP,
    MAP,
    MAP,
    MAP,
    MAP,
    MAP,
    MAP,
    MAP,
    MAP,
    MAP,
    MAP,
    MAP,
    MAP_8,
    MAP_16,
    MAP_32,
    MAP_64,
    ERROR2,
    ERROR2,
    ERROR2,
    MAP_BREAK,
    TAG_KNOWN,
    TAG_KNOWN,
    TAG_KNOWN,
    TAG_KNOWN,
    TAG_KNOWN,
    TAG_KNOWN,
    TAG_UNASSIGNED,
    TAG_UNASSIGNED,
    TAG_UNASSIGNED,
    TAG_UNASSIGNED,
    TAG_UNASSIGNED,
    TAG_UNASSIGNED,
    TAG_UNASSIGNED,
    TAG_UNASSIGNED,
    TAG_UNASSIGNED,
    TAG_UNASSIGNED,
    TAG_UNASSIGNED,
    TAG_UNASSIGNED,
    TAG_UNASSIGNED,
    TAG_UNASSIGNED,
    TAG_UNASSIGNED,
    TAG_UNASSIGNED,
    TAG_UNASSIGNED,
    TAG_UNASSIGNED,
    TAG_MORE_1,
    TAG_MORE_2,
    TAG_MORE_4,
    TAG_MORE_8,
    ERROR2,
    ERROR2,
    ERROR2,
    ERROR2,
    SIMPLE_UNASSIGNED,
    SIMPLE_UNASSIGNED,
    SIMPLE_UNASSIGNED,
    SIMPLE_UNASSIGNED,
    SIMPLE_UNASSIGNED,
    SIMPLE_UNASSIGNED,
    SIMPLE_UNASSIGNED,
    SIMPLE_UNASSIGNED,
    SIMPLE_UNASSIGNED,
    SIMPLE_UNASSIGNED,
    SIMPLE_UNASSIGNED,
    SIMPLE_UNASSIGNED,
    SIMPLE_UNASSIGNED,
    SIMPLE_UNASSIGNED,
    SIMPLE_UNASSIGNED,
    SIMPLE_UNASSIGNED,
    SIMPLE_UNASSIGNED,
    SIMPLE_UNASSIGNED,
    SIMPLE_UNASSIGNED,
    SIMPLE_UNASSIGNED,
    SIMPLE_FALSE,
    SIMPLE_TRUE,
    SIMPLE_NULL,
    SIMPLE_UNDEFINED,
    SIMPLE_BYTE,
    SIMPLE_FLOAT_HALF,
    SIMPLE_FLOAT_SINGLE,
    SIMPLE_FLOAT_DOUBLE,
    ERROR2,
    ERROR2,
    ERROR2,
    BREAK
  ];
  return {
    parse: parse2
  };
};
var utils$3 = {};
var constants$3 = {};
const Bignumber$2 = bignumber.exports.BigNumber;
constants$3.MT = {
  POS_INT: 0,
  NEG_INT: 1,
  BYTE_STRING: 2,
  UTF8_STRING: 3,
  ARRAY: 4,
  MAP: 5,
  TAG: 6,
  SIMPLE_FLOAT: 7
};
constants$3.TAG = {
  DATE_STRING: 0,
  DATE_EPOCH: 1,
  POS_BIGINT: 2,
  NEG_BIGINT: 3,
  DECIMAL_FRAC: 4,
  BIGFLOAT: 5,
  BASE64URL_EXPECTED: 21,
  BASE64_EXPECTED: 22,
  BASE16_EXPECTED: 23,
  CBOR: 24,
  URI: 32,
  BASE64URL: 33,
  BASE64: 34,
  REGEXP: 35,
  MIME: 36
};
constants$3.NUMBYTES = {
  ZERO: 0,
  ONE: 24,
  TWO: 25,
  FOUR: 26,
  EIGHT: 27,
  INDEFINITE: 31
};
constants$3.SIMPLE = {
  FALSE: 20,
  TRUE: 21,
  NULL: 22,
  UNDEFINED: 23
};
constants$3.SYMS = {
  NULL: Symbol("null"),
  UNDEFINED: Symbol("undef"),
  PARENT: Symbol("parent"),
  BREAK: Symbol("break"),
  STREAM: Symbol("stream")
};
constants$3.SHIFT32 = Math.pow(2, 32);
constants$3.SHIFT16 = Math.pow(2, 16);
constants$3.MAX_SAFE_HIGH = 2097151;
constants$3.NEG_ONE = new Bignumber$2(-1);
constants$3.TEN = new Bignumber$2(10);
constants$3.TWO = new Bignumber$2(2);
constants$3.PARENT = {
  ARRAY: 0,
  OBJECT: 1,
  MAP: 2,
  TAG: 3,
  BYTE_STRING: 4,
  UTF8_STRING: 5
};
(function(exports2) {
  const { Buffer: Buffer2 } = buffer;
  const Bignumber2 = bignumber.exports.BigNumber;
  const constants2 = constants$3;
  const SHIFT322 = constants2.SHIFT32;
  const SHIFT16 = constants2.SHIFT16;
  const MAX_SAFE_HIGH = 2097151;
  exports2.parseHalf = function parseHalf(buf) {
    var exp, mant, sign;
    sign = buf[0] & 128 ? -1 : 1;
    exp = (buf[0] & 124) >> 2;
    mant = (buf[0] & 3) << 8 | buf[1];
    if (!exp) {
      return sign * 5960464477539063e-23 * mant;
    } else if (exp === 31) {
      return sign * (mant ? 0 / 0 : Infinity);
    } else {
      return sign * Math.pow(2, exp - 25) * (1024 + mant);
    }
  };
  function toHex2(n2) {
    if (n2 < 16) {
      return "0" + n2.toString(16);
    }
    return n2.toString(16);
  }
  exports2.arrayBufferToBignumber = function(buf) {
    const len2 = buf.byteLength;
    let res = "";
    for (let i2 = 0; i2 < len2; i2++) {
      res += toHex2(buf[i2]);
    }
    return new Bignumber2(res, 16);
  };
  exports2.buildMap = (obj) => {
    const res = /* @__PURE__ */ new Map();
    const keys = Object.keys(obj);
    const length2 = keys.length;
    for (let i2 = 0; i2 < length2; i2++) {
      res.set(keys[i2], obj[keys[i2]]);
    }
    return res;
  };
  exports2.buildInt32 = (f2, g2) => {
    return f2 * SHIFT16 + g2;
  };
  exports2.buildInt64 = (f1, f2, g1, g2) => {
    const f3 = exports2.buildInt32(f1, f2);
    const g3 = exports2.buildInt32(g1, g2);
    if (f3 > MAX_SAFE_HIGH) {
      return new Bignumber2(f3).times(SHIFT322).plus(g3);
    } else {
      return f3 * SHIFT322 + g3;
    }
  };
  exports2.writeHalf = function writeHalf(buf, half) {
    const u322 = Buffer2.allocUnsafe(4);
    u322.writeFloatBE(half, 0);
    const u2 = u322.readUInt32BE(0);
    if ((u2 & 8191) !== 0) {
      return false;
    }
    var s16 = u2 >> 16 & 32768;
    const exp = u2 >> 23 & 255;
    const mant = u2 & 8388607;
    if (exp >= 113 && exp <= 142) {
      s16 += (exp - 112 << 10) + (mant >> 13);
    } else if (exp >= 103 && exp < 113) {
      if (mant & (1 << 126 - exp) - 1) {
        return false;
      }
      s16 += mant + 8388608 >> 126 - exp;
    } else {
      return false;
    }
    buf.writeUInt16BE(s16, 0);
    return true;
  };
  exports2.keySorter = function(a, b2) {
    var lenA = a[0].byteLength;
    var lenB = b2[0].byteLength;
    if (lenA > lenB) {
      return 1;
    }
    if (lenB > lenA) {
      return -1;
    }
    return a[0].compare(b2[0]);
  };
  exports2.isNegativeZero = (x2) => {
    return x2 === 0 && 1 / x2 < 0;
  };
  exports2.nextPowerOf2 = (n2) => {
    let count = 0;
    if (n2 && !(n2 & n2 - 1)) {
      return n2;
    }
    while (n2 !== 0) {
      n2 >>= 1;
      count += 1;
    }
    return 1 << count;
  };
})(utils$3);
const constants$2 = constants$3;
const MT$1 = constants$2.MT;
const SIMPLE = constants$2.SIMPLE;
const SYMS$1 = constants$2.SYMS;
class Simple$1 {
  constructor(value2) {
    if (typeof value2 !== "number") {
      throw new Error("Invalid Simple type: " + typeof value2);
    }
    if (value2 < 0 || value2 > 255 || (value2 | 0) !== value2) {
      throw new Error("value must be a small positive integer: " + value2);
    }
    this.value = value2;
  }
  toString() {
    return "simple(" + this.value + ")";
  }
  inspect() {
    return "simple(" + this.value + ")";
  }
  encodeCBOR(gen) {
    return gen._pushInt(this.value, MT$1.SIMPLE_FLOAT);
  }
  static isSimple(obj) {
    return obj instanceof Simple$1;
  }
  static decode(val, hasParent) {
    if (hasParent == null) {
      hasParent = true;
    }
    switch (val) {
      case SIMPLE.FALSE:
        return false;
      case SIMPLE.TRUE:
        return true;
      case SIMPLE.NULL:
        if (hasParent) {
          return null;
        } else {
          return SYMS$1.NULL;
        }
      case SIMPLE.UNDEFINED:
        if (hasParent) {
          return void 0;
        } else {
          return SYMS$1.UNDEFINED;
        }
      case -1:
        if (!hasParent) {
          throw new Error("Invalid BREAK");
        }
        return SYMS$1.BREAK;
      default:
        return new Simple$1(val);
    }
  }
}
var simple = Simple$1;
class Tagged$1 {
  constructor(tag, value2, err) {
    this.tag = tag;
    this.value = value2;
    this.err = err;
    if (typeof this.tag !== "number") {
      throw new Error("Invalid tag type (" + typeof this.tag + ")");
    }
    if (this.tag < 0 || (this.tag | 0) !== this.tag) {
      throw new Error("Tag must be a positive integer: " + this.tag);
    }
  }
  toString() {
    return `${this.tag}(${JSON.stringify(this.value)})`;
  }
  encodeCBOR(gen) {
    gen._pushTag(this.tag);
    return gen.pushAny(this.value);
  }
  convert(converters) {
    var er, f2;
    f2 = converters != null ? converters[this.tag] : void 0;
    if (typeof f2 !== "function") {
      f2 = Tagged$1["_tag" + this.tag];
      if (typeof f2 !== "function") {
        return this;
      }
    }
    try {
      return f2.call(Tagged$1, this.value);
    } catch (error) {
      er = error;
      this.err = er;
      return this;
    }
  }
}
var tagged$1 = Tagged$1;
const defaultBase$1 = self.location ? self.location.protocol + "//" + self.location.host : "";
const URL$3 = self.URL;
class URLWithLegacySupport$2 {
  constructor(url2 = "", base = defaultBase$1) {
    this.super = new URL$3(url2, base);
    this.path = this.pathname + this.search;
    this.auth = this.username && this.password ? this.username + ":" + this.password : null;
    this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null;
  }
  get hash() {
    return this.super.hash;
  }
  get host() {
    return this.super.host;
  }
  get hostname() {
    return this.super.hostname;
  }
  get href() {
    return this.super.href;
  }
  get origin() {
    return this.super.origin;
  }
  get password() {
    return this.super.password;
  }
  get pathname() {
    return this.super.pathname;
  }
  get port() {
    return this.super.port;
  }
  get protocol() {
    return this.super.protocol;
  }
  get search() {
    return this.super.search;
  }
  get searchParams() {
    return this.super.searchParams;
  }
  get username() {
    return this.super.username;
  }
  set hash(hash2) {
    this.super.hash = hash2;
  }
  set host(host2) {
    this.super.host = host2;
  }
  set hostname(hostname) {
    this.super.hostname = hostname;
  }
  set href(href) {
    this.super.href = href;
  }
  set origin(origin) {
    this.super.origin = origin;
  }
  set password(password) {
    this.super.password = password;
  }
  set pathname(pathname) {
    this.super.pathname = pathname;
  }
  set port(port) {
    this.super.port = port;
  }
  set protocol(protocol) {
    this.super.protocol = protocol;
  }
  set search(search) {
    this.super.search = search;
  }
  set searchParams(searchParams) {
    this.super.searchParams = searchParams;
  }
  set username(username) {
    this.super.username = username;
  }
  createObjectURL(o) {
    return this.super.createObjectURL(o);
  }
  revokeObjectURL(o) {
    this.super.revokeObjectURL(o);
  }
  toJSON() {
    return this.super.toJSON();
  }
  toString() {
    return this.super.toString();
  }
  format() {
    return this.toString();
  }
}
function format$2(obj) {
  if (typeof obj === "string") {
    const url2 = new URL$3(obj);
    return url2.toString();
  }
  if (!(obj instanceof URL$3)) {
    const userPass = obj.username && obj.password ? `${obj.username}:${obj.password}@` : "";
    const auth = obj.auth ? obj.auth + "@" : "";
    const port = obj.port ? ":" + obj.port : "";
    const protocol = obj.protocol ? obj.protocol + "//" : "";
    const host2 = obj.host || "";
    const hostname = obj.hostname || "";
    const search = obj.search || (obj.query ? "?" + obj.query : "");
    const hash2 = obj.hash || "";
    const pathname = obj.pathname || "";
    const path = obj.path || pathname + search;
    return `${protocol}${userPass || auth}${host2 || hostname + port}${path}${hash2}`;
  }
}
var urlBrowser = {
  URLWithLegacySupport: URLWithLegacySupport$2,
  URLSearchParams: self.URLSearchParams,
  defaultBase: defaultBase$1,
  format: format$2
};
const { URLWithLegacySupport: URLWithLegacySupport$1, format: format$1 } = urlBrowser;
var relative$1 = (url2, location = {}, protocolMap = {}, defaultProtocol) => {
  let protocol = location.protocol ? location.protocol.replace(":", "") : "http";
  protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ":";
  let urlParsed;
  try {
    urlParsed = new URLWithLegacySupport$1(url2);
  } catch (err) {
    urlParsed = {};
  }
  const base = Object.assign({}, location, {
    protocol: protocol || urlParsed.protocol,
    host: location.host || urlParsed.host
  });
  return new URLWithLegacySupport$1(url2, format$1(base)).toString();
};
const {
  URLWithLegacySupport,
  format,
  URLSearchParams: URLSearchParams$1,
  defaultBase
} = urlBrowser;
const relative = relative$1;
var isoUrl = {
  URL: URLWithLegacySupport,
  URLSearchParams: URLSearchParams$1,
  format,
  relative,
  defaultBase
};
const { Buffer: Buffer$4 } = buffer;
const ieee754 = ieee754$1;
const Bignumber$1 = bignumber.exports.BigNumber;
const parser = decoder_asm;
const utils$2 = utils$3;
const c$1 = constants$3;
const Simple = simple;
const Tagged = tagged$1;
const { URL: URL$2 } = isoUrl;
class Decoder$1 {
  constructor(opts) {
    opts = opts || {};
    if (!opts.size || opts.size < 65536) {
      opts.size = 65536;
    } else {
      opts.size = utils$2.nextPowerOf2(opts.size);
    }
    this._heap = new ArrayBuffer(opts.size);
    this._heap8 = new Uint8Array(this._heap);
    this._buffer = Buffer$4.from(this._heap);
    this._reset();
    this._knownTags = Object.assign({
      0: (val) => new Date(val),
      1: (val) => new Date(val * 1e3),
      2: (val) => utils$2.arrayBufferToBignumber(val),
      3: (val) => c$1.NEG_ONE.minus(utils$2.arrayBufferToBignumber(val)),
      4: (v2) => {
        return c$1.TEN.pow(v2[0]).times(v2[1]);
      },
      5: (v2) => {
        return c$1.TWO.pow(v2[0]).times(v2[1]);
      },
      32: (val) => new URL$2(val),
      35: (val) => new RegExp(val)
    }, opts.tags);
    this.parser = parser(commonjsGlobal, {
      log: console.log.bind(console),
      pushInt: this.pushInt.bind(this),
      pushInt32: this.pushInt32.bind(this),
      pushInt32Neg: this.pushInt32Neg.bind(this),
      pushInt64: this.pushInt64.bind(this),
      pushInt64Neg: this.pushInt64Neg.bind(this),
      pushFloat: this.pushFloat.bind(this),
      pushFloatSingle: this.pushFloatSingle.bind(this),
      pushFloatDouble: this.pushFloatDouble.bind(this),
      pushTrue: this.pushTrue.bind(this),
      pushFalse: this.pushFalse.bind(this),
      pushUndefined: this.pushUndefined.bind(this),
      pushNull: this.pushNull.bind(this),
      pushInfinity: this.pushInfinity.bind(this),
      pushInfinityNeg: this.pushInfinityNeg.bind(this),
      pushNaN: this.pushNaN.bind(this),
      pushNaNNeg: this.pushNaNNeg.bind(this),
      pushArrayStart: this.pushArrayStart.bind(this),
      pushArrayStartFixed: this.pushArrayStartFixed.bind(this),
      pushArrayStartFixed32: this.pushArrayStartFixed32.bind(this),
      pushArrayStartFixed64: this.pushArrayStartFixed64.bind(this),
      pushObjectStart: this.pushObjectStart.bind(this),
      pushObjectStartFixed: this.pushObjectStartFixed.bind(this),
      pushObjectStartFixed32: this.pushObjectStartFixed32.bind(this),
      pushObjectStartFixed64: this.pushObjectStartFixed64.bind(this),
      pushByteString: this.pushByteString.bind(this),
      pushByteStringStart: this.pushByteStringStart.bind(this),
      pushUtf8String: this.pushUtf8String.bind(this),
      pushUtf8StringStart: this.pushUtf8StringStart.bind(this),
      pushSimpleUnassigned: this.pushSimpleUnassigned.bind(this),
      pushTagUnassigned: this.pushTagUnassigned.bind(this),
      pushTagStart: this.pushTagStart.bind(this),
      pushTagStart4: this.pushTagStart4.bind(this),
      pushTagStart8: this.pushTagStart8.bind(this),
      pushBreak: this.pushBreak.bind(this)
    }, this._heap);
  }
  get _depth() {
    return this._parents.length;
  }
  get _currentParent() {
    return this._parents[this._depth - 1];
  }
  get _ref() {
    return this._currentParent.ref;
  }
  _closeParent() {
    var p2 = this._parents.pop();
    if (p2.length > 0) {
      throw new Error(`Missing ${p2.length} elements`);
    }
    switch (p2.type) {
      case c$1.PARENT.TAG:
        this._push(
          this.createTag(p2.ref[0], p2.ref[1])
        );
        break;
      case c$1.PARENT.BYTE_STRING:
        this._push(this.createByteString(p2.ref, p2.length));
        break;
      case c$1.PARENT.UTF8_STRING:
        this._push(this.createUtf8String(p2.ref, p2.length));
        break;
      case c$1.PARENT.MAP:
        if (p2.values % 2 > 0) {
          throw new Error("Odd number of elements in the map");
        }
        this._push(this.createMap(p2.ref, p2.length));
        break;
      case c$1.PARENT.OBJECT:
        if (p2.values % 2 > 0) {
          throw new Error("Odd number of elements in the map");
        }
        this._push(this.createObject(p2.ref, p2.length));
        break;
      case c$1.PARENT.ARRAY:
        this._push(this.createArray(p2.ref, p2.length));
        break;
    }
    if (this._currentParent && this._currentParent.type === c$1.PARENT.TAG) {
      this._dec();
    }
  }
  _dec() {
    const p2 = this._currentParent;
    if (p2.length < 0) {
      return;
    }
    p2.length--;
    if (p2.length === 0) {
      this._closeParent();
    }
  }
  _push(val, hasChildren) {
    const p2 = this._currentParent;
    p2.values++;
    switch (p2.type) {
      case c$1.PARENT.ARRAY:
      case c$1.PARENT.BYTE_STRING:
      case c$1.PARENT.UTF8_STRING:
        if (p2.length > -1) {
          this._ref[this._ref.length - p2.length] = val;
        } else {
          this._ref.push(val);
        }
        this._dec();
        break;
      case c$1.PARENT.OBJECT:
        if (p2.tmpKey != null) {
          this._ref[p2.tmpKey] = val;
          p2.tmpKey = null;
          this._dec();
        } else {
          p2.tmpKey = val;
          if (typeof p2.tmpKey !== "string") {
            p2.type = c$1.PARENT.MAP;
            p2.ref = utils$2.buildMap(p2.ref);
          }
        }
        break;
      case c$1.PARENT.MAP:
        if (p2.tmpKey != null) {
          this._ref.set(p2.tmpKey, val);
          p2.tmpKey = null;
          this._dec();
        } else {
          p2.tmpKey = val;
        }
        break;
      case c$1.PARENT.TAG:
        this._ref.push(val);
        if (!hasChildren) {
          this._dec();
        }
        break;
      default:
        throw new Error("Unknown parent type");
    }
  }
  _createParent(obj, type, len2) {
    this._parents[this._depth] = {
      type,
      length: len2,
      ref: obj,
      values: 0,
      tmpKey: null
    };
  }
  _reset() {
    this._res = [];
    this._parents = [{
      type: c$1.PARENT.ARRAY,
      length: -1,
      ref: this._res,
      values: 0,
      tmpKey: null
    }];
  }
  createTag(tagNumber, value2) {
    const typ = this._knownTags[tagNumber];
    if (!typ) {
      return new Tagged(tagNumber, value2);
    }
    return typ(value2);
  }
  createMap(obj, len2) {
    return obj;
  }
  createObject(obj, len2) {
    return obj;
  }
  createArray(arr, len2) {
    return arr;
  }
  createByteString(raw2, len2) {
    return Buffer$4.concat(raw2);
  }
  createByteStringFromHeap(start, end) {
    if (start === end) {
      return Buffer$4.alloc(0);
    }
    return Buffer$4.from(this._heap.slice(start, end));
  }
  createInt(val) {
    return val;
  }
  createInt32(f2, g2) {
    return utils$2.buildInt32(f2, g2);
  }
  createInt64(f1, f2, g1, g2) {
    return utils$2.buildInt64(f1, f2, g1, g2);
  }
  createFloat(val) {
    return val;
  }
  createFloatSingle(a, b2, c2, d2) {
    return ieee754.read([a, b2, c2, d2], 0, false, 23, 4);
  }
  createFloatDouble(a, b2, c2, d2, e2, f2, g2, h2) {
    return ieee754.read([a, b2, c2, d2, e2, f2, g2, h2], 0, false, 52, 8);
  }
  createInt32Neg(f2, g2) {
    return -1 - utils$2.buildInt32(f2, g2);
  }
  createInt64Neg(f1, f2, g1, g2) {
    const f3 = utils$2.buildInt32(f1, f2);
    const g3 = utils$2.buildInt32(g1, g2);
    if (f3 > c$1.MAX_SAFE_HIGH) {
      return c$1.NEG_ONE.minus(new Bignumber$1(f3).times(c$1.SHIFT32).plus(g3));
    }
    return -1 - (f3 * c$1.SHIFT32 + g3);
  }
  createTrue() {
    return true;
  }
  createFalse() {
    return false;
  }
  createNull() {
    return null;
  }
  createUndefined() {
    return void 0;
  }
  createInfinity() {
    return Infinity;
  }
  createInfinityNeg() {
    return -Infinity;
  }
  createNaN() {
    return NaN;
  }
  createNaNNeg() {
    return NaN;
  }
  createUtf8String(raw2, len2) {
    return raw2.join("");
  }
  createUtf8StringFromHeap(start, end) {
    if (start === end) {
      return "";
    }
    return this._buffer.toString("utf8", start, end);
  }
  createSimpleUnassigned(val) {
    return new Simple(val);
  }
  pushInt(val) {
    this._push(this.createInt(val));
  }
  pushInt32(f2, g2) {
    this._push(this.createInt32(f2, g2));
  }
  pushInt64(f1, f2, g1, g2) {
    this._push(this.createInt64(f1, f2, g1, g2));
  }
  pushFloat(val) {
    this._push(this.createFloat(val));
  }
  pushFloatSingle(a, b2, c2, d2) {
    this._push(this.createFloatSingle(a, b2, c2, d2));
  }
  pushFloatDouble(a, b2, c2, d2, e2, f2, g2, h2) {
    this._push(this.createFloatDouble(a, b2, c2, d2, e2, f2, g2, h2));
  }
  pushInt32Neg(f2, g2) {
    this._push(this.createInt32Neg(f2, g2));
  }
  pushInt64Neg(f1, f2, g1, g2) {
    this._push(this.createInt64Neg(f1, f2, g1, g2));
  }
  pushTrue() {
    this._push(this.createTrue());
  }
  pushFalse() {
    this._push(this.createFalse());
  }
  pushNull() {
    this._push(this.createNull());
  }
  pushUndefined() {
    this._push(this.createUndefined());
  }
  pushInfinity() {
    this._push(this.createInfinity());
  }
  pushInfinityNeg() {
    this._push(this.createInfinityNeg());
  }
  pushNaN() {
    this._push(this.createNaN());
  }
  pushNaNNeg() {
    this._push(this.createNaNNeg());
  }
  pushArrayStart() {
    this._createParent([], c$1.PARENT.ARRAY, -1);
  }
  pushArrayStartFixed(len2) {
    this._createArrayStartFixed(len2);
  }
  pushArrayStartFixed32(len1, len2) {
    const len3 = utils$2.buildInt32(len1, len2);
    this._createArrayStartFixed(len3);
  }
  pushArrayStartFixed64(len1, len2, len3, len4) {
    const len5 = utils$2.buildInt64(len1, len2, len3, len4);
    this._createArrayStartFixed(len5);
  }
  pushObjectStart() {
    this._createObjectStartFixed(-1);
  }
  pushObjectStartFixed(len2) {
    this._createObjectStartFixed(len2);
  }
  pushObjectStartFixed32(len1, len2) {
    const len3 = utils$2.buildInt32(len1, len2);
    this._createObjectStartFixed(len3);
  }
  pushObjectStartFixed64(len1, len2, len3, len4) {
    const len5 = utils$2.buildInt64(len1, len2, len3, len4);
    this._createObjectStartFixed(len5);
  }
  pushByteStringStart() {
    this._parents[this._depth] = {
      type: c$1.PARENT.BYTE_STRING,
      length: -1,
      ref: [],
      values: 0,
      tmpKey: null
    };
  }
  pushByteString(start, end) {
    this._push(this.createByteStringFromHeap(start, end));
  }
  pushUtf8StringStart() {
    this._parents[this._depth] = {
      type: c$1.PARENT.UTF8_STRING,
      length: -1,
      ref: [],
      values: 0,
      tmpKey: null
    };
  }
  pushUtf8String(start, end) {
    this._push(this.createUtf8StringFromHeap(start, end));
  }
  pushSimpleUnassigned(val) {
    this._push(this.createSimpleUnassigned(val));
  }
  pushTagStart(tag) {
    this._parents[this._depth] = {
      type: c$1.PARENT.TAG,
      length: 1,
      ref: [tag]
    };
  }
  pushTagStart4(f2, g2) {
    this.pushTagStart(utils$2.buildInt32(f2, g2));
  }
  pushTagStart8(f1, f2, g1, g2) {
    this.pushTagStart(utils$2.buildInt64(f1, f2, g1, g2));
  }
  pushTagUnassigned(tagNumber) {
    this._push(this.createTag(tagNumber));
  }
  pushBreak() {
    if (this._currentParent.length > -1) {
      throw new Error("Unexpected break");
    }
    this._closeParent();
  }
  _createObjectStartFixed(len2) {
    if (len2 === 0) {
      this._push(this.createObject({}));
      return;
    }
    this._createParent({}, c$1.PARENT.OBJECT, len2);
  }
  _createArrayStartFixed(len2) {
    if (len2 === 0) {
      this._push(this.createArray([]));
      return;
    }
    this._createParent(new Array(len2), c$1.PARENT.ARRAY, len2);
  }
  _decode(input) {
    if (input.byteLength === 0) {
      throw new Error("Input too short");
    }
    this._reset();
    this._heap8.set(input);
    const code2 = this.parser.parse(input.byteLength);
    if (this._depth > 1) {
      while (this._currentParent.length === 0) {
        this._closeParent();
      }
      if (this._depth > 1) {
        throw new Error("Undeterminated nesting");
      }
    }
    if (code2 > 0) {
      throw new Error("Failed to parse");
    }
    if (this._res.length === 0) {
      throw new Error("No valid result");
    }
  }
  decodeFirst(input) {
    this._decode(input);
    return this._res[0];
  }
  decodeAll(input) {
    this._decode(input);
    return this._res;
  }
  static decode(input, enc) {
    if (typeof input === "string") {
      input = Buffer$4.from(input, enc || "hex");
    }
    const dec = new Decoder$1({ size: input.length });
    return dec.decodeFirst(input);
  }
  static decodeAll(input, enc) {
    if (typeof input === "string") {
      input = Buffer$4.from(input, enc || "hex");
    }
    const dec = new Decoder$1({ size: input.length });
    return dec.decodeAll(input);
  }
}
Decoder$1.decodeFirst = Decoder$1.decode;
var decoder = Decoder$1;
const { Buffer: Buffer$3 } = buffer;
const Decoder = decoder;
const utils$1 = utils$3;
class Diagnose extends Decoder {
  createTag(tagNumber, value2) {
    return `${tagNumber}(${value2})`;
  }
  createInt(val) {
    return super.createInt(val).toString();
  }
  createInt32(f2, g2) {
    return super.createInt32(f2, g2).toString();
  }
  createInt64(f1, f2, g1, g2) {
    return super.createInt64(f1, f2, g1, g2).toString();
  }
  createInt32Neg(f2, g2) {
    return super.createInt32Neg(f2, g2).toString();
  }
  createInt64Neg(f1, f2, g1, g2) {
    return super.createInt64Neg(f1, f2, g1, g2).toString();
  }
  createTrue() {
    return "true";
  }
  createFalse() {
    return "false";
  }
  createFloat(val) {
    const fl2 = super.createFloat(val);
    if (utils$1.isNegativeZero(val)) {
      return "-0_1";
    }
    return `${fl2}_1`;
  }
  createFloatSingle(a, b2, c2, d2) {
    const fl2 = super.createFloatSingle(a, b2, c2, d2);
    return `${fl2}_2`;
  }
  createFloatDouble(a, b2, c2, d2, e2, f2, g2, h2) {
    const fl2 = super.createFloatDouble(a, b2, c2, d2, e2, f2, g2, h2);
    return `${fl2}_3`;
  }
  createByteString(raw2, len2) {
    const val = raw2.join(", ");
    if (len2 === -1) {
      return `(_ ${val})`;
    }
    return `h'${val}`;
  }
  createByteStringFromHeap(start, end) {
    const val = Buffer$3.from(
      super.createByteStringFromHeap(start, end)
    ).toString("hex");
    return `h'${val}'`;
  }
  createInfinity() {
    return "Infinity_1";
  }
  createInfinityNeg() {
    return "-Infinity_1";
  }
  createNaN() {
    return "NaN_1";
  }
  createNaNNeg() {
    return "-NaN_1";
  }
  createNull() {
    return "null";
  }
  createUndefined() {
    return "undefined";
  }
  createSimpleUnassigned(val) {
    return `simple(${val})`;
  }
  createArray(arr, len2) {
    const val = super.createArray(arr, len2);
    if (len2 === -1) {
      return `[_ ${val.join(", ")}]`;
    }
    return `[${val.join(", ")}]`;
  }
  createMap(map2, len2) {
    const val = super.createMap(map2);
    const list = Array.from(val.keys()).reduce(collectObject(val), "");
    if (len2 === -1) {
      return `{_ ${list}}`;
    }
    return `{${list}}`;
  }
  createObject(obj, len2) {
    const val = super.createObject(obj);
    const map2 = Object.keys(val).reduce(collectObject(val), "");
    if (len2 === -1) {
      return `{_ ${map2}}`;
    }
    return `{${map2}}`;
  }
  createUtf8String(raw2, len2) {
    const val = raw2.join(", ");
    if (len2 === -1) {
      return `(_ ${val})`;
    }
    return `"${val}"`;
  }
  createUtf8StringFromHeap(start, end) {
    const val = Buffer$3.from(
      super.createUtf8StringFromHeap(start, end)
    ).toString("utf8");
    return `"${val}"`;
  }
  static diagnose(input, enc) {
    if (typeof input === "string") {
      input = Buffer$3.from(input, enc || "hex");
    }
    const dec = new Diagnose();
    return dec.decodeFirst(input);
  }
}
var diagnose = Diagnose;
function collectObject(val) {
  return (acc, key) => {
    if (acc) {
      return `${acc}, ${key}: ${val[key]}`;
    }
    return `${key}: ${val[key]}`;
  };
}
const { Buffer: Buffer$2 } = buffer;
const { URL: URL$1 } = isoUrl;
const Bignumber = bignumber.exports.BigNumber;
const utils = utils$3;
const constants$1 = constants$3;
const MT = constants$1.MT;
const NUMBYTES = constants$1.NUMBYTES;
const SHIFT32 = constants$1.SHIFT32;
const SYMS = constants$1.SYMS;
const TAG = constants$1.TAG;
const HALF = constants$1.MT.SIMPLE_FLOAT << 5 | constants$1.NUMBYTES.TWO;
const FLOAT = constants$1.MT.SIMPLE_FLOAT << 5 | constants$1.NUMBYTES.FOUR;
const DOUBLE = constants$1.MT.SIMPLE_FLOAT << 5 | constants$1.NUMBYTES.EIGHT;
const TRUE = constants$1.MT.SIMPLE_FLOAT << 5 | constants$1.SIMPLE.TRUE;
const FALSE = constants$1.MT.SIMPLE_FLOAT << 5 | constants$1.SIMPLE.FALSE;
const UNDEFINED = constants$1.MT.SIMPLE_FLOAT << 5 | constants$1.SIMPLE.UNDEFINED;
const NULL = constants$1.MT.SIMPLE_FLOAT << 5 | constants$1.SIMPLE.NULL;
const MAXINT_BN = new Bignumber("0x20000000000000");
const BUF_NAN = Buffer$2.from("f97e00", "hex");
const BUF_INF_NEG = Buffer$2.from("f9fc00", "hex");
const BUF_INF_POS = Buffer$2.from("f97c00", "hex");
function toType(obj) {
  return {}.toString.call(obj).slice(8, -1);
}
class Encoder {
  constructor(options) {
    options = options || {};
    this.streaming = typeof options.stream === "function";
    this.onData = options.stream;
    this.semanticTypes = [
      [URL$1, this._pushUrl],
      [Bignumber, this._pushBigNumber]
    ];
    const addTypes = options.genTypes || [];
    const len2 = addTypes.length;
    for (let i2 = 0; i2 < len2; i2++) {
      this.addSemanticType(
        addTypes[i2][0],
        addTypes[i2][1]
      );
    }
    this._reset();
  }
  addSemanticType(type, fun) {
    const len2 = this.semanticTypes.length;
    for (let i2 = 0; i2 < len2; i2++) {
      const typ = this.semanticTypes[i2][0];
      if (typ === type) {
        const old = this.semanticTypes[i2][1];
        this.semanticTypes[i2][1] = fun;
        return old;
      }
    }
    this.semanticTypes.push([type, fun]);
    return null;
  }
  push(val) {
    if (!val) {
      return true;
    }
    this.result[this.offset] = val;
    this.resultMethod[this.offset] = 0;
    this.resultLength[this.offset] = val.length;
    this.offset++;
    if (this.streaming) {
      this.onData(this.finalize());
    }
    return true;
  }
  pushWrite(val, method2, len2) {
    this.result[this.offset] = val;
    this.resultMethod[this.offset] = method2;
    this.resultLength[this.offset] = len2;
    this.offset++;
    if (this.streaming) {
      this.onData(this.finalize());
    }
    return true;
  }
  _pushUInt8(val) {
    return this.pushWrite(val, 1, 1);
  }
  _pushUInt16BE(val) {
    return this.pushWrite(val, 2, 2);
  }
  _pushUInt32BE(val) {
    return this.pushWrite(val, 3, 4);
  }
  _pushDoubleBE(val) {
    return this.pushWrite(val, 4, 8);
  }
  _pushNaN() {
    return this.push(BUF_NAN);
  }
  _pushInfinity(obj) {
    const half = obj < 0 ? BUF_INF_NEG : BUF_INF_POS;
    return this.push(half);
  }
  _pushFloat(obj) {
    const b2 = Buffer$2.allocUnsafe(2);
    if (utils.writeHalf(b2, obj)) {
      if (utils.parseHalf(b2) === obj) {
        return this._pushUInt8(HALF) && this.push(b2);
      }
    }
    const b4 = Buffer$2.allocUnsafe(4);
    b4.writeFloatBE(obj, 0);
    if (b4.readFloatBE(0) === obj) {
      return this._pushUInt8(FLOAT) && this.push(b4);
    }
    return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj);
  }
  _pushInt(obj, mt, orig) {
    const m2 = mt << 5;
    if (obj < 24) {
      return this._pushUInt8(m2 | obj);
    }
    if (obj <= 255) {
      return this._pushUInt8(m2 | NUMBYTES.ONE) && this._pushUInt8(obj);
    }
    if (obj <= 65535) {
      return this._pushUInt8(m2 | NUMBYTES.TWO) && this._pushUInt16BE(obj);
    }
    if (obj <= 4294967295) {
      return this._pushUInt8(m2 | NUMBYTES.FOUR) && this._pushUInt32BE(obj);
    }
    if (obj <= Number.MAX_SAFE_INTEGER) {
      return this._pushUInt8(m2 | NUMBYTES.EIGHT) && this._pushUInt32BE(Math.floor(obj / SHIFT32)) && this._pushUInt32BE(obj % SHIFT32);
    }
    if (mt === MT.NEG_INT) {
      return this._pushFloat(orig);
    }
    return this._pushFloat(obj);
  }
  _pushIntNum(obj) {
    if (obj < 0) {
      return this._pushInt(-obj - 1, MT.NEG_INT, obj);
    } else {
      return this._pushInt(obj, MT.POS_INT);
    }
  }
  _pushNumber(obj) {
    switch (false) {
      case obj === obj:
        return this._pushNaN(obj);
      case isFinite(obj):
        return this._pushInfinity(obj);
      case obj % 1 !== 0:
        return this._pushIntNum(obj);
      default:
        return this._pushFloat(obj);
    }
  }
  _pushString(obj) {
    const len2 = Buffer$2.byteLength(obj, "utf8");
    return this._pushInt(len2, MT.UTF8_STRING) && this.pushWrite(obj, 5, len2);
  }
  _pushBoolean(obj) {
    return this._pushUInt8(obj ? TRUE : FALSE);
  }
  _pushUndefined(obj) {
    return this._pushUInt8(UNDEFINED);
  }
  _pushArray(gen, obj) {
    const len2 = obj.length;
    if (!gen._pushInt(len2, MT.ARRAY)) {
      return false;
    }
    for (let j = 0; j < len2; j++) {
      if (!gen.pushAny(obj[j])) {
        return false;
      }
    }
    return true;
  }
  _pushTag(tag) {
    return this._pushInt(tag, MT.TAG);
  }
  _pushDate(gen, obj) {
    return gen._pushTag(TAG.DATE_EPOCH) && gen.pushAny(Math.round(obj / 1e3));
  }
  _pushBuffer(gen, obj) {
    return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj);
  }
  _pushNoFilter(gen, obj) {
    return gen._pushBuffer(gen, obj.slice());
  }
  _pushRegexp(gen, obj) {
    return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source);
  }
  _pushSet(gen, obj) {
    if (!gen._pushInt(obj.size, MT.ARRAY)) {
      return false;
    }
    for (const x2 of obj) {
      if (!gen.pushAny(x2)) {
        return false;
      }
    }
    return true;
  }
  _pushUrl(gen, obj) {
    return gen._pushTag(TAG.URI) && gen.pushAny(obj.format());
  }
  _pushBigint(obj) {
    let tag = TAG.POS_BIGINT;
    if (obj.isNegative()) {
      obj = obj.negated().minus(1);
      tag = TAG.NEG_BIGINT;
    }
    let str = obj.toString(16);
    if (str.length % 2) {
      str = "0" + str;
    }
    const buf = Buffer$2.from(str, "hex");
    return this._pushTag(tag) && this._pushBuffer(this, buf);
  }
  _pushBigNumber(gen, obj) {
    if (obj.isNaN()) {
      return gen._pushNaN();
    }
    if (!obj.isFinite()) {
      return gen._pushInfinity(obj.isNegative() ? -Infinity : Infinity);
    }
    if (obj.isInteger()) {
      return gen._pushBigint(obj);
    }
    if (!(gen._pushTag(TAG.DECIMAL_FRAC) && gen._pushInt(2, MT.ARRAY))) {
      return false;
    }
    const dec = obj.decimalPlaces();
    const slide = obj.multipliedBy(new Bignumber(10).pow(dec));
    if (!gen._pushIntNum(-dec)) {
      return false;
    }
    if (slide.abs().isLessThan(MAXINT_BN)) {
      return gen._pushIntNum(slide.toNumber());
    } else {
      return gen._pushBigint(slide);
    }
  }
  _pushMap(gen, obj) {
    if (!gen._pushInt(obj.size, MT.MAP)) {
      return false;
    }
    return this._pushRawMap(
      obj.size,
      Array.from(obj)
    );
  }
  _pushObject(obj) {
    if (!obj) {
      return this._pushUInt8(NULL);
    }
    var len2 = this.semanticTypes.length;
    for (var i2 = 0; i2 < len2; i2++) {
      if (obj instanceof this.semanticTypes[i2][0]) {
        return this.semanticTypes[i2][1].call(obj, this, obj);
      }
    }
    var f2 = obj.encodeCBOR;
    if (typeof f2 === "function") {
      return f2.call(obj, this);
    }
    var keys = Object.keys(obj);
    var keyLength = keys.length;
    if (!this._pushInt(keyLength, MT.MAP)) {
      return false;
    }
    return this._pushRawMap(
      keyLength,
      keys.map((k2) => [k2, obj[k2]])
    );
  }
  _pushRawMap(len2, map2) {
    map2 = map2.map(function(a) {
      a[0] = Encoder.encode(a[0]);
      return a;
    }).sort(utils.keySorter);
    for (var j = 0; j < len2; j++) {
      if (!this.push(map2[j][0])) {
        return false;
      }
      if (!this.pushAny(map2[j][1])) {
        return false;
      }
    }
    return true;
  }
  write(obj) {
    return this.pushAny(obj);
  }
  pushAny(obj) {
    var typ = toType(obj);
    switch (typ) {
      case "Number":
        return this._pushNumber(obj);
      case "String":
        return this._pushString(obj);
      case "Boolean":
        return this._pushBoolean(obj);
      case "Object":
        return this._pushObject(obj);
      case "Array":
        return this._pushArray(this, obj);
      case "Uint8Array":
        return this._pushBuffer(this, Buffer$2.isBuffer(obj) ? obj : Buffer$2.from(obj));
      case "Null":
        return this._pushUInt8(NULL);
      case "Undefined":
        return this._pushUndefined(obj);
      case "Map":
        return this._pushMap(this, obj);
      case "Set":
        return this._pushSet(this, obj);
      case "URL":
        return this._pushUrl(this, obj);
      case "BigNumber":
        return this._pushBigNumber(this, obj);
      case "Date":
        return this._pushDate(this, obj);
      case "RegExp":
        return this._pushRegexp(this, obj);
      case "Symbol":
        switch (obj) {
          case SYMS.NULL:
            return this._pushObject(null);
          case SYMS.UNDEFINED:
            return this._pushUndefined(void 0);
          default:
            throw new Error("Unknown symbol: " + obj.toString());
        }
      default:
        throw new Error("Unknown type: " + typeof obj + ", " + (obj ? obj.toString() : ""));
    }
  }
  finalize() {
    if (this.offset === 0) {
      return null;
    }
    var result = this.result;
    var resultLength = this.resultLength;
    var resultMethod = this.resultMethod;
    var offset = this.offset;
    var size = 0;
    var i2 = 0;
    for (; i2 < offset; i2++) {
      size += resultLength[i2];
    }
    var res = Buffer$2.allocUnsafe(size);
    var index2 = 0;
    var length2 = 0;
    for (i2 = 0; i2 < offset; i2++) {
      length2 = resultLength[i2];
      switch (resultMethod[i2]) {
        case 0:
          result[i2].copy(res, index2);
          break;
        case 1:
          res.writeUInt8(result[i2], index2, true);
          break;
        case 2:
          res.writeUInt16BE(result[i2], index2, true);
          break;
        case 3:
          res.writeUInt32BE(result[i2], index2, true);
          break;
        case 4:
          res.writeDoubleBE(result[i2], index2, true);
          break;
        case 5:
          res.write(result[i2], index2, length2, "utf8");
          break;
        default:
          throw new Error("unkown method");
      }
      index2 += length2;
    }
    var tmp = res;
    this._reset();
    return tmp;
  }
  _reset() {
    this.result = [];
    this.resultMethod = [];
    this.resultLength = [];
    this.offset = 0;
  }
  static encode(o) {
    const enc = new Encoder();
    const ret = enc.pushAny(o);
    if (!ret) {
      throw new Error("Failed to encode input");
    }
    return enc.finalize();
  }
}
var encoder = Encoder;
(function(exports2) {
  exports2.Diagnose = diagnose;
  exports2.Decoder = decoder;
  exports2.Encoder = encoder;
  exports2.Simple = simple;
  exports2.Tagged = tagged$1;
  exports2.decodeAll = exports2.Decoder.decodeAll;
  exports2.decodeFirst = exports2.Decoder.decodeFirst;
  exports2.diagnose = exports2.Diagnose.diagnose;
  exports2.encode = exports2.Encoder.encode;
  exports2.decode = exports2.Decoder.decode;
  exports2.leveldb = {
    decode: exports2.Decoder.decodeAll,
    encode: exports2.Encoder.encode,
    buffer: true,
    name: "cbor"
  };
})(src$1);
var safeBuffer = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(module2, exports2) {
  var buffer2 = buffer$1;
  var Buffer2 = buffer2.Buffer;
  function copyProps(src2, dst) {
    for (var key in src2) {
      dst[key] = src2[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module2.exports = buffer2;
  } else {
    copyProps(buffer2, exports2);
    exports2.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length2) {
    return Buffer2(arg, encodingOrOffset, length2);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length2) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length2);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== void 0) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer2.SlowBuffer(size);
  };
})(safeBuffer, safeBuffer.exports);
const Buffer$1 = safeBuffer.exports.Buffer;
var bufferPipe = class BufferPipe {
  constructor(buf = Buffer$1.from([])) {
    this.buffer = buf;
    this._bytesRead = 0;
    this._bytesWrote = 0;
  }
  read(num) {
    this._bytesRead += num;
    const data2 = this.buffer.slice(0, num);
    this.buffer = this.buffer.slice(num);
    return data2;
  }
  write(buf) {
    buf = Buffer$1.from(buf);
    this._bytesWrote += buf.length;
    this.buffer = Buffer$1.concat([this.buffer, buf]);
  }
  get end() {
    return !this.buffer.length;
  }
  get bytesRead() {
    return this._bytesRead;
  }
  get bytesWrote() {
    return this._bytesWrote;
  }
};
function safeRead$1(pipe, num) {
  if (pipe.buffer.length < num) {
    throw new Error("unexpected end of buffer");
  }
  return pipe.read(num);
}
function lebEncode$1(value2) {
  if (typeof value2 === "number") {
    value2 = BigInt(value2);
  }
  if (value2 < BigInt(0)) {
    throw new Error("Cannot leb encode negative values.");
  }
  const pipe = new bufferPipe();
  while (true) {
    const i2 = Number(value2 & BigInt(127));
    value2 /= BigInt(128);
    if (value2 === BigInt(0)) {
      pipe.write([i2]);
      break;
    } else {
      pipe.write([i2 | 128]);
    }
  }
  return new buffer$1.Buffer(pipe.buffer);
}
function lebDecode$1(pipe) {
  let weight = BigInt(1);
  let value2 = BigInt(0);
  let byte;
  do {
    byte = safeRead$1(pipe, 1)[0];
    value2 += BigInt(byte & 127).valueOf() * weight;
    weight *= BigInt(128);
  } while (byte >= 128);
  return value2;
}
function slebEncode$1(value2) {
  if (typeof value2 === "number") {
    value2 = BigInt(value2);
  }
  const isNeg = value2 < BigInt(0);
  if (isNeg) {
    value2 = -value2 - BigInt(1);
  }
  const pipe = new bufferPipe();
  while (true) {
    const i2 = getLowerBytes(value2);
    value2 /= BigInt(128);
    if (isNeg && value2 === BigInt(0) && (i2 & 64) !== 0 || !isNeg && value2 === BigInt(0) && (i2 & 64) === 0) {
      pipe.write([i2]);
      break;
    } else {
      pipe.write([i2 | 128]);
    }
  }
  function getLowerBytes(num) {
    const bytes2 = num % BigInt(128);
    if (isNeg) {
      return Number(BigInt(128) - bytes2 - BigInt(1));
    } else {
      return Number(bytes2);
    }
  }
  return new buffer$1.Buffer(pipe.buffer);
}
function slebDecode$1(pipe) {
  const pipeView = new Uint8Array(pipe.buffer);
  let len2 = 0;
  for (; len2 < pipeView.byteLength; len2++) {
    if (pipeView[len2] < 128) {
      if ((pipeView[len2] & 64) === 0) {
        return lebDecode$1(pipe);
      }
      break;
    }
  }
  const bytes2 = new Uint8Array(safeRead$1(pipe, len2 + 1));
  let value2 = BigInt(0);
  for (let i2 = bytes2.byteLength - 1; i2 >= 0; i2--) {
    value2 = value2 * BigInt(128) + BigInt(128 - (bytes2[i2] & 127) - 1);
  }
  return -value2 - BigInt(1);
}
function writeUIntLE$1(value2, byteLength2) {
  if (BigInt(value2) < BigInt(0)) {
    throw new Error("Cannot write negative values.");
  }
  return writeIntLE$1(value2, byteLength2);
}
function writeIntLE$1(value2, byteLength2) {
  value2 = BigInt(value2);
  const pipe = new bufferPipe();
  let i2 = 0;
  let mul = BigInt(256);
  let sub = BigInt(0);
  let byte = Number(value2 % mul);
  pipe.write([byte]);
  while (++i2 < byteLength2) {
    if (value2 < 0 && sub === BigInt(0) && byte !== 0) {
      sub = BigInt(1);
    }
    byte = Number((value2 / mul - sub) % BigInt(256));
    pipe.write([byte]);
    mul *= BigInt(256);
  }
  return new buffer$1.Buffer(pipe.buffer);
}
function readUIntLE$1(pipe, byteLength2) {
  let val = BigInt(safeRead$1(pipe, 1)[0]);
  let mul = BigInt(1);
  let i2 = 0;
  while (++i2 < byteLength2) {
    mul *= BigInt(256);
    const byte = BigInt(safeRead$1(pipe, 1)[0]);
    val = val + mul * byte;
  }
  return val;
}
function readIntLE$1(pipe, byteLength2) {
  let val = readUIntLE$1(pipe, byteLength2);
  const mul = BigInt(2) ** (BigInt(8) * BigInt(byteLength2 - 1) + BigInt(7));
  if (val >= mul) {
    val -= mul * BigInt(2);
  }
  return val;
}
function blobFromBuffer(b2) {
  return b2;
}
function blobFromUint8Array(arr) {
  return buffer$1.Buffer.from(arr);
}
function blobFromText(text) {
  return buffer$1.Buffer.from(text);
}
function blobFromHex(hex) {
  return buffer$1.Buffer.from(hex, "hex");
}
function blobToHex(blob) {
  return blob.toString("hex");
}
function blobToUint8Array(blob) {
  return new Uint8Array(blob.slice(0, blob.byteLength));
}
function makeNonce$1() {
  return lebEncode$1(BigInt(+Date.now()) * BigInt(1e5) + BigInt(Math.floor(Math.random() * 1e5)));
}
function idlHash$1(s) {
  const utf8encoder = new TextEncoder();
  const array2 = utf8encoder.encode(s);
  let h2 = 0;
  for (const c2 of array2) {
    h2 = (h2 * 223 + c2) % 2 ** 32;
  }
  return h2;
}
function idlLabelToId$1(label) {
  if (/^_\d+_$/.test(label) || /^_0x[0-9a-fA-F]+_$/.test(label)) {
    const num = +label.slice(1, -1);
    if (Number.isSafeInteger(num) && num >= 0 && num < 2 ** 32) {
      return num;
    }
  }
  return idlHash$1(label);
}
const magicNumber$1 = "DIDL";
function zipWith$1(xs, ys, f2) {
  return xs.map((x2, i2) => f2(x2, ys[i2]));
}
class TypeTable$1 {
  constructor() {
    this._typs = [];
    this._idx = /* @__PURE__ */ new Map();
  }
  has(obj) {
    return this._idx.has(obj.name);
  }
  add(type, buf) {
    const idx = this._typs.length;
    this._idx.set(type.name, idx);
    this._typs.push(buf);
  }
  merge(obj, knot) {
    const idx = this._idx.get(obj.name);
    const knotIdx = this._idx.get(knot);
    if (idx === void 0) {
      throw new Error("Missing type index for " + obj);
    }
    if (knotIdx === void 0) {
      throw new Error("Missing type index for " + knot);
    }
    this._typs[idx] = this._typs[knotIdx];
    this._typs.splice(knotIdx, 1);
    this._idx.delete(knot);
  }
  encode() {
    const len2 = lebEncode$1(this._typs.length);
    const buf = buffer$1.Buffer.concat(this._typs);
    return buffer$1.Buffer.concat([len2, buf]);
  }
  indexOf(typeName) {
    if (!this._idx.has(typeName)) {
      throw new Error("Missing type index for " + typeName);
    }
    return slebEncode$1(this._idx.get(typeName) || 0);
  }
}
class Visitor$1 {
  visitType(t2, data2) {
    throw new Error("Not implemented");
  }
  visitPrimitive(t2, data2) {
    return this.visitType(t2, data2);
  }
  visitEmpty(t2, data2) {
    return this.visitPrimitive(t2, data2);
  }
  visitBool(t2, data2) {
    return this.visitPrimitive(t2, data2);
  }
  visitNull(t2, data2) {
    return this.visitPrimitive(t2, data2);
  }
  visitReserved(t2, data2) {
    return this.visitPrimitive(t2, data2);
  }
  visitText(t2, data2) {
    return this.visitPrimitive(t2, data2);
  }
  visitNumber(t2, data2) {
    return this.visitPrimitive(t2, data2);
  }
  visitInt(t2, data2) {
    return this.visitNumber(t2, data2);
  }
  visitNat(t2, data2) {
    return this.visitNumber(t2, data2);
  }
  visitFloat(t2, data2) {
    return this.visitPrimitive(t2, data2);
  }
  visitFixedInt(t2, data2) {
    return this.visitNumber(t2, data2);
  }
  visitFixedNat(t2, data2) {
    return this.visitNumber(t2, data2);
  }
  visitPrincipal(t2, data2) {
    return this.visitPrimitive(t2, data2);
  }
  visitConstruct(t2, data2) {
    return this.visitType(t2, data2);
  }
  visitVec(t2, ty, data2) {
    return this.visitConstruct(t2, data2);
  }
  visitOpt(t2, ty, data2) {
    return this.visitConstruct(t2, data2);
  }
  visitRecord(t2, fields, data2) {
    return this.visitConstruct(t2, data2);
  }
  visitTuple(t2, components, data2) {
    const fields = components.map((ty, i2) => [`_${i2}_`, ty]);
    return this.visitRecord(t2, fields, data2);
  }
  visitVariant(t2, fields, data2) {
    return this.visitConstruct(t2, data2);
  }
  visitRec(t2, ty, data2) {
    return this.visitConstruct(ty, data2);
  }
  visitFunc(t2, data2) {
    return this.visitConstruct(t2, data2);
  }
  visitService(t2, data2) {
    return this.visitConstruct(t2, data2);
  }
}
class Type$1 {
  display() {
    return this.name;
  }
  valueToString(x2) {
    return toReadableString$1(x2);
  }
  buildTypeTable(typeTable) {
    if (!typeTable.has(this)) {
      this._buildTypeTableImpl(typeTable);
    }
  }
}
class PrimitiveType$1 extends Type$1 {
  checkType(t2) {
    if (this.name !== t2.name) {
      throw new Error(`type mismatch: type on the wire ${t2.name}, expect type ${this.name}`);
    }
    return t2;
  }
  _buildTypeTableImpl(typeTable) {
    return;
  }
}
class ConstructType$1 extends Type$1 {
  checkType(t2) {
    if (t2 instanceof RecClass$1) {
      const ty = t2.getType();
      if (typeof ty === "undefined") {
        throw new Error("type mismatch with uninitialized type");
      }
      return ty;
    }
    throw new Error(`type mismatch: type on the wire ${t2.name}, expect type ${this.name}`);
  }
  encodeType(typeTable) {
    return typeTable.indexOf(this.name);
  }
}
class EmptyClass$1 extends PrimitiveType$1 {
  accept(v2, d2) {
    return v2.visitEmpty(this, d2);
  }
  covariant(x2) {
    return false;
  }
  encodeValue() {
    throw new Error("Empty cannot appear as a function argument");
  }
  valueToString() {
    throw new Error("Empty cannot appear as a value");
  }
  encodeType() {
    return slebEncode$1(-17);
  }
  decodeValue() {
    throw new Error("Empty cannot appear as an output");
  }
  get name() {
    return "empty";
  }
}
class BoolClass$1 extends PrimitiveType$1 {
  accept(v2, d2) {
    return v2.visitBool(this, d2);
  }
  covariant(x2) {
    return typeof x2 === "boolean";
  }
  encodeValue(x2) {
    const buf = buffer$1.Buffer.alloc(1);
    buf.writeInt8(x2 ? 1 : 0, 0);
    return buf;
  }
  encodeType() {
    return slebEncode$1(-2);
  }
  decodeValue(b2, t2) {
    this.checkType(t2);
    const x2 = safeRead$1(b2, 1).toString("hex");
    if (x2 === "00") {
      return false;
    } else if (x2 === "01") {
      return true;
    } else {
      throw new Error("Boolean value out of range");
    }
  }
  get name() {
    return "bool";
  }
}
class NullClass$1 extends PrimitiveType$1 {
  accept(v2, d2) {
    return v2.visitNull(this, d2);
  }
  covariant(x2) {
    return x2 === null;
  }
  encodeValue() {
    return buffer$1.Buffer.alloc(0);
  }
  encodeType() {
    return slebEncode$1(-1);
  }
  decodeValue(b2, t2) {
    this.checkType(t2);
    return null;
  }
  get name() {
    return "null";
  }
}
class ReservedClass$1 extends PrimitiveType$1 {
  accept(v2, d2) {
    return v2.visitReserved(this, d2);
  }
  covariant(x2) {
    return true;
  }
  encodeValue() {
    return buffer$1.Buffer.alloc(0);
  }
  encodeType() {
    return slebEncode$1(-16);
  }
  decodeValue(b2, t2) {
    if (t2.name !== this.name) {
      t2.decodeValue(b2, t2);
    }
    return null;
  }
  get name() {
    return "reserved";
  }
}
function isValidUTF8(buf) {
  return buffer$1.Buffer.compare(new buffer$1.Buffer(buf.toString(), "utf8"), buf) === 0;
}
class TextClass$1 extends PrimitiveType$1 {
  accept(v2, d2) {
    return v2.visitText(this, d2);
  }
  covariant(x2) {
    return typeof x2 === "string";
  }
  encodeValue(x2) {
    const buf = buffer$1.Buffer.from(x2, "utf8");
    const len2 = lebEncode$1(buf.length);
    return buffer$1.Buffer.concat([len2, buf]);
  }
  encodeType() {
    return slebEncode$1(-15);
  }
  decodeValue(b2, t2) {
    this.checkType(t2);
    const len2 = lebDecode$1(b2);
    const buf = safeRead$1(b2, Number(len2));
    if (!isValidUTF8(buf)) {
      throw new Error("Not valid UTF8 text");
    }
    return buf.toString("utf8");
  }
  get name() {
    return "text";
  }
  valueToString(x2) {
    return '"' + x2 + '"';
  }
}
class IntClass$1 extends PrimitiveType$1 {
  accept(v2, d2) {
    return v2.visitInt(this, d2);
  }
  covariant(x2) {
    return typeof x2 === "bigint" || Number.isInteger(x2);
  }
  encodeValue(x2) {
    return slebEncode$1(x2);
  }
  encodeType() {
    return slebEncode$1(-4);
  }
  decodeValue(b2, t2) {
    this.checkType(t2);
    return slebDecode$1(b2);
  }
  get name() {
    return "int";
  }
  valueToString(x2) {
    return x2.toString();
  }
}
class NatClass$1 extends PrimitiveType$1 {
  accept(v2, d2) {
    return v2.visitNat(this, d2);
  }
  covariant(x2) {
    return typeof x2 === "bigint" && x2 >= BigInt(0) || Number.isInteger(x2) && x2 >= 0;
  }
  encodeValue(x2) {
    return lebEncode$1(x2);
  }
  encodeType() {
    return slebEncode$1(-3);
  }
  decodeValue(b2, t2) {
    this.checkType(t2);
    return lebDecode$1(b2);
  }
  get name() {
    return "nat";
  }
  valueToString(x2) {
    return x2.toString();
  }
}
class FloatClass$1 extends PrimitiveType$1 {
  constructor(_bits) {
    super();
    this._bits = _bits;
    if (_bits !== 32 && _bits !== 64) {
      throw new Error("not a valid float type");
    }
  }
  accept(v2, d2) {
    return v2.visitFloat(this, d2);
  }
  covariant(x2) {
    return typeof x2 === "number" || x2 instanceof Number;
  }
  encodeValue(x2) {
    const buf = buffer$1.Buffer.allocUnsafe(this._bits / 8);
    if (this._bits === 32) {
      buf.writeFloatLE(x2, 0);
    } else {
      buf.writeDoubleLE(x2, 0);
    }
    return buf;
  }
  encodeType() {
    const opcode = this._bits === 32 ? -13 : -14;
    return slebEncode$1(opcode);
  }
  decodeValue(b2, t2) {
    this.checkType(t2);
    const x2 = safeRead$1(b2, this._bits / 8);
    if (this._bits === 32) {
      return x2.readFloatLE(0);
    } else {
      return x2.readDoubleLE(0);
    }
  }
  get name() {
    return "float" + this._bits;
  }
  valueToString(x2) {
    return x2.toString();
  }
}
class FixedIntClass$1 extends PrimitiveType$1 {
  constructor(_bits) {
    super();
    this._bits = _bits;
  }
  accept(v2, d2) {
    return v2.visitFixedInt(this, d2);
  }
  covariant(x2) {
    const min = BigInt(2) ** BigInt(this._bits - 1) * BigInt(-1);
    const max = BigInt(2) ** BigInt(this._bits - 1) - BigInt(1);
    if (typeof x2 === "bigint") {
      return x2 >= min && x2 <= max;
    } else if (Number.isInteger(x2)) {
      const v2 = BigInt(x2);
      return v2 >= min && v2 <= max;
    } else {
      return false;
    }
  }
  encodeValue(x2) {
    return writeIntLE$1(x2, this._bits / 8);
  }
  encodeType() {
    const offset = Math.log2(this._bits) - 3;
    return slebEncode$1(-9 - offset);
  }
  decodeValue(b2, t2) {
    this.checkType(t2);
    const num = readIntLE$1(b2, this._bits / 8);
    if (this._bits <= 32) {
      return Number(num);
    } else {
      return num;
    }
  }
  get name() {
    return `int${this._bits}`;
  }
  valueToString(x2) {
    return x2.toString();
  }
}
class FixedNatClass$1 extends PrimitiveType$1 {
  constructor(bits) {
    super();
    this.bits = bits;
  }
  accept(v2, d2) {
    return v2.visitFixedNat(this, d2);
  }
  covariant(x2) {
    const max = BigInt(2) ** BigInt(this.bits);
    if (typeof x2 === "bigint" && x2 >= BigInt(0)) {
      return x2 < max;
    } else if (Number.isInteger(x2) && x2 >= 0) {
      const v2 = BigInt(x2);
      return v2 < max;
    } else {
      return false;
    }
  }
  encodeValue(x2) {
    return writeUIntLE$1(x2, this.bits / 8);
  }
  encodeType() {
    const offset = Math.log2(this.bits) - 3;
    return slebEncode$1(-5 - offset);
  }
  decodeValue(b2, t2) {
    this.checkType(t2);
    const num = readUIntLE$1(b2, this.bits / 8);
    if (this.bits <= 32) {
      return Number(num);
    } else {
      return num;
    }
  }
  get name() {
    return `nat${this.bits}`;
  }
  valueToString(x2) {
    return x2.toString();
  }
}
class VecClass$1 extends ConstructType$1 {
  constructor(_type) {
    super();
    this._type = _type;
    this._blobOptimization = false;
    if (_type instanceof FixedNatClass$1 && _type.bits === 8) {
      this._blobOptimization = true;
    }
  }
  accept(v2, d2) {
    return v2.visitVec(this, this._type, d2);
  }
  covariant(x2) {
    return Array.isArray(x2) && x2.every((v2) => this._type.covariant(v2));
  }
  encodeValue(x2) {
    const len2 = lebEncode$1(x2.length);
    if (this._blobOptimization) {
      return buffer$1.Buffer.concat([len2, buffer$1.Buffer.from(x2)]);
    }
    return buffer$1.Buffer.concat([len2, ...x2.map((d2) => this._type.encodeValue(d2))]);
  }
  _buildTypeTableImpl(typeTable) {
    this._type.buildTypeTable(typeTable);
    const opCode = slebEncode$1(-19);
    const buffer2 = this._type.encodeType(typeTable);
    typeTable.add(this, buffer$1.Buffer.concat([opCode, buffer2]));
  }
  decodeValue(b2, t2) {
    const vec = this.checkType(t2);
    if (!(vec instanceof VecClass$1)) {
      throw new Error("Not a vector type");
    }
    const len2 = Number(lebDecode$1(b2));
    if (this._blobOptimization) {
      return [...new Uint8Array(b2.read(len2))];
    }
    const rets = [];
    for (let i2 = 0; i2 < len2; i2++) {
      rets.push(this._type.decodeValue(b2, vec._type));
    }
    return rets;
  }
  get name() {
    return `vec ${this._type.name}`;
  }
  display() {
    return `vec ${this._type.display()}`;
  }
  valueToString(x2) {
    const elements = x2.map((e2) => this._type.valueToString(e2));
    return "vec {" + elements.join("; ") + "}";
  }
}
class OptClass$1 extends ConstructType$1 {
  constructor(_type) {
    super();
    this._type = _type;
  }
  accept(v2, d2) {
    return v2.visitOpt(this, this._type, d2);
  }
  covariant(x2) {
    return Array.isArray(x2) && (x2.length === 0 || x2.length === 1 && this._type.covariant(x2[0]));
  }
  encodeValue(x2) {
    if (x2.length === 0) {
      return buffer$1.Buffer.from([0]);
    } else {
      return buffer$1.Buffer.concat([buffer$1.Buffer.from([1]), this._type.encodeValue(x2[0])]);
    }
  }
  _buildTypeTableImpl(typeTable) {
    this._type.buildTypeTable(typeTable);
    const opCode = slebEncode$1(-18);
    const buffer2 = this._type.encodeType(typeTable);
    typeTable.add(this, buffer$1.Buffer.concat([opCode, buffer2]));
  }
  decodeValue(b2, t2) {
    const opt = this.checkType(t2);
    if (!(opt instanceof OptClass$1)) {
      throw new Error("Not an option type");
    }
    const len2 = safeRead$1(b2, 1).toString("hex");
    if (len2 === "00") {
      return [];
    } else if (len2 === "01") {
      return [this._type.decodeValue(b2, opt._type)];
    } else {
      throw new Error("Not an option value");
    }
  }
  get name() {
    return `opt ${this._type.name}`;
  }
  display() {
    return `opt ${this._type.display()}`;
  }
  valueToString(x2) {
    if (x2.length === 0) {
      return "null";
    } else {
      return `opt ${this._type.valueToString(x2[0])}`;
    }
  }
}
class RecordClass$1 extends ConstructType$1 {
  constructor(fields = {}) {
    super();
    this._fields = Object.entries(fields).sort((a, b2) => idlLabelToId$1(a[0]) - idlLabelToId$1(b2[0]));
  }
  accept(v2, d2) {
    return v2.visitRecord(this, this._fields, d2);
  }
  tryAsTuple() {
    const res = [];
    for (let i2 = 0; i2 < this._fields.length; i2++) {
      const [key, type] = this._fields[i2];
      if (key !== `_${i2}_`) {
        return null;
      }
      res.push(type);
    }
    return res;
  }
  covariant(x2) {
    return typeof x2 === "object" && this._fields.every(([k2, t2]) => {
      if (!x2.hasOwnProperty(k2)) {
        throw new Error(`Record is missing key "${k2}".`);
      }
      return t2.covariant(x2[k2]);
    });
  }
  encodeValue(x2) {
    const values2 = this._fields.map(([key]) => x2[key]);
    const bufs = zipWith$1(this._fields, values2, ([, c2], d2) => c2.encodeValue(d2));
    return buffer$1.Buffer.concat(bufs);
  }
  _buildTypeTableImpl(T2) {
    this._fields.forEach(([_2, value2]) => value2.buildTypeTable(T2));
    const opCode = slebEncode$1(-20);
    const len2 = lebEncode$1(this._fields.length);
    const fields = this._fields.map(([key, value2]) => buffer$1.Buffer.concat([lebEncode$1(idlLabelToId$1(key)), value2.encodeType(T2)]));
    T2.add(this, buffer$1.Buffer.concat([opCode, len2, buffer$1.Buffer.concat(fields)]));
  }
  decodeValue(b2, t2) {
    const record = this.checkType(t2);
    if (!(record instanceof RecordClass$1)) {
      throw new Error("Not a record type");
    }
    const x2 = {};
    let idx = 0;
    for (const [hash2, type] of record._fields) {
      if (idx >= this._fields.length || idlLabelToId$1(this._fields[idx][0]) !== idlLabelToId$1(hash2)) {
        type.decodeValue(b2, type);
        continue;
      }
      const [expectKey, expectType] = this._fields[idx];
      x2[expectKey] = expectType.decodeValue(b2, type);
      idx++;
    }
    if (idx < this._fields.length) {
      throw new Error("Cannot find field " + this._fields[idx][0]);
    }
    return x2;
  }
  get name() {
    const fields = this._fields.map(([key, value2]) => key + ":" + value2.name);
    return `record {${fields.join("; ")}}`;
  }
  display() {
    const fields = this._fields.map(([key, value2]) => key + ":" + value2.display());
    return `record {${fields.join("; ")}}`;
  }
  valueToString(x2) {
    const values2 = this._fields.map(([key]) => x2[key]);
    const fields = zipWith$1(this._fields, values2, ([k2, c2], d2) => k2 + "=" + c2.valueToString(d2));
    return `record {${fields.join("; ")}}`;
  }
}
class TupleClass$1 extends RecordClass$1 {
  constructor(_components) {
    const x2 = {};
    _components.forEach((e2, i2) => x2["_" + i2 + "_"] = e2);
    super(x2);
    this._components = _components;
  }
  accept(v2, d2) {
    return v2.visitTuple(this, this._components, d2);
  }
  covariant(x2) {
    return Array.isArray(x2) && x2.length >= this._fields.length && this._components.every((t2, i2) => t2.covariant(x2[i2]));
  }
  encodeValue(x2) {
    const bufs = zipWith$1(this._components, x2, (c2, d2) => c2.encodeValue(d2));
    return buffer$1.Buffer.concat(bufs);
  }
  decodeValue(b2, t2) {
    const tuple = this.checkType(t2);
    if (!(tuple instanceof TupleClass$1)) {
      throw new Error("not a tuple type");
    }
    if (tuple._components.length < this._components.length) {
      throw new Error("tuple mismatch");
    }
    const res = [];
    for (const [i2, wireType] of tuple._components.entries()) {
      if (i2 >= this._components.length) {
        wireType.decodeValue(b2, wireType);
      } else {
        res.push(this._components[i2].decodeValue(b2, wireType));
      }
    }
    return res;
  }
  display() {
    const fields = this._components.map((value2) => value2.display());
    return `record {${fields.join("; ")}}`;
  }
  valueToString(values2) {
    const fields = zipWith$1(this._components, values2, (c2, d2) => c2.valueToString(d2));
    return `record {${fields.join("; ")}}`;
  }
}
class VariantClass$1 extends ConstructType$1 {
  constructor(fields = {}) {
    super();
    this._fields = Object.entries(fields).sort((a, b2) => idlLabelToId$1(a[0]) - idlLabelToId$1(b2[0]));
  }
  accept(v2, d2) {
    return v2.visitVariant(this, this._fields, d2);
  }
  covariant(x2) {
    return typeof x2 === "object" && Object.entries(x2).length === 1 && this._fields.every(([k2, v2]) => {
      return !x2.hasOwnProperty(k2) || v2.covariant(x2[k2]);
    });
  }
  encodeValue(x2) {
    for (let i2 = 0; i2 < this._fields.length; i2++) {
      const [name, type] = this._fields[i2];
      if (x2.hasOwnProperty(name)) {
        const idx = lebEncode$1(i2);
        const buf = type.encodeValue(x2[name]);
        return buffer$1.Buffer.concat([idx, buf]);
      }
    }
    throw Error("Variant has no data: " + x2);
  }
  _buildTypeTableImpl(typeTable) {
    this._fields.forEach(([, type]) => {
      type.buildTypeTable(typeTable);
    });
    const opCode = slebEncode$1(-21);
    const len2 = lebEncode$1(this._fields.length);
    const fields = this._fields.map(([key, value2]) => buffer$1.Buffer.concat([lebEncode$1(idlLabelToId$1(key)), value2.encodeType(typeTable)]));
    typeTable.add(this, buffer$1.Buffer.concat([opCode, len2, ...fields]));
  }
  decodeValue(b2, t2) {
    const variant = this.checkType(t2);
    if (!(variant instanceof VariantClass$1)) {
      throw new Error("Not a variant type");
    }
    const idx = Number(lebDecode$1(b2));
    if (idx >= variant._fields.length) {
      throw Error("Invalid variant index: " + idx);
    }
    const [wireHash, wireType] = variant._fields[idx];
    for (const [key, expectType] of this._fields) {
      if (idlLabelToId$1(wireHash) === idlLabelToId$1(key)) {
        const value2 = expectType.decodeValue(b2, wireType);
        return { [key]: value2 };
      }
    }
    throw new Error("Cannot find field hash " + wireHash);
  }
  get name() {
    const fields = this._fields.map(([key, type]) => key + ":" + type.name);
    return `variant {${fields.join("; ")}}`;
  }
  display() {
    const fields = this._fields.map(([key, type]) => key + (type.name === "null" ? "" : `:${type.display()}`));
    return `variant {${fields.join("; ")}}`;
  }
  valueToString(x2) {
    for (const [name, type] of this._fields) {
      if (x2.hasOwnProperty(name)) {
        const value2 = type.valueToString(x2[name]);
        if (value2 === "null") {
          return `variant {${name}}`;
        } else {
          return `variant {${name}=${value2}}`;
        }
      }
    }
    throw new Error("Variant has no data: " + x2);
  }
}
class RecClass$1 extends ConstructType$1 {
  constructor() {
    super(...arguments);
    this._id = RecClass$1._counter++;
    this._type = void 0;
  }
  accept(v2, d2) {
    if (!this._type) {
      throw Error("Recursive type uninitialized.");
    }
    return v2.visitRec(this, this._type, d2);
  }
  fill(t2) {
    this._type = t2;
  }
  getType() {
    return this._type;
  }
  covariant(x2) {
    return this._type ? this._type.covariant(x2) : false;
  }
  encodeValue(x2) {
    if (!this._type) {
      throw Error("Recursive type uninitialized.");
    }
    return this._type.encodeValue(x2);
  }
  _buildTypeTableImpl(typeTable) {
    if (!this._type) {
      throw Error("Recursive type uninitialized.");
    }
    typeTable.add(this, buffer$1.Buffer.alloc(0));
    this._type.buildTypeTable(typeTable);
    typeTable.merge(this, this._type.name);
  }
  decodeValue(b2, t2) {
    if (!this._type) {
      throw Error("Recursive type uninitialized.");
    }
    return this._type.decodeValue(b2, t2);
  }
  get name() {
    return `rec_${this._id}`;
  }
  display() {
    if (!this._type) {
      throw Error("Recursive type uninitialized.");
    }
    return `\u03BC${this.name}.${this._type.name}`;
  }
  valueToString(x2) {
    if (!this._type) {
      throw Error("Recursive type uninitialized.");
    }
    return this._type.valueToString(x2);
  }
}
RecClass$1._counter = 0;
function decodePrincipalId$1(b2) {
  const x2 = safeRead$1(b2, 1).toString("hex");
  if (x2 !== "01") {
    throw new Error("Cannot decode principal");
  }
  const len2 = Number(lebDecode$1(b2));
  const hex = safeRead$1(b2, len2).toString("hex").toUpperCase();
  return Principal$2.fromHex(hex);
}
class PrincipalClass$1 extends PrimitiveType$1 {
  accept(v2, d2) {
    return v2.visitPrincipal(this, d2);
  }
  covariant(x2) {
    return x2 && x2._isPrincipal;
  }
  encodeValue(x2) {
    const hex = x2.toHex();
    const buf = buffer$1.Buffer.from(hex, "hex");
    const len2 = lebEncode$1(buf.length);
    return buffer$1.Buffer.concat([buffer$1.Buffer.from([1]), len2, buf]);
  }
  encodeType() {
    return slebEncode$1(-24);
  }
  decodeValue(b2, t2) {
    this.checkType(t2);
    return decodePrincipalId$1(b2);
  }
  get name() {
    return "principal";
  }
  valueToString(x2) {
    return `${this.name} "${x2.toText()}"`;
  }
}
class FuncClass$1 extends ConstructType$1 {
  constructor(argTypes, retTypes, annotations = []) {
    super();
    this.argTypes = argTypes;
    this.retTypes = retTypes;
    this.annotations = annotations;
  }
  static argsToString(types, v2) {
    if (types.length !== v2.length) {
      throw new Error("arity mismatch");
    }
    return "(" + types.map((t2, i2) => t2.valueToString(v2[i2])).join(", ") + ")";
  }
  accept(v2, d2) {
    return v2.visitFunc(this, d2);
  }
  covariant(x2) {
    return Array.isArray(x2) && x2.length === 2 && x2[0] && x2[0]._isPrincipal && typeof x2[1] === "string";
  }
  encodeValue(x2) {
    const hex = x2[0].toHex();
    const buf = buffer$1.Buffer.from(hex, "hex");
    const len2 = lebEncode$1(buf.length);
    const canister = buffer$1.Buffer.concat([buffer$1.Buffer.from([1]), len2, buf]);
    const method2 = buffer$1.Buffer.from(x2[1], "utf8");
    const methodLen = lebEncode$1(method2.length);
    return buffer$1.Buffer.concat([buffer$1.Buffer.from([1]), canister, methodLen, method2]);
  }
  _buildTypeTableImpl(T2) {
    this.argTypes.forEach((arg) => arg.buildTypeTable(T2));
    this.retTypes.forEach((arg) => arg.buildTypeTable(T2));
    const opCode = slebEncode$1(-22);
    const argLen = lebEncode$1(this.argTypes.length);
    const args = buffer$1.Buffer.concat(this.argTypes.map((arg) => arg.encodeType(T2)));
    const retLen = lebEncode$1(this.retTypes.length);
    const rets = buffer$1.Buffer.concat(this.retTypes.map((arg) => arg.encodeType(T2)));
    const annLen = lebEncode$1(this.annotations.length);
    const anns = buffer$1.Buffer.concat(this.annotations.map((a) => this.encodeAnnotation(a)));
    T2.add(this, buffer$1.Buffer.concat([opCode, argLen, args, retLen, rets, annLen, anns]));
  }
  decodeValue(b2) {
    const x2 = safeRead$1(b2, 1).toString("hex");
    if (x2 !== "01") {
      throw new Error("Cannot decode function reference");
    }
    const canister = decodePrincipalId$1(b2);
    const mLen = Number(lebDecode$1(b2));
    const buf = safeRead$1(b2, mLen);
    if (!isValidUTF8(buf)) {
      throw new Error("Not valid UTF8 method name");
    }
    const method2 = buf.toString("utf8");
    return [canister, method2];
  }
  get name() {
    const args = this.argTypes.map((arg) => arg.name).join(", ");
    const rets = this.retTypes.map((arg) => arg.name).join(", ");
    const annon = " " + this.annotations.join(" ");
    return `(${args}) -> (${rets})${annon}`;
  }
  valueToString([principal, str]) {
    return `func "${principal.toText()}".${str}`;
  }
  display() {
    const args = this.argTypes.map((arg) => arg.display()).join(", ");
    const rets = this.retTypes.map((arg) => arg.display()).join(", ");
    const annon = " " + this.annotations.join(" ");
    return `(${args}) \u2192 (${rets})${annon}`;
  }
  encodeAnnotation(ann) {
    if (ann === "query") {
      return buffer$1.Buffer.from([1]);
    } else if (ann === "oneway") {
      return buffer$1.Buffer.from([2]);
    } else {
      throw new Error("Illeagal function annotation");
    }
  }
}
class ServiceClass$1 extends ConstructType$1 {
  constructor(fields) {
    super();
    this._fields = Object.entries(fields).sort((a, b2) => idlLabelToId$1(a[0]) - idlLabelToId$1(b2[0]));
  }
  accept(v2, d2) {
    return v2.visitService(this, d2);
  }
  covariant(x2) {
    return x2 && x2._isPrincipal;
  }
  encodeValue(x2) {
    const hex = x2.toHex();
    const buf = buffer$1.Buffer.from(hex, "hex");
    const len2 = lebEncode$1(buf.length);
    return buffer$1.Buffer.concat([buffer$1.Buffer.from([1]), len2, buf]);
  }
  _buildTypeTableImpl(T2) {
    this._fields.forEach(([_2, func]) => func.buildTypeTable(T2));
    const opCode = slebEncode$1(-23);
    const len2 = lebEncode$1(this._fields.length);
    const meths = this._fields.map(([label, func]) => {
      const labelBuf = buffer$1.Buffer.from(label, "utf8");
      const labelLen = lebEncode$1(labelBuf.length);
      return buffer$1.Buffer.concat([labelLen, labelBuf, func.encodeType(T2)]);
    });
    T2.add(this, buffer$1.Buffer.concat([opCode, len2, buffer$1.Buffer.concat(meths)]));
  }
  decodeValue(b2) {
    return decodePrincipalId$1(b2);
  }
  get name() {
    const fields = this._fields.map(([key, value2]) => key + ":" + value2.name);
    return `service {${fields.join("; ")}}`;
  }
  valueToString(x2) {
    return `service "${x2.toText()}"`;
  }
}
function toReadableString$1(x2) {
  return JSON.stringify(x2, (_key, value2) => typeof value2 === "bigint" ? `BigInt(${value2})` : value2);
}
function encode$3(argTypes, args) {
  if (args.length < argTypes.length) {
    throw Error("Wrong number of message arguments");
  }
  const typeTable = new TypeTable$1();
  argTypes.forEach((t2) => t2.buildTypeTable(typeTable));
  const magic = buffer$1.Buffer.from(magicNumber$1, "utf8");
  const table = typeTable.encode();
  const len2 = lebEncode$1(args.length);
  const typs = buffer$1.Buffer.concat(argTypes.map((t2) => t2.encodeType(typeTable)));
  const vals = buffer$1.Buffer.concat(zipWith$1(argTypes, args, (t2, x2) => {
    if (!t2.covariant(x2)) {
      throw new Error(`Invalid ${t2.display()} argument: ${toReadableString$1(x2)}`);
    }
    return t2.encodeValue(x2);
  }));
  return blobFromBuffer(buffer$1.Buffer.concat([magic, table, len2, typs, vals]));
}
function decode$4(retTypes, bytes2) {
  const b2 = new bufferPipe(bytes2);
  if (bytes2.byteLength < magicNumber$1.length) {
    throw new Error("Message length smaller than magic number");
  }
  const magic = safeRead$1(b2, magicNumber$1.length).toString();
  if (magic !== magicNumber$1) {
    throw new Error("Wrong magic number: " + magic);
  }
  function readTypeTable(pipe) {
    const typeTable = [];
    const len2 = Number(lebDecode$1(pipe));
    for (let i2 = 0; i2 < len2; i2++) {
      const ty = Number(slebDecode$1(pipe));
      switch (ty) {
        case -18:
        case -19: {
          const t2 = Number(slebDecode$1(pipe));
          typeTable.push([ty, t2]);
          break;
        }
        case -20:
        case -21: {
          const fields = [];
          let objectLength = Number(lebDecode$1(pipe));
          let prevHash;
          while (objectLength--) {
            const hash2 = Number(lebDecode$1(pipe));
            if (hash2 >= Math.pow(2, 32)) {
              throw new Error("field id out of 32-bit range");
            }
            if (typeof prevHash === "number" && prevHash >= hash2) {
              throw new Error("field id collision or not sorted");
            }
            prevHash = hash2;
            const t2 = Number(slebDecode$1(pipe));
            fields.push([hash2, t2]);
          }
          typeTable.push([ty, fields]);
          break;
        }
        case -22: {
          for (let k2 = 0; k2 < 2; k2++) {
            let funcLength = Number(lebDecode$1(pipe));
            while (funcLength--) {
              slebDecode$1(pipe);
            }
          }
          const annLen = Number(lebDecode$1(pipe));
          safeRead$1(pipe, annLen);
          typeTable.push([ty, void 0]);
          break;
        }
        case -23: {
          let servLength = Number(lebDecode$1(pipe));
          while (servLength--) {
            const l2 = Number(lebDecode$1(pipe));
            safeRead$1(pipe, l2);
            slebDecode$1(pipe);
          }
          typeTable.push([ty, void 0]);
          break;
        }
        default:
          throw new Error("Illegal op_code: " + ty);
      }
    }
    const rawList = [];
    const length2 = Number(lebDecode$1(pipe));
    for (let i2 = 0; i2 < length2; i2++) {
      rawList.push(Number(slebDecode$1(pipe)));
    }
    return [typeTable, rawList];
  }
  const [rawTable, rawTypes] = readTypeTable(b2);
  if (rawTypes.length < retTypes.length) {
    throw new Error("Wrong number of return values");
  }
  const table = rawTable.map((_2) => Rec$1());
  function getType2(t2) {
    if (t2 < -24) {
      throw new Error("future value not supported");
    }
    if (t2 < 0) {
      switch (t2) {
        case -1:
          return Null$1;
        case -2:
          return Bool$1;
        case -3:
          return Nat$1;
        case -4:
          return Int$1;
        case -5:
          return Nat8$1;
        case -6:
          return Nat16$1;
        case -7:
          return Nat32$1;
        case -8:
          return Nat64$1;
        case -9:
          return Int8$1;
        case -10:
          return Int16$1;
        case -11:
          return Int32$1;
        case -12:
          return Int64$1;
        case -13:
          return Float32$1;
        case -14:
          return Float64$1;
        case -15:
          return Text$1;
        case -16:
          return Reserved$1;
        case -17:
          return Empty$1;
        case -24:
          return Principal$1;
        default:
          throw new Error("Illegal op_code: " + t2);
      }
    }
    if (t2 >= rawTable.length) {
      throw new Error("type index out of range");
    }
    return table[t2];
  }
  function buildType(entry) {
    switch (entry[0]) {
      case -19: {
        const ty = getType2(entry[1]);
        return Vec$1(ty);
      }
      case -18: {
        const ty = getType2(entry[1]);
        return Opt$1(ty);
      }
      case -20: {
        const fields = {};
        for (const [hash2, ty] of entry[1]) {
          const name = `_${hash2}_`;
          fields[name] = getType2(ty);
        }
        const record = Record$1(fields);
        const tuple = record.tryAsTuple();
        if (Array.isArray(tuple)) {
          return Tuple$1(...tuple);
        } else {
          return record;
        }
      }
      case -21: {
        const fields = {};
        for (const [hash2, ty] of entry[1]) {
          const name = `_${hash2}_`;
          fields[name] = getType2(ty);
        }
        return Variant$1(fields);
      }
      case -22: {
        return Func$1([], [], []);
      }
      case -23: {
        return Service$1({});
      }
      default:
        throw new Error("Illegal op_code: " + entry[0]);
    }
  }
  rawTable.forEach((entry, i2) => {
    const t2 = buildType(entry);
    table[i2].fill(t2);
  });
  const types = rawTypes.map((t2) => getType2(t2));
  const output = retTypes.map((t2, i2) => {
    return t2.decodeValue(b2, types[i2]);
  });
  for (let ind = retTypes.length; ind < types.length; ind++) {
    types[ind].decodeValue(b2, types[ind]);
  }
  if (b2.buffer.length > 0) {
    throw new Error("decode: Left-over bytes");
  }
  return output;
}
const Empty$1 = new EmptyClass$1();
const Reserved$1 = new ReservedClass$1();
const Bool$1 = new BoolClass$1();
const Null$1 = new NullClass$1();
const Text$1 = new TextClass$1();
const Int$1 = new IntClass$1();
const Nat$1 = new NatClass$1();
const Float32$1 = new FloatClass$1(32);
const Float64$1 = new FloatClass$1(64);
const Int8$1 = new FixedIntClass$1(8);
const Int16$1 = new FixedIntClass$1(16);
const Int32$1 = new FixedIntClass$1(32);
const Int64$1 = new FixedIntClass$1(64);
const Nat8$1 = new FixedNatClass$1(8);
const Nat16$1 = new FixedNatClass$1(16);
const Nat32$1 = new FixedNatClass$1(32);
const Nat64$1 = new FixedNatClass$1(64);
const Principal$1 = new PrincipalClass$1();
function Tuple$1(...types) {
  return new TupleClass$1(types);
}
function Vec$1(t2) {
  return new VecClass$1(t2);
}
function Opt$1(t2) {
  return new OptClass$1(t2);
}
function Record$1(t2) {
  return new RecordClass$1(t2);
}
function Variant$1(fields) {
  return new VariantClass$1(fields);
}
function Rec$1() {
  return new RecClass$1();
}
function Func$1(args, ret, annotations = []) {
  return new FuncClass$1(args, ret, annotations);
}
function Service$1(t2) {
  return new ServiceClass$1(t2);
}
const IDL$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Visitor: Visitor$1,
  Type: Type$1,
  PrimitiveType: PrimitiveType$1,
  ConstructType: ConstructType$1,
  EmptyClass: EmptyClass$1,
  BoolClass: BoolClass$1,
  NullClass: NullClass$1,
  ReservedClass: ReservedClass$1,
  TextClass: TextClass$1,
  IntClass: IntClass$1,
  NatClass: NatClass$1,
  FloatClass: FloatClass$1,
  FixedIntClass: FixedIntClass$1,
  FixedNatClass: FixedNatClass$1,
  VecClass: VecClass$1,
  OptClass: OptClass$1,
  RecordClass: RecordClass$1,
  TupleClass: TupleClass$1,
  VariantClass: VariantClass$1,
  RecClass: RecClass$1,
  PrincipalClass: PrincipalClass$1,
  FuncClass: FuncClass$1,
  ServiceClass: ServiceClass$1,
  encode: encode$3,
  decode: decode$4,
  Empty: Empty$1,
  Reserved: Reserved$1,
  Bool: Bool$1,
  Null: Null$1,
  Text: Text$1,
  Int: Int$1,
  Nat: Nat$1,
  Float32: Float32$1,
  Float64: Float64$1,
  Int8: Int8$1,
  Int16: Int16$1,
  Int32: Int32$1,
  Int64: Int64$1,
  Nat8: Nat8$1,
  Nat16: Nat16$1,
  Nat32: Nat32$1,
  Nat64: Nat64$1,
  Principal: Principal$1,
  Tuple: Tuple$1,
  Vec: Vec$1,
  Opt: Opt$1,
  Record: Record$1,
  Variant: Variant$1,
  Rec: Rec$1,
  Func: Func$1,
  Service: Service$1
}, Symbol.toStringTag, { value: "Module" }));
function toHex$1(requestId) {
  return blobToHex(requestId);
}
function hash$1(data2) {
  const hashed = sha256$1.exports.sha256.create().update(data2).arrayBuffer();
  return blobFromUint8Array(new Uint8Array(hashed));
}
function hashValue$1(value2) {
  if (value2 instanceof src$1.Tagged) {
    return hashValue$1(value2.value);
  } else if (typeof value2 === "string") {
    return hashString$1(value2);
  } else if (typeof value2 === "number") {
    return hash$1(lebEncode$1(value2));
  } else if (buffer$1.Buffer.isBuffer(value2)) {
    return hash$1(blobFromUint8Array(new Uint8Array(value2)));
  } else if (value2 instanceof Uint8Array || value2 instanceof ArrayBuffer) {
    return hash$1(blobFromUint8Array(new Uint8Array(value2)));
  } else if (Array.isArray(value2)) {
    const vals = value2.map(hashValue$1);
    return hash$1(buffer$1.Buffer.concat(vals));
  } else if (value2 instanceof Principal$2) {
    return hash$1(blobFromUint8Array(value2.toUint8Array()));
  } else if (typeof value2 === "object" && value2 !== null && typeof value2.toHash === "function") {
    return hashValue$1(value2.toHash());
  } else if (typeof value2 === "bigint") {
    return hash$1(lebEncode$1(value2));
  }
  throw Object.assign(new Error(`Attempt to hash a value of unsupported type: ${value2}`), {
    value: value2
  });
}
const hashString$1 = (value2) => {
  const encoder2 = new TextEncoder();
  const encoded = encoder2.encode(value2);
  return hash$1(buffer$1.Buffer.from(encoded));
};
function concat$2(bs) {
  return blobFromBuffer(buffer$1.Buffer.concat(bs));
}
function requestIdOf$1(request2) {
  const hashed = Object.entries(request2).filter(([, value2]) => value2 !== void 0).map(([key, value2]) => {
    const hashedKey = hashString$1(key);
    const hashedValue = hashValue$1(value2);
    return [hashedKey, hashedValue];
  });
  const traversed = hashed;
  const sorted = traversed.sort(([k1], [k2]) => {
    return buffer$1.Buffer.compare(buffer$1.Buffer.from(k1), buffer$1.Buffer.from(k2));
  });
  const concatenated = concat$2(sorted.map(concat$2));
  const requestId = hash$1(concatenated);
  return requestId;
}
var __rest = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
        t2[p2[i2]] = s[p2[i2]];
    }
  return t2;
};
const domainSeparator = buffer$1.Buffer.from(new TextEncoder().encode("\nic-request"));
class SignIdentity {
  getPrincipal() {
    if (!this._principal) {
      this._principal = Principal$2.selfAuthenticating(this.getPublicKey().toDer());
    }
    return this._principal;
  }
  async transformRequest(request2) {
    const { body } = request2, fields = __rest(request2, ["body"]);
    const requestId = await requestIdOf$1(body);
    return Object.assign(Object.assign({}, fields), { body: {
      content: body,
      sender_pubkey: this.getPublicKey().toDer(),
      sender_sig: await this.sign(blobFromBuffer(buffer$1.Buffer.concat([domainSeparator, requestId])))
    } });
  }
}
class AnonymousIdentity$1 {
  getPrincipal() {
    return Principal$2.anonymous();
  }
  async transformRequest(request2) {
    return Object.assign(Object.assign({}, request2), { body: { content: request2.body } });
  }
}
function createIdentityDescriptor(identity) {
  const identityIndicator = "getPublicKey" in identity ? { type: "PublicKeyIdentity", publicKey: identity.getPublicKey().toDer().toString("hex") } : { type: "AnonymousIdentity" };
  return identityIndicator;
}
function isIdentityDescriptor(value2) {
  var _a, _b;
  switch ((_a = value2) === null || _a === void 0 ? void 0 : _a.type) {
    case "AnonymousIdentity":
      return true;
    case "PublicKeyIdentity":
      if (typeof ((_b = value2) === null || _b === void 0 ? void 0 : _b.publicKey) !== "string") {
        return false;
      }
      return true;
  }
  return false;
}
var src = {};
var serializer$2 = {};
var value = {};
Object.defineProperty(value, "__esModule", { value: true });
const MAX_U64_NUMBER = 9007199254740992;
function _concat(a, ...args) {
  const newBuffer = new Uint8Array(a.byteLength + args.reduce((acc, b2) => acc + b2.byteLength, 0));
  newBuffer.set(new Uint8Array(a), 0);
  let i2 = a.byteLength;
  for (const b2 of args) {
    newBuffer.set(new Uint8Array(b2), i2);
    i2 += b2.byteLength;
  }
  return newBuffer.buffer;
}
function _serializeValue(major, minor, value2) {
  value2 = value2.replace(/[^0-9a-fA-F]/g, "");
  const length2 = 2 ** (minor - 24);
  value2 = value2.slice(-length2 * 2).padStart(length2 * 2, "0");
  const bytes2 = [(major << 5) + minor].concat(value2.match(/../g).map((byte) => parseInt(byte, 16)));
  return new Uint8Array(bytes2).buffer;
}
function _serializeNumber(major, value2) {
  if (value2 < 24) {
    return new Uint8Array([(major << 5) + value2]).buffer;
  } else {
    const minor = value2 <= 255 ? 24 : value2 <= 65535 ? 25 : value2 <= 4294967295 ? 26 : 27;
    return _serializeValue(major, minor, value2.toString(16));
  }
}
function _serializeString(str) {
  const utf8 = [];
  for (let i2 = 0; i2 < str.length; i2++) {
    let charcode = str.charCodeAt(i2);
    if (charcode < 128) {
      utf8.push(charcode);
    } else if (charcode < 2048) {
      utf8.push(192 | charcode >> 6, 128 | charcode & 63);
    } else if (charcode < 55296 || charcode >= 57344) {
      utf8.push(224 | charcode >> 12, 128 | charcode >> 6 & 63, 128 | charcode & 63);
    } else {
      i2++;
      charcode = (charcode & 1023) << 10 | str.charCodeAt(i2) & 1023;
      utf8.push(240 | charcode >> 18, 128 | charcode >> 12 & 63, 128 | charcode >> 6 & 63, 128 | charcode & 63);
    }
  }
  return _concat(new Uint8Array(_serializeNumber(3, str.length)), new Uint8Array(utf8));
}
function tagged(tag, value2) {
  if (tag == 14277111) {
    return _concat(new Uint8Array([217, 217, 247]), value2);
  }
  if (tag < 24) {
    return _concat(new Uint8Array([(6 << 5) + tag]), value2);
  } else {
    const minor = tag <= 255 ? 24 : tag <= 65535 ? 25 : tag <= 4294967295 ? 26 : 27;
    const length2 = 2 ** (minor - 24);
    const value3 = tag.toString(16).slice(-length2 * 2).padStart(length2 * 2, "0");
    const bytes2 = [(6 << 5) + minor].concat(value3.match(/../g).map((byte) => parseInt(byte, 16)));
    return new Uint8Array(bytes2).buffer;
  }
}
value.tagged = tagged;
function raw(bytes2) {
  return new Uint8Array(bytes2).buffer;
}
value.raw = raw;
function uSmall(n2) {
  if (isNaN(n2)) {
    throw new RangeError("Invalid number.");
  }
  n2 = Math.min(Math.max(0, n2), 23);
  const bytes2 = [(0 << 5) + n2];
  return new Uint8Array(bytes2).buffer;
}
value.uSmall = uSmall;
function u8(u82, radix) {
  u82 = parseInt("" + u82, radix);
  if (isNaN(u82)) {
    throw new RangeError("Invalid number.");
  }
  u82 = Math.min(Math.max(0, u82), 255);
  u82 = u82.toString(16);
  return _serializeValue(0, 24, u82);
}
value.u8 = u8;
function u16(u162, radix) {
  u162 = parseInt("" + u162, radix);
  if (isNaN(u162)) {
    throw new RangeError("Invalid number.");
  }
  u162 = Math.min(Math.max(0, u162), 65535);
  u162 = u162.toString(16);
  return _serializeValue(0, 25, u162);
}
value.u16 = u16;
function u32(u322, radix) {
  u322 = parseInt("" + u322, radix);
  if (isNaN(u322)) {
    throw new RangeError("Invalid number.");
  }
  u322 = Math.min(Math.max(0, u322), 4294967295);
  u322 = u322.toString(16);
  return _serializeValue(0, 26, u322);
}
value.u32 = u32;
function u64(u642, radix) {
  if (typeof u642 == "string" && radix == 16) {
    if (u642.match(/[^0-9a-fA-F]/)) {
      throw new RangeError("Invalid number.");
    }
    return _serializeValue(0, 27, u642);
  }
  u642 = parseInt("" + u642, radix);
  if (isNaN(u642)) {
    throw new RangeError("Invalid number.");
  }
  u642 = Math.min(Math.max(0, u642), MAX_U64_NUMBER);
  u642 = u642.toString(16);
  return _serializeValue(0, 27, u642);
}
value.u64 = u64;
function iSmall(n2) {
  if (isNaN(n2)) {
    throw new RangeError("Invalid number.");
  }
  if (n2 === 0) {
    return uSmall(0);
  }
  n2 = Math.min(Math.max(0, -n2), 24) - 1;
  const bytes2 = [(1 << 5) + n2];
  return new Uint8Array(bytes2).buffer;
}
value.iSmall = iSmall;
function i8(i82, radix) {
  i82 = parseInt("" + i82, radix);
  if (isNaN(i82)) {
    throw new RangeError("Invalid number.");
  }
  i82 = Math.min(Math.max(0, -i82 - 1), 255);
  i82 = i82.toString(16);
  return _serializeValue(1, 24, i82);
}
value.i8 = i8;
function i16(i162, radix) {
  i162 = parseInt("" + i162, radix);
  if (isNaN(i162)) {
    throw new RangeError("Invalid number.");
  }
  i162 = Math.min(Math.max(0, -i162 - 1), 65535);
  i162 = i162.toString(16);
  return _serializeValue(1, 25, i162);
}
value.i16 = i16;
function i32(i322, radix) {
  i322 = parseInt("" + i322, radix);
  if (isNaN(i322)) {
    throw new RangeError("Invalid number.");
  }
  i322 = Math.min(Math.max(0, -i322 - 1), 4294967295);
  i322 = i322.toString(16);
  return _serializeValue(1, 26, i322);
}
value.i32 = i32;
function i64(i642, radix) {
  if (typeof i642 == "string" && radix == 16) {
    if (i642.startsWith("-")) {
      i642 = i642.slice(1);
    } else {
      i642 = "0";
    }
    if (i642.match(/[^0-9a-fA-F]/) || i642.length > 16) {
      throw new RangeError("Invalid number.");
    }
    let done = false;
    let newI64 = i642.split("").reduceRight((acc, x2) => {
      if (done) {
        return x2 + acc;
      }
      let n2 = parseInt(x2, 16) - 1;
      if (n2 >= 0) {
        done = true;
        return n2.toString(16) + acc;
      } else {
        return "f" + acc;
      }
    }, "");
    if (!done) {
      return u64(0);
    }
    return _serializeValue(1, 27, newI64);
  }
  i642 = parseInt("" + i642, radix);
  if (isNaN(i642)) {
    throw new RangeError("Invalid number.");
  }
  i642 = Math.min(Math.max(0, -i642 - 1), 9007199254740992);
  i642 = i642.toString(16);
  return _serializeValue(1, 27, i642);
}
value.i64 = i64;
function number$1(n2) {
  if (n2 >= 0) {
    if (n2 < 24) {
      return uSmall(n2);
    } else if (n2 <= 255) {
      return u8(n2);
    } else if (n2 <= 65535) {
      return u16(n2);
    } else if (n2 <= 4294967295) {
      return u32(n2);
    } else {
      return u64(n2);
    }
  } else {
    if (n2 >= -24) {
      return iSmall(n2);
    } else if (n2 >= -255) {
      return i8(n2);
    } else if (n2 >= -65535) {
      return i16(n2);
    } else if (n2 >= -4294967295) {
      return i32(n2);
    } else {
      return i64(n2);
    }
  }
}
value.number = number$1;
function bytes(bytes2) {
  return _concat(_serializeNumber(2, bytes2.byteLength), bytes2);
}
value.bytes = bytes;
function string(str) {
  return _serializeString(str);
}
value.string = string;
function array(items) {
  return _concat(_serializeNumber(4, items.length), ...items);
}
value.array = array;
function map(items, stable = false) {
  if (!(items instanceof Map)) {
    items = new Map(Object.entries(items));
  }
  let entries = Array.from(items.entries());
  if (stable) {
    entries = entries.sort(([keyA], [keyB]) => keyA.localeCompare(keyB));
  }
  return _concat(_serializeNumber(5, items.size), ...entries.map(([k2, v2]) => _concat(_serializeString(k2), v2)));
}
value.map = map;
function singleFloat(f2) {
  const single = new Float32Array([f2]);
  return _concat(new Uint8Array([(7 << 5) + 26]), new Uint8Array(single.buffer));
}
value.singleFloat = singleFloat;
function doubleFloat(f2) {
  const single = new Float64Array([f2]);
  return _concat(new Uint8Array([(7 << 5) + 27]), new Uint8Array(single.buffer));
}
value.doubleFloat = doubleFloat;
function bool(v2) {
  return v2 ? true_() : false_();
}
value.bool = bool;
function true_() {
  return raw(new Uint8Array([(7 << 5) + 21]));
}
value.true_ = true_;
function false_() {
  return raw(new Uint8Array([(7 << 5) + 20]));
}
value.false_ = false_;
function null_() {
  return raw(new Uint8Array([(7 << 5) + 22]));
}
value.null_ = null_;
function undefined_() {
  return raw(new Uint8Array([(7 << 5) + 23]));
}
value.undefined_ = undefined_;
var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (Object.hasOwnProperty.call(mod, k2))
        result[k2] = mod[k2];
  }
  result["default"] = mod;
  return result;
};
Object.defineProperty(serializer$2, "__esModule", { value: true });
const cbor$1 = __importStar(value);
const BufferClasses = [
  ArrayBuffer,
  Uint8Array,
  Uint16Array,
  Uint32Array,
  Int8Array,
  Int16Array,
  Int32Array,
  Float32Array,
  Float64Array
];
class JsonDefaultCborEncoder {
  constructor(_serializer, _stable = false) {
    this._serializer = _serializer;
    this._stable = _stable;
    this.name = "jsonDefault";
    this.priority = -100;
  }
  match(value2) {
    return ["undefined", "boolean", "number", "string", "object"].indexOf(typeof value2) != -1;
  }
  encode(value2) {
    switch (typeof value2) {
      case "undefined":
        return cbor$1.undefined_();
      case "boolean":
        return cbor$1.bool(value2);
      case "number":
        if (Math.floor(value2) === value2) {
          return cbor$1.number(value2);
        } else {
          return cbor$1.doubleFloat(value2);
        }
      case "string":
        return cbor$1.string(value2);
      case "object":
        if (value2 === null) {
          return cbor$1.null_();
        } else if (Array.isArray(value2)) {
          return cbor$1.array(value2.map((x2) => this._serializer.serializeValue(x2)));
        } else if (BufferClasses.find((x2) => value2 instanceof x2)) {
          return cbor$1.bytes(value2.buffer);
        } else if (Object.getOwnPropertyNames(value2).indexOf("toJSON") !== -1) {
          return this.encode(value2.toJSON());
        } else if (value2 instanceof Map) {
          const m2 = /* @__PURE__ */ new Map();
          for (const [key, item] of value2.entries()) {
            m2.set(key, this._serializer.serializeValue(item));
          }
          return cbor$1.map(m2, this._stable);
        } else {
          const m2 = /* @__PURE__ */ new Map();
          for (const [key, item] of Object.entries(value2)) {
            m2.set(key, this._serializer.serializeValue(item));
          }
          return cbor$1.map(m2, this._stable);
        }
      default:
        throw new Error("Invalid value.");
    }
  }
}
serializer$2.JsonDefaultCborEncoder = JsonDefaultCborEncoder;
class ToCborEncoder {
  constructor() {
    this.name = "cborEncoder";
    this.priority = -90;
  }
  match(value2) {
    return typeof value2 == "object" && typeof value2["toCBOR"] == "function";
  }
  encode(value2) {
    return value2.toCBOR();
  }
}
serializer$2.ToCborEncoder = ToCborEncoder;
class CborSerializer {
  constructor() {
    this._encoders = /* @__PURE__ */ new Set();
  }
  static withDefaultEncoders(stable = false) {
    const s = new this();
    s.addEncoder(new JsonDefaultCborEncoder(s, stable));
    s.addEncoder(new ToCborEncoder());
    return s;
  }
  removeEncoder(name) {
    for (const encoder2 of this._encoders.values()) {
      if (encoder2.name == name) {
        this._encoders.delete(encoder2);
      }
    }
  }
  addEncoder(encoder2) {
    this._encoders.add(encoder2);
  }
  getEncoderFor(value2) {
    let chosenEncoder = null;
    for (const encoder2 of this._encoders) {
      if (!chosenEncoder || encoder2.priority > chosenEncoder.priority) {
        if (encoder2.match(value2)) {
          chosenEncoder = encoder2;
        }
      }
    }
    if (chosenEncoder === null) {
      throw new Error("Could not find an encoder for value.");
    }
    return chosenEncoder;
  }
  serializeValue(value2) {
    return this.getEncoderFor(value2).encode(value2);
  }
  serialize(value2) {
    return this.serializeValue(value2);
  }
}
serializer$2.CborSerializer = CborSerializer;
class SelfDescribeCborSerializer extends CborSerializer {
  serialize(value2) {
    return cbor$1.raw(new Uint8Array([
      ...new Uint8Array([217, 217, 247]),
      ...new Uint8Array(super.serializeValue(value2))
    ]));
  }
}
serializer$2.SelfDescribeCborSerializer = SelfDescribeCborSerializer;
(function(exports2) {
  function __export(m2) {
    for (var p2 in m2)
      if (!exports2.hasOwnProperty(p2))
        exports2[p2] = m2[p2];
  }
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (Object.hasOwnProperty.call(mod, k2))
          result[k2] = mod[k2];
    }
    result["default"] = mod;
    return result;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __export(serializer$2);
  const value$1 = __importStar2(value);
  exports2.value = value$1;
})(src);
class PrincipalEncoder$1 {
  get name() {
    return "Principal";
  }
  get priority() {
    return 0;
  }
  match(value2) {
    return value2 && value2._isPrincipal === true;
  }
  encode(v2) {
    return src.value.bytes(v2.toUint8Array().buffer);
  }
}
class BufferEncoder$1 {
  get name() {
    return "Buffer";
  }
  get priority() {
    return 1;
  }
  match(value2) {
    return buffer$1.Buffer.isBuffer(value2);
  }
  encode(v2) {
    return src.value.bytes(new Uint8Array(v2));
  }
}
class BigIntEncoder$1 {
  get name() {
    return "BigInt";
  }
  get priority() {
    return 1;
  }
  match(value2) {
    return typeof value2 === `bigint`;
  }
  encode(v2) {
    if (v2 > BigInt(0)) {
      return src.value.tagged(2, src.value.bytes(blobFromHex(v2.toString(16))));
    } else {
      return src.value.tagged(3, src.value.bytes(blobFromHex((BigInt("-1") * v2).toString(16))));
    }
  }
}
const serializer$1 = src.SelfDescribeCborSerializer.withDefaultEncoders(true);
serializer$1.addEncoder(new PrincipalEncoder$1());
serializer$1.addEncoder(new BufferEncoder$1());
serializer$1.addEncoder(new BigIntEncoder$1());
var CborTag$1;
(function(CborTag2) {
  CborTag2[CborTag2["Uint64LittleEndian"] = 71] = "Uint64LittleEndian";
  CborTag2[CborTag2["Semantic"] = 55799] = "Semantic";
})(CborTag$1 || (CborTag$1 = {}));
const encode$2 = (value2) => {
  return blobFromBuffer(buffer$1.Buffer.from(serializer$1.serialize(value2)));
};
function decodePositiveBigInt$1(buf) {
  const len2 = buf.byteLength;
  let res = BigInt(0);
  for (let i2 = 0; i2 < len2; i2++) {
    res = res * BigInt(256) + BigInt(buf[i2]);
  }
  return res;
}
function decode$3(input) {
  const decoder2 = new src$1.Decoder({
    size: input.byteLength,
    tags: {
      2: (val) => decodePositiveBigInt$1(val),
      3: (val) => -decodePositiveBigInt$1(val),
      [CborTag$1.Semantic]: (value2) => value2
    }
  });
  const result = decoder2.decodeFirst(input);
  return result;
}
const cbor = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get CborTag() {
    return CborTag$1;
  },
  encode: encode$2,
  decode: decode$3
}, Symbol.toStringTag, { value: "Module" }));
const NANOSECONDS_PER_MILLISECONDS$1 = BigInt(1e6);
const REPLICA_PERMITTED_DRIFT_MILLISECONDS$1 = BigInt(60 * 1e3);
class Expiry$1 {
  constructor(deltaInMSec) {
    this._value = (BigInt(Date.now()) + BigInt(deltaInMSec) - REPLICA_PERMITTED_DRIFT_MILLISECONDS$1) * NANOSECONDS_PER_MILLISECONDS$1;
  }
  toCBOR() {
    return src.value.u64(this._value.toString(16), 16);
  }
  toHash() {
    return lebEncode$1(this._value);
  }
}
function makeNonceTransform$1(nonceFn = makeNonce$1) {
  return async (request2) => {
    if (request2.endpoint === "call") {
      request2.body.nonce = nonceFn();
    }
  };
}
function makeExpiryTransform(delayInMilliseconds) {
  return async (request2) => {
    request2.body.ingress_expiry = new Expiry$1(delayInMilliseconds);
  };
}
var SubmitRequestType$1;
(function(SubmitRequestType2) {
  SubmitRequestType2["Call"] = "call";
})(SubmitRequestType$1 || (SubmitRequestType$1 = {}));
var RequestStatusResponseStatus$1;
(function(RequestStatusResponseStatus2) {
  RequestStatusResponseStatus2["Received"] = "received";
  RequestStatusResponseStatus2["Processing"] = "processing";
  RequestStatusResponseStatus2["Replied"] = "replied";
  RequestStatusResponseStatus2["Rejected"] = "rejected";
  RequestStatusResponseStatus2["Unknown"] = "unknown";
  RequestStatusResponseStatus2["Done"] = "done";
})(RequestStatusResponseStatus$1 || (RequestStatusResponseStatus$1 = {}));
const DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS$1 = 5 * 60 * 1e3;
const IC_ROOT_KEY$1 = "308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100814c0e6ec71fab583b08bd81373c255c3c371b2e84863c98a4f1e08b74235d14fb5d9c0cd546d9685f913a0c0b2cc5341583bf4b4392e467db96d65b9bb4cb717112f8472e0d5a4d14505ffd7484b01291091c5f87b98883463f98091a0baaae";
function getDefaultFetch$1() {
  const result = typeof window === "undefined" ? typeof global === "undefined" ? typeof self === "undefined" ? void 0 : self.fetch.bind(self) : global.fetch.bind(global) : window.fetch.bind(window);
  if (!result) {
    throw new Error("Could not find default `fetch` implementation.");
  }
  return result;
}
class HttpAgent$1 {
  constructor(options = {}) {
    this._pipeline = [];
    this._rootKeyFetched = false;
    this.rootKey = blobFromHex(IC_ROOT_KEY$1);
    if (options.source) {
      if (!(options.source instanceof HttpAgent$1)) {
        throw new Error("An Agent's source can only be another HttpAgent");
      }
      this._pipeline = [...options.source._pipeline];
      this._identity = options.source._identity;
      this._fetch = options.source._fetch;
      this._host = options.source._host;
      this._credentials = options.source._credentials;
    } else {
      this._fetch = options.fetch || getDefaultFetch$1() || fetch.bind(global);
    }
    if (options.host !== void 0) {
      if (!options.host.match(/^[a-z]+:/) && typeof window !== "undefined") {
        this._host = new URL(window.location.protocol + "//" + options.host);
      } else {
        this._host = new URL(options.host);
      }
    } else if (options.source !== void 0) {
      this._host = options.source._host;
    } else {
      const location = typeof window !== "undefined" ? window.location : void 0;
      if (!location) {
        throw new Error("Must specify a host to connect to.");
      }
      this._host = new URL(location + "");
    }
    if (options.credentials) {
      const { name, password } = options.credentials;
      this._credentials = `${name}${password ? ":" + password : ""}`;
    }
    this._identity = Promise.resolve(options.identity || new AnonymousIdentity$1());
  }
  addTransform(fn, priority = fn.priority || 0) {
    const i2 = this._pipeline.findIndex((x2) => (x2.priority || 0) < priority);
    this._pipeline.splice(i2 >= 0 ? i2 : this._pipeline.length, 0, Object.assign(fn, { priority }));
  }
  async getPrincipal() {
    return (await this._identity).getPrincipal();
  }
  async call(canisterId, options, identity) {
    const id2 = await (identity !== void 0 ? await identity : await this._identity);
    const canister = Principal$2.from(canisterId);
    const ecid = options.effectiveCanisterId ? Principal$2.from(options.effectiveCanisterId) : canister;
    const sender = id2.getPrincipal() || Principal$2.anonymous();
    const submit = {
      request_type: SubmitRequestType$1.Call,
      canister_id: canister,
      method_name: options.methodName,
      arg: options.arg,
      sender,
      ingress_expiry: new Expiry$1(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS$1)
    };
    let transformedRequest = await this._transform({
      request: {
        body: null,
        method: "POST",
        headers: Object.assign({ "Content-Type": "application/cbor" }, this._credentials ? { Authorization: "Basic " + btoa(this._credentials) } : {})
      },
      endpoint: "call",
      body: submit
    });
    transformedRequest = await id2.transformRequest(transformedRequest);
    const body = encode$2(transformedRequest.body);
    const [response, requestId] = await Promise.all([
      this._fetch("" + new URL(`/api/v2/canister/${ecid.toText()}/call`, this._host), Object.assign(Object.assign({}, transformedRequest.request), { body })),
      requestIdOf$1(submit)
    ]);
    if (!response.ok) {
      throw new Error(`Server returned an error:
  Code: ${response.status} (${response.statusText})
  Body: ${await response.text()}
`);
    }
    return {
      requestId,
      response: {
        ok: response.ok,
        status: response.status,
        statusText: response.statusText
      }
    };
  }
  async query(canisterId, fields, identity) {
    const id2 = await (identity !== void 0 ? await identity : await this._identity);
    const canister = typeof canisterId === "string" ? Principal$2.fromText(canisterId) : canisterId;
    const sender = (id2 === null || id2 === void 0 ? void 0 : id2.getPrincipal()) || Principal$2.anonymous();
    const request2 = {
      request_type: "query",
      canister_id: canister,
      method_name: fields.methodName,
      arg: fields.arg,
      sender,
      ingress_expiry: new Expiry$1(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS$1)
    };
    let transformedRequest = await this._transform({
      request: {
        method: "POST",
        headers: Object.assign({ "Content-Type": "application/cbor" }, this._credentials ? { Authorization: "Basic " + btoa(this._credentials) } : {})
      },
      endpoint: "read",
      body: request2
    });
    transformedRequest = await id2.transformRequest(transformedRequest);
    const body = encode$2(transformedRequest.body);
    const response = await this._fetch("" + new URL(`/api/v2/canister/${canister.toText()}/query`, this._host), Object.assign(Object.assign({}, transformedRequest.request), { body }));
    if (!response.ok) {
      throw new Error(`Server returned an error:
  Code: ${response.status} (${response.statusText})
  Body: ${await response.text()}
`);
    }
    return decode$3(buffer$1.Buffer.from(await response.arrayBuffer()));
  }
  async readState(canisterId, fields, identity) {
    const canister = typeof canisterId === "string" ? Principal$2.fromText(canisterId) : canisterId;
    const id2 = await (identity !== void 0 ? await identity : await this._identity);
    const sender = (id2 === null || id2 === void 0 ? void 0 : id2.getPrincipal()) || Principal$2.anonymous();
    let transformedRequest = await this._transform({
      request: {
        method: "POST",
        headers: Object.assign({ "Content-Type": "application/cbor" }, this._credentials ? { Authorization: "Basic " + btoa(this._credentials) } : {})
      },
      endpoint: "read_state",
      body: {
        request_type: "read_state",
        paths: fields.paths,
        sender,
        ingress_expiry: new Expiry$1(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS$1)
      }
    });
    transformedRequest = await id2.transformRequest(transformedRequest);
    const body = encode$2(transformedRequest.body);
    const response = await this._fetch("" + new URL(`/api/v2/canister/${canister}/read_state`, this._host), Object.assign(Object.assign({}, transformedRequest.request), { body }));
    if (!response.ok) {
      throw new Error(`Server returned an error:
  Code: ${response.status} (${response.statusText})
  Body: ${await response.text()}
`);
    }
    return decode$3(buffer$1.Buffer.from(await response.arrayBuffer()));
  }
  async status() {
    const headers = this._credentials ? {
      Authorization: "Basic " + btoa(this._credentials)
    } : {};
    const response = await this._fetch("" + new URL(`/api/v2/status`, this._host), { headers });
    if (!response.ok) {
      throw new Error(`Server returned an error:
  Code: ${response.status} (${response.statusText})
  Body: ${await response.text()}
`);
    }
    const buffer2 = await response.arrayBuffer();
    return decode$3(new Uint8Array(buffer2));
  }
  async fetchRootKey() {
    if (!this._rootKeyFetched) {
      this.rootKey = blobFromUint8Array((await this.status()).root_key);
      this._rootKeyFetched = true;
    }
    return this.rootKey;
  }
  _transform(request2) {
    let p2 = Promise.resolve(request2);
    for (const fn of this._pipeline) {
      p2 = p2.then((r2) => fn(r2).then((r22) => r22 || r2));
    }
    return p2;
  }
}
var ProxyMessageKind$1;
(function(ProxyMessageKind2) {
  ProxyMessageKind2["Error"] = "err";
  ProxyMessageKind2["GetPrincipal"] = "gp";
  ProxyMessageKind2["GetPrincipalResponse"] = "gpr";
  ProxyMessageKind2["Query"] = "q";
  ProxyMessageKind2["QueryResponse"] = "qr";
  ProxyMessageKind2["Call"] = "c";
  ProxyMessageKind2["CallResponse"] = "cr";
  ProxyMessageKind2["ReadState"] = "rs";
  ProxyMessageKind2["ReadStateResponse"] = "rsr";
  ProxyMessageKind2["Status"] = "s";
  ProxyMessageKind2["StatusResponse"] = "sr";
})(ProxyMessageKind$1 || (ProxyMessageKind$1 = {}));
class ProxyStubAgent {
  constructor(_frontend, _agent) {
    this._frontend = _frontend;
    this._agent = _agent;
  }
  onmessage(msg) {
    switch (msg.type) {
      case ProxyMessageKind$1.GetPrincipal:
        this._agent.getPrincipal().then((response) => {
          this._frontend({
            id: msg.id,
            type: ProxyMessageKind$1.GetPrincipalResponse,
            response: response.toText()
          });
        });
        break;
      case ProxyMessageKind$1.Query:
        this._agent.query(...msg.args).then((response) => {
          this._frontend({
            id: msg.id,
            type: ProxyMessageKind$1.QueryResponse,
            response
          });
        });
        break;
      case ProxyMessageKind$1.Call:
        this._agent.call(...msg.args).then((response) => {
          this._frontend({
            id: msg.id,
            type: ProxyMessageKind$1.CallResponse,
            response
          });
        });
        break;
      case ProxyMessageKind$1.ReadState:
        this._agent.readState(...msg.args).then((response) => {
          this._frontend({
            id: msg.id,
            type: ProxyMessageKind$1.ReadStateResponse,
            response
          });
        });
        break;
      case ProxyMessageKind$1.Status:
        this._agent.status().then((response) => {
          this._frontend({
            id: msg.id,
            type: ProxyMessageKind$1.StatusResponse,
            response
          });
        });
        break;
      default:
        throw new Error(`Invalid message received: ${JSON.stringify(msg)}`);
    }
  }
}
class ProxyAgent {
  constructor(_backend) {
    this._backend = _backend;
    this._nextId = 0;
    this._pendingCalls = /* @__PURE__ */ new Map();
    this.rootKey = null;
  }
  onmessage(msg) {
    const id2 = msg.id;
    const maybePromise = this._pendingCalls.get(id2);
    if (!maybePromise) {
      throw new Error("A proxy get the same message twice...");
    }
    this._pendingCalls.delete(id2);
    const [resolve, reject] = maybePromise;
    switch (msg.type) {
      case ProxyMessageKind$1.Error:
        return reject(msg.error);
      case ProxyMessageKind$1.GetPrincipalResponse:
      case ProxyMessageKind$1.CallResponse:
      case ProxyMessageKind$1.QueryResponse:
      case ProxyMessageKind$1.ReadStateResponse:
      case ProxyMessageKind$1.StatusResponse:
        return resolve(msg.response);
      default:
        throw new Error(`Invalid message being sent to ProxyAgent: ${JSON.stringify(msg)}`);
    }
  }
  async getPrincipal() {
    return this._sendAndWait({
      id: this._nextId++,
      type: ProxyMessageKind$1.GetPrincipal
    }).then((principal) => {
      if (typeof principal !== "string") {
        throw new Error("Invalid principal received.");
      }
      return Principal$2.fromText(principal);
    });
  }
  readState(canisterId, fields) {
    return this._sendAndWait({
      id: this._nextId++,
      type: ProxyMessageKind$1.ReadState,
      args: [canisterId.toString(), fields]
    });
  }
  call(canisterId, fields) {
    return this._sendAndWait({
      id: this._nextId++,
      type: ProxyMessageKind$1.Call,
      args: [canisterId.toString(), fields]
    });
  }
  status() {
    return this._sendAndWait({
      id: this._nextId++,
      type: ProxyMessageKind$1.Status
    });
  }
  query(canisterId, fields) {
    return this._sendAndWait({
      id: this._nextId++,
      type: ProxyMessageKind$1.Query,
      args: [canisterId.toString(), fields]
    });
  }
  async _sendAndWait(msg) {
    return new Promise((resolve, reject) => {
      this._pendingCalls.set(msg.id, [resolve, reject]);
      this._backend(msg);
    });
  }
  async fetchRootKey() {
    const rootKey = (await this.status()).root_key;
    this.rootKey = rootKey;
    return rootKey;
  }
}
function getDefaultAgent$1() {
  const agent = typeof window === "undefined" ? typeof global === "undefined" ? typeof self === "undefined" ? void 0 : self.ic.agent : global.ic.agent : window.ic.agent;
  if (!agent) {
    throw new Error("No Agent could be found.");
  }
  return agent;
}
const managementCanisterIdl$1 = ({ IDL: IDL2 }) => {
  const canister_id2 = IDL2.Principal;
  const wasm_module = IDL2.Vec(IDL2.Nat8);
  const CanisterSettings = IDL2.Record({
    compute_allocation: IDL2.Opt(IDL2.Nat),
    memory_allocation: IDL2.Opt(IDL2.Nat)
  });
  return IDL2.Service({
    provisional_create_canister_with_cycles: IDL2.Func([IDL2.Record({ amount: IDL2.Opt(IDL2.Nat), settings: IDL2.Opt(CanisterSettings) })], [IDL2.Record({ canister_id: canister_id2 })], []),
    create_canister: IDL2.Func([], [IDL2.Record({ canister_id: canister_id2 })], []),
    install_code: IDL2.Func([
      IDL2.Record({
        mode: IDL2.Variant({ install: IDL2.Null, reinstall: IDL2.Null, upgrade: IDL2.Null }),
        canister_id: canister_id2,
        wasm_module,
        arg: IDL2.Vec(IDL2.Nat8)
      })
    ], [], []),
    set_controller: IDL2.Func([IDL2.Record({ canister_id: canister_id2, new_controller: IDL2.Principal })], [], [])
  });
};
function getManagementCanister$1(config) {
  function transform2(methodName, args, callConfig) {
    const first = args[0];
    let effectiveCanisterId = Principal$2.fromHex("");
    if (first && typeof first === "object" && first.canister_id) {
      effectiveCanisterId = Principal$2.from(first.canister_id);
    }
    return { effectiveCanisterId };
  }
  return Actor$1.createActor(managementCanisterIdl$1, Object.assign(Object.assign(Object.assign({}, config), { canisterId: Principal$2.fromHex("") }), {
    callTransform: transform2,
    queryTransform: transform2
  }));
}
class AgentError$1 extends Error {
}
var decode$2;
(function() {
  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var lookup2 = new Uint8Array(256);
  for (var i2 = 0; i2 < chars.length; i2++) {
    lookup2[chars.charCodeAt(i2)] = i2;
  }
  decode$2 = function(base64) {
    var bufferLength = base64.length * 0.75, len2 = base64.length, i3, p2 = 0, encoded1, encoded2, encoded3, encoded4;
    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }
    var arraybuffer = new ArrayBuffer(bufferLength), bytes2 = new Uint8Array(arraybuffer);
    for (i3 = 0; i3 < len2; i3 += 4) {
      encoded1 = lookup2[base64.charCodeAt(i3)];
      encoded2 = lookup2[base64.charCodeAt(i3 + 1)];
      encoded3 = lookup2[base64.charCodeAt(i3 + 2)];
      encoded4 = lookup2[base64.charCodeAt(i3 + 3)];
      bytes2[p2++] = encoded1 << 2 | encoded2 >> 4;
      bytes2[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
      bytes2[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }
    return arraybuffer;
  };
})();
let wasm$1;
const wasmBytesBase64$1 = `
    AGFzbQEAAAABXg9gAn9/AGABfwBgA39/fwBgAn9/AX9gAX8Bf2ADf39/AX9gBH9/f38AYAV/f39/fwBgBn9/f39/fwF/
    YAAAYAZ/f39/f38AYAV/fn5+fgBgAAF/YAF/AX5gAn9/AX4DvAG6AQgEAAEAAAABAgEDAAAMAAACAQEKAQAHBgEAAQEA
    AgcCAgABAgAGAAgOBAEBBAAAAQALAQkAAwMAAQQBAAICAAIBAQEBAQEGAQACAQEEAAECAQEABQMBAQMEAwQCAwAAAAEA
    AAAAAAEFAQEAAAACAQIAAQMAAQAGBAACAgMEAAAAAAAGAAQABAQEBAAAAwIAAgACAAEBAAAAAQEBAAEAAAAAAgAAAQAB
    AQEBAQEBAQEBAQIBAAAAAQ0AAQQFAXABBQUFAwEAEQYJAX8BQYCAwAALBzYEBm1lbW9yeQIACGJsc19pbml0AA0KYmxz
    X3ZlcmlmeQAnEV9fd2JpbmRnZW5fbWFsbG9jAHwJDQEAQQELBLgBCrkBtwEKiO8CugGXVQIQfwV+IwBB4OEAayIGJABB
    KxABIgkEQCAJQfSgwABBKxBnIQwDQCAHQStHBEAgByAMaiIJQV9BfyAJLQAAIglBn39qQf8BcUEaSRsgCXE6AAAgB0EB
    aiEHDAELC0EAIQcgBkGoA2pBOBByGiAGQQE2AuADIAZB6ANqQTgQciEPIAZBoARqQQE2AgAgBkGoBmpBoKfAABBfIAZB
    qAZqECkhCSAGQbgVakGAAhByGiAGQdjbAGpBgAEQchogBkGbI2pBgQIQciENIAZBsAxqQcAAEHIaIAZByM8AakHAABBy
    GiAGQdDVAGpBwAAQchogBkEAOgCaIyAGIAlB/wBqIhBBA3ZBAWoiCkEBdCILOgCZIyAGIApBB3Y6AJgjIAtBf2pBBXYi
    CEEBaiERA0AgB0ErRwRAIAcgDWogByAMai0AADoAACAHQQFqIQcMAQsLIAZBKzoAxiMgBkEgaiAGQZgjakEvQdinwAAQ
    ggEgBkGwDGpBwAAgAiADIAYoAiAgBigCJBATQQAhDUEAIAtrIRIgBkGZI2ohE0EBIQNBACEJA0ACQCANIAMgEUtyRQRA
    IAMgCEshDSADIAMgCE1qIQJBACEHA0AgB0EgRgRAIAYgAzoAmCNBACEHA0AgB0ErRwRAIAcgE2ogByAMai0AADoAACAH
    QQFqIQcMAQsLIAZBKzoAxCMgBkEYaiAGQZgjakEtQeinwAAQggFBACEHIAZByM8AakEAIAZB0NUAakEgIAYoAhggBigC
    HBATIAkgEmohAyAJIAlBgAIgCUGAAksbIg5rIRQgBkG4FWogCWohFQJAA0AgB0EgRg0FIAcgFGpFDQEgByAVaiAGQcjP
    AGogB2otAAA6AAAgAyAHQQFqIgdqDQALIAIhAyALIQkMBQsgDkGAAkH4p8AAEDwABSAGQcjPAGogB2oiDiAOLQAAIAZB
    sAxqIAdqLQAAcyIOOgAAIAZB0NUAaiAHaiAOOgAAIAdBAWohBwwBCwALAAsgEEGACEkhDUEAIQNBACEJA0ACQCAJQQJH
    BEAgCUEBaiELIAZBuBVqIANqIQJBACEHAkADQCAHIApGBEAgDQRAIAZByM8AakHwABByGiAGQdjbAGohCCAKIQcDQCAH
    BEAgBkHIzwBqQQgQLiAGIAYpA8hPIAgxAAB8NwPITyAHQX9qIQcgCEEBaiEIDAELCyAGQcjPAGoQRSAGQdDVAGogBkGo
    BmoQMCAGQZgjakHwABByGiAGQcjPAGogBkHQ1QBqEDZBAEgNBUEAIQIDQCAGQdDVAGpBARAuIAJBAWohAiAGQcjPAGog
    BkHQ1QBqEDZBf0oNAAsDQCACQQFIDQZBACEHA0AgB0HoAEYEQCAGIAYpA7hWQgGHNwO4VkEAIQcDQCAHQfAARwRAIAZB
    mCNqIAdqIAZByM8AaiAHaikDADcDACAHQQhqIQcMAQsLIAZBmCNqIAZB0NUAahBkIAZBmCNqEEUgBikDgCRCP4chF0EA
    IQcDQCAHQfAARwRAIAZByM8AaiAHaiIIIAZBmCNqIAdqKQMAIhYgCCkDAIUgF4MgFoU3AwAgB0EIaiEHDAELCyACQX9q
    IQIMAgUgBkHQ1QBqIAdqIgggCEEIaikDAEI5hkKAgICAgICAgAKDIAgpAwBCAYeENwMAIAdBCGohBwwBCwALAAsACyAK
    QYABQaChwAAQPQALIAMgB2oiCEH/AU0EQCAHQYABRg0CIAZB2NsAaiAHaiACIAdqLQAAOgAAIAdBAWohBwwBCwsgCEGA
    AkGwocAAEDwAC0GAAUGAAUHAocAAEDwACyAGQShqIAZBqANqEAIgBkG4EmogDxACIAZBKGogBkG4EmoQDCAGQegBakHo
    g8AAEF8CQAJAIAZB6AFqEFoNACAGQShqEIQBDQAgBkGIPWoQS0EAIQcgBkGIwwBqQTgQchogBkG4IWpBOBByGiAGQYjA
    AGoQSyAGQcjEAGoQSyAGQcjJAGoQSyAGQcjMAGoQSyAGQagGahBLIAZBsAxqEEsgBkHIzwBqEEsgBkHQ1QBqEEsgBkHY
    2wBqEEsgBkG4FWoQSyAGQZgjaiAGQcjJAGpBwAEQZxogBkHYJGogBkHIzABqQcABEGcaIAZBmCZqIAZBqAZqQcABEGca
    IAZB2CdqIAZBsAxqQcABEGcaIAZBmClqIAZByM8AakHAARBnGiAGQdgqaiAGQdDVAGpBwAEQZxogBkGYLGogBkHY2wBq
    QcABEGcaIAZB2C1qIAZBuBVqQcABEGcaIAZBuBVqQecAEHIaIAZBiMAAaiAGQShqEH8gBkGIwABqEBggBkGYI2ogBkEo
    ahB/A0AgB0HACkYEQCAGQbghaiAGQegBahBrIAYpA7ghIRcgBkG4IWpBARCdASAGQbghahBEIAYpA7ghIRYgBkGIwwBq
    IAZBuCFqEGsgBkGIwwBqQQEQnQEgBkGIwwBqEEQgBkG4IWogBkGIwwBqIBdCAoGnEE8gBkGIwABqIAZBKGogFkICgacQ
    bSAGQcjEAGogBkGIwABqEH8gBkG4IWoQKUEDaiIJQQJ2IgdBAWohAkEAIQgCQAJAAkADQAJAIAZBuCFqQQUQjAEhAyAC
    IAhGBEAgCUGYA0kNASACQecAQbCEwAAQPAALIAhB5wBGDQIgBkG4FWogCGogA0FwaiIDOgAAIAZBuCFqIANBGHRBGHUQ
    ngEgBkG4IWoQRCAGQbghakEEEDsgCEEBaiEIDAELCyAGQbgVaiACaiADOgAAIANBGHRBGHVBf2oiA0EBdiECIANBD0sN
    ASAGQYg9aiAGQZgjaiACQcABbGoQfwNAIAdBf0YEQCAGQYg9aiAGQcjEAGoQcyAGQZgjaiAGQYg9akHAARBnGgwICyAH
    QeYASw0DIAZBiMAAaiAGQZgjaiAGQbgVaiAHaiwAABAfIAdBf2ohByAGQYg9ahAYIAZBiD1qEBggBkGIPWoQGCAGQYg9
    ahAYIAZBiD1qIAZBiMAAahAMDAALAAtB5wBB5wBBoITAABA8AAsgAkEIQcCEwAAQPAALIAdB5wBB0ITAABA8AAUgBkHI
    xABqIAZBmCNqIAdqIgIQfyACQcABaiICIAZByMQAahB/IAIgBkGIwABqEAwgB0HAAWohBwwBCwALAAsgBkGYI2oQSwsgB
    kEoaiAGQZgjahB/IAZBKGoQRyAMEAlBACEHIAZBqAZqQTAQchogBkGwDGpBoKfAABBfAkACQAJAAkACQANAAkAgB0EwRg
    RAIAYgBi0AqAZBH3E6AKgGIAZByM8AaiAGQagGahBdIAENAUEAQQBB8ILAABA8AAsgASAHRg0CIAZBqAZqIAdqIAAgB2o
    tAAA6AAAgB0EBaiEHDAELC0EAIQcCQCAALAAAIgJBAE4EQCAAQTBqIQAgAUEwIAFBMEsbQVBqIQIDQCAHQTBGBEAgBkHY
    2wBqIAZBqAZqEF0gBkHoAWoQSyAGQegBaiAGQcjPAGoQtAEgBkGoAmoiACAGQdjbAGoQtAEgBkHoAmoQaSAGQegBahBEI
    AZBuBVqIAZB6AFqEE0gBkGYI2ogABCFASAGQZgjahADIAZBmCNqIAZBuBVqEFkNAyAGQegBahCUAQwDCyACIAdGDQQgBk
    GoBmogB2ogACAHai0AADoAACAHQQFqIQcMAAsACyAGQZgjahBLIAZB0NUAakE4EHIaIAZBATYCiFYgBkGYI2ogBkHIzwB
    qELQBIAZBmCNqEEQgBkGYJGoQaSAGQdjbAGogBkGYI2oQTQJAIAZB2NsAaiAGQdDVAGoQXEEBRwRAIAZBmCNqEJQBDAEL
    IAZBuBVqIAZB2NsAaiAGQdDVAGoQIyAGQbgVahBYBEAgBkG4FWoQQSAGQbgVahBECyAGQdgjaiAGQbgVahClAQsgAkEgc
    UEFdiAGQdgjahBMQQFGRwRAIAZBmCNqEKYBCyAGQegBaiAGQZgjakHAARBnGgsgBkHQPGpB8IHAABBfIAZB6AFqEIQBRQ
    0CDAMLIAEgAUHggsAAEDwACyAHQTBqIAFBgIPAABA8AAsgBkGoA2oQSyAGQagDaiAGQegBahB/IAZBuBJqEEsgBkG4Emo
    gBkHoAWoQfyAGQbgSahBHIAZByMcAakHwgcAAEF8gBkGYI2pBqILAABBfIAZBiMMAaiAGQZgjahCLAUEAIQAgBkG4IWpB
    OBByGiAGQfAhakE4EHIhCSAGQdjbAGpB8IHAABBfIAZBuBVqQYCAwAAQXyAGQZgjakE4EHIaIAZBkCNqIQsgBkGwFWohC
    gJAAkADQCAAQQdGDQIgAEEBaiEBIAZBuBVqIABBA3RqIQxCACEXQQAhAwNAIANBf2ohByAKIANBA3RqIQIgCyAAIANqQQ
    N0aiEIA0AgB0EGRgRAIAEhAAwDCyAIQQhqIQggAkEIaiECIAAgB0EBaiIHakEGSw0ACyAAQQZNBEAgB0EGSw0DIAdBAWo
    hAyAGQQhqIAIpAwAiFiAWQj+HIAwpAwAiFiAWQj+HEDEgCCAGKQMIIhkgF3wiFiAIKQMAIhp8IhhC//////////8DgzcD
    ACAYIBZUrSAWIBlUrSAGQRBqKQMAIBdCP4d8fCAaQj+HfHxCBoYgGEI6iIQhFwwBCwsLIABBB0G0ncAAEDwACyAHQQdBx
    J3AABA8AAsgBkG4IWogBkHQPGoQayAGQbghaiAGQZgjahAkIAkgBkHQPGoQayAJIAZBmCNqEBwgCSAGQdjbAGoQYyAGQb
    gSaiAGQYjDAGoQSCAGQbghahApIQAgBkGIyABqIAZBuCFqIAZByMcAahCNASAGQYjIAGoQKSAASQRAIAZBuCFqIAZBiMg
    AahBrIAZBqANqEKYBCyAJECkhACAGQYjIAGogCSAGQcjHAGoQjQEgBkGIyABqECkgAEkEQCAJIAZBiMgAahBrIAZBuBJq
    EKYBCyAGQbghahBEIAkQREEAIQcgBkHIyABqQTgQchogBkGIyQBqQTgQchogBkGYO2pBOBByGiAGQYg9ahBLIAZBiMAAa
    hBLIAZByMQAahBLIAZByMkAahBLIAZByMwAahBLIAZBqAZqEEsgBkGwDGoQSyAGQcjPAGoQSyAGQdDVAGoQSyAGQdjbAG
    oQSyAGQbgVahBLIAZBmCNqIAZByMkAakHAARBnGiAGQdgkaiAGQcjMAGpBwAEQZyEAIAZBmCZqIAZBqAZqQcABEGchASA
    GQdgnaiAGQbAMakHAARBnIQsgBkGYKWogBkHIzwBqQcABEGchCiAGQdgqaiAGQdDVAGpBwAEQZyECIAZBmCxqIAZB2NsA
    akHAARBnIQMgBkHYLWogBkG4FWpBwAEQZyEIIAZBuBVqQcwBEHIaIAZByMgAaiAGQbghahBrIAZBiMkAaiAJEGsgACAGQ
    agDahB/IAAgBkG4EmoQcyABIAZBqANqEH8gASAGQbgSahAMIAZBiD1qIAZBuBJqEH8gBkGIPWoQGCAGQcjEAGogABB/IA
    ZBmCNqIAZByMQAahB/IAZBmCNqIAZBiD1qEHMgBkHIxABqIAEQfyALIAZByMQAahB/IAsgBkGIPWoQDCAGQYjAAGogBkG
    oA2oQfyAGQYjAAGoQGCAGQcjEAGogABB/IAIgBkHIxABqEH8gAiAGQYjAAGoQDCAGQcjEAGogARB/IAMgBkHIxABqEH8g
    AyAGQYjAAGoQDCAGQcjEAGogAhB/IAogBkHIxABqEH8gCiAGQYg9ahBzIAZByMQAaiADEH8gCCAGQcjEAGoQfyAIIAZBi
    D1qEAwgBikDyEghFyAGQcjIAGpBARCdASAGQcjIAGoQRCAGKQPISCEWIAZBmDtqIAZByMgAahBrIAZBmDtqQQEQnQEgBk
    GYO2oQRCAGQcjIAGogBkGYO2ogF0ICgacQTyAGQYjAAGogBkGoA2ogFkICgacQbSAGQcjEAGogBkGIwABqEH8gBikDiEk
    hFyAGQYjJAGpBARCdASAGQYjJAGoQRCAGKQOISSEWIAZBmDtqIAZBiMkAahBrIAZBmDtqQQEQnQEgBkGYO2oQRCAGQYjJ
    AGogBkGYO2ogF0ICgacQTyAGQYg9aiAGQbgSaiAWQgKBpxBtIAZByMQAaiAGQYg9ahAMIAZBmDtqIAZByMgAahBrIAZBm
    DtqIAZBiMkAahBhIAZBmDtqEEQgBkGYO2oQKUEBaiICQQF2IghBAWohAAJAAkACQAJAA0ACQCAGQcjIAGpBAxCMASEBIA
    AgB0YEQCAGQYjJAGpBAxCMASEDIAJBlgNJDQEgAEHMAUG0g8AAEDwACyAGQcjIAGogAUF8aiIBEJ4BIAZByMgAahBEIAZ
    ByMgAakECEDsgBkGIyQBqIAZBiMkAakEDEIwBQXxqIgMQngEgBkGIyQBqEEQgBkGIyQBqQQIQOyAHQcwBRg0CIAZBuBVq
    IAdqIAMgAUECdGo6AAAgB0EBaiEHDAELCyAGQbgVaiAAaiADIAFBAnRqIgA6AAAgAEEYdEEYdUF/aiIBQQF2IQAgAUEPS
    w0BIAZBiD1qIAZBmCNqIABBwAFsahB/A0AgCEF/Rg0EIAhBywFLDQMgBkGIwABqIAZBmCNqIAZBuBVqIAhqLAAAEB8gCE
    F/aiEIIAZBiD1qEBggBkGIPWoQGCAGQYg9aiAGQYjAAGoQDAwACwALQcwBQcwBQaSDwAAQPAALIABBCEHEg8AAEDwACyA
    IQcwBQdSDwAAQPAALIAZBiD1qIAZByMQAahBzIAZBqANqIAZBiD1qQcABEGcaQX8hByAGQagDahCEAUUNASAGQegBahCm
    AUEAIQcgBkHIzwBqQeAAEHIaIAUEQANAIAdB4ABGBEAgBiAGLQDIT0EfcToAyE8gBkHQ1QBqIAZByM8AahAhAkACQAJAI
    AQsAAAiA0F/SgRAIARB4ABqIQAgBUHgACAFQeAASxtBoH9qIQFBACEHA0AgB0HgAEYEQCAGQZgjaiAGQcjPAGoQISAGQa
    gDaiAGQdDVAGogBkGYI2oQPwwDCyABIAdGDQMgBkHIzwBqIAdqIAAgB2otAAA6AAAgB0EBaiEHDAALAAsgBkGYI2oQKiA
    GQYjAAGpBOBByGiAGQQE2AsBAIAZBmCNqIAZB0NUAahCQASAGQZgkaiIBELABIAZBmCVqELABIAZBmCNqEKgBIAZB2NsA
    aiAGQZgjahAmIAZBuBVqIAZB2NsAahBeIAZBuBVqEKYBIAZBuBVqIAZB2NsAahAPIAZBsAxqIAZBuBVqQcAAEGcaAkAgB
    kGwDGogBkGIwABqEFxBAUcEQCAGQZgjahCYAQwBCyAGQdjbAGoQhwFFBEAgBkHIxABqIAZBmNwAaiIAEIUBIAZByMkAai
    AGQdjbAGoQhQEgBkHIzABqIAZB2NsAahCFASAGQagGakE4EHIaIAZBATYC4AYgBkGwDGpBOBByGiAGQQE2AugMIAZByMQ
    AahADIAZByMkAahADIAZByMQAaiAGQcjJAGoQeCAGQcjEAGoQRCAGQbgVaiAGQcjEAGogBkGIwABqECMgBkHIyQBqIAZB
    uBVqEKUBIAZByMQAaiAGQcjJAGoQpQEgBkHIyQBqIAZB2NsAahClASAGQcjJAGogBkHIxABqEHggBkHIyQBqEEQgBkHIy
    QBqEEIgBkHIxABqIAAQpQEgBkHIxABqEEIgBkHIyQBqIAZBsAxqEFwhAiAGQcjMAGogBkGwDGoQpQEgBkHIzABqEEEgBk
    HIzABqEEQgBkGoBmogBkHIyQBqEKUBIAZBqAZqEEEgBkGoBmoQRCAGQcjJAGogBkGoBmpBASACayICEHkgBkGwDGogBkH
    IzABqIAIQeSAGQbgVaiAGQcjJAGogBkGwDGoQIyAGQdjbAGogBkG4FWoQpQEgBkHIzABqIAZByMkAahClASAGQcjMAGog
    BkGwDGoQNCAGQcjMAGogBkHY2wBqEEggACAGQcjMAGoQpQEgACAGQcjEAGoQSCAGQagGaiAGQdjbAGoQpQEgBkHY2wBqI
    AAgAhB5IAAgBkGoBmogAhB5IAZB2NsAahCJASEAIAZBuBVqIAZB2NsAahBeIAZBuBVqEDogBkG4FWoQqAEgBkHY2wBqIA
    ZBuBVqIAAQjwELIAZB2NsAahCJAQRAIAZB2NsAahA6CyAGQdjbAGoQqwEgASAGQdjbAGoQkAELQQAhAgJAIAEQhwENACA
    GQdgkahBMIgINACABEEwhAgsgA0EgcUEFdiACQQFGRwRAIAZBmCNqEJwBCyAGQagDaiAGQZgjakGAAxBnGgsgBkHIyABq
    QfCBwAAQXyAGQagDahCIAQ0FIAZBuBJqECogBkG4FWoQKiAGQdDVAGoQKiAGQdjbAGoQKiAGQZgjahAqIAZBuBhqIAZB0
    NUAakGAAxBnIQ0gBkG4G2ogBkHY2wBqQYADEGchCSAGQbgeaiAGQZgjakGAAxBnIQAgBkHY2wBqQbiAwAAQXyAGQZgjak
    HwgMAAEF8gBkGIwwBqIAZB2NsAaiAGQZgjahBJIAZBiMkAakHwgcAAEF9BACEHIAZBuCFqQTgQchogBkHwIWpBqAEQciE
    DIAZBsAxqQfCBwAAQXyAGQcjPAGpBgIDAABBfIAZB4CJqIQEgBkGoImohDyAGQdDVAGogBkHIyABqEF8DQCAHQagBRg0C
    IAZBuCFqIAdqIgIgBkHQ1QBqEGsgAiAGQcjPAGoQJCAHQThqIQcgBkHQ1QBqIAZByM8AahAcDAALAAsgB0HgAGogBUGwp
    MAAEDwACyABIAZB0NUAahBrQQAhByAGQdjbAGpBOBByGiAGQZgjaiADIAZBsAxqEI0BIAZB2NsAaiAGQZgjahBrIAMgBk
    HY2wBqEGsgBkGYI2ogASAGQbAMahCNASAGQdjbAGogBkGYI2oQayABIAZB2NsAahBrIAZBiD1qECogBkGIwwBqEEAgBkG
    IwwBqEKgBIAZBmDtqQTgQchogBkG4FWogBkGoA2oQfgNAIAdBgAlGBEACQCAGQbgVaiECQQAhBwNAIAdB4AFHBEAgBkG4
    IWogB2oiBBApIQUgBkGYI2ogBCAGQYjJAGoQjQEgBkGYO2ogBkGYI2oQayAGQZg7ahApIAVJBEAgBCAGQZg7ahBrIAIQn
    AELIAQQRCAHQThqIQcgAkGAA2ohAgwBCwsgBkHIxABqECogBkGIwABqECogBkGYI2oQKiAGQcjJAGoQKiAGQcjMAGoQKi
    AGQagGahAqIAZBsAxqECogBkHIzwBqECogBkHQ1QBqECogBkHY2wBqECogBkGYJmogBkHIyQBqQYADEGchAiAGQZgpaiA
    GQcjMAGpBgAMQZyEEIAZBmCxqIAZBqAZqQYADEGchBSAGQZgvaiAGQbAMakGAAxBnIQsgBkGYMmogBkHIzwBqQYADEGch
    CiAGQZg1aiAGQdDVAGpBgAMQZyEIIAZBmDhqIAZB2NsAakGAAxBnIQxBACEHIAZBqAZqQTgQchogBkGwDGogBkG4IWoQX
    yAGQcjPAGogAxBfIAZB0NUAaiAPEF8gBkHY2wBqIAEQXyAGQegMaiAGQcjPAGpBOBBnGiAGQaANaiAGQdDVAGpBOBBnGi
    AGQdgNaiAGQdjbAGpBOBBnGiAGQdDVAGpBlwMQchogBkHY2wBqQZcDEHIaA0AgB0HgAUYEQAJAIAZBmCNqIAZBuBVqEH4
    gBkHIxABqIAZBmCNqEH4gAiAGQcjEAGoQfiACIA0QCyAEIAZByMQAahB+IAQgCRALIAZByMQAaiACEH4gBSAGQcjEAGoQ
    fiAFIAkQCyAGQcjEAGogBkGYI2oQfiALIAZByMQAahB+IAsgABALIAZByMQAaiACEH4gCiAGQcjEAGoQfiAKIAAQCyAGQ
    cjEAGogBBB+IAggBkHIxABqEH4gCCAAEAsgBkHIxABqIAUQfiAMIAZByMQAahB+IAwgABALIAZBsAxqQQEgBikDsAxCAo
    GnayIFEJ0BIAZBsAxqEEQgBkGoBmoQdEEAIQAgBkGwDGohAgJAAkACQAJAA38gAEEERgR/IAZBqAZqECkiA0GXA08NAiA
    DQQFqIQkgBkHY2wBqIANqQQE6AAAgBkHY2wBqIQggAwVBACEHA0AgB0E4RwRAIAZBqAZqIAdqIgEgASkDACACIAdqKQMA
    hDcDACAHQQhqIQcMAQsLIAJBOGohAiAAQQFqIQAMAQsLIQcDQCAHBEAgBkGwDGpBARA7IAggBikDsAxCAoGnQQF0QX9qO
    gAAIAdBf2ohByAIQQFqIQgMAQsLQQAhBwNAIAcgCUYEQCAGQYjAAGogBkGYI2ogBkHQ1QBqIANqLQAAQRl0QRh1QQFyEC
    AgA0F/aiEHA0AgB0F/Rg0GIAZBiMAAahAUIAdBlgNLDQUgBkHIxABqIAZBmCNqIAZB2NsAaiAHai0AACAGQdDVAGogB2o
    tAABBAXRqQRh0QRh1ECAgB0F/aiEHIAZBiMAAaiAGQcjEAGoQCwwACwALIAdBlwNGDQIgB0EBaiEBQQAhACAGQdDVAGog
    B2oiC0EAOgAAIAZB2NsAaiAHai0AACEKQQEhAkE4IQcDQCAHQeABRgRAIAEhBwwCBSAGQbAMaiAHaiIEKQMAIRcgBEEBE
    DsgBCAKIBdCAoGnbCIIQRh0QRl1EJ4BIAQQRCALIAAgAiAIbGoiADoAACAHQThqIQcgAkEBdCECDAELAAsACwALIANBlw
    NBkKXAABA8AAtBlwNBlwNBoKXAABA8AAsgB0GXA0GwpcAAEDwACyAGQcjEAGogBkGIwABqEH4gBkHIzwBqECogBkHIzwB
    qIAZBuBVqEH4gBkHIzwBqEJwBIAZByMQAaiAGQcjPAGoQCyAGQYjAAGogBkHIxABqIAUQbyAGQbgSaiAGQYjAAGoQfkF/
    IQcgBkG4EmoQiAFFDQogBkG4EmoQOCAGQbgVakG4gMAAEF8gBkGYI2pB8IDAABBfIAZBmDtqIAZBuBVqIAZBmCNqEEkgB
    kGYPGpBOBByGiAGQdA8akE4EHIaIAZBiD1qECogBkHoAWoQhAFFBEAgBkEoahCEAQ0BIAZBiMAAahAqIAZBiMAAaiAGQb
    gSahB+IAZBiMAAahBKIAZBiMMAahBLIAZBiMMAaiAGQegBahB/IAZBiMMAahBHIAZByMQAahAqIAZByMQAaiAGQagDahB
    +IAZByMQAahBKIAZBuCFqEEsgBkG4IWogBkEoahB/IAZBuCFqEEcgBkGYI2ogBkGIwwBqEIUBIAZByMcAaiAGQZgjahCF
    ASAGQZgjaiAGQcjDAGoQhQEgBkGIyABqIAZBmCNqEIUBIAZBmCNqIAZBuCFqEIUBIAZByMgAaiAGQZgjahCFASAGQZgja
    iAGQfghahCFASAGQYjJAGogBkGYI2oQhQEgBkHIyQBqECogBkHIzABqECogBkHQ1QBqEGAgBkHIyQBqIAZBiMAAahB+IA
    ZByMwAaiAGQcjEAGoQfiAGQbAMahAqIAZBsAxqIAZBiMAAahB+IAZBsAxqEJwBIAZByM8AahAqIAZByM8AaiAGQcjEAGo
    QfiAGQcjPAGoQnAEgBkHQPGogBkGYPGoQVEF/aiEHA0AgB0EBTQRAIAZB0NUAahCTASAGQagGaiAGQdDVAGpBiAYQZxoM
    BgsgBkHQ1QBqEBsgBkHY2wBqIAZByMkAaiAGQcjHAGogBkGIyABqEBcgBkG4FWogBkHIzABqIAZByMgAaiAGQYjJAGoQF
    yAGQdjbAGogBkG4FWoQBiAGQdDVAGogBkHY2wBqEAQCQAJAIAZB0DxqIAdBf2oiBxBXIAZBmDxqIAcQV2tBAWoOAwECAA
    ILIAZB2NsAaiAGQcjJAGogBkGIwABqIAZByMcAaiAGQYjIAGoQFiAGQZgjaiAGQcjMAGogBkHIxABqIAZByMgAaiAGQYj
    JAGoQFiAGQdjbAGogBkGYI2oQBiAGQdDVAGogBkHY2wBqEAQMAQsgBkHY2wBqIAZByMkAaiAGQbAMaiAGQcjHAGogBkGI
    yABqEBYgBkGYI2ogBkHIzABqIAZByM8AaiAGQcjIAGogBkGIyQBqEBYgBkHY2wBqIAZBmCNqEAYgBkHQ1QBqIAZB2NsAa
    hAEDAALAAsgBkGoBmogBkGoA2ogBkEoahAQDAMLBSAGQbAMaiAHahBEIAdBOGohBwwBCwsgBkGoBmogBkG4EmogBkHoAW
    oQEAsFIAZBiD1qIAZBuBVqIAdqIgIQfiACQYADaiIEIAZBiD1qEH4gBkGYI2ogBkGIwwBqEF4gBkGYI2oQMiAEEKYBIAJ
    BgARqIgUQpgEgAkGABWoiAhCmASACEKsBIAQgBkGYI2oQDyAFIAZBmCNqEA8gBSAGQYjDAGoQDyAHQYADaiEHDAELCyAG
    QbgVakG4gMAAEF8gBkGYI2pB8IDAABBfIAZByMQAaiAGQbgVaiAGQZgjahBJIAZBiMAAakGAgMAAEF8gBkGwDGogBkGoB
    moQaiAGQcjPAGogBkGwDGoQaiAGQdDVAGogBkHIzwBqEI4BIAZB2NsAaiAGQcjRAGoiARCOASAGQbgVaiAGQcjPAGoQjg
    EgBkGYI2oQLyAGQcjPAGoQmQEgBkHQ1QBqECIgBkHY2wBqIAZByNMAaiIAEBkgBkHY2wBqEGYgBkHQ1QBqIAZB2NsAahC
    BASAGQdDVAGoQrAEgBkHY2wBqIAAQkgEgBkHY2wBqECIgBkHY2wBqEGYgBkG4FWogARAZIAZB2NsAaiAGQbgVahCBASAG
    QdjbAGoQrAEgBkG4FWogARCSASAGQbgVahAiIAZBmCNqIAZByM8AahCSASAGQZgjaiAAEBkgBkG4FWogBkGYI2oQgQEgB
    kG4FWoQrAEgBkGYI2ogARCSASAGQZgjaiAGQbgVahAZIAZBmCNqEGYgBkHIzwBqIAZB0NUAahAZIAZBmCNqIAZByM8Aah
    CWASAAIAZB2NsAahAZIAAQZiAGQZgjaiAAEJYBIAZBmCNqEKwBIAZByMkAaiAGQZgjahBeIAZByMwAaiAGQZgkaiICEF4
    gBkHIyQBqEDIgBkHIzABqEDIgBkHIzABqEFUgBkHIzABqEKgBIAZByMkAaiAGQcjMAGoQfSAGQcjJAGoQQCAGQZgjaiAG
    QcjJAGoQDyAGQcjJAGoQOiAGQcjJAGoQqAEgAiAGQcjJAGoQDyAGQcjPAGogBkHQ1QBqEJIBIAZByM8AaiAGQZgjahAZI
    AEgBkHY2wBqEJIBIAEgBkGYI2oQGSAAIAZBuBVqEJIBIAAgBkGYI2oQGSAGQQU2AshVIAZBsAxqEJMBIAZBsAxqIAZByM
    8AahAOIAZByM8AaiAGQbAMahBsIAZBsAxqIAZByMQAahA3IAZBsAxqIAZByMQAahA3IAZBsAxqIAZByM8AahAOIAZB0NU
    AaiAGQbAMahBqIAZB0NUAahAaIAZB0NUAaiAGQbAMahAOIAZBmCNqIAZBsAxqIAZBiMAAahAdIAZB2NsAaiAGQZgjahBq
    IAZB2NsAahCTASAGQbgVaiAGQbAMahBqIAZBuBVqEJMBIAZBsAxqIAZB2NsAahBsIAZBsAxqIAZBuBVqEA4gBkGYI2ogB
    kGwDGogBkGIwABqEB0gBkHY2wBqIAZBmCNqEGwgBkHY2wBqEJMBIAZBuBVqIAZBsAxqEGwgBkG4FWoQkwEgBkGwDGogBk
    HY2wBqEGwgBkGwDGogBkG4FWoQDiAGQZgjaiAGQbAMaiAGQYjAAGoQHSAGQdjbAGogBkGYI2oQbCAGQdjbAGoQkwEgBkG
    4FWogBkGwDGoQbCAGQbgVaiAGQcjEAGoQNyAGQbAMaiAGQdjbAGoQbCAGQbAMaiAGQbgVahAOIAZBmCNqIAZBsAxqIAZB
    iMAAahAdIAZB2NsAaiAGQZgjahBsIAZBmCNqIAZB2NsAaiAGQYjAAGoQHSAGQdjbAGogBkGYI2oQbCAGQbgVaiAGQbAMa
    hBsIAZBuBVqIAZByMQAahA3IAZBuBVqIAZByMQAahA3IAZB2NsAaiAGQbgVahAOIAZBuBVqIAZBsAxqEGwgBkG4FWoQkw
    EgBkGwDGogBkHY2wBqEGwgBkGwDGogBkG4FWoQDiAGQbAMaiAGQdDVAGoQDiAGQbAMahCaASAGQagGaiAGQbAMakGIBhB
    nGiAGQZgjahBuIAZBqAZqIAZBmCNqEHtFDQMgBkGoB2ogAhB7RQ0DIAZBqAhqEIYBRQ0DQQAhByAGQagKahCGAUUNAwwE
    CyAFIAdHBEAgBkHIzwBqIAdqIAQgB2otAAA6AAAgB0EBaiEHDAELCyAFIAVBoKTAABA8AAtBAEEAQZCkwAAQPAALQX8hB
    wsgBkHg4QBqJAAgBw8LQQAhByAGQbAMakE4EHIaA0AgB0E4RwRAIAZBsAxqIAdqIAZByM8AaiAHaikDADcDACAHQQhqIQ
    cMAQsLIAZBmCNqIAZBsAxqEIsBIAZBqANqIAlBBnRqIAZBmCNqQcAAEGcaIAMgCmohAyALIQkMAAsACyAHIAlqIQkgAiE
    DDAALAAtBK0EBQaS5wQAoAgAiAEEBIAAbEQAAAAvBKgIIfwF+AkACQAJAAkAgAEH1AU8EQCAAQc3/e08NAiAAQQtqIgBB
    eHEhBkHYtcEAKAIAIgdFDQFBHyEIQQAgBmshBQJAAkAgBkH///8HTQRAIAZBBiAAQQh2ZyIAa0EfcXZBAXEgAEEBdGtBP
    mohCAsgCEECdEHkt8EAaigCACIABEAgBkEAQRkgCEEBdmtBH3EgCEEfRht0IQMDQAJAIABBBGooAgBBeHEiBCAGSQ0AIA
    QgBmsiBCAFTw0AIAAhAiAEIgUNAEEAIQUMAwsgAEEUaigCACIEIAEgBCAAIANBHXZBBHFqQRBqKAIAIgBHGyABIAQbIQE
    gA0EBdCEDIAANAAsgAQRAIAEhAAwCCyACDQILQQAhAkECIAhBH3F0IgBBACAAa3IgB3EiAEUNAyAAQQAgAGtxaEECdEHk
    t8EAaigCACIARQ0DCwNAIAAgAiAAQQRqKAIAQXhxIgEgBk8gASAGayIDIAVJcSIEGyECIAMgBSAEGyEFIAAoAhAiAQR/I
    AEFIABBFGooAgALIgANAAsgAkUNAgtB5LjBACgCACIAIAZPQQAgBSAAIAZrTxsNASACKAIYIQcCQAJAIAIgAigCDCIBRg
    RAIAJBFEEQIAJBFGoiAygCACIBG2ooAgAiAA0BQQAhAQwCCyACKAIIIgAgATYCDCABIAA2AggMAQsgAyACQRBqIAEbIQM
    DQCADIQQgACIBQRRqIgMoAgAiAEUEQCABQRBqIQMgASgCECEACyAADQALIARBADYCAAsCQCAHRQ0AAkAgAiACKAIcQQJ0
    QeS3wQBqIgAoAgBHBEAgB0EQQRQgBygCECACRhtqIAE2AgAgAUUNAgwBCyAAIAE2AgAgAQ0AQdi1wQBB2LXBACgCAEF+I
    AIoAhx3cTYCAAwBCyABIAc2AhggAigCECIABEAgASAANgIQIAAgATYCGAsgAkEUaigCACIARQ0AIAFBFGogADYCACAAIA
    E2AhgLAkAgBUEQTwRAIAIgBkEDcjYCBCACIAZqIgcgBUEBcjYCBCAFIAdqIAU2AgAgBUGAAk8EQEEfIQAgB0IANwIQIAV
    B////B00EQCAFQQYgBUEIdmciAGtBH3F2QQFxIABBAXRrQT5qIQALIAcgADYCHCAAQQJ0QeS3wQBqIQQCQAJAAkACQEHY
    tcEAKAIAIgNBASAAQR9xdCIBcQRAIAQoAgAiA0EEaigCAEF4cSAFRw0BIAMhAAwCC0HYtcEAIAEgA3I2AgAgBCAHNgIAI
    AcgBDYCGAwDCyAFQQBBGSAAQQF2a0EfcSAAQR9GG3QhAQNAIAMgAUEddkEEcWpBEGoiBCgCACIARQ0CIAFBAXQhASAAIQ
    MgAEEEaigCAEF4cSAFRw0ACwsgACgCCCIBIAc2AgwgACAHNgIIIAdBADYCGCAHIAA2AgwgByABNgIIDAQLIAQgBzYCACA
    HIAM2AhgLIAcgBzYCDCAHIAc2AggMAgsgBUEDdiIBQQN0Qdy1wQBqIQACf0HUtcEAKAIAIgNBASABdCIBcQRAIAAoAggM
    AQtB1LXBACABIANyNgIAIAALIQUgACAHNgIIIAUgBzYCDCAHIAA2AgwgByAFNgIIDAELIAIgBSAGaiIAQQNyNgIEIAAgA
    moiACAAKAIEQQFyNgIECyACQQhqDwsCQAJAQdS1wQAoAgAiB0EQIABBC2pBeHEgAEELSRsiBkEDdiIBdiICQQNxRQRAIA
    ZB5LjBACgCAE0NAyACDQFB2LXBACgCACIARQ0DIABBACAAa3FoQQJ0QeS3wQBqKAIAIgFBBGooAgBBeHEgBmshBSABIQM
    DQCABKAIQIgBFBEAgAUEUaigCACIARQ0ECyAAQQRqKAIAQXhxIAZrIgIgBSACIAVJIgIbIQUgACADIAIbIQMgACEBDAAL
    AAsCQCACQX9zQQFxIAFqIgVBA3QiAEHktcEAaigCACIDQQhqIgIoAgAiASAAQdy1wQBqIgBHBEAgASAANgIMIAAgATYCC
    AwBC0HUtcEAIAdBfiAFd3E2AgALIAMgBUEDdCIAQQNyNgIEIAAgA2oiACAAKAIEQQFyNgIEIAIPCwJAQQIgAXQiAEEAIA
    BrciACIAF0cSIAQQAgAGtxaCIBQQN0IgBB5LXBAGooAgAiA0EIaiIEKAIAIgIgAEHctcEAaiIARwRAIAIgADYCDCAAIAI
    2AggMAQtB1LXBACAHQX4gAXdxNgIACyADIAZBA3I2AgQgAyAGaiIFIAFBA3QiACAGayIHQQFyNgIEIAAgA2ogBzYCAEHk
    uMEAKAIAIgAEQCAAQQN2IgJBA3RB3LXBAGohAEHsuMEAKAIAIQgCf0HUtcEAKAIAIgFBASACQR9xdCICcQRAIAAoAggMA
    QtB1LXBACABIAJyNgIAIAALIQMgACAINgIIIAMgCDYCDCAIIAA2AgwgCCADNgIIC0HsuMEAIAU2AgBB5LjBACAHNgIAIA
    QPCyADKAIYIQcCQAJAIAMgAygCDCIBRgRAIANBFEEQIANBFGoiASgCACICG2ooAgAiAA0BQQAhAQwCCyADKAIIIgAgATY
    CDCABIAA2AggMAQsgASADQRBqIAIbIQIDQCACIQQgACIBQRRqIgIoAgAiAEUEQCABQRBqIQIgASgCECEACyAADQALIARB
    ADYCAAsgB0UNAyADIAMoAhxBAnRB5LfBAGoiACgCAEcEQCAHQRBBFCAHKAIQIANGG2ogATYCACABRQ0EDAMLIAAgATYCA
    CABDQJB2LXBAEHYtcEAKAIAQX4gAygCHHdxNgIADAMLAkACQAJAAkACQEHkuMEAKAIAIgEgBkkEQEHouMEAKAIAIgAgBk
    sNA0EAIQUgBkGvgARqIgJBEHZAACIAQX9GDQYgAEEQdCIDRQ0GQfS4wQAgAkGAgHxxIgVB9LjBACgCAGoiAjYCAEH4uME
    AQfi4wQAoAgAiACACIAAgAksbNgIAQfC4wQAoAgAiBEUNAUH8uMEAIQADQCAAKAIAIgEgACgCBCICaiADRg0DIAAoAggi
    AA0ACwwEC0HsuMEAKAIAIQMCfyABIAZrIgJBD00EQEHsuMEAQQA2AgBB5LjBAEEANgIAIAMgAUEDcjYCBCABIANqIgJBB
    GohACACKAIEQQFyDAELQeS4wQAgAjYCAEHsuMEAIAMgBmoiADYCACAAIAJBAXI2AgQgASADaiACNgIAIANBBGohACAGQQ
    NyCyEGIAAgBjYCACADQQhqDwtBkLnBACgCACIAQQAgACADTRtFBEBBkLnBACADNgIAC0GUucEAQf8fNgIAQYC5wQAgBTY
    CAEH8uMEAIAM2AgBB6LXBAEHctcEANgIAQfC1wQBB5LXBADYCAEHktcEAQdy1wQA2AgBB+LXBAEHstcEANgIAQey1wQBB
    5LXBADYCAEGAtsEAQfS1wQA2AgBB9LXBAEHstcEANgIAQYi2wQBB/LXBADYCAEH8tcEAQfS1wQA2AgBBkLbBAEGEtsEAN
    gIAQYS2wQBB/LXBADYCAEGYtsEAQYy2wQA2AgBBjLbBAEGEtsEANgIAQaC2wQBBlLbBADYCAEGUtsEAQYy2wQA2AgBBiL
    nBAEEANgIAQai2wQBBnLbBADYCAEGctsEAQZS2wQA2AgBBpLbBAEGctsEANgIAQbC2wQBBpLbBADYCAEGstsEAQaS2wQA
    2AgBBuLbBAEGstsEANgIAQbS2wQBBrLbBADYCAEHAtsEAQbS2wQA2AgBBvLbBAEG0tsEANgIAQci2wQBBvLbBADYCAEHE
    tsEAQby2wQA2AgBB0LbBAEHEtsEANgIAQcy2wQBBxLbBADYCAEHYtsEAQcy2wQA2AgBB1LbBAEHMtsEANgIAQeC2wQBB1
    LbBADYCAEHctsEAQdS2wQA2AgBB6LbBAEHctsEANgIAQfC2wQBB5LbBADYCAEHktsEAQdy2wQA2AgBB+LbBAEHstsEANg
    IAQey2wQBB5LbBADYCAEGAt8EAQfS2wQA2AgBB9LbBAEHstsEANgIAQYi3wQBB/LbBADYCAEH8tsEAQfS2wQA2AgBBkLf
    BAEGEt8EANgIAQYS3wQBB/LbBADYCAEGYt8EAQYy3wQA2AgBBjLfBAEGEt8EANgIAQaC3wQBBlLfBADYCAEGUt8EAQYy3
    wQA2AgBBqLfBAEGct8EANgIAQZy3wQBBlLfBADYCAEGwt8EAQaS3wQA2AgBBpLfBAEGct8EANgIAQbi3wQBBrLfBADYCA
    EGst8EAQaS3wQA2AgBBwLfBAEG0t8EANgIAQbS3wQBBrLfBADYCAEHIt8EAQby3wQA2AgBBvLfBAEG0t8EANgIAQdC3wQ
    BBxLfBADYCAEHEt8EAQby3wQA2AgBB2LfBAEHMt8EANgIAQcy3wQBBxLfBADYCAEHgt8EAQdS3wQA2AgBB1LfBAEHMt8E
    ANgIAQfC4wQAgAzYCAEHct8EAQdS3wQA2AgBB6LjBACAFQVhqIgA2AgAgAyAAQQFyNgIEIAAgA2pBKDYCBEGMucEAQYCA
    gAE2AgAMAwsgAEEMaigCACADIARNciABIARLcg0BIAAgAiAFajYCBEHwuMEAQfC4wQAoAgAiA0EPakF4cSIBQXhqNgIAQ
    ei4wQBB6LjBACgCACAFaiICIAMgAWtqQQhqIgA2AgAgAUF8aiAAQQFyNgIAIAIgA2pBKDYCBEGMucEAQYCAgAE2AgAMAg
    tB6LjBACAAIAZrIgI2AgBB8LjBAEHwuMEAKAIAIgEgBmoiADYCACAAIAJBAXI2AgQgASAGQQNyNgIEIAFBCGohBQwCC0G
    QucEAQZC5wQAoAgAiACADIAAgA0kbNgIAIAMgBWohAUH8uMEAIQACQANAIAEgACgCAEcEQCAAKAIIIgANAQwCCwsgAEEM
    aigCAA0AIAAgAzYCACAAIAAoAgQgBWo2AgQgAyAGQQNyNgIEIAMgBmohBCABIANrIAZrIQYCQAJAIAFB8LjBACgCAEcEQ
    EHsuMEAKAIAIAFGDQEgAUEEaigCACIAQQNxQQFGBEAgASAAQXhxIgAQFSAAIAZqIQYgACABaiEBCyABIAEoAgRBfnE2Ag
    QgBCAGQQFyNgIEIAQgBmogBjYCACAGQYACTwRAQR8hBSAEQgA3AhAgBkH///8HTQRAIAZBBiAGQQh2ZyIAa0EfcXZBAXE
    gAEEBdGtBPmohBQsgBCAFNgIcIAVBAnRB5LfBAGohAQJAAkACQAJAQdi1wQAoAgAiAkEBIAVBH3F0IgBxBEAgASgCACIC
    QQRqKAIAQXhxIAZHDQEgAiEFDAILQdi1wQAgACACcjYCACABIAQ2AgAgBCABNgIYDAMLIAZBAEEZIAVBAXZrQR9xIAVBH
    0YbdCEBA0AgAiABQR12QQRxakEQaiIAKAIAIgVFDQIgAUEBdCEBIAUiAkEEaigCAEF4cSAGRw0ACwsgBSgCCCIAIAQ2Ag
    wgBSAENgIIIARBADYCGCAEIAU2AgwgBCAANgIIDAULIAAgBDYCACAEIAI2AhgLIAQgBDYCDCAEIAQ2AggMAwsgBkEDdiI
    CQQN0Qdy1wQBqIQACf0HUtcEAKAIAIgFBASACdCICcQRAIAAoAggMAQtB1LXBACABIAJyNgIAIAALIQUgACAENgIIIAUg
    BDYCDCAEIAA2AgwgBCAFNgIIDAILQfC4wQAgBDYCAEHouMEAQei4wQAoAgAgBmoiADYCACAEIABBAXI2AgQMAQtB7LjBA
    CAENgIAQeS4wQBB5LjBACgCACAGaiIANgIAIAQgAEEBcjYCBCAAIARqIAA2AgALIANBCGoPC0H8uMEAIQADQAJAIAAoAg
    AiAiAETQRAIAIgACgCBGoiAiAESw0BCyAAKAIIIQAMAQsLQfC4wQAgAzYCAEHouMEAIAVBWGoiADYCACADIABBAXI2AgQ
    gACADakEoNgIEQYy5wQBBgICAATYCACAEIAJBYGpBeHFBeGoiACAAIARBEGpJGyIBQRs2AgRB/LjBACkCACEJIAFBEGpB
    hLnBACkCADcCACABIAk3AghBgLnBACAFNgIAQfy4wQAgAzYCAEGEucEAIAFBCGo2AgBBiLnBAEEANgIAIAFBHGohAANAI
    ABBBzYCACACIABBBGoiAEsNAAsgASAERg0AIAEgASgCBEF+cTYCBCAEIAEgBGsiBUEBcjYCBCABIAU2AgAgBUGAAk8EQE
    EfIQAgBEIANwIQIAVB////B00EQCAFQQYgBUEIdmciAGtBH3F2QQFxIABBAXRrQT5qIQALIARBHGogADYCACAAQQJ0QeS
    3wQBqIQMCQAJAAkACQEHYtcEAKAIAIgFBASAAQR9xdCICcQRAIAMoAgAiAkEEaigCAEF4cSAFRw0BIAIhAAwCC0HYtcEA
    IAEgAnI2AgAgAyAENgIAIARBGGogAzYCAAwDCyAFQQBBGSAAQQF2a0EfcSAAQR9GG3QhAQNAIAIgAUEddkEEcWpBEGoiA
    ygCACIARQ0CIAFBAXQhASAAIQIgAEEEaigCAEF4cSAFRw0ACwsgACgCCCICIAQ2AgwgACAENgIIIARBGGpBADYCACAEIA
    A2AgwgBCACNgIIDAMLIAMgBDYCACAEQRhqIAI2AgALIAQgBDYCDCAEIAQ2AggMAQsgBUEDdiICQQN0Qdy1wQBqIQACf0H
    UtcEAKAIAIgFBASACdCICcQRAIAAoAggMAQtB1LXBACABIAJyNgIAIAALIQEgACAENgIIIAEgBDYCDCAEIAA2AgwgBCAB
    NgIIC0EAIQVB6LjBACgCACIAIAZNDQBB6LjBACAAIAZrIgI2AgBB8LjBAEHwuMEAKAIAIgEgBmoiADYCACAAIAJBAXI2A
    gQgASAGQQNyNgIEIAFBCGoPCyAFDwsgASAHNgIYIAMoAhAiAARAIAEgADYCECAAIAE2AhgLIANBFGooAgAiAEUNACABQR
    RqIAA2AgAgACABNgIYCwJAIAVBEE8EQCADIAZBA3I2AgQgAyAGaiIEIAVBAXI2AgQgBCAFaiAFNgIAQeS4wQAoAgAiAAR
    AIABBA3YiAkEDdEHctcEAaiEAQey4wQAoAgAhBwJ/QdS1wQAoAgAiAUEBIAJBH3F0IgJxBEAgACgCCAwBC0HUtcEAIAEg
    AnI2AgAgAAshAiAAIAc2AgggAiAHNgIMIAcgADYCDCAHIAI2AggLQey4wQAgBDYCAEHkuMEAIAU2AgAMAQsgAyAFIAZqI
    gBBA3I2AgQgACADaiIAIAAoAgRBAXI2AgQLIANBCGoLtA8BA38jAEGAC2siAiQAIAJBCGoQSyACQcgBakE4EHIaIAJBAT
    YCgAIgAkGIAmpBOBByGiACQQE2AsACIAJByAJqQTgQchogAkEBNgKAAyACQYgDakE4EHIaIAJBATYCwAMgAkHIA2pBOBB
    yGiACQQE2AoAEIAJBiARqQQEQigEgAkHIBGpBOBByGiACQQE2AoAFIAJBiAVqQTgQchogAkEBNgLABSACQcgFaiABEIUB
    IAJBiAZqQTgQchogAkEBNgLABiACQcgGakE4EHIaIAJBATYCgAcgAkGIB2pBOBByGiACQQE2AsAHIAJByAdqQTgQchogA
    kEBNgKACCACQcgFahBYIQMgAkHICWpB4ITAABBfIAJBiApqIAJByAlqEIsBIAJByAFqIAJBiApqEKUBIAJByAlqQZiFwA
    AQXyACQYgKaiACQcgJahCLASACQYgCaiACQYgKahClASACQcgFahADIAJByAVqQQsQUiACQYgGaiACQcgFahClASACQYg
    GaiACQYgEahB4IAJBiAZqEEQgAkGIBmogAkHIBWoQSCACQYgFaiACQcgBahClASACQYgFaiACQYgGahBIIAJBiAZqIAJB
    iARqEHggAkGIBmoQRCACQYgGaiACQYgCahBIIAJBiAZqEEEgAkGIBmoQRCACQYgDaiACQYgGahClASACQcgDaiACQcgFa
    hClASACQcgDaiACQYgDahBIIAJByAdqIAJBiANqEKUBIAJByAdqEAMgAkHIBmogAkGIBWoQpQEgAkHIBmoQAyACQYgGai
    ACQcgBahClASACQYgGaiACQcgGahBIIAJByAdqIAJBiAZqEHggAkHIB2oQRCACQcgHaiACQYgDahBIIAJByAZqIAJBiAV
    qEEggAkGIBmogAkGIAmoQpQEgAkGIBmogAkHIBmoQSCACQcgHaiACQYgGahB4IAJByAdqEEQgAkGIBmogAkHIB2oQpQEg
    AkGIBmogAkGIBWoQSCACQYgGaiACQYgHahBcIQQgAkGIBWogAkGIBmoQpQEgAkGIBWogAkGIB2oQNCACQYgFaiACQcgHa
    hBIIAJBiANqIAJBiAVqEEggAkHIA2ogAkGIBWoQSCACQcgFaiABEEggAkHIBmogAkGIBWoQpQEgAkHIBmoQAyACQYgFai
    ACQcgGahClASACQYgFaiACQcgFahBIIAJByAVqIAJBiAZqEKUBIAJByAVqQQsQUiACQcgJakHQhcAAEF8gAkGICmogAkH
    ICWoQiwEgAkHIAmogAkGICmoQpQEgAkHIAmogAkGIB2oQSCACQYgDaiACQcgDakEBIARrIgEQeSACQcgGaiACQYgFaiAB
    EHkgAkGIBmogAkHIBWogARB5IAJBiAdqIAJByAJqIAEQeSACQYgKaiACQYgGaiACQYgHahAjIAJByARqIAJBiApqEKUBI
    AJByARqIAJByAZqEEggAkHIBGoQWCEBIAJBiAZqIAJByARqEKUBIAJBiAZqEEEgAkGIBmoQRCACQcgEaiACQYgGaiABIA
    NzEHkgAkGICmpBiIbAABBfIAJBiAhqIAJBiApqEIsBQTghAQNAIAFBoAVGRQRAIAJBiAhqIAJBiANqEEggAkHICWogAUG
    IhsAAahBfIAFBOGohASACQYgKaiACQcgJahCLASACQYgGaiACQYgKahClASACQYgIaiACQYgGahB4IAJBiAhqEEQMAQsL
    IAJByAhqIAJBiANqEIUBIAJByAlqQaiLwAAQXyACQYgKaiACQcgJahCLASACQYgGaiACQYgKahClASACQcgIaiACQYgGa
    hB4IAJByAhqEERBACEBA0AgAUH4A0ZFBEAgAkHICGogAkGIA2oQSCACQcgJaiABQeCLwABqEF8gAUE4aiEBIAJBiApqIA
    JByAlqEIsBIAJBiAZqIAJBiApqEKUBIAJByAhqIAJBiAZqEHggAkHICGoQRAwBCwsgAkGICmpB2I/AABBfIAJBiAlqIAJ
    BiApqEIsBQQAhAQNAIAFByAZGBEACQCACQcgJaiACQYgDahCFASACQcgKakHYlsAAEF8gAkGICmogAkHICmoQiwEgAkGI
    BmogAkGICmoQpQEgAkHICWogAkGIBmoQeCACQcgJahBEQQAhAQNAIAFBkAZGDQEgAkHICWogAkGIA2oQSCACQcgKaiABQ
    ZCXwABqEF8gAUE4aiEBIAJBiApqIAJByApqEIsBIAJBiAZqIAJBiApqEKUBIAJByAlqIAJBiAZqEHggAkHICWoQRAwACw
    ALBSACQYgJaiACQYgDahBIIAJByAlqIAFBkJDAAGoQXyABQThqIQEgAkGICmogAkHICWoQiwEgAkGIBmogAkGICmoQpQE
    gAkGICWogAkGIBmoQeCACQYgJahBEDAELCyACQYgJaiACQcgEahBIIAJBiAZqIAJBiAhqEKUBIAJBiAZqIAJByAlqEEgg
    AkEIaiACQYgGahClASACQYgGaiACQYgJahClASACQYgGaiACQcgIahBIIAJByABqIAJBiAZqEKUBIAJBiAZqIAJByAhqE
    KUBIAJBiAZqIAJByAlqEEggAkGIAWogAkGIBmoQpQEgACACQQhqQcABEGcaIAJBgAtqJAALzQ0CE38IfiMAQYADayIBJA
    AgADQCOCIUIBR+QoCAgBBaBEAgABASCyABQeABakHoABByGiABQcgBaiAAKQMAIhggGEI/hyIZIBggGRAxIAEgASkDyAE
    iFEL//////////wODNwPYASABQdABaikDACIXQgaGIBRCOoiEIRUgF0I6iCEaIABBCGoiCyEFIAAhBkEBIQcDQCAHQQZP
    BEAgAEEYaiEMIABBKGohCyAAQRBqIQcgACkDMCEYQQQhBkEAIQkgAUGgAWohDUEDIQpBAiEIQQchBQJAAkADQCAFQQpLD
    QIgBiAIIAYgCEsbIQ4gBiAKIAYgCksbQQN0QWhqIQ8gAUGYAWogBUEDdCIQIABqQVBqKQMAIhQgFEI/hyAYIBhCP4ciGR
    AxIAVBAWoiEUEBdiESIA0pAwAhFyABKQOYASEUIAshAyAHIQQgBUF7aiITIQICQANAIAIgDkcEQCACQQdGDQIgAUGIAWo
    gBCkDACIWIBZCP4cgAykDACIWIBZCP4cQMSABKQOIASIWIBR8IhQgFlStIAFBkAFqKQMAIBd8fCEXIANBeGohAyAEQQhq
    IQQgAkEBaiECDAELCyABQdgBaiAQaiAUQgGGIhYgFXwiFUL//////////wODNwMAIAFB+ABqIAAgE0EDdGopAwAiGyAbQ
    j+HIBggGRAxIBUgFlStIBdCAYYgFEI/iIQgGnx8IhRCOochGiAUQgaGIBVCOoiEIRkgBUECaiEFIAFBgAFqKQMAIRcgAS
    kDeCEUIAshAyAJIQIDQCACIA9GBEAgAUHYAGogACASQQN0aikDACIVIBVCP4ciFiAVIBYQMSABQdgBaiARQQN0aiAUQgG
    GIhYgGXwiFSABKQNYfCIZQv//////////A4M3AwAgGSAVVK0gAUHgAGopAwAgFSAWVK0gF0IBhiAUQj+IhCAafHx8fCIU
    QjqHIRogFEIGhiAZQjqIhCEVIApBAmohCiAJQRBqIQkgCEECaiEIIAZBAWohBiAHQRBqIQcMAwsgAkEgRg0DIAFB6ABqI
    AIgDGopAwAiFSAVQj+HIAMpAwAiFSAVQj+HEDEgASkDaCIVIBR8IhQgFVStIAFB8ABqKQMAIBd8fCEXIANBeGohAyACQQ
    hqIQIMAAsACwtBB0EHQbSewAAQPAALQQdBB0HEnsAAEDwACyABQagBaiAAKQMoIhQgFEI/hyAYIBhCP4ciFBAxIAEgFSA
    BKQOoASIVQgGGIhl8IhdC//////////8DgzcDsAIgAUG4AWogGCAUIBggFBAxIAEgFyAZVK0gAUGwAWopAwBCAYYgFUI/
    iIQgGnx8IhhCBoYgF0I6iIQiFyABKQO4AXwiFEL//////////wODNwO4AiABIBQgF1StIAFBwAFqKQMAIBhCOod8fEIGh
    iAUQjqIhDcDwAIgAUHIAmogAUHYAWoQBSAAIAFByAJqEGsgAEECNgI4IAFBgANqJAAPCyABQcgAaiAAIAdBA3QiDGopAw
    AiFCAUQj+HIBggGRAxIAdBAWoiDUEBdiEOIAFB0ABqKQMAIRcgASkDSCEUIAghAiAGIQMgCiEEIAshCQNAIAJFBEAgAUH
    YAWogDGogFEIBhiIWIBV8IhVC//////////8DgzcDACABQShqIAAgDUEDdCIMaikDACIbIBtCP4cgGCAZEDEgFSAWVK0g
    F0IBhiAUQj+IhCAafHwiFEI6hyEaIBRCBoYgFUI6iIQhFiAHQQJqIQkgAUEwaikDACEXQQAhAiABKQMoIRQgBSEDIAshB
    ANAIAIgCGpFBEAgAUEIaiAAIA5BA3RqKQMAIhUgFUI/hyIbIBUgGxAxIAFB2AFqIAxqIBRCAYYiGyAWfCIVIAEpAwh8Ih
    ZC//////////8DgzcDACAWIBVUrSABQRBqKQMAIBUgG1StIBdCAYYgFEI/iIQgGnx8fHwiFEI6hyEaIBRCBoYgFkI6iIQ
    hFSAFQRBqIQUgCEEBaiEIIAZBEGohBiAKQQJqIQogCSEHDAQLIAIgB2oiDUEGTQRAIAFBGGogBCkDACIVIBVCP4cgAykD
    ACIVIBVCP4cQMSABKQMYIhUgFHwiFCAVVK0gAUEgaikDACAXfHwhFyADQXhqIQMgAkF/aiECIARBCGohBAwBCwsgDUEHQ
    aSewAAQPAALIARBBk0EQCABQThqIAkpAwAiFiAWQj+HIAMpAwAiFiAWQj+HEDEgASkDOCIWIBR8IhQgFlStIAFBQGspAw
    AgF3x8IRcgAkF/aiECIANBeGohAyAEQX9qIQQgCUEIaiEJDAELCwsgBEEHQZSewAAQPAAL7wwBBH8jAEHADWsiAiQAAkA
    gACgCgAYiA0EBRwRAIAEoAoAGIgRBAUYNAQJAAkACQAJAIARBA00EQCADQX5xQQJGDQEgAiAAEI4BIAJBgAJqEC8gAkGA
    BGoQLyACQYAGahAvIAJBgAhqIAAQjgEgAkGACmoQLyACIAEQGSACQYAIaiAAQYACaiIFEJYBIAJBgAhqEKwBIAJBgAJqI
    AJBgAhqEJIBIAJBgAJqIAEQGSACQYAIaiAFEJIBIAJBgAhqIABBgARqIgMQlgEgAkGACGoQrAEgAkGABmogAkGACGoQkg
    EgBEECRg0CIAJBwAxqIAFBgAVqEF4gAkGABmogAkHADGoQogEMAwsgAiAAEI4BIAJBgAJqEC8gAkGABGoQLyACQYAGahA
    vIAIgARAZAkACQCAEQQRGIgQNACAAKAKABkEERg0AIAJBgARqIABBgAJqEJIBIAJBgARqIAFBgAJqEBkMAQsgAkHADGpB
    OBByGiACQQE2AvgMIAJBgA1qQTgQchogAkG4DWpBATYCACACQYAIakE4EHIaIAJBATYCuAggAkHACGpBOBByGiACQfgIa
    kEBNgIAIAJBgApqIABBgANqIgMQXiACQYAIaiACQYAKahCQASACQYAKaiABQYADaiIFEF4gAkGACGogAkGACmoQDyACQc
    AMahCpASAERQRAIAJBgApqIAMQXiACQcAMaiACQYAKahCQASACQYAKaiABQYACahBeIAJBwAxqIAJBgApqEA8LIAAoAoA
    GQQRHBEAgAkGACmogAEGAAmoQXiACQcAMaiACQYAKahCQASACQYAKaiAFEF4gAkHADGogAkGACmoQDwsgAkGABGogAkHA
    DGogAkGACGoQoQEgAkGABGoQZgsgAkGACGogABCOASACQYAKaiABEI4BIAJBgAhqIABBgAJqIgQQlgEgAkGACGoQrAEgA
    kGACmogAUGAAmoiBRCWASACQYAKahCsASACQYACaiACQYAIahCSASACQYACaiACQYAKahAZIAJBgAhqIAQQkgEgAkGACG
    ogAEGABGoiAxCWASACQYAIahCsASACQYAKaiAFEJIBIAJBgApqIAFBgARqIgUQlgEgAkGACmoQrAEgAkGABmogAkGACGo
    QkgEgAkGABmogAkGACmoQGSACQYAIaiACEJIBIAJBgAhqECsgAkGACmogAkGABGoQkgEgAkGACmoQKyACQYACaiACQYAI
    ahCWASAEIAJBgAJqEJIBIAQgAkGACmoQlgEgAkGABmogAkGACmoQlgEgAkGABGogAkGACGoQlgEgAkGACGogABCSASACQ
    YAIaiADEJYBIAJBgAhqEKwBIAJBgApqIAEQkgEgAkGACmogBRCWASACQYAKahCsASACQYAIaiACQYAKahAZIAJBgARqIA
    JBgAhqEJYBIAJBgAhqIAMQkgEgAkGACGogBRAZIAJBgApqIAJBgAhqEJIBIAJBgApqECsgAyACQYAEahCSASADIAJBgAp
    qEJYBIAJBgAZqIAJBgApqEJYBIAJBgAhqEGYgBCACQYAIahCWAQwDCyAAIAEQBgwECyACQcAMaiABQYAFahBeIAJBgAxq
    IAJBwAxqQcAAEGcaIAJBgAZqIAJBgAxqEKMBCyACQYAGahBmIAJBgAhqIAIQkgEgAkGACGoQKyACQYACaiACQYAIahCWA
    SAFIAJBgAJqEJIBIAJBgARqIAJBgAhqEJIBIAJBgAhqIAAQkgEgAkGACGogAxCWASACQYAIahCsASACQYAKaiABEJIBIA
    JBgApqIAFBgARqEJYBIAJBgApqEKwBIAJBgAhqIAJBgApqEBkgAkGABGogAkGACGoQlgEgAkGACGogAxCSAQJAIARBAkc
    EQCACQcAMaiABQYAFahBeIAJBgAhqIAJBwAxqEKIBDAELIAJBwAxqIAFBgAVqEF4gAkGADGogAkHADGpBwAAQZxogAkGA
    CGogAkGADGoQowELIAJBgAhqEGYgAkGACmogAkGACGoQkgEgAkGACmoQKyADIAJBgARqEJIBIAMgAkGACmoQlgEgAkGAB
    mogAkGACmoQlgEgAkGACGoQZiAFIAJBgAhqEJYBCyACQYAGahCsASACQYAGahBmIAAgAhCSASAAIAJBgAZqEJYBIABBBT
    YCgAYgABCZAQwBCyAAIAEQbAsgAkHADWokAAuaCQIPfwt+IwBBwAJrIgIkACACQeAAakGgp8AAEF8gAEE4EHIhDCACQZg
    BakHwABByGiACQZACakEwEHIaIAwQdCACIAEpAwAiFEL9//P/z///+QF+Qv//////////A4MiETcDiAIgAkHQAGogEUIA
    IAIpA2AiGCAYQj+HIhoQMSAUIAIpA1AiEXwiFiARVK0gAkHYAGopAwAgFEI/h3x8IhRCOocgASkDCCIRQj+HfCARIBRCB
    oYgFkI6iIQiEXwiEiARVK18IRNBASEDAkADQAJAIANBB0YEQCACQZACaiEJIAJB6ABqIQpBByEEIAJB4ABqIQ0gAkGIAm
    ohDkEGIQ8MAQsgA0EBdiIAQQFqIQUgCiAAayEGIAkgAEEDdCIHayEAIAdBCGohCCACQUBrIANBA3QiBCACQeAAamopAwA
    iFiAWQj+HIhQgAikDiAIiESARQj+HEDEgAkHIAGopAwAgEiAVfCIRIBJUrSATIBd8fHwgESACKQNAfCITIBFUrXwhEiAD
    QQFqIQcDQCADIAVNBEAgAkGIAmogBGogE0L9//P/z///+QF+Qv//////////A4MiETcDACACQTBqIBFCACAYIBoQMSACQ
    SBqIBFCACAWIBQQMSACQZgBaiADQQR0aiIAIAJBKGopAwAiGzcDCCAAIAIpAyAiGTcDACACKQMwIhEgE3wiFiARVK0gAk
    E4aikDACASfHwiFEI6hyABIAdBA3RqKQMAIhFCP4d8IBEgFEIGhiAWQjqIhCIRfCISIBFUrXwhEyAVIBl8IhUgGVStIBc
    gG3x8IRcgCUEIaiEJIApBAWohCiAHIQMMAwsgBkEGSw0DIAJBEGogAkHgAGogCGopAwAgAkHgAGogAGopAwB9IhEgEUI/
    hyACQYgCaiAAaikDACACQYgCaiAIaikDAH0iESARQj+HEDEgAikDECIRIBN8IhMgEVStIAJBGGopAwAgEnx8IRIgBUEBa
    iEFIABBeGohACAGQX9qIQYgCEEIaiEIDAALAAsLA0ACQCAEQQ1HBEAgDyAEQQF2IgBrIQUgDiAAQQN0IgtrIRAgDSALay
    EIIBMgF3wgEiAVfCITIBJUrXwhEiAEQQFqIQdBMCEAIAkhBiAKIQMDQCAAIAtGDQIgBUEGTQRAIAIgAyALaikDACAAIAh
    qKQMAfSIRIBFCP4cgACAQaikDACAGIAtqKQMAfSIRIBFCP4cQMSACKQMAIhEgE3wiEyARVK0gAkEIaikDACASfHwhEiAF
    QX9qIQUgBkEIaiEGIANBCGohAyAAQXhqIQAMAQsLIAVBB0HknsAAEDwACyAMIBJC//////////8DgzcDMCACQcACaiQAD
    wsgBEEDdCAMakFIaiATQv//////////A4M3AwAgEkI6hyABIAdBA3RqKQMAIhFCP4d8IBEgEkIGhiATQjqIhCIRfCISIB
    FUrXwhEyAXIARBBHQgAmpBOGoiAEEIaikDAH0gFSAAKQMAIhFUrX0hFyAOQQhqIQ4gDUEIaiENIA9BAWohDyAVIBF9IRU
    gByEEDAALAAsgBkEHQdSewAAQPAAL+QkBBH8jAEGACWsiAiQAIAJBgAhqIAAQXiACIAJBgAhqEF4gAkGACGogAEGAAWoi
    BBBeIAJBgAFqIAJBgAhqEF4gAkGACGogARBeIAIgAkGACGoQDyACQYAIaiABQYABaiIFEF4gAkGAAWogAkGACGoQDyAAK
    AKABiEDAkACQCABKAKABkECRwRAIANBAkYNASACQYAIaiAAQYAFahBeIAJBgAJqIAJBgAhqEF4gAkGACGogAUGABWoQXi
    ACQYACaiACQYAIahAPDAILIANBAkYEQCACQYAIaiAAQYAFahBeIAJBgAdqIAJBgAhqQcAAEGcaIAJBgAZqIAJBgAdqEIU
    BIAJBgAhqIAFBgAVqEF4gAkGAB2ogAkGACGpBwAAQZxogAkGABmogAkGAB2oQSCACQYAIakE4EHIaIAJBATYCuAggAkHA
    CGpBOBByIAJB+AhqQQE2AgAgAkGACGogAkGABmoQpQEQsgEgAkGAAmogAkGACGpBgAEQZxoMAgsgAkGACGogAEGABWoQX
    iACQYACaiACQYAIahBeIAJBgAhqIAFBgAVqEF4gAkGAB2ogAkGACGpBwAAQZxogAkGAAmogAkGAB2oQoAEMAQsgAkGACG
    ogAUGABWoQXiACQYACaiACQYAIahBeIAJBgAhqIABBgAVqEF4gAkGAB2ogAkGACGpBwAAQZxogAkGAAmogAkGAB2oQoAE
    LIAJBgAhqIAAQXiACQYADaiACQYAIahBeIAJBgAhqIAEQXiACQYAEaiACQYAIahBeIAJBgAhqIAQQXiACQYADaiACQYAI
    ahCVASACQYADahCoASACQYAIaiAFEF4gAkGABGogAkGACGoQlQEgAkGABGoQqAEgAkGABWogAkGAA2oQXiACQYAFaiACQ
    YAEahAPIAJBgAZqIAIQXiACQYAGaiACQYABahCVASACQYAGahA6IAJBgAVqIAJBgAZqEJUBIAJBgAhqIAAQXiACQYADai
    ACQYAIahCQASACQYAIaiAAQYAFaiIDEF4gAkGAA2ogAkGACGoQlQEgAkGAA2oQqAEgAkGACGogARBeIAJBgARqIAJBgAh
    qEJABIAJBgAhqIAFBgAVqIgEQXiACQYAEaiACQYAIahCVASACQYAEahCoASACQYAHaiACQYADahBeIAJBgAdqIAJBgARq
    EA8gAkGABmogAhCQASACQYAGaiACQYACahCVASACQYAGahA6IAJBgAdqIAJBgAZqEJUBIAJBgAhqIAQQXiACQYADaiACQ
    YAIahCQASACQYAIaiADEF4gAkGAA2ogAkGACGoQlQEgAkGAA2oQqAEgAkGACGogBRBeIAJBgARqIAJBgAhqEJABIAJBgA
    hqIAEQXiACQYAEaiACQYAIahCVASACQYAEahCoASACQYAIaiACQYADahBeIAJBgAhqIAJBgARqEA8gAkGABmogAkGAAWo
    QkAEgAkGABmogAkGAAmoQlQEgAkGABmoQOiACQYAIaiACQYAGahCVASACQYABahBVIAIgAkGAAWoQlQEgACACIAJBgAVq
    EKEBIAJBgAJqEFUgAkGAAmoQqAEgAEGAA2ogAkGAAmoQkAEgAEGAAmoQqQEgAkGACGoQqAEgAkGACGoQVSAAQYAEaiIBI
    AJBgAhqIAJBgAdqEKEBIAAQrAEgARCsASAAQQQ2AoAGIAJBgAlqJAALnwgBB38jAEGgC2siASQAIAFBCGpBoKfAABBfIA
    FBCGpBARCeAQNAIAJBMEYEQCABIAEpAzhCAYc3AzggAUEIakEBEJ4BIAFBCGpBARA7QQAhAiABQYABakE4EHIaIAFB4Ap
    qQTgQchogAUGACWpBOBByGiABQQE2ArgBIAFBwAFqQTgQciEEIAFB+AFqQQE2AgAgAUGAAmpBOBByGiABQbgCakEBNgIA
    IAFBwAJqQTgQchogAUH4AmpBATYCACABQYADakE4EHIaIAFBuANqQQE2AgAgAUHAA2pBOBByGiABQfgDakEBNgIAIAFBg
    ARqQTgQchogAUG4BGpBATYCACABQcAEakE4EHIaIAFB+ARqQQE2AgAgAUGABWpBOBByGiABQbgFakEBNgIAIAFBwAVqQT
    gQchogAUH4BWpBATYCACABQYAGakE4EHIaIAFBuAZqQQE2AgAgAUHABmpBOBByGiABQfgGakEBNgIAIAFBgAdqQTgQcho
    gAUG4B2pBATYCACABQcAHakE4EHIaIAFB+AdqQQE2AgAgAUGACGogAUHgCmpBOBBnGiABQbgIakEBNgIAIAFBwAhqIAFB
    gAlqQTgQZxogAUH4CGpBATYCACABQYAJakHnABByGiABQegJaiAAEIUBIAFB6AlqEEQgAUGoCmogAUEIahBfIAFBqApqE
    EQgAUGoCmoQKUEDaiIFQQJ2IgNBAWohBgJAAkACQAJAAkACQANAAkAgAiAGRgRAIAFBgAFqEGkgBCABQegJahClASABQe
    AKakE4EHIaIAFBATYCmAtBgHkhAgwBCyABQagKaiABQagKakEEEIwBIgcQngEgAUGoCmoQRCACQecARg0CIAFBgAlqIAJ
    qIAc6AAAgAUGoCmpBBBA7IAJBAWohAgwBCwsDQCACBEAgAUHgCmogAUGAAWogAmoiBEHAB2oQpQEgBEGACGoiBCABQeAK
    ahClASAEIAFB6AlqEEggAkFAayECDAELCyAFQZwDTw0BIAFBgAlqIANqLAAAIgJBD0sNAiABQUBrIAFBgAFqIAJBBnRqE
    IUBIANBf2ohAgNAIAJBf0YNBiABQUBrEAMgAUFAaxADIAFBQGsQAyABQUBrEAMgAkHmAEsNBCABQYAJaiACai0AACIDQQ
    9LDQUgAUFAayABQYABaiADQQZ0ahBIIAJBf2ohAgwACwALQecAQecAQYSjwAAQPAALIANB5wBBlKPAABA8AAsgAkEQQaS
    jwAAQPAALIAJB5wBBtKPAABA8AAsgA0EYdEEYdUEQQcSjwAAQPAALIAFBQGsQEiAAIAFBQGsQpQEgAUGgC2okAAUgAUEI
    aiACaiIDIANBCGopAwBCOYZCgICAgICAgIACgyADKQMAQgGHhDcDACACQQhqIQIMAQsLC8EHAhJ/BX4jAEGQAmsiBCQAI
    ABB8AAQciEPIARBMGpB4AEQchogBEEwaiEAAkADQCADQThGBEACQCAPIAQpAzAiGEL//////////wODNwMAIAFBCGohCS
    ACQQhqIQogAiEMIAEhDUF4IRBBASEGIBghFSAEQThqKQMAIhkhFwNAAkAgF0IGhiAVQjqIhCEWIBdCOochFyAGQQdGBEA
    gAUEIaiEMIAJBCGohDUEHIQBBBiEKDAELIAsgBkEBdiIFayEAIAwgBUEDdCIIayERIA0gCGshEiAEQTBqIAZBBHRqIgVB
    CGopAwAgGXwgBSkDACIVIBh8IhggFVStfCIZIBd8IBYgGHwiFSAYVK18IRcgCEFQaiETIAggEGohFCAGQQFqIQ5BACEDI
    AkhByAKIQUDQCADIBRGBEAgDyAGQQN0aiAVQv//////////A4M3AwAgDEEIaiEMIA1BCGohDSALQQFqIQsgEEF4aiEQIA
    4hBgwDCyADIBNGDQYgAEEGSw0DIARBEGogAyARaikDACAFIAhqKQMAfSIWIBZCP4cgByAIaikDACADIBJqKQMAfSIWIBZ
    CP4cQMSAEKQMQIhYgFXwiFSAWVK0gBEEYaikDACAXfHwhFyAAQX9qIQAgB0EIaiEHIAVBCGohBSADQXhqIQMMAAsACwsD
    QAJAIABBDUcEQCAKIABBAXYiBWshByACIAVBA3QiCWshCCABIAlrIQsgGSAAQQR0IARqQUBqIgVBCGopAwB9IBggBSkDA
    CIVVK19IhkgF3wgGCAVfSIYIBZ8IhcgGFStfCEVIABBAWohBkEwIQMgDCEFIA0hDgNAIAMgCUYNAiAHQQZNBEAgBCADIA
    hqKQMAIAkgDmopAwB9IhYgFkI/hyAFIAlqKQMAIAMgC2opAwB9IhYgFkI/hxAxIAQpAwAiFiAXfCIXIBZUrSAEQQhqKQM
    AIBV8fCEVIAdBf2ohByAFQQhqIQUgDkEIaiEOIANBeGohAwwBCwsgB0EHQYSewAAQPAALIA8gFjcDaCAEQZACaiQADwsg
    DyAAQQN0aiAXQv//////////A4M3AwAgFUIGhiAXQjqIhCEWIAJBCGohAiABQQhqIQEgCkEBaiEKIBVCOochFyAGIQAMA
    AsACwUgBEEgaiACIANqKQMAIhUgFUI/hyABIANqKQMAIhUgFUI/hxAxIAAgBEEoaikDADcDCCAAIAQpAyA3AwAgAEEQai
    EAIANBCGohAwwBCwsgAEEHQfSdwAAQPAALQQdBB0HkncAAEDwAC8sIAQV/IABBeGoiASAAQXxqKAIAIgNBeHEiAGohAgJ
    AAkAgA0EBcQ0AIANBA3FFDQEgASgCACIDIABqIQAgASADayIBQey4wQAoAgBGBEAgAigCBEEDcUEDRw0BQeS4wQAgADYC
    ACACIAIoAgRBfnE2AgQgASAAQQFyNgIEIAAgAWogADYCAA8LIAEgAxAVCwJAIAJBBGoiBCgCACIDQQJxBEAgBCADQX5xN
    gIAIAEgAEEBcjYCBCAAIAFqIAA2AgAMAQsCQCACQfC4wQAoAgBHBEBB7LjBACgCACACRg0BIAIgA0F4cSICEBUgASAAIA
    JqIgBBAXI2AgQgACABaiAANgIAIAFB7LjBACgCAEcNAkHkuMEAIAA2AgAPC0HwuMEAIAE2AgBB6LjBAEHouMEAKAIAIAB
    qIgA2AgAgASAAQQFyNgIEQey4wQAoAgAgAUYEQEHkuMEAQQA2AgBB7LjBAEEANgIAC0GMucEAKAIAIgIgAE8NAkHwuMEA
    KAIAIgBFDQICQEHouMEAKAIAIgNBKUkNAEH8uMEAIQEDQCABKAIAIgQgAE0EQCAEIAEoAgRqIABLDQILIAEoAggiAQ0AC
    wtBlLnBAAJ/Qf8fQYS5wQAoAgAiAEUNABpBACEBA0AgAUEBaiEBIAAoAggiAA0ACyABQf8fIAFB/x9LGws2AgAgAyACTQ
    0CQYy5wQBBfzYCAA8LQey4wQAgATYCAEHkuMEAQeS4wQAoAgAgAGoiADYCACABIABBAXI2AgQgACABaiAANgIADwtBlLn
    BAAJ/AkAgAEGAAk8EQEEfIQIgAUIANwIQIABB////B00EQCAAQQYgAEEIdmciAmtBH3F2QQFxIAJBAXRrQT5qIQILIAFB
    HGogAjYCACACQQJ0QeS3wQBqIQMCQAJAAkACQAJAQdi1wQAoAgAiBEEBIAJBH3F0IgVxBEAgAygCACIDQQRqKAIAQXhxI
    ABHDQEgAyECDAILQdi1wQAgBCAFcjYCACADIAE2AgAMAwsgAEEAQRkgAkEBdmtBH3EgAkEfRht0IQQDQCADIARBHXZBBH
    FqQRBqIgUoAgAiAkUNAiAEQQF0IQQgAiEDIAJBBGooAgBBeHEgAEcNAAsLIAIoAggiACABNgIMIAIgATYCCCABQRhqQQA
    2AgAgASACNgIMIAEgADYCCAwCCyAFIAE2AgALIAFBGGogAzYCACABIAE2AgwgASABNgIIC0GUucEAQZS5wQAoAgBBf2oi
    ADYCACAADQNBhLnBACgCACIADQFB/x8MAgsgAEEDdiICQQN0Qdy1wQBqIQACf0HUtcEAKAIAIgNBASACdCICcQRAIAAoA
    ggMAQtB1LXBACACIANyNgIAIAALIQIgACABNgIIIAIgATYCDCABIAA2AgwgASACNgIIDwtBACEBA0AgAUEBaiEBIAAoAg
    giAA0ACyABQf8fIAFB/x9LGws2AgALC9AHAgp/An4jAEEwayIIJABBJyECAkAgADUCACIMQpDOAFQEQCAMIQ0MAQsDQCA
    IQQlqIAJqIgBBfGogDEKQzgCAIg1C8LF/fiAMfKciA0H//wNxQeQAbiIEQQF0QeaowABqLwAAOwAAIABBfmogBEGcf2wg
    A2pB//8DcUEBdEHmqMAAai8AADsAACACQXxqIQIgDEL/wdcvViANIQwNAAsLIA2nIgBB4wBKBEAgAkF+aiICIAhBCWpqI
    A2nIgNB//8DcUHkAG4iAEGcf2wgA2pB//8DcUEBdEHmqMAAai8AADsAAAsCQCAAQQpOBEAgAkF+aiIFIAhBCWpqIABBAX
    RB5qjAAGovAAA7AAAMAQsgAkF/aiIFIAhBCWpqIABBMGo6AAALQScgBWshA0EBIQJBK0GAgMQAIAEoAgAiAEEBcSIGGyE
    EIABBHXRBH3VB9KrAAHEhByAIQQlqIAVqIQUCQCABKAIIQQFHBEAgASAEIAcQUw0BIAEoAhggBSADIAFBHGooAgAoAgwR
    BQAhAgwBCyABQQxqKAIAIgkgAyAGaiIGTQRAIAEgBCAHEFMNASABKAIYIAUgAyABQRxqKAIAKAIMEQUAIQIMAQsCQAJAA
    kACQCAAQQhxBEAgASgCBCEKIAFBMDYCBCABLQAgIQsgAUEBOgAgIAEgBCAHEFMNBUEAIQIgCSAGayIAIQRBASABLQAgIg
    cgB0EDRhtBA3FBAWsOAwIBAgMLQQAhAiAJIAZrIgAhCQJAAkACQEEBIAEtACAiBiAGQQNGG0EDcUEBaw4DAQABAgsgAEE
    BdiECIABBAWpBAXYhCQwBC0EAIQkgACECCyACQQFqIQIDQCACQX9qIgJFDQQgASgCGCABKAIEIAEoAhwoAhARAwBFDQAL
    QQEhAgwECyAAQQF2IQIgAEEBakEBdiEEDAELQQAhBCAAIQILIAJBAWohAgJAA0AgAkF/aiICRQ0BIAEoAhggASgCBCABK
    AIcKAIQEQMARQ0AC0EBIQIMAgsgASgCBCEHQQEhAiABKAIYIAUgAyABKAIcKAIMEQUADQEgBEEBaiEAIAEoAhwhAyABKA
    IYIQQDQCAAQX9qIgAEQCAEIAcgAygCEBEDAEUNAQwDCwsgASALOgAgIAEgCjYCBEEAIQIMAQsgASgCBCEGQQEhAiABIAQ
    gBxBTDQAgASgCGCAFIAMgASgCHCgCDBEFAA0AIAlBAWohACABKAIcIQMgASgCGCEBA0AgAEF/aiIARQRAQQAhAgwCCyAB
    IAYgAygCEBEDAEUNAAsLIAhBMGokACACC7gGAQV/IwBBgAhrIgIkACACIAAQXiACIAEQDyACQYABaiAAQYABaiIDEF4gA
    kGAAWogAUGAAWoiBRAPIAJBgAJqIABBgAJqIgQQXiACQYACaiABQYACaiIGEA8gAkGAA2ogABBeIAJBgANqIAMQlQEgAk
    GAA2oQqAEgAkGABGogARBeIAJBgARqIAUQlQEgAkGABGoQqAEgAkGAA2ogAkGABGoQDyACQYAEaiACEJABIAJBgARqIAJ
    BgAFqEJUBIAJBgANqIAJBgARqEH0gAkGAA2oQqAEgAkGABGogAxCQASACQYAEaiAEEJUBIAJBgARqEKgBIAJBgAVqIAUQ
    XiACQYAFaiAGEJUBIAJBgAVqEKgBIAJBgARqIAJBgAVqEA8gAkGABWogAkGAAWoQkAEgAkGABWogAkGAAmoQlQEgAkGAB
    GogAkGABWoQfSACQYAEahCoASACQYAFaiAAEJABIAJBgAVqIAQQlQEgAkGABWoQqAEgAkGABmogARBeIAJBgAZqIAYQlQ
    EgAkGABmoQqAEgAkGABWogAkGABmoQDyACQYAGaiACEJABIAJBgAZqIAJBgAJqEJUBIAJBgAZqIAJBgAVqELUBIAJBgAZ
    qEKgBIAJBgAVqIAIQkAEgAkGABWogAhCVASACIAJBgAVqEJUBIAIQqAEgAkGAAmpBDBCfASACQYACahBVIAJBgAJqEKgB
    IAJBgAdqIAJBgAFqEF4gAkGAB2ogAkGAAmoQlQEgAkGAB2oQqAEgAkGAAWogAkGAAmoQfSACQYABahCoASACQYAGakEME
    J8BIAJBgAZqEFUgAkGABmoQqAEgAkGABWogAkGABmoQkAEgAkGABWogAkGABGoQDyACQYACaiACQYADahCQASACQYACai
    ACQYABahAPIAJBgAVqIAJBgAJqELUBIAJBgAZqIAIQDyACQYABaiACQYAHahAPIAJBgAZqIAJBgAFqEJUBIAIgAkGAA2o
    QDyACQYAHaiACQYAEahAPIAJBgAdqIAIQlQEgACACQYAFahCQASAAEKgBIAMgAkGABmoQkAEgAxCoASAEIAJBgAdqEJAB
    IAQQqAEgAkGACGokAAv2BQEFfyMAQYAEayICJAAgAiAAEIUBIAIgARBIIAJBQGsgAEFAayIDEIUBIAJBQGsgAUFAayIFE
    EggAkGAAWogAEGAAWoiBBCFASACQYABaiABQYABaiIGEEggAkHAAWogABCFASACQcABaiADEHggAkHAAWoQRCACQYACai
    ABEIUBIAJBgAJqIAUQeCACQYACahBEIAJBwAFqIAJBgAJqEEggAkGAAmogAhClASACQYACaiACQUBrEHggAkHAAWogAkG
    AAmoQgAEgAkHAAWoQRCACQYACaiADEKUBIAJBgAJqIAQQeCACQYACahBEIAJBwAJqIAUQhQEgAkHAAmogBhB4IAJBwAJq
    EEQgAkGAAmogAkHAAmoQSCACQcACaiACQUBrEKUBIAJBwAJqIAJBgAFqEHggAkGAAmogAkHAAmoQgAEgAkGAAmoQRCACQ
    cACaiAAEKUBIAJBwAJqIAQQeCACQcACahBEIAJBgANqIAEQhQEgAkGAA2ogBhB4IAJBgANqEEQgAkHAAmogAkGAA2oQSC
    ACQYADaiACEKUBIAJBgANqIAJBgAFqEHggAkGAA2ogAkHAAmoQswEgAkGAA2oQRCACQcACaiACEKUBIAJBwAJqIAIQeCA
    CIAJBwAJqEHggAhBEIAJBgAFqQQwQUiACQcADaiACQUBrEIUBIAJBwANqIAJBgAFqEHggAkHAA2oQRCACQUBrIAJBgAFq
    EIABIAJBQGsQRCACQYADakEMEFIgAkHAAmogAkGAA2oQpQEgAkHAAmogAkGAAmoQSCACQYABaiACQcABahClASACQYABa
    iACQUBrEEggAkHAAmogAkGAAWoQswEgAkGAA2ogAhBIIAJBQGsgAkHAA2oQSCACQYADaiACQUBrEHggAiACQcABahBIIA
    JBwANqIAJBgAJqEEggAkHAA2ogAhB4IAAgAkHAAmoQpQEgABBEIAMgAkGAA2oQpQEgAxBEIAQgAkHAA2oQpQEgBBBEIAJ
    BgARqJAALxQUBBH8jAEHwEmsiACQAIAAQOEF/IQEgABCIAUUEQCAAQYADakE4EHIaIABBuANqQTgQchogAEG4A2ogAEGA
    A2oQVCAAQfAKakG4gMAAEF8gAEHwDWpB8IDAABBfIABB8ANqIABB8ApqIABB8A1qEEkgAEHwBGpBOBByGiAAQQE2AqgFI
    ABBsAVqQTgQchogAEHoBWpBATYCACAAQfAFakE4EHIaIABBATYCqAYgAEGwBmpBOBByGiAAQegGakEBNgIAIABB8AZqQT
    gQchogAEEBNgKoByAAQbAHakE4EHIaIABB6AdqQQE2AgBBf2ohAyAAQfAHahAqIABB8AdqIAAQfiAAQfAKahAqIABB8Ap
    qIABB8AdqEH4gAEHwDWoQKiAAQfANaiAAQfAHahB+IABB8A1qEJwBAkACQAJAA0AgAiEBIANBAkkNAyAAQfAKaiAAQfAE
    aiAAQfAFaiAAQfAGahAlIAFBxABNBEAgAEHwEGogAEHwBGogAEHwBWogAEHwBmoQRiABQQh0QdCrwABqIABB8BBqEJIBI
    AFBAWohAgJAAkAgAEG4A2ogA0F/aiIDEFcgAEGAA2ogAxBXa0EBag4DAQMAAwsgAEHwCmogAEHwB2ogAEHwBGogAEHwBW
    ogAEHwBmoQHiABQcMASw0DIABB8BBqIABB8ARqIABB8AVqIABB8AZqEEYgAkEIdEHQq8AAaiAAQfAQahCSASABQQJqIQI
    MAgsgAEHwCmogAEHwDWogAEHwBGogAEHwBWogAEHwBmoQHiABQcMASw0DIABB8BBqIABB8ARqIABB8AVqIABB8AZqEEYg
    AkEIdEHQq8AAaiAAQfAQahCSASABQQJqIQIMAQsLIAFBxQBBvIHAABA8AAtBxQBBxQBBzIHAABA8AAtBxQBBxQBB3IHAA
    BA8AAtBACEBCyAAQfASaiQAIAEL8gQBBH8jAEGADGsiAiQAIAIgABCOASACQYACahAvIAJBgARqIABBgAJqIgMQjgEgAk
    GABmoQLyACQYAIaiAAEI4BIAJBgApqIAEQjgEgAiABEBkgAkGABGogAUGAAmoiBBAZIAJBgAhqIAMQlgEgAkGACmogBBC
    WASACQYAIahCsASACQYAKahCsASACQYACaiACQYAIahCSASACQYACaiACQYAKahAZIAJBgAhqIAMQkgEgAkGACGogAEGA
    BGoiBRCWASACQYAKaiAEEJIBIAJBgApqIAFBgARqIgQQlgEgAkGACGoQrAEgAkGACmoQrAEgAkGABmogAkGACGoQkgEgA
    kGABmogAkGACmoQGSACQYAIaiACEJIBIAJBgAhqECsgAkGACmogAkGABGoQkgEgAkGACmoQKyACQYACaiACQYAIahCWAS
    ADIAJBgAJqEJIBIAMgAkGACmoQlgEgAkGABmogAkGACmoQlgEgAkGABGogAkGACGoQlgEgAkGACGogABCSASACQYAIaiA
    FEJYBIAJBgAhqEKwBIAJBgApqIAEQkgEgAkGACmogBBCWASACQYAKahCsASACQYAIaiACQYAKahAZIAJBgARqIAJBgAhq
    EJYBIAJBgAhqIAUQkgEgAkGACGogBBAZIAJBgApqIAJBgAhqEJIBIAJBgApqECsgBSACQYAEahCSASAFIAJBgApqEJYBI
    AJBgAZqIAJBgApqEJYBIAJBgAhqEGYgAyACQYAIahCWASACQYAGahCsASACQYAGahBmIAAgAhCSASAAIAJBgAZqEJYBIA
    BBBTYCgAYgABCZASACQYAMaiQAC68EAQV/IwBBkAZrIgIkACAAQUBrIQQCQCABQfgAaigCACABKAI4aqwgAEH4AGooAgA
    iAyAAKAI4IgVqrH5CgICAEFMNACAFQQJOBH8gABASIAAoAngFIAMLQQJIDQAgBBASCyACQaCnwAAQX0EAIQMgAkE4akHw
    ABByGiABQUBrIQUDQCADQThGBEAgAkHwAGohBkEAIQMDQCADQThGRQRAIAMgBmogAiADaikDADcDACADQQhqIQMMAQsLI
    AJBqAFqIAAQXyACQeABaiABEF8gAkGYAmogACABEAggAkGIA2ogBCAFEAggAkGoAWogBBBhIAJBqAFqEEQgAkHgAWogBR
    BhIAJB4AFqEEQgAkH4A2ogAkGoAWogAkHgAWoQCEEAIQMgAkHoBGpB8AAQchoDQCADQfAARkUEQCACQegEaiADaiACQZg
    CaiADaikDADcDACADQQhqIQMMAQsLIAJB6ARqIAJBiANqEGVBACEDA0AgA0HwAEZFBEAgAkGIA2ogA2oiASACQThqIANq
    KQMAIAEpAwB9NwMAIANBCGohAwwBCwsgAkGYAmogAkGIA2oQZSACQZgCahBFIAJB+ANqIAJB6ARqEGQgAkH4A2oQRSACQ
    dgFaiACQZgCahAFIAAgAkHYBWoQayAAQQM2AjggAkHYBWogAkH4A2oQBSAEIAJB2AVqEGsgAEECNgJ4IAJBkAZqJAAFIA
    JBOGogA2pCADcDACADQQhqIQMMAQsLC5QEAQF/IwBB0CJrIgMkACADQcAWakG4gMAAEF8gA0HIHGpB8IDAABBfIANBCGo
    gA0HAFmogA0HIHGoQSSADQYgBakE4EHIaIANBwAFqQTgQchogA0H4AWoQKgJAIAIQhAFFBEAgA0H4BGoQKiADQfgEaiAB
    EH4gA0H4BGoQSiADQfgHahBLIANB+AdqIAIQfyADQfgHahBHIANByBxqIANB+AdqEIUBIANBuAlqIANByBxqEIUBIANBy
    BxqIANBuAhqEIUBIANB+AlqIANByBxqEIUBIANBuApqECogA0G4DWoQYCADQbgKaiADQfgEahB+IANBwBNqECogA0HAE2
    ogA0H4BGoQfiADQcATahCcASADQcABaiADQYgBahBUQX9qIQIDQCACQQFNBEAgA0G4DWoQkwEgACADQbgNakGIBhBnGgw
    DBSADQbgNahAbIANBwBZqIANBuApqIANBuAlqIANB+AlqEBcCQAJAAkAgA0HAAWogAkF/aiICEFcgA0GIAWogAhBXa0EB
    ag4DAQIAAgsgA0HIHGogA0G4CmogA0H4BGogA0G4CWogA0H4CWoQFiADQcAWaiADQcgcahAGDAELIANByBxqIANBuApqI
    ANBwBNqIANBuAlqIANB+AlqEBYgA0HAFmogA0HIHGoQBgsgA0G4DWogA0HAFmoQBAwBCwALAAsgABBgCyADQdAiaiQAC8
    MDARV/A0AgAUHAAUYEQAJAIABBKGohCyAAQRRqKAIAIgwhCCAAQRBqKAIAIg0hAyAAQQxqKAIAIg4hAiAAKAIIIg8hASA
    AQRhqKAIAIhAhCiAAQRxqKAIAIhEhBCAAQSBqKAIAIhIhByAAQSRqKAIAIhMhBgNAIAchCSAEIQcgCiEEIAVBgAJGDQEg
    AiADcSEUIAIgA3MhFSAFIAtqKAIAIAVB9J7AAGooAgAgBEEadyAEQRV3cyAEQQd3cyAGaiAJIARBf3NxIAQgB3FyampqI
    gYgCGohCiAFQQRqIQUgAyEIIAIhAyABIQIgAUEedyABQRN3cyABQQp3cyAUIAEgFXFzaiAGaiEBIAkhBgwACwALBSAAIA
    FqIgNB6ABqIANBzABqKAIAIANBKGooAgAgA0EsaigCACICQRl3IAJBDndzIAJBA3ZzIANB4ABqKAIAIgJBD3cgAkENd3M
    gAkEKdnNqamo2AgAgAUEEaiEBDAELCyAAIAYgE2o2AiQgACAJIBJqNgIgIAAgByARajYCHCAAIAQgEGo2AhggACAIIAxq
    NgIUIAAgAyANajYCECAAIAIgDmo2AgwgACABIA9qNgIIC9YDAgZ/An4jAEHwAGsiASQAIAFBoKfAABBfIAFBOGogARBfI
    AAQRAJAAkACQCABAn8gACgCOCICQRBMBEAgAkF/ahA5DAELIAEpAzAiCEIBfCIHIAhUDQEgACkDMCIIQoCAgICAgICAgH
    9RQQAgB0J/URsNAiABQThqIAggB3+nECghByABIAEpA2ggB0I6hnw3A2ggACABQThqEGIgABBEQQILIgMQLSAAQQhqIQQ
    DQCADRQ0DIAEgASkDCEI5hkKAgICAgICAgAKDIAEpAwBCAYeEIgc3AwAgASAAKQMAIAd9IgdC//////////8DgzcDOEEA
    IQIDQCAHQjqHIQcgAkEoRkUEQCABIAJqIgVBCGoiBiAFQRBqKQMAQjmGQoCAgICAgICAAoMgBikDAEIBh4QiCDcDACABI
    AJqQUBrIAIgBGopAwAgCH0gB3wiB0L//////////wODNwMAIAJBCGohAgwBCwsgASABKQMwQgGHIgg3AzAgASAAKQMwIA
    h9IAd8Igc3A2ggACABQThqIAdCP4enQQFqEE8gA0F/aiEDDAALAAtBoKLAAEEZQbyiwAAQWwALQdCiwABBH0G8osAAEFs
    ACyAAQQE2AjggAUHwAGokAAuhAwEBfyMAQZADayIGJAAgBkEIakHAABByGiAGQcgAakGoAhByGiAGQcgAahBDA0AgAQRA
    IAZByABqQQAQPiABQX9qIQEMAQUCQCACBEAgBkHIAGogAiADEHoLIAQEQCAGQcgAaiAEIAUQegsgBkGIA2pCADcDACAGQ
    YADakIANwMAIAZB+AJqQgA3AwAgBkIANwPwAiAGKAJIIQEgBigCTCECIAZByABqQYABED4DQCAGKAJIQf8DcUHAA0ZFBE
    AgBkHIAGpBABA+DAELCyAGQawBaiABNgIAIAZBqAFqIAI2AgAgBkHIAGoQEUEAIQJBACEBA0AgAUEgRkUEQCAGQfACaiA
    BaiABQXxxIAZqQdAAaigCACACQX9zQRhxdjoAACACQQhqIQIgAUEBaiEBDAELCyAGQcgAahBDQQAhAQNAIAFBIEZFBEAg
    BkEIaiABaiAGQfACaiABai0AADoAACABQQFqIQEMAQsLQQAhAQNAIAFBIEYNASAAIAFqIAZBCGogAWotAAA6AAAgAUEBa
    iEBDAALAAsLCyAGQZADaiQAC6EDAQN/IwBBgAZrIgEkACABIABBgAFqIgMQXiABQYABaiADEF4gAUGAAWoQMiABQYACai
    ABEF4gAUGAAmogAEGAAmoiAhAPIAFBgANqIAIQXiABQYADahAyIAIgAUGAAWoQkAEgAiABQYABahCVASACEKgBIAIQpwE
    gAhCnASACEKgBIAFBgANqQQwQnwEgAUGAA2oQVSABQYADahCoASABQYAEaiABQYADahBeIAFBgARqIAIQDyABQYAFaiAB
    QYABahBeIAFBgAVqIAFBgANqEJUBIAFBgAVqEKgBIAIgAUGAAmoQDyABQYACaiABQYADahCQASABQYACaiABQYADahCVA
    SABQYADaiABQYACahCVASABQYADahCoASABQYABaiABQYADahB9IAFBgAFqEKgBIAFBgAVqIAFBgAFqEA8gAUGABWogAU
    GABGoQlQEgAUGAAmogABCQASABQYACaiABEA8gACABQYABahCQASAAEKgBIAAgAUGAAmoQDyAAEKcBIAAQqAEgAyABQYA
    FahCQASADEKgBIAFBgAZqJAALhQMBBH8CQAJAIAFBgAJPBEAgAEEYaigCACEEAkACQCAAIAAoAgwiAkYEQCAAQRRBECAA
    QRRqIgIoAgAiAxtqKAIAIgENAUEAIQIMAgsgACgCCCIBIAI2AgwgAiABNgIIDAELIAIgAEEQaiADGyEDA0AgAyEFIAEiA
    kEUaiIDKAIAIgFFBEAgAkEQaiEDIAIoAhAhAQsgAQ0ACyAFQQA2AgALIARFDQIgACAAQRxqKAIAQQJ0QeS3wQBqIgEoAg
    BHBEAgBEEQQRQgBCgCECAARhtqIAI2AgAgAkUNAwwCCyABIAI2AgAgAg0BQdi1wQBB2LXBACgCAEF+IAAoAhx3cTYCAA8
    LIABBDGooAgAiAiAAQQhqKAIAIgBHBEAgACACNgIMIAIgADYCCA8LQdS1wQBB1LXBACgCAEF+IAFBA3Z3cTYCAAwBCyAC
    IAQ2AhggACgCECIBBEAgAiABNgIQIAEgAjYCGAsgAEEUaigCACIARQ0AIAJBFGogADYCACAAIAI2AhgLC7MCAQF/IwBBg
    AtrIgUkACAFEC8gBUGAAmoQLyAFQYAEahAvIAVBgAZqQTgQchogBUEBNgK4BiAFQcAGakE4EHIaIAVB+AZqQQE2AgAgBU
    GAB2pBOBByGiAFQQE2ArgHIAVBwAdqQTgQchogBUH4B2pBATYCACAFQYAIakE4EHIaIAVBATYCuAggBUHACGpBOBByGiA
    FQfgIakEBNgIAIAEgAiAFQYAGaiAFQYAHaiAFQYAIahAeIAVBgAhqIAMQoAEgBUGABmogBBCgASAFQYAJaiAFQYAGaiAF
    QYAHahCRASAFIAVBgAlqEJIBIAVBgAlqIAVBgAhqEJsBIAVBgARqIAVBgAlqEJIBIAVBgARqEGYgACAFIAVBgAJqIAVBg
    ARqEHYgAEEDNgKABiAFQYALaiQAC7ECAQF/IwBBgAtrIgQkACAEEC8gBEGAAmoQLyAEQYAEahAvIARBgAZqQTgQchogBE
    EBNgK4BiAEQcAGakE4EHIaIARB+AZqQQE2AgAgBEGAB2pBOBByGiAEQQE2ArgHIARBwAdqQTgQchogBEH4B2pBATYCACA
    EQYAIakE4EHIaIARBATYCuAggBEHACGpBOBByGiAEQfgIakEBNgIAIAEgBEGABmogBEGAB2ogBEGACGoQJSAEQYAIaiAC
    EKABIARBgAZqIAMQoAEgBEGACWogBEGABmogBEGAB2oQkQEgBCAEQYAJahCSASAEQYAJaiAEQYAIahCbASAEQYAEaiAEQ
    YAJahCSASAEQYAEahBmIAAgBCAEQYACaiAEQYAEahB2IABBAzYCgAYgBEGAC2okAAvJAgEDfyMAQcACayIBJAAgASAAQU
    BrIgMQhQEgARADIAFBQGsgAxCFASABQUBrIABBgAFqIgIQSCABQYABaiACEIUBIAFBgAFqEAMgAiABEKUBIAIgARB4IAI
    QRCACEE4gAhBOIAIQRCABQYABakEMEFIgAUHAAWogAUGAAWoQhQEgAUHAAWogAhBIIAFBgAJqIAEQhQEgAUGAAmogAUGA
    AWoQeCABQYACahBEIAIgAUFAaxBIIAFBQGsgAUGAAWoQpQEgAUFAayABQYABahB4IAFBgAFqIAFBQGsQeCABIAFBgAFqE
    IABIAEQRCABQYACaiABEEggAUGAAmogAUHAAWoQeCABQUBrIAAQpQEgAUFAayADEEggACABEKUBIAAQRCAAIAFBQGsQSC
    AAEE4gABBEIAMgAUGAAmoQpQEgAxBEIAFBwAJqJAALrQIBA38jAEGABGsiAiQAIAIgABBeIAJBgAFqIABBgAFqIgMQXiA
    CQYACakE4EHIaIAJBATYCuAIgAkHAAmpBOBByGiACQfgCakEBNgIAIAJBgANqIAMQXiACIAEQDyACQYABaiABQYABaiIE
    EA8gAkGAAmogBBCQASACQYACaiABEJUBIAJBgANqIAAQlQEgAkGAAmoQqAEgAkGAA2oQqAEgAkGAA2ogAkGAAmoQDyACQ
    YACaiACEJABIAJBgAJqEDogAkGAA2ogAkGAAmoQlQEgAkGAA2oQqAEgAkGAAmogAkGAAWoQkAEgAkGAAmoQOiADIAJBgA
    NqEJABIAMgAkGAAmoQlQEgAkGAAWoQVSAAIAJBgAFqEJABIAAgAhCVASAAEKwBIAJBgARqJAALvQIBA38jAEGACGsiASQ
    AIAEgABCOASABQYACaiAAQYAEaiICEI4BIAFBgARqIABBgAJqIgMQjgEgAUGABmoQLyAAECIgAUGABmogABCSASABQYAG
    aiAAEJYBIAAgAUGABmoQlgEgABCsASABELYBIAEQrwEgACABEJYBIAFBgAJqECIgAUGAAmoQZiABQYAGaiABQYACahCSA
    SABQYAGaiABQYACahCWASABQYACaiABQYAGahCWASABQYACahCsASABQYAEahAiIAFBgAZqIAFBgARqEJIBIAFBgAZqIA
    FBgARqEJYBIAFBgARqIAFBgAZqEJYBIAFBgARqEKwBIAMQrgEgAxCvASACELYBIAIQrwEgAyABQYACahCWASACIAFBgAR
    qEJYBIABBBTYCgAYgABCaASABQYAIaiQAC7ICAQN/IwBBgAhrIgEkACAAKAKABkEBRwRAIAEgABCOASABQYACaiAAQYAC
    aiIDEI4BIAFBgARqIABBgARqIgIQjgEgAUGABmogABCOASABECIgAUGAAmogAhAZIAFBgAJqEK8BIAFBgAJqEKwBIAFBg
    ARqECIgAUGABmogAxAZIAFBgAZqEK8BIAIgABCWASACIAMQlgEgAhCsASACECIgACABEJIBIAEgAUGAAmoQlgEgARCsAS
    ABIAFBgARqEJYBIAEgAUGABmoQlgEgARCsASABECsgAUGAAmoQZiABQYAEahBmIAAgAUGAAmoQlgEgAyABQYAEahCSASA
    DIAFBgAZqEJYBIAIgARCWASAAQQRBBSAAKAKABkF+cUECRhs2AoAGIAAQmQELIAFBgAhqJAALigIBAn8jAEHgAWsiAiQA
    IAAQRCACQQhqQTAQchogAkIBNwMAIAJBOGogABBfIAJB8ABqIAEQXyACQagBakE4EHIaIAAQdANAIAJBOGogAkHwAGoQN
    UF/TARAA0ACQCADQQBMDQAgAkHwAGpBARA7IAJBARA7IAJBqAFqIAJBOGoQayACQagBaiACQfAAahBiIAJBqAFqEEQgAk
    E4aiACQagBaiACKQPYAUI/h6dBAWoiARBPIAJBqAFqIAAQayACQagBaiACEGEgAkGoAWoQRCAAIAJBqAFqIAEQTyADQX9
    qIQMMAQsLBSACQQEQLSACQfAAakEBEC0gA0EBaiEDDAELCyACQeABaiQAC54CAQF/IwBBgA1rIgMkACADIAEQaiADEJkB
    IANBiAZqIAIQXyADQYgGahBEIANBwAZqIANBiAZqEF8gA0HABmpBAxAoGiADQcAGahBEIANB+AZqIAMQagJAIANBwAZqE
    FpFBEAgA0HABmoQKUF/aiECA0AgAkEBTQRAIANB+AZqEJoBDAMLIANB+AZqEBoCQAJAIANBwAZqIAJBf2oiAhBXIANBiA
    ZqIAIQV2tBAWoOAwECAAILIANB+AZqIAMQDgwBCyADEJMBIANB+AZqIAMQDiADEJMBDAALAAsgA0H4BmoQsAEgA0H4B2o
    QqQEgA0H4CGoQrQEgA0H4CmoQrQEgA0EBNgL4DAsgACADQfgGakGIBhBnGiADQYANaiQAC5ACAQJ/IwBBgAJrIgUkACAF
    QYABaiAAEF4gAiAFQYABahCQASAFQYABaiAAQYABahBeIAQgBUGAAWoQkAEgBUGAAWogAEGAAmoiBhBeIAUgBUGAAWoQX
    iAFQYABaiAGEF4gAyAFQYABahCQASAFQYABaiABQYABaiIGEF4gBSAFQYABahAPIAVBgAFqIAEQXiADIAVBgAFqEA8gAi
    ADEH0gAhCoASAEIAUQfSAEEKgBIAUgAhCQASACEFUgAhCoASAFQYABaiAGEF4gBSAFQYABahAPIAMgBBCQASAFQYABaiA
    BEF4gAyAFQYABahAPIAMgBRB9IAMQqAEgBBA6IAQQqAEgACABEAsgBUGAAmokAAvkAQECfyMAQcABayIDJAAgAxBLIAAg
    ASACQR91IgQgAnMgBEF/c2pBAm0iAkF/akEfdhBtIAAgAUHAAWogAkEBc0F/akEfdhBtIAAgAUGAA2ogAkECc0F/akEfd
    hBtIAAgAUHABGogAkEDc0F/akEfdhBtIAAgAUGABmogAkEEc0F/akEfdhBtIAAgAUHAB2ogAkEFc0F/akEfdhBtIAAgAU
    GACWogAkEGc0F/akEfdhBtIAAgAUHACmogAkEHc0F/akEfdhBtIAMgABB/IAMQpgEgACADIARBAXEQbSADQcABaiQAC+Q
    BAQJ/IwBBgANrIgMkACADECogACABIAJBH3UiBCACcyAEQX9zakECbSICQX9qQR92EG8gACABQYADaiACQQFzQX9qQR92
    EG8gACABQYAGaiACQQJzQX9qQR92EG8gACABQYAJaiACQQNzQX9qQR92EG8gACABQYAMaiACQQRzQX9qQR92EG8gACABQ
    YAPaiACQQVzQX9qQR92EG8gACABQYASaiACQQZzQX9qQR92EG8gACABQYAVaiACQQdzQX9qQR92EG8gAyAAEH4gAxCcAS
    AAIAMgBEEBcRBvIANBgANqJAALvAEBAn8jAEGwAWsiAiQAIAJBMBByIQIDQCADQTBGBEACQCABQTBqIQEgAkEwaiACEHV
    BACEDA0AgA0EwRg0BIAIgA2ogASADai0AADoAACADQQFqIQMMAAsACwUgAiADaiABIANqLQAAOgAAIANBAWohAwwBCwsg
    AkHwAGogAhB1IABBOBByIgBBATYCOCAAQUBrQTgQciAAQfgAakEBNgIAIAAgAkHwAGoQpQEgAkEwahClASACQbABaiQAC
    9QBAQJ/IwBBgANrIgEkACABIAAQXiABQYABaiAAQYABaiICEF4gAUGAAmogABBeIAFBgAJqIAIQDyABIAIQlQEgAUGAAW
    oQVSABQYABaiAAEJUBIAEQqAEgAUGAAWoQqAEgACABEJABIAAgAUGAAWoQDyABQYABaiABQYACahCQASABQYABahBVIAF
    BgAFqIAFBgAJqEJUBIAFBgAFqEKgBIAFBgAFqEDogACABQYABahCVASABQYACahCnASACIAFBgAJqEJABIAAQrAEgAUGA
    A2okAAvEAQEBfyMAQYADayIDJAAgA0EIaiABEIUBAkAgAkUEQCADQQhqEAcMAQsgA0EIaiACEKUBCyADQcgAakHYo8AAE
    F8gA0GAAWogA0HIAGoQiwEgA0HAAWogA0EIahCFASADQcABahADIANBwAFqIAEQSCAAIAEQhQEgACADQQhqEEggA0GAAm
    ogA0HAAWoQhQEgABBYIQEgA0HAAmogABCFASADQcACahBBIANBwAJqEEQgACADQcACaiABEHkgA0GAA2okAAufAQEBfyM
    AQfAAayICJAAgAiABEF9BACEBIAJBOGpBOBByGiAAEEQCQCAAIAIQNUEASA0AA0AgAkEBEC0gAUEBaiEBIAAgAhA1QX9K
    DQALA0AgAUEATA0BIAJBARA7IAJBOGogABBrIAJBOGogAhBiIAJBOGoQRCAAIAJBOGogAikDaEI/h6dBAWoQTyABQX9qI
    QEMAAsACyACQfAAaiQAC7IBAQF/IwBBgAJrIgQkACAEQYABaiAAEF4gAyAEQYABahCQASAEQYABaiAAQYABahBeIAQgBE
    GAAWoQXiAEQYABaiAAQYACahBeIAIgBEGAAWoQkAEgASAEEJABIAEgAhAPIAMQMiAEEDIgAhAyIAEQpwEgARA6IAEQqAE
    gARBVIAEQqAEgAkEMEJ8BIANBAxCfASACEFUgAhCoASACIAQQfSACEKgBIAAQFCAEQYACaiQAC58BAQJ/IwBBgAJrIgIk
    ACAAIAEQXiAAEDIgAkGIAWpB2KTAABBfIAJBCGpBOBByGiACQQE2AkAgAkHIAGpBOBByIAJBgAFqQQE2AgAgAkHAAWogA
    kGIAWoQiwEgAkEIaiACQcABahClARCyASACQQhqEKgBIAJBCGoQVSACQQhqEKgBIAAgARAPIAAgAkEIahCVASAAEKsBIA
    JBgAJqJAALowEBAX8jAEEwayIGJAAgBkEQaiAAIAEQsQEgBiAGKAIUIgA2AhwgBiAGKAIQIgE2AhggBkEIaiACIAMQsQE
    gBiAGKAIMIgI2AiQgBiAGKAIIIgM2AiAgBiAEIAUQsQEgBiAGKAIEIgQ2AiwgBiAGKAIAIgU2AiggASAAIAMgAiAFIAQQ
    ACAGQShqEKQBIAZBIGoQpAEgBkEYahCkASAGQTBqJAALiAECA38DfiMAQRBrIgIkAAN+IANBOEYEfiACQRBqJAAgBgUgA
    iAAIANqIgQpAwAiBSAFQj+HIAGsIgUgBUI/hxAxIAQgAikDACIHIAZ8IgVC//////////8DgzcDACAFIAdUrSACQQhqKQ
    MAIAZCP4d8fEIGhiAFQjqIhCEGIANBCGohAwwBCwsLhAECA38BfiMAQUBqIgEkACABQQhqIAAQXyABQQhqEEQgAUE4aiE
    CQQYhA0HcAiEAAn8DQEEAIANBAEgNARogAikDACIEUARAIAJBeGohAiAAQUZqIQAgA0F/aiEDDAELCwN/IARQBH8gAAUg
    AEEBaiEAIARCAn8hBAwBCwsLIAFBQGskAAuHAQEBfyMAQcABayIBJAAgAEE4EHIiAEEBNgI4IABBQGtBOBByGiAAQfgAa
    kEBNgIAIAEQUCABQYgBakE4EHIaIABBgAFqIAFBgAEQZxogAEGAAmpBOBByGiAAQbgCakEBNgIAIABBvAJqIAFBhAFqQT
    wQZxogAEH4AmpBATYCACABQcABaiQAC48BAQJ/IwBBgAJrIgEkACAAEKwBIAEgABBeIAFBgAFqQTgQchogAUEBNgK4ASA
    BQcABakE4EHIaIAFB+AFqQQE2AgAgASAAQYABaiICEJUBIAEQOiABQYABaiABEJABIAFBgAFqIAIQlQEgAiABEJABIAIg
    ABCVASAAIAFBgAFqEJABIAAQrAEgAUGAAmokAAt9AgF/An4jAEGAAWsiASQAIAFBCGogABCFASABQQhqEBIgAUHIAGogA
    UEIahCDAUEIIQADQCAAQThGRQRAIAFByABqIABqKQMAIAKEIQIgAEEIaiEADAELCyABKQNIIQMgAUGAAWokACACQn98IA
    NCAYVCf3yDQjqIp0EBcQuJAQIBfwJ+IAAgACkDMCABQT9xrSIDhiAAKQMoQTogAWtBP3GtIgSHhDcDMCAAQShqIQFBBiE
    CA0AgAkEBTQRAIAAgACkDACADhkL//////////wODNwMABSABIAEpAwAgA4ZC//////////8DgyABQXhqIgEpAwAgBIeE
    NwMAIAJBf2ohAgwBCwsLiQECAX8CfiAAIAApA2BBOiABQTpwIgFrrSIEhyAAKQNoIAGtIgOGhDcDaCAAQeAAaiEBQQ0hA
    gNAIAJBAU0EQCAAIAApAwAgA4ZC//////////8DgzcDAAUgASABKQMAIAOGQv//////////A4MgAUF4aiIBKQMAIASHhD
    cDACACQX9qIQIMAQsLC3EBAX8jAEFAaiIBJAAgAEE4EHIiAEEBNgI4IABBQGtBOBByGiAAQfgAakEBNgIAIAFBCGpBOBB
    yGiAAQYABakE4EHIaIABBuAFqQQE2AgAgAEG8AWogAUEEakE8EGcaIABB+AFqQQE2AgAgAUFAayQAC4EBAgF/AX4gAEHw
    ABByIQADQCACQThGBEACQCAAIAEpAzAiA0I6hzcDOCAAIANC//////////8DgzcDMCAAQUBrIQBBACECA0AgAkEwRg0BI
    AAgAmpCADcDACACQQhqIQIMAAsACwUgACACaiABIAJqKQMANwMAIAJBCGohAgwBCwsLdQECfiAAIANCIIgiBSABQiCIIg
    Z+IAIgA358IAEgBH58IANC/////w+DIgIgAUL/////D4MiAX4iA0IgiCACIAZ+fCICQiCIfCABIAV+IAJC/////w+DfCI
    BQiCIfDcDCCAAIANC/////w+DIAFCIIaENwMAC3YBAn8jAEHAAWsiASQAIAEgABCFASABQUBrIAAQhQEgAUGAAWogAEFA
    ayICEIUBIAEgAhB4IAFBQGsgABB4IAFBQGsQRCACIAFBQGsQSCABQYABahBBIAAgAUGAAWoQeCABEEQgABBEIAAgARBII
    AFBwAFqJAALkwEBAn9B0LXBAEHQtcEAKAIAQQFqNgIAAkACQEGYucEAKAIAQQFGBEBBnLnBAEGcucEAKAIAQQFqIgA2Ag
    AgAEECSw0CQaC5wQAoAgAiAUF/Sg0BDAILQZi5wQBCgYCAgBA3AwBBoLnBACgCACIAQQBIDQFBoLnBACAANgIAAAtBoLn
    BACABNgIAIABBAUsNAAALAAtnAQJ/IwBBQGoiAiQAIAAQRCACIAAQhQECQCABRQRAIAAQBwwBCyAAIAEQpQELQQAhAQNA
    IAFBAUsgA3JFBEAgABADIAFBAEchAyABIAFFaiEBDAELCyAAIAIQSCAAEBIgAkFAayQAC18CAX8EfkIBIQNBMCECA38gA
    kF4RgR/IARCAYYgA3ynQX9qBSABIAJqKQMAIgUgACACaikDACIGfUI6hyADgyAEhCEEIAJBeGohAiAFIAaFQn98QjqHIA
    ODIQMMAQsLC2ACAX8EfkIBIQNB6AAhAgN/IAJBeEYEfyAEQgGGIAN8p0F/agUgASACaikDACIFIAAgAmopAwAiBn1COoc
    gA4MgBIQhBCACQXhqIQIgBSAGhUJ/fEI6hyADgyEDDAELCwt3AQN/IwBBgAJrIgIkACACIAEQXiACQYABaiABEF4gAhAy
    IAJBgAFqIAIQDyAAIAJBgAFqEJcBIABBgAJqIgMgAkGAAWoQlwEgAEGABGoiBCACQYABahCXASADIAEQogEgBCACEKIBI
    ABBBTYCgAYgAkGAAmokAAt6AQF/IwBB4ANrIgEkACABQYABakHApcAAEF8gAUG4AWpB+KXAABBfIAEgAUGAAWogAUG4AW
    oQSSABQfACakGwpsAAEF8gAUGoA2pB6KbAABBfIAFB8AFqIAFB8AJqIAFBqANqEEkgACABIAFB8AFqED8gAUHgA2okAAt
    nACAAQQF2IAByIgBBAnYgAHIiAEEEdiAAciIAQQh2IAByIgBBEHYgAHIiACAAQQF2QdWq1aoFcWsiAEECdkGz5syZA3Eg
    AEGz5syZA3FqIgBBBHYgAGpBj568+ABxQYGChAhsQRh2C2cBAn8jAEGAAWsiASQAIAEgABCFASABQUBrQTgQchogAUEBN
    gJ4IAEgAEFAayICEHggARBBIAFBQGsgARClASABQUBrIAIQeCACIAEQpQEgAiAAEHggACABQUBrEKUBIAFBgAFqJAALaA
    IBfwJ+IAFBP3GtIQNBOiABa0E/ca0hBEEAIQEDQCABQTBGBEAgACAAKQMwIAOHNwMwBSAAIAFqIgIgAkEIaikDACAEhkL
    //////////wODIAIpAwAgA4eENwMAIAFBCGohAQwBCwsLbAEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBHGpBAjYC
    ACADQSxqQQI2AgAgA0ICNwIMIANBlKjAADYCCCADQQI2AiQgAyADQSBqNgIYIAMgAzYCKCADIANBBGo2AiAgA0EIaiACE
    HAAC2wBAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakECNgIAIANCAjcCDCADQbCqwAA2AgggA0
    ECNgIkIAMgA0EgajYCGCADIANBBGo2AiggAyADNgIgIANBCGogAhBwAAtlAQJ/IAAgACgCACICQQhqIgM2AgAgACACQQN
    2QTxxakEoaiICIAFB/wFxIAIoAgBBCHRyNgIAAkACQCADRQRAIABBADYCACAAIAAoAgRBAWo2AgQMAQsgA0H/A3ENAQsg
    ABARCwtnAQF/IwBBgAJrIgMkACAAECogACABEJABIABBgAFqIgEgAhCQASAAQYACahCwASAAEKgBIAMgABAmIANBgAFqI
    AEQXiADQYABahAyIANBgAFqIAMQe0UEQCAAEJgBCyADQYACaiQAC18BAn8jAEGAAWsiASQAIAAQqAEgASAAEIUBIAFBQG
    sgAEFAayICEIUBIAEQAyABQUBrEAMgASABQUBrEHggAUEAEDQgACABEEggARBBIAEQRCACIAEQSCABQYABaiQAC10BAn8
    jAEFAaiIBJAAgAUEIakGgp8AAEF8gAUEIaiAAKAI4QX9qEDkiAhAtIAAgAUEIahBjIABBASACQQFqQR9xdCICNgI4IAJB
    gICAEE4EQCAAEBILIAFBQGskAAtfAgF/AX4jAEHwAGsiASQAIAFBoKfAABBfIAApAwAhAiABQThqIAAQXyAAQQEQOyABQ
    ThqIAEQYSABQThqEEQgAUE4akEBEDsgACABQThqIAJCAoGnEE8gAUHwAGokAAt7AQJ/IABBKGohAgNAIAFBgAJGBEAgAE
    LnzKfQ1tDrs7t/NwIIIABCADcCACAAQSBqQquzj/yRo7Pw2wA3AgAgAEEYakL/pLmIxZHagpt/NwIAIABBEGpC8ua746O
    n/aelfzcCAAUgASACakEANgIAIAFBBGohAQwBCwsLaQICfwF+IAAgACkDACIDQv//////////A4M3AwBBCCEBA0AgA0I6
    hyEDIAFBMEYEQCAAIAApAzAgA3w3AzAFIAAgAWoiAiACKQMAIAN8IgNC//////////8DgzcDACABQQhqIQEMAQsLC2oCA
    n8BfiAAIAApAwAiA0L//////////wODNwMAQQghAQNAIANCOochAyABQegARgRAIAAgACkDaCADfDcDaAUgACABaiICIA
    IpAwAgA3wiA0L//////////wODNwMAIAFBCGohAQwBCwsLWQEBfyMAQYADayIEJAAgBCADEF4gBBBAIARBgAFqIAEQXiA
    EQYACaiACEF4gBEGAAWogBBAPIARBgAJqIAQQDyAAIARBgAFqIARBgAJqEJEBIARBgANqJAALWQECfyMAQUBqIgEkAAJA
    IAAQhAENACABQQEQigEgAEGAAWoiAiABEFkNACACQQAQNCAAIAIQSCAAEBIgAEFAayIAIAIQSCAAEBIgAiABEKUBCyABQ
    UBrJAALVwEBfyMAQbABayICJAAgATQCOCAANAI4fkKAgIAQWQRAIAAQEgsgAkEIaiAAIAEQCCACQfgAaiACQQhqEAUgAC
    ACQfgAahBrIABBAjYCOCACQbABaiQAC08BAn8jAEFAaiIDJAAgAEE4EHIiAEEBNgI4IABBQGtBOBByIABB+ABqQQE2AgA
    gAyABEIsBIAAgAxClASADIAIQiwEgAxClASADQUBrJAALWQECfyMAQYABayIBJAACQCAAEIgBDQAgARBQIABBgAJqIgIg
    ARB7DQAgAhBAIAAgAhAPIAAQqwEgAEGAAWoiACACEA8gABCrASACIAEQkAELIAFBgAFqJAALSwEBfyMAQUBqIgEkACAAQ
    TgQciIAQQE2AjggAUEBEIoBIABBQGsgAUHAABBnGiAAQYABakE4EHIaIABBuAFqQQE2AgAgAUFAayQAC0sBAn8jAEHwAG
    siASQAIAAQd0UEQCABQaCnwAAQXyABQThqIAAQgwEgASABQThqEGIgARBEIAFBOGogARA1IQILIAFB8ABqJAAgAgtPAQF
    /IwBBgAFrIgIkACAAIAEQhQEgABADIAJByABqQdikwAAQXyACQQhqIAJByABqEIsBIAAgARBIIAAgAkEIahB4IAAQEiAC
    QYABaiQAC0kBAn8DQCABQThGRQRAIAAgAWoiAiACKQMAQgGGNwMAIAFBCGohAQwBCwsgACAAKAI4QQF0IgE2AjggAUGAg
    IAQTgRAIAAQEgsLQgIBfwJ+QQAgAmusIQQDQCADQThHBEAgACADaiICIAIpAwAiBSABIANqKQMAhSAEgyAFhTcDACADQQ
    hqIQMMAQsLC0YBAn8jAEFAaiIBJAAgAEE4EHIiAEEBNgI4IABBQGtBOBByIABB+ABqQQE2AgAgAUEBEIoBIAAgARClARC
    yASABQUBrJAALTgEBfyMAQYAEayIBJAAgABAvIAEQLyABQYACahAvIABBgAJqIAFBgAIQZxogAEGABGogAUGAAmpBgAIQ
    ZxogAEEANgKABiABQYAEaiQAC0sBAX8jAEFAaiICJAACQCAAKAI4IAFsQYCAgBBOBEAgAiABEIoBIAAgAhBIDAELIAAgA
    RAoGiAAIAAoAjggAWw2AjgLIAJBQGskAAtKAAJ/IAFBgIDEAEcEQEEBIAAoAhggASAAQRxqKAIAKAIQEQMADQEaCyACRQ
    RAQQAPCyAAKAIYIAJBACAAQRxqKAIAKAIMEQUACwtCAQF/IwBBQGoiAiQAIAJBCGpBgIDAABBfIAEgAkEIahBrIAEQRCA
    AIAEQayAAQQMQKBogABBEIAAQKSACQUBrJAALSQECfyMAQcABayIBJAAgASAAEF4gAUGAAWogABCFASAAIABBQGsiAhCl
    ASAAEEEgAiABQYABahClASAAIAEQlQEgAUHAAWokAAtIAQF/IwBB4AFrIgEkACABQeihwAAQXyABQThqIAAgARAIIAFBq
    AFqIAFBOGoQBSAAIAFBqAFqEGsgAEECNgI4IAFB4AFqJAALPgEBfyABQTpuIQIgAUGVA00EQCAAIAJBA3RqKQMAQgEgAU
    H//wNxQTpwrYaDQgBVDwsgAkEHQdSdwAAQPAALQAIBfwF+IwBBgAFrIgEkACABQQhqIAAQhQEgAUEIahASIAFByABqIAF
    BCGoQgwEgASkDSCABQYABaiQAQgKBpws8AQF/IwBBgAFrIgIkACACIAAQhQEgAkFAayABEIUBIAIQEiACQUBrEBIgAiAC
    QUBrEDUgAkGAAWokAEULPAIBfwF+A38gAUE4RgR/IAJCf3xCgICAgICAgIAEg0I6iKcFIAAgAWopAwAgAoQhAiABQQhqI
    QEMAQsLC0cBAX8jAEEgayIDJAAgA0EUakEANgIAIANB9KrAADYCECADQgE3AgQgAyABNgIcIAMgADYCGCADIANBGGo2Ag
    AgAyACEHAACzkBAX8jAEFAaiICJAAgAiAAEIUBIAIQByABBEAgASACEKUBCyACEAMgAiAAEEggAhAsIAJBQGskAAs6AQF
    /IABBOBByIQADQCACQTBGRQRAIABBCBAtIAAgACkDACABIAJqMQAAfDcDACACQQFqIQIMAQsLCzQBAX8gAEE4EHIiAEEB
    NgI4IABBQGtBOBByIABB+ABqQQE2AgAgACABEKUBIAFBQGsQpQELMAEBfyAAQTgQciEAA0AgAkE4RwRAIAAgAmogASACa
    ikDADcDACACQQhqIQIMAQsLCz8BAX8jAEGAAmsiASQAIAAQUSABEG4gACABEJIBIABBgAJqEK0BIABBgARqEK0BIABBAT
    YCgAYgAUGAAmokAAswAQJ/A0AgAkE4RwRAIAAgAmoiAyADKQMAIAEgAmopAwB8NwMAIAJBCGohAgwBCwsLMAECfwNAIAJ
    BOEcEQCAAIAJqIgMgAykDACABIAJqKQMAfTcDACACQQhqIQIMAQsLCzABAn8DQCACQThHBEAgACACaiIDIAEgAmopAwAg
    AykDAH03AwAgAkEIaiECDAELCwsxAQJ/A0AgAkHwAEcEQCAAIAJqIgMgAykDACABIAJqKQMAfTcDACACQQhqIQIMAQsLC
    zEBAn8DQCACQfAARwRAIAAgAmoiAyADKQMAIAEgAmopAwB8NwMAIAJBCGohAgwBCwsLOQECfyMAQYABayIBJAAgASAAQY
    ABaiICEF4gAiAAEJABIAEQVSAAIAEQkAEgABCsASABQYABaiQACzMBAX8gAgRAIAAhAwNAIAMgAS0AADoAACABQQFqIQE
    gA0EBaiEDIAJBf2oiAg0ACwsgAAtIAQN/IwBBEGsiASQAIAAoAgwhAyAAKAIIIgJFBEBB9KrAAEErQaCrwAAQWwALIAEg
    AzYCCCABIAA2AgQgASACNgIAIAEQcQALMgEBfyAAQgE3AwBBCCEBA0AgAUE4RkUEQCAAIAFqQgA3AwAgAUEIaiEBDAELC
    yAAEFYLNwAgABBRIAAgARCSASAAQYACaiABQYACahCSASAAQYAEaiABQYAEahCSASAAIAEoAoAGNgKABgsoAQF/A0AgAk
    E4RwRAIAAgAmogASACaikDADcDACACQQhqIQIMAQsLCzMAIAAgARCSASAAQYACaiABQYACahCSASAAQYAEaiABQYAEahC
    SASAAIAEoAoAGNgKABgsoACAAIAEgAhB5IABBQGsgAUFAayACEHkgAEGAAWogAUGAAWogAhB5Cy4BAX8jAEGAAWsiASQA
    IAAQLyABEFAgACABEJABIABBgAFqEKkBIAFBgAFqJAALLQAgACABIAIQjwEgAEGAAWogAUGAAWogAhCPASAAQYACaiABQ
    YACaiACEI8BCzQBAX8jAEEQayICJAAgAiABNgIMIAIgADYCCCACQaSowAA2AgQgAkH0qsAANgIAIAIQaAALPgEBfyMAQR
    BrIgEkACABQQhqIABBCGooAgA2AgAgASAAKQIANwMAIAEoAgAiAEEUaigCABogACgCBBoQMwALKQEBfyABBEAgACECA0A
    gAkEAOgAAIAJBAWohAiABQX9qIgENAAsLIAALKwEBfyMAQcABayICJAAgAhBLIAIgARB/IAIQpgEgACACEAwgAkHAAWok
    AAsiAQF/A0AgAUE4RwRAIAAgAWpCADcDACABQQhqIQEMAQsLCycBAX8jAEFAaiICJAAgAkEIaiABEF0gACACQQhqEIsBI
    AJBQGskAAsrACAAEFEgACABEJIBIABBgAJqIAIQkgEgAEGABGogAxCSASAAQQU2AoAGCyMBAX8jAEFAaiIBJAAgASAAEI
    UBIAEQEiABEFogAUFAayQACykAIAAgARBhIAAgACgCOCABKAI4aiIBNgI4IAFBgICAEE4EQCAAEBILCyUAIAAgASACEE8
    gAEEAIAJrIAAoAjgiACABKAI4c3EgAHM2AjgLIwADQCACBEAgACABLQAAED4gAkF/aiECIAFBAWohAQwBCwsLIgACQCAA
    IAEQWUUNACAAQUBrIAFBQGsQWUUNAEEBDwtBAAskAAJAIABBfE0EQCAARQRAQQQhAAwCCyAAEAEiAA0BCwALIAALJwEBf
    yMAQYABayICJAAgAiABEF4gAhA6IAAgAhCVASACQYABaiQACycAIAAgARCQASAAQYABaiABQYABahCQASAAQYACaiABQY
    ACahCQAQslACAAIAEQpQEgAEFAayABQUBrEKUBIABBgAFqIAFBgAFqEKUBCyUBAX8jAEFAaiICJAAgAiABEIUBIAIQQSA
    AIAIQeCACQUBrJAALKAEBfyMAQYACayICJAAgAiABEI4BIAIQKyAAIAIQlgEgAkGAAmokAAsjAEGEAiACSQRAIAJBhAIg
    AxA9AAsgACACNgIEIAAgATYCAAsiAQF/IwBB8ABrIgIkACACIAEQMCAAIAIQBSACQfAAaiQACxwAAkAgABB3RQ0AIABBg
    AFqEHdFDQBBAQ8LQQALHwAgAEE4EHIiAEEBNgI4IAAgARBrIAAgASgCODYCOAseAAJAIAAQhwFFDQAgAEGAAWoQhwFFDQ
    BBAQ8LQQALGwACQCAAEHdFDQAgAEFAaxB3RQ0AQQEPC0EACx4AAkAgABCHAUUNACAAQYACahCHAUUNAEEBDwtBAAsaAQF
    /IAAQWCIBIABBQGsQWCABcyAAEHdxcwsaACAAQTgQciIAQQE2AjggACABEJ0BIAAQVgsZACAAQTgQciIAQQE2AjggACAB
    EGsgABBWCxcAIAAQRCAAKAIAQX8gAUEfcXRBf3NxCxoAIAAgARBfIAAgAhAkIAAgAhBjIAAgAhAkCxwAIAAQLyAAIAEQk
    AEgAEGAAWogAUGAAWoQkAELGAAgACABIAIQeSAAQUBrIAFBQGsgAhB5CxYAIAAgARClASAAQUBrIAFBQGsQpQELGAAgAB
    AvIAAgARCQASAAQYABaiACEJABCxgAIAAgARCQASAAQYABaiABQYABahCQAQsZACAAEK4BIABBgAJqELYBIABBgARqEK4
    BCxcAIAAQsgEgAEFAaxBpIABBgAFqELIBCxQAIAAgARB4IABBQGsgAUFAaxB4CxgAIAAgARCVASAAQYABaiABQYABahCV
    AQsYACAAEKYBIABBgAFqIgAQpgEgACABEA8LGQAgABCpASAAQYABahCwASAAQYACahCpAQsZACAAEKwBIABBgAJqEKwBI
    ABBgARqEKwBCxkAIAAQqgEgAEGAAmoQqgEgAEGABGoQqgELFgAgABAvIAAgARCQASAAQYABahCpAQsWACAAQYABaiIAEK
    gBIAAQOiAAEKgBCxQAIAAQRCAAIAApAwAgAax8NwMACxQAIAAQRCAAIAApAwAgAax9NwMACxEAIAAgARBSIABBQGsgARB
    SCxEAIAAgARBIIABBQGsgARBICxQAIAAgARCQASAAQYABaiACEJABCxIAIAAgARAPIABBgAFqIAEQDwsUACAAIAEQoAEg
    AEGAAWogARCgAQsRACAAKAIEBEAgACgCABAJCwsSACAAIAEQayAAIAEoAjg2AjgLDwAgAEFAayIAEEEgABBECw0AIAAQT
    iAAQUBrEE4LDQAgABBEIABBQGsQRAsPACAAELIBIABBQGsQsgELEAAgABCrASAAQYABahCrAQsNACAAEBIgAEFAaxASCx
    AAIAAQqAEgAEGAAWoQqAELEAAgABCpASAAQYABahCpAQsPACAAQYABahA6IAAQrAELEAAgABCnASAAQYABahCnAQsOACA
    AEGkgAEFAaxCyAQsQACAAIAI2AgQgACABNgIACw0AIAAQdCAAQQE2AjgLDAAgABBBIAAgARB4CwwAIAAgARBrIAAQVgsN
    ACAAEDogACABEJUBCwsAIAAQOiAAEKwBCwwAQunQotvMouq7RgsDAAELAwABCwv+PZoCAEGCgMAACwcBAAAAAQI0AEG4g
    MAAC9sBuF8jku11BwFjT+D5WE+pA2dPnKtLeD0Akew9ffXy9AMD1g8fDSwgAK1vjPCZwa4A8DtNkAEAAADzStxtEor3AI
    uwH1tTsFYDgvLFYx+X7AAysL/NHtseAkehVLifHyMCQHo6ogw4sQGz4sMPAAAAAHNyYy9ibHMxMjM4MS9wYWlyLnJzqAA
    QABQAAAAHAQAACQAAAKgAEAAUAAAADAEAAA0AAACoABAAFAAAABEBAAANAAAAAAAAAAEAAAD///8Dv/+W/78AaQM7VYAd
    moCAAefMIPV1pkwBp+1zAEGogsAACyz+//7///8BAosAgILYBPYB4Y1oiW++kwLOdqvfPagdAMZpulHOdt8Dy1nGFwBB4
    ILAAAuRAZABEAATAAAA0AEAABgAAACQARAAEwAAANQBAAARAAAAkAEQABMAAADWAQAAHAAAAHNyYy9ibHMxMjM4MS9lY3
    AucnMAkAEQABMAAAAZBQAADQAAAJABEAATAAAAGwUAAAkAAACQARAAEwAAABwFAAARAAAAkAEQABMAAAAfBQAAHAAAAAA
    AAAABAAEAAAABAjQAQaCEwAALuSCQARAAEwAAAGcEAAARAAAAkAEQABMAAABsBAAADQAAAJABEAATAAAAbgQAABUAAACQ
    ARAAEwAAAHAEAAAgAAAAHUxYLQgo9ADXXz44aOPbAInJGoj9roEBomOjmrkPTgGY6rCCSW3JAoBOWs9QOu4AimlEAQAAA
    ADgKxeO6UjMAXSpOluMVsgAolXvNe/8FADngsIBPcnDA8EWIDvuPnUAusRiAAwgWgDRCCkuAQAAALgh6L1iEMUA3/4Vlz
    tIpQGLCDH8A9S9AbsR/Cc0UtIDHfAS2hvXowEqPc423S/bAshidB8AAAAAKdKiiy66yAHqR06TLeDGAiSMtsYkvPEDAo/
    w3iCL+AGd1zE97u2BA4ilRy+cg4kDSMIIbgAAAAB7+wUWP99nAjJ7Fwrjx90CaW+GFDsANgMrVFv+4Zl3A8x9+g1bVtIB
    Aju2nPiBcwIH2iEDAQAAAJ4MOb5nECQDX97JALfLQgIx+rexS69LAYydZXIx6AACyy7dIo8TXQHUDYML8enzAuH4sWkBA
    AAAF+OXhGqYcQFbpdOtpXylAPrkHV2MkmwBFovSVX2eswF1O8QNmb5jAc0s5B7x42kCH8/TgAAAAACOyPDjGFbLAOdrHT
    0yPvIBmzNTJw/vYgALmsY2bZ2sAuVtNVN+EdEAIQ4duvj2agBw54F7AQAAAITtOaEl8tcBt7JLQTBKlADaqLKGnI8hAiN
    AhjM+PJkAhhWxv1LmigOwyY1aShP5A1Nl7dYAAAAAgyllb8bBEwFzRs+5ckvDAQgK+Wh+CbkCTntu5kll9wGxPNu1Sqf3
    AwZIdMD/xFwDUDIMYwEAAADZlYis6UwVARTxnQfMG4oChYnB+oJZtgK7IfzsX0loAZnbmVSOEeQDLK2Q2RB9ZgCjJpfpA
    AAAAGFomx1kiLMB8WQcxDiXuAEzNQgzG58oA8zGl/w2qpUB5PXXElTlBwN0goHTbRvzA2ZxjncBAAAAsNyerJ2fFwD4p1
    yCSo8PA1jJJY7GHlAC46GVD2alzAEkA84bmgrRATESRAc7nl0C2wVA1QAAAAC7g8uz8e40ALrVMMa8qTwCg7SGHg3HMwK
    X1V8Qqr1sAecXfByoRyECrC5iwcvqUAI+7ZRyAQAAALdJRnNiFqwCq1uLuXy1MABhhSxO22y1A4nJfwFciyICPjBrhRWY
    2QEHRAIu0MygA7HyBRoBAAAACt3saNGEYwELQBne0pLTATFZwTGPlzMBfdvdQN9bugO0gvaAZqWzAo9b2xG1SnoCqxP8l
    QAAAABB1qF5Oux2AxHckO6qpJkAOFCDmPNn2gBA0K3ZhMV1AI1/4Myjx68Bz4Kkl+BTaQNqzw6hAAAAAF5azL2b2fcBxL
    R4RCdSbgH6gMUimN8cAltmoKIpbwgDY39umQHPdABs/SyMLCpZA6nCekoBAAAAOkrobkl0JQA7G3jD49TsAKfO6e0qBnM
    AuDglhk69ZgJXD1chZ1ngAxiDz0OGTVoAz6osdwAAAAClBGOfovktAHDEowjxkjQAQPeCiUvyzgMOKTS1cjqnAzVXOenG
    BgUD30NOVe6ZOQGOXzXnAAAAAB6iMjVbOZ0DVAdezQfqpgC9qW0wO4NOAK017oqBhGYBx9//faDnQwNXx5sCKkWKACAWj
    joBAAAA2CzGjZPoDQMEcT27D0m1AZcE/dYovIoCMlNFlcVa/AAkCFtU60B8A/urDrK/uGIBGlglNAAAAAAZPrhcujnCAD
    +3PyWfJfQAas3qrBEL4ACZ8kczxmm9AUGJbx+Z8r8BivlNoJfI6AHlL5ayAAAAAP87K8huJ8gBeboJLBshqgI9cfWLxIg
    lAJsEMADCMygD6EFwNjblmAJEHC3SEGfVAt6lYSUBAAAAHBvSQPr5PAEmfg+Nb6A1AlUrxor8F4YAVnLqIm2NLgHv1QFv
    +tNLA4u5LIZrxj8DSNWojAAAAAAEtshpvla0AMEdB7C/n0ABZisb8FqpTwG3XuVoWRI+Ah0Yy7Uu30IDzkKpk/PAQwLp5
    GteAQAAAEsidVRxHmsC4e1rXtkmQQC6Rs6nltP1AKxmo5WhXwcCPWde/KPESAN9VqhAxDORA0WWElwAAAAAMwGY2/XT2Q
    IQmcoIRyvkA2zMWQbE0zICmU8AVjA1IAA7e3XcFeN7AisAv9ymskcDSjlaJAAAAAD4HpcL8ARMAYN8hGRkcBQCbPAzRnu
    ADgGcADvCmtCoALGnekQ/9QQAWEJVdObkBgDByoKxAAAAAI5NB9CkyAcCs4E10QZ9cwKdJEP2EfnnA6+5GAnDq+ICWTVS
    zO3S/gNQMEaut73NAwipRosBAAAAMsER0BpxEwA6v+6PM5fOAxsDYZ44FuQDYET/JL2yLQPLL82T+0MdA+NCf4NvNN8Ae
    eQTlwEAAAAwHHPK66qvA8qbrlN3FdwDs7lDTR7t5wFhGvjba0WeAgwqxCNKoa0Dea+OSG2vYQChp7vhAAAAAIel23tXDj
    cA2OiB4XGAlAGd5qsM8qHmAi16sAl3nlkAvTqPu6FNHgKIJyP6EpplA4sBxJ8AAAAAKftwGKNMXgFoTfq3P1SRAS9kQsg
    mbNoADvR/YPeO/wIFChd0xqYsAa9Jpvcbrs4AU418mAAAAADy1ulfhfhhAbJX0IORsB4CenTzNNbEEwDFSC0Thq8oA7hb
    5zxreScA9F2yLO8G6wO8ubBKAAAAAPClMzaxOrIBphygVrLJ2AMD4kRVrdPDAUHZ9d62vlID0Kd0oKbwuAFHeISI2tIYA
    KT8A2YBAAAA2/7o8uzatgEQKhBkAjf+Ae7CrVETIv0DDObhQjmP7wM2VRnEKRWiAvjTK9fEP/gD3j/AjAAAAADL9OWwd1
    w1Ail7h7GnrhYA5J3PUTLAPgKSJ3DkrTvkAqcq1FdndNgCRh0mXggHJgJuN4YfAAAAAPbhLcdA4t8A7kgBLIqFVAMmfdo
    AFLnkAxINi3OMYlkD4lIllEk7agAy4Si9mZulArqGxwwAAAAAlsZBLlrnlwD4L+qLZcRZAWxN03q2PjQCQT704DyVsAHp
    IxKDRvt2A7UNRHUEljsBEGqZNAEAAAAzuweXcUWYAq/w6M6mux4D0Dw9VFbJ9gJKrUiloSI5AhOtEfrcgEkBwkdnCbiT6
    AKBfNmQAAAAAI9LYx06RxUAEeAlTTxcvQDKBaLKVmPNAzvJTOHOiZcBD8RxwRl4DQJXCcmaD3C3AYEd+uAAAAAA9wbtJh
    Pc+gE0IDPFYe9FASDkgCSUJ98A0i0Hn6ScUwJbVr/yds1TAUP3otjOk8sCDkBgJgAAAADMRTNXOLGZAkewQu742AEAMGm
    42QCa7wJz9ZkIfCtmA0YzVJYUX7QAUUzY8PifHQMUlWutAAAAAJIQVuIptYQCpfqu3xsmWgJvURN56oyoAT4wSgs5vysC
    /5R/RwzFSAIHS2H9z0AHAnS2y6wAAAAAqGqPupy0+AAAgcHg06dwARqHXGpjbrMBZDmkmIbt5gDQbZwdkdIaACgEPFJvA
    akDniUvTQAAAABVP5G4i/RuAI3XbEr1qBcCc7xPfernkgEhTO0e9oSPAfcWMpCEStkDZYGgOoebwgHaXKVnAQAAAEpdU1
    WdPSMD2iCS5O69+AMshbQ5v8RQAxWvgmS9GpMDDPv5xEzX0QNT+YbGSBjbANOObIYBAAAA2S6BFVpB7gAYuXcAAmw9AJI
    rE1djIP0AzfpfP33oewE3pOVu/6a7An4374D6qY8Di/A+agEAAABcd2oSmRMaAU/ux2JpAKcCXx0FoADEWwJNd73jMzTq
    A/3sXkuC6awAzaHu8Mt2pgIIfABmAQAAAKy3+ap/R8YCgDhz6ndu4wCfRKb18LaHAbMXB2JDVRkDUgG3gjF4rAK6mexny
    7ZhAJdSno0AAAAAHQClESMUOQJ2e7v0A3fFAiBqkeyd/KABu1DB7qY9fAKc0cbcjSL4AkQyAyz50BcBlQcOvgAAAAAWVF
    9EmG3SAGrrpaCwPNkAJxf0anKeSAL2SDhM83ZvA8UV0dG07YkD70iDfOWUYwKHKH1rAQAAAPJnvz21OCUCR+Jbvo01XwF
    nyi7NedJdAtYwxPy5RlUBhcR4V7GObgGfq+rbiTaQAQYz31gAAAAAPaBJLiwQ9gJMjafU2IEJAYr3AT5FbzUAhJJyVhPH
    3ANPyIW4SMNDAFsvg4YHSOAAwnUtlgEAAADBYzawU5JHAUAbCIO9I9oAf6Dncr61MgIMu5svYOKVA20aYOnq0PoAUASGl
    CwmpwLDxBJhAQAAAHNyYy9ibHMxMjM4MS9iaWcucnMAoA4QABMAAADMAQAALQAAAKAOEAATAAAAzAEAADUAAACgDhAAEw
    AAABkCAAANAAAAoA4QABMAAAA4AwAAGAAAAKAOEAATAAAAOAMAACEAAACgDhAAEwAAAEIDAAAhAAAAoA4QABMAAABbAwA
    AFwAAAKAOEAATAAAAZAMAABcAAACgDhAAEwAAAHIDAAAwAAAAoA4QABMAAAB7AwAAMAAAAKAOEAATAAAApwMAABgAAACg
    DhAAEwAAALUDAAAYAAAAmC+KQpFEN3HP+8C1pdu16VvCVjnxEfFZpII/ktVeHKuYqgfYAVuDEr6FMSTDfQxVdF2+cv6x3
    oCnBtybdPGbwcFpm+SGR77vxp3BD8yhDCRvLOktqoR0StypsFzaiPl2UlE+mG3GMajIJwOwx39Zv/ML4MZHkafVUWPKBm
    cpKRSFCrcnOCEbLvxtLE0TDThTVHMKZbsKanYuycKBhSxykqHov6JLZhqocItLwqNRbMcZ6JLRJAaZ1oU1DvRwoGoQFsG
    kGQhsNx5Md0gntbywNLMMHDlKqthOT8qcW/NvLmjugo90b2OleBR4yIQIAseM+v++kOtsUKT3o/m+8nhxxkJMU19TSUdf
    QkxTMTIzODFHMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPX05VTF8A0BAQABMAAAA/AAAALgAAANAQEAATAAAAPQAAABUAAADQE
    BAAEwAAAD0AAAANAAAAc3JjL2JsczEyMzgxL2Jscy5ycwAAAAAArve+1aE5BgLok91iZEwkAdIsbk61CS0C2+VwMbbEEQ
    GZYzb76G2KA7ycH+3PFk8AK2qmngEAAABhdHRlbXB0IHRvIGRpdmlkZSBieSB6ZXJvAAAAbxEQABIAAAB8AQAAFAAAAAA
    AAABhdHRlbXB0IHRvIGRpdmlkZSB3aXRoIG92ZXJmbG93c3JjL2JsczEyMzgxL2ZwLnJzAAAAbxEQABIAAAASAgAADQAA
    AG8REAASAAAAHgIAACYAAABvERAAEgAAAB4CAAAjAAAAbxEQABIAAAAkAgAAFwAAAG8REAASAAAAJAIAABQAAAAAAAAAq
    qr//////gHu//9UrP//AupBYg9rDyoBw5z9ShTOEwJLd2TXrEtDAu3pxpKm+V8Cox4RoAEAAABAEhAAFAAAABUBAAATAA
    AAQBIQABQAAAAeAQAAGAAAAEASEAAUAAAAJAEAABwAAABzcmMvYmxzMTIzODEvZWNwMi5ycwAAAAAEAEGQpcAAC7wGQBI
    QABQAAADmAgAACQAAAEASEAAUAAAA7gIAAA0AAABAEhAAFAAAAP4CAAAhAAAAuL0hwchWgAD1+24BqskAA7pwFz2uR7YA
    RNEK7ADpUwN65MZREMUtA0kBgkmkwiMALyuqJAAAAAB+KwRdBX2sAflVF+WERDwDNJME9ce9GwJp12rYgmRCA9BrWWVPJ
    4gA6DRrH9hnnAAFtgI+AQAAAAEouAiGVJMBeKIo6w5zsgIjyRINFpWmAQq1nU73MqoCm/2tGjUu2gJxczJjhFufAHdSXc
    4AAAAAvnlf8F8HqQJqaAc710nDAfOzmulytSoB0pm8jp0W+gEoPsuZi8IrAKw0qwwzzakDAkpsYAAAAACrqv/////+Ae7
    //1Ss//8C6kFiD2sPKgHDnP1KFM4TAkt3ZNesS0MC7enGkqb5XwKjHhGgAQAAAAgUEAALAAAAjwEAAA8AAAAIFBAACwAA
    AKcBAAATAAAACBQQAAsAAACqAQAADQAAAHNyYy9obWFjLnJzADQUEAAgAAAAVBQQABIAAAADAAAAAAAAAAEAAAAEAAAAa
    W5kZXggb3V0IG9mIGJvdW5kczogdGhlIGxlbiBpcyAgYnV0IHRoZSBpbmRleCBpcyAwMDAxMDIwMzA0MDUwNjA3MDgwOT
    EwMTExMjEzMTQxNTE2MTcxODE5MjAyMTIyMjMyNDI1MjYyNzI4MjkzMDMxMzIzMzM0MzUzNjM3MzgzOTQwNDE0MjQzNDQ
    0NTQ2NDc0ODQ5NTA1MTUyNTM1NDU1NTY1NzU4NTk2MDYxNjI2MzY0NjU2NjY3Njg2OTcwNzE3MjczNzQ3NTc2Nzc3ODc5
    ODA4MTgyODM4NDg1ODY4Nzg4ODk5MDkxOTI5Mzk0OTU5Njk3OTg5OQAAQBUQABAAAABQFRAAIgAAAHJhbmdlIGVuZCBpb
    mRleCAgb3V0IG9mIHJhbmdlIGZvciBzbGljZSBvZiBsZW5ndGggAABjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIG
    EgYE5vbmVgIHZhbHVlALAVEAAcAAAA7gEAAB4AAABsaWJyYXJ5L3N0ZC9zcmMvcGFuaWNraW5nLnJzAEGIrMAACwEBAEH
    IrMAACwEBAEGIrcAACwEBAEHIrcAACwEBAEGIrsAACwEBAEHIrsAACwEBAEGIr8AACwEBAEHIr8AACwEBAEGIsMAACwEB
    AEHIsMAACwEBAEGIscAACwEBAEHIscAACwEBAEGIssAACwEBAEHIssAACwEBAEGIs8AACwEBAEHIs8AACwEBAEGItMAAC
    wEBAEHItMAACwEBAEGItcAACwEBAEHItcAACwEBAEGItsAACwEBAEHItsAACwEBAEGIt8AACwEBAEHIt8AACwEBAEGIuM
    AACwEBAEHIuMAACwEBAEGIucAACwEBAEHIucAACwEBAEGIusAACwEBAEHIusAACwEBAEGIu8AACwEBAEHIu8AACwEBAEG
    IvMAACwEBAEHIvMAACwEBAEGIvcAACwEBAEHIvcAACwEBAEGIvsAACwEBAEHIvsAACwEBAEGIv8AACwEBAEHIv8AACwEB
    AEGIwMAACwEBAEHIwMAACwEBAEGIwcAACwEBAEHIwcAACwEBAEGIwsAACwEBAEHIwsAACwEBAEGIw8AACwEBAEHIw8AAC
    wEBAEGIxMAACwEBAEHIxMAACwEBAEGIxcAACwEBAEHIxcAACwEBAEGIxsAACwEBAEHIxsAACwEBAEGIx8AACwEBAEHIx8
    AACwEBAEGIyMAACwEBAEHIyMAACwEBAEGIycAACwEBAEHIycAACwEBAEGIysAACwEBAEHIysAACwEBAEGIy8AACwEBAEH
    Iy8AACwEBAEGIzMAACwEBAEHIzMAACwEBAEGIzcAACwEBAEHIzcAACwEBAEGIzsAACwEBAEHIzsAACwEBAEGIz8AACwEB
    AEHIz8AACwEBAEGI0MAACwEBAEHI0MAACwEBAEGI0cAACwEBAEHI0cAACwEBAEGI0sAACwEBAEHI0sAACwEBAEGI08AAC
    wEBAEHI08AACwEBAEGI1MAACwEBAEHI1MAACwEBAEGI1cAACwEBAEHI1cAACwEBAEGI1sAACwEBAEHI1sAACwEBAEGI18
    AACwEBAEHI18AACwEBAEGI2MAACwEBAEHI2MAACwEBAEGI2cAACwEBAEHI2cAACwEBAEGI2sAACwEBAEHI2sAACwEBAEG
    I28AACwEBAEHI28AACwEBAEGI3MAACwEBAEHI3MAACwEBAEGI3cAACwEBAEHI3cAACwEBAEGI3sAACwEBAEHI3sAACwEB
    AEGI38AACwEBAEHI38AACwEBAEGI4MAACwEBAEHI4MAACwEBAEGI4cAACwEBAEHI4cAACwEBAEGI4sAACwEBAEHI4sAAC
    wEBAEGI48AACwEBAEHI48AACwEBAEGI5MAACwEBAEHI5MAACwEBAEGI5cAACwEBAEHI5cAACwEBAEGI5sAACwEBAEHI5s
    AACwEBAEGI58AACwEBAEHI58AACwEBAEGI6MAACwEBAEHI6MAACwEBAEGI6cAACwEBAEHI6cAACwEBAEGI6sAACwEBAEH
    I6sAACwEBAEGI68AACwEBAEHI68AACwEBAEGI7MAACwEBAEHI7MAACwEBAEGI7cAACwEBAEHI7cAACwEBAEGI7sAACwEB
    AEHI7sAACwEBAEGI78AACwEBAEHI78AACwEBAEGI8MAACwEBAEHI8MAACwEBAEGI8cAACwEBAEHI8cAACwEBAEGI8sAAC
    wEBAEHI8sAACwEBAEGI88AACwEBAEHI88AACwEBAEGI9MAACwEBAEHI9MAACwEBAEGI9cAACwEBAEHI9cAACwEBAEGI9s
    AACwEBAEHI9sAACwEBAEGI98AACwEBAEHI98AACwEBAEGI+MAACwEBAEHI+MAACwEBAEGI+cAACwEBAEHI+cAACwEBAEG
    I+sAACwEBAEHI+sAACwEBAEGI+8AACwEBAEHI+8AACwEBAEGI/MAACwEBAEHI/MAACwEBAEGI/cAACwEBAEHI/cAACwEB
    AEGI/sAACwEBAEHI/sAACwEBAEGI/8AACwEBAEHI/8AACwEBAEGIgMEACwEBAEHIgMEACwEBAEGIgcEACwEBAEHIgcEAC
    wEBAEGIgsEACwEBAEHIgsEACwEBAEGIg8EACwEBAEHIg8EACwEBAEGIhMEACwEBAEHIhMEACwEBAEGIhcEACwEBAEHIhc
    EACwEBAEGIhsEACwEBAEHIhsEACwEBAEGIh8EACwEBAEHIh8EACwEBAEGIiMEACwEBAEHIiMEACwEBAEGIicEACwEBAEH
    IicEACwEBAEGIisEACwEBAEHIisEACwEBAEGIi8EACwEBAEHIi8EACwEBAEGIjMEACwEBAEHIjMEACwEBAEGIjcEACwEB
    AEHIjcEACwEBAEGIjsEACwEBAEHIjsEACwEBAEGIj8EACwEBAEHIj8EACwEBAEGIkMEACwEBAEHIkMEACwEBAEGIkcEAC
    wEBAEHIkcEACwEBAEGIksEACwEBAEHIksEACwEBAEGIk8EACwEBAEHIk8EACwEBAEGIlMEACwEBAEHIlMEACwEBAEGIlc
    EACwEBAEHIlcEACwEBAEGIlsEACwEBAEHIlsEACwEBAEGIl8EACwEBAEHIl8EACwEBAEGImMEACwEBAEHImMEACwEBAEG
    ImcEACwEBAEHImcEACwEBAEGImsEACwEBAEHImsEACwEBAEGIm8EACwEBAEHIm8EACwEBAEGInMEACwEBAEHInMEACwEB
    AEGIncEACwEBAEHIncEACwEBAEGInsEACwEBAEHInsEACwEBAEGIn8EACwEBAEHIn8EACwEBAEGIoMEACwEBAEHIoMEAC
    wEBAEGIocEACwEBAEHIocEACwEBAEGIosEACwEBAEHIosEACwEBAEGIo8EACwEBAEHIo8EACwEBAEGIpMEACwEBAEHIpM
    EACwEBAEGIpcEACwEBAEHIpcEACwEBAEGIpsEACwEBAEHIpsEACwEBAEGIp8EACwEBAEHIp8EACwEBAEGIqMEACwEBAEH
    IqMEACwEBAEGIqcEACwEBAEHIqcEACwEBAEGIqsEACwEBAEHIqsEACwEBAEGIq8EACwEBAEHIq8EACwEBAEGIrMEACwEB
    AEHIrMEACwEBAEGIrcEACwEBAEHIrcEACwEBAEGIrsEACwEBAEHIrsEACwEBAEGIr8EACwEBAEHIr8EACwEBAEGIsMEAC
    wEBAEHIsMEACwEBAEGIscEACwEBAEHIscEACwEBAEGIssEACwEBAEHIssEACwEBAEGIs8EACwEBAEHIs8EACwEBAEGItM
    EACwEBAEHItMEACwEBAEGItcEACwEBAEHItcEACwEBAHsJcHJvZHVjZXJzAghsYW5ndWFnZQEEUnVzdAAMcHJvY2Vzc2V
    kLWJ5AwVydXN0Yx0xLjQ5LjAgKGUxODg0YThlMyAyMDIwLTEyLTI5KQZ3YWxydXMGMC4xOC4wDHdhc20tYmluZGdlbhIw
    LjIuNzAgKGI2MzU1YzI3MCk=
`.replace(/[^0-9a-zA-Z/+]/g, "");
const wasmBytes$1 = decode$2(wasmBytesBase64$1);
function bls_init$1() {
  let ret = wasm$1.bls_init();
  return ret;
}
let cachegetUint8Memory0$1 = null;
function getUint8Memory0$1() {
  if (cachegetUint8Memory0$1 === null || cachegetUint8Memory0$1.buffer !== wasm$1.memory.buffer) {
    cachegetUint8Memory0$1 = new Uint8Array(wasm$1.memory.buffer);
  }
  return cachegetUint8Memory0$1;
}
function passArray8ToWasm0$1(arg, malloc) {
  const ptr = malloc(arg.length * 1);
  getUint8Memory0$1().set(arg, ptr / 1);
  return [ptr, arg.length];
}
function bls_verify$1(sig, m2, w2) {
  const [ptr0, len0] = passArray8ToWasm0$1(sig, wasm$1.__wbindgen_malloc);
  const [ptr1, len1] = passArray8ToWasm0$1(m2, wasm$1.__wbindgen_malloc);
  const [ptr2, len2] = passArray8ToWasm0$1(w2, wasm$1.__wbindgen_malloc);
  const ret = wasm$1.bls_verify(ptr0, len0, ptr1, len1, ptr2, len2);
  return ret;
}
async function load$1(module2, imports) {
  if (typeof Response === "function" && module2 instanceof Response) {
    const bytes2 = await module2.arrayBuffer();
    return await WebAssembly.instantiate(bytes2, imports);
  } else {
    const instance = await WebAssembly.instantiate(module2, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module: module2 };
    } else {
      return instance;
    }
  }
}
async function init$e() {
  const imports = {};
  const { instance, module: module2 } = await load$1(wasmBytes$1, imports);
  wasm$1 = instance.exports;
  init$e.__wbindgen_wasm_module = module2;
  return wasm$1;
}
let verify$1;
async function blsVerify$1(pk2, sig, msg) {
  if (!verify$1) {
    await init$e();
    if (bls_init$1() !== 0) {
      throw new Error("Cannot initialize BLS");
    }
    verify$1 = (pk1, sig1, msg1) => {
      return bls_verify$1(sig1, msg1, pk1) === 0;
    };
  }
  return verify$1(pk2, sig, msg);
}
class UnverifiedCertificateError extends AgentError$1 {
  constructor() {
    super(`Cannot lookup unverified certificate. Call 'verify()' first.`);
  }
}
function hashTreeToString(tree) {
  const indent = (s) => s.split("\n").map((x2) => "  " + x2).join("\n");
  function labelToString(label) {
    const decoder2 = new TextDecoder(void 0, { fatal: true });
    try {
      return JSON.stringify(decoder2.decode(label));
    } catch (e2) {
      return `data(...${label.byteLength} bytes)`;
    }
  }
  switch (tree[0]) {
    case 0:
      return "()";
    case 1: {
      const left2 = hashTreeToString(tree[1]);
      const right2 = hashTreeToString(tree[2]);
      return `sub(
 left:
${indent(left2)}
---
 right:
${indent(right2)}
)`;
    }
    case 2: {
      const label = labelToString(tree[1]);
      const sub = hashTreeToString(tree[2]);
      return `label(
 label:
${indent(label)}
 sub:
${indent(sub)}
)`;
    }
    case 3: {
      return `leaf(...${tree[1].byteLength} bytes)`;
    }
    case 4: {
      return `pruned(${blobToHex(blobFromUint8Array(new Uint8Array(tree[1])))}`;
    }
    default: {
      return `unknown(${JSON.stringify(tree[0])})`;
    }
  }
}
function isBufferEqual$1(a, b2) {
  if (a.length !== b2.length) {
    return false;
  }
  for (let i2 = 0; i2 < a.length; i2++) {
    if (a[i2] !== b2[i2]) {
      return false;
    }
  }
  return true;
}
class Certificate$1 {
  constructor(response, _agent = getDefaultAgent$1()) {
    this._agent = _agent;
    this.verified = false;
    this._rootKey = null;
    this.cert = decode$3(response.certificate);
  }
  lookupEx(path) {
    this.checkState();
    return lookupPathEx(path, this.cert.tree);
  }
  lookup(path) {
    this.checkState();
    return lookup_path$1(path, this.cert.tree);
  }
  async verify() {
    const rootHash = await reconstruct$1(this.cert.tree);
    const derKey = await this._checkDelegation(this.cert.delegation);
    const sig = this.cert.signature;
    const key = extractDER$1(derKey);
    const msg = buffer$1.Buffer.concat([domain_sep$1("ic-state-root"), rootHash]);
    const res = await blsVerify$1(key, sig, msg);
    this.verified = res;
    return res;
  }
  checkState() {
    if (!this.verified) {
      throw new UnverifiedCertificateError();
    }
  }
  async _checkDelegation(d2) {
    if (!d2) {
      if (!this._rootKey) {
        if (this._agent.rootKey) {
          this._rootKey = this._agent.rootKey;
          return this._rootKey;
        }
        throw new Error(`Agent does not have a rootKey. Do you need to call 'fetchRootKey'?`);
      }
      return this._rootKey;
    }
    const cert = new Certificate$1(d2, this._agent);
    if (!await cert.verify()) {
      throw new Error("fail to verify delegation certificate");
    }
    const lookup2 = cert.lookupEx(["subnet", d2.subnet_id, "public_key"]);
    if (!lookup2) {
      throw new Error(`Could not find subnet key for subnet 0x${d2.subnet_id.toString("hex")}`);
    }
    return buffer$1.Buffer.from(lookup2);
  }
}
const DER_PREFIX$1 = buffer$1.Buffer.from("308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100", "hex");
const KEY_LENGTH$1 = 96;
function extractDER$1(buf) {
  const expectedLength = DER_PREFIX$1.length + KEY_LENGTH$1;
  if (buf.length !== expectedLength) {
    throw new TypeError(`BLS DER-encoded public key must be ${expectedLength} bytes long`);
  }
  const prefix2 = buf.slice(0, DER_PREFIX$1.length);
  if (!isBufferEqual$1(prefix2, DER_PREFIX$1)) {
    throw new TypeError(`BLS DER-encoded public key is invalid. Expect the following prefix: ${DER_PREFIX$1}, but get ${prefix2}`);
  }
  return buf.slice(DER_PREFIX$1.length);
}
async function reconstruct$1(t2) {
  switch (t2[0]) {
    case 0:
      return hash$1(domain_sep$1("ic-hashtree-empty"));
    case 4:
      return buffer$1.Buffer.from(t2[1]);
    case 3:
      return hash$1(buffer$1.Buffer.concat([
        domain_sep$1("ic-hashtree-leaf"),
        buffer$1.Buffer.from(t2[1])
      ]));
    case 2:
      return hash$1(buffer$1.Buffer.concat([
        domain_sep$1("ic-hashtree-labeled"),
        buffer$1.Buffer.from(t2[1]),
        buffer$1.Buffer.from(await reconstruct$1(t2[2]))
      ]));
    case 1:
      return hash$1(buffer$1.Buffer.concat([
        domain_sep$1("ic-hashtree-fork"),
        buffer$1.Buffer.from(await reconstruct$1(t2[1])),
        buffer$1.Buffer.from(await reconstruct$1(t2[2]))
      ]));
    default:
      throw new Error("unreachable");
  }
}
function domain_sep$1(s) {
  const buf = buffer$1.Buffer.alloc(1);
  buf.writeUInt8(s.length, 0);
  return buffer$1.Buffer.concat([buf, buffer$1.Buffer.from(s)]);
}
function lookupPathEx(path, tree) {
  const maybeReturn = lookup_path$1(path.map((p2) => {
    if (typeof p2 === "string") {
      return blobFromText(p2);
    } else {
      return blobFromUint8Array(new Uint8Array(p2));
    }
  }), tree);
  return maybeReturn && blobToUint8Array(blobFromBuffer(maybeReturn));
}
function lookup_path$1(path, tree) {
  if (path.length === 0) {
    switch (tree[0]) {
      case 3: {
        return buffer$1.Buffer.from(tree[1]);
      }
      default: {
        return void 0;
      }
    }
  }
  const t2 = find_label$1(path[0], flatten_forks$1(tree));
  if (t2) {
    return lookup_path$1(path.slice(1), t2);
  }
}
function flatten_forks$1(t2) {
  switch (t2[0]) {
    case 0:
      return [];
    case 1:
      return flatten_forks$1(t2[1]).concat(flatten_forks$1(t2[2]));
    default:
      return [t2];
  }
}
function find_label$1(l2, trees) {
  if (trees.length === 0) {
    return void 0;
  }
  for (const t2 of trees) {
    if (t2[0] === 2) {
      const p2 = buffer$1.Buffer.from(t2[1]);
      if (isBufferEqual$1(l2, p2)) {
        return t2[2];
      }
    }
  }
}
const FIVE_MINUTES_IN_MSEC$1 = 5 * 60 * 1e3;
function defaultStrategy$1() {
  return chain$1(conditionalDelay$1(once$1(), 1e3), backoff$1(1e3, 1.2), timeout$2(FIVE_MINUTES_IN_MSEC$1));
}
function once$1() {
  let first = true;
  return async () => {
    if (first) {
      first = false;
      return true;
    }
    return false;
  };
}
function conditionalDelay$1(condition, timeInMsec) {
  return async (canisterId, requestId, status) => {
    if (await condition(canisterId, requestId, status)) {
      return new Promise((resolve) => setTimeout(resolve, timeInMsec));
    }
  };
}
function maxAttempts(count) {
  let attempts = count;
  return async (canisterId, requestId, status) => {
    if (--attempts <= 0) {
      throw new Error(`Failed to retrieve a reply for request after ${count} attempts:
  Request ID: ${toHex$1(requestId)}
  Request status: ${status}
`);
    }
  };
}
function throttle(throttleInMsec) {
  return () => new Promise((resolve) => setTimeout(resolve, throttleInMsec));
}
function timeout$2(timeInMsec) {
  const end = Date.now() + timeInMsec;
  return async (canisterId, requestId, status) => {
    if (Date.now() > end) {
      throw new Error(`Request timed out after ${timeInMsec} msec:
  Request ID: ${toHex$1(requestId)}
  Request status: ${status}
`);
    }
  };
}
function backoff$1(startingThrottleInMsec, backoffFactor) {
  let currentThrottling = startingThrottleInMsec;
  return () => new Promise((resolve) => setTimeout(() => {
    currentThrottling *= backoffFactor;
    resolve();
  }, currentThrottling));
}
function chain$1(...strategies) {
  return async (canisterId, requestId, status) => {
    for (const a of strategies) {
      await a(canisterId, requestId, status);
    }
  };
}
const strategy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  defaultStrategy: defaultStrategy$1,
  once: once$1,
  conditionalDelay: conditionalDelay$1,
  maxAttempts,
  throttle,
  timeout: timeout$2,
  backoff: backoff$1,
  chain: chain$1
}, Symbol.toStringTag, { value: "Module" }));
async function pollForResponse$1(agent, canisterId, requestId, strategy2) {
  const path = [blobFromText("request_status"), requestId];
  const state = await agent.readState(canisterId, { paths: [path] });
  const cert = new Certificate$1(state, agent);
  const verified = await cert.verify();
  if (!verified) {
    throw new Error("Fail to verify certificate");
  }
  const maybeBuf = cert.lookup([...path, blobFromText("status")]);
  let status;
  if (typeof maybeBuf === "undefined") {
    status = RequestStatusResponseStatus$1.Unknown;
  } else {
    status = maybeBuf.toString();
  }
  switch (status) {
    case RequestStatusResponseStatus$1.Replied: {
      return cert.lookup([...path, blobFromText("reply")]);
    }
    case RequestStatusResponseStatus$1.Received:
    case RequestStatusResponseStatus$1.Unknown:
    case RequestStatusResponseStatus$1.Processing:
      await strategy2(canisterId, requestId, status);
      return pollForResponse$1(agent, canisterId, requestId, strategy2);
    case RequestStatusResponseStatus$1.Rejected: {
      const rejectCode = cert.lookup([...path, blobFromText("reject_code")]).toString();
      const rejectMessage = cert.lookup([...path, blobFromText("reject_message")]).toString();
      throw new Error(`Call was rejected:
  Request ID: ${toHex$1(requestId)}
  Reject code: ${rejectCode}
  Reject text: ${rejectMessage}
`);
    }
    case RequestStatusResponseStatus$1.Done:
      throw new Error(`Call was marked as done but we never saw the reply:
  Request ID: ${toHex$1(requestId)}
`);
  }
  throw new Error("unreachable");
}
const index$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  pollForResponse: pollForResponse$1,
  strategy,
  defaultStrategy: defaultStrategy$1
}, Symbol.toStringTag, { value: "Module" }));
class ActorCallError$1 extends AgentError$1 {
  constructor(canisterId, methodName, type, props) {
    super([
      `Call failed:`,
      `  Canister: ${canisterId.toText()}`,
      `  Method: ${methodName} (${type})`,
      ...Object.getOwnPropertyNames(props).map((n2) => `  "${n2}": ${JSON.stringify(props[n2])}`)
    ].join("\n"));
    this.canisterId = canisterId;
    this.methodName = methodName;
    this.type = type;
    this.props = props;
  }
}
class QueryCallRejectedError$1 extends ActorCallError$1 {
  constructor(canisterId, methodName, result) {
    var _a;
    super(canisterId, methodName, "query", {
      Status: result.status,
      Code: (_a = ReplicaRejectCode$1[result.reject_code]) !== null && _a !== void 0 ? _a : `Unknown Code "${result.reject_code}"`,
      Message: result.reject_message
    });
    this.result = result;
  }
}
class UpdateCallRejectedError$1 extends ActorCallError$1 {
  constructor(canisterId, methodName, requestId, response) {
    super(canisterId, methodName, "update", {
      "Request ID": toHex$1(requestId),
      "HTTP status code": response.status.toString(),
      "HTTP status text": response.statusText
    });
    this.requestId = requestId;
    this.response = response;
  }
}
var CanisterInstallMode$1;
(function(CanisterInstallMode2) {
  CanisterInstallMode2["Install"] = "install";
  CanisterInstallMode2["Reinstall"] = "reinstall";
  CanisterInstallMode2["Upgrade"] = "upgrade";
})(CanisterInstallMode$1 || (CanisterInstallMode$1 = {}));
const metadataSymbol$1 = Symbol.for("ic-agent-metadata");
class Actor$1 {
  constructor(metadata) {
    this[metadataSymbol$1] = Object.freeze(metadata);
  }
  static agentOf(actor) {
    return actor[metadataSymbol$1].config.agent;
  }
  static interfaceOf(actor) {
    return actor[metadataSymbol$1].service;
  }
  static canisterIdOf(actor) {
    return Principal$2.from(actor[metadataSymbol$1].config.canisterId);
  }
  static async install(fields, config) {
    const mode = fields.mode === void 0 ? CanisterInstallMode$1.Install : fields.mode;
    const arg = fields.arg ? [...fields.arg] : [];
    const wasmModule = [...fields.module];
    const canisterId = typeof config.canisterId === "string" ? Principal$2.fromText(config.canisterId) : config.canisterId;
    await getManagementCanister$1(config).install_code({
      mode: { [mode]: null },
      arg,
      wasm_module: wasmModule,
      canister_id: canisterId
    });
  }
  static async createCanister(config) {
    const { canister_id: canisterId } = await getManagementCanister$1(config || {}).provisional_create_canister_with_cycles({ amount: [], settings: [] });
    return canisterId;
  }
  static async createAndInstallCanister(interfaceFactory, fields, config) {
    const canisterId = await this.createCanister(config);
    await this.install(Object.assign({}, fields), Object.assign(Object.assign({}, config), { canisterId }));
    return this.createActor(interfaceFactory, Object.assign(Object.assign({}, config), { canisterId }));
  }
  static createActorClass(interfaceFactory) {
    const service = interfaceFactory({ IDL: IDL$1 });
    class CanisterActor extends Actor$1 {
      constructor(config) {
        const canisterId = typeof config.canisterId === "string" ? Principal$2.fromText(config.canisterId) : config.canisterId;
        super({
          config: Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG$1), config), { canisterId }),
          service
        });
        for (const [methodName, func] of service._fields) {
          this[methodName] = _createActorMethod$1(this, methodName, func);
        }
      }
    }
    return CanisterActor;
  }
  static createActor(interfaceFactory, configuration) {
    return new (this.createActorClass(interfaceFactory))(configuration);
  }
}
function decodeReturnValue$1(types, msg) {
  const returnValues = decode$4(types, buffer$1.Buffer.from(msg));
  switch (returnValues.length) {
    case 0:
      return void 0;
    case 1:
      return returnValues[0];
    default:
      return returnValues;
  }
}
const DEFAULT_ACTOR_CONFIG$1 = {
  pollingStrategyFactory: defaultStrategy$1
};
function _createActorMethod$1(actor, methodName, func) {
  let caller;
  if (func.annotations.includes("query")) {
    caller = async (options, ...args) => {
      var _a, _b;
      options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol$1].config).queryTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol$1].config), options)));
      const agent = options.agent || actor[metadataSymbol$1].config.agent || getDefaultAgent$1();
      const cid = Principal$2.from(options.canisterId || actor[metadataSymbol$1].config.canisterId);
      const arg = encode$3(func.argTypes, args);
      const result = await agent.query(cid, { methodName, arg });
      switch (result.status) {
        case "rejected":
          throw new QueryCallRejectedError$1(cid, methodName, result);
        case "replied":
          return decodeReturnValue$1(func.retTypes, result.reply.arg);
      }
    };
  } else {
    caller = async (options, ...args) => {
      var _a, _b;
      options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol$1].config).callTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol$1].config), options)));
      const agent = options.agent || actor[metadataSymbol$1].config.agent || getDefaultAgent$1();
      const { canisterId, effectiveCanisterId, pollingStrategyFactory } = Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG$1), actor[metadataSymbol$1].config), options);
      const cid = Principal$2.from(canisterId);
      const ecid = effectiveCanisterId !== void 0 ? Principal$2.from(effectiveCanisterId) : cid;
      const arg = encode$3(func.argTypes, args);
      const { requestId, response } = await agent.call(cid, {
        methodName,
        arg,
        effectiveCanisterId: ecid
      });
      if (!response.ok) {
        throw new UpdateCallRejectedError$1(cid, methodName, requestId, response);
      }
      const pollStrategy = pollingStrategyFactory();
      const responseBytes = await pollForResponse$1(agent, ecid, requestId, pollStrategy);
      if (responseBytes !== void 0) {
        return decodeReturnValue$1(func.retTypes, responseBytes);
      } else if (func.retTypes.length === 0) {
        return void 0;
      } else {
        throw new Error(`Call was returned undefined, but type [${func.retTypes.join(",")}].`);
      }
    };
  }
  const handler = (...args) => caller({}, ...args);
  handler.withOptions = (options) => (...args) => caller(options, ...args);
  return handler;
}
const assetCanister = ({ IDL: IDL2 }) => {
  return IDL2.Service({
    retrieve: IDL2.Func([IDL2.Text], [IDL2.Vec(IDL2.Nat8)], ["query"]),
    store: IDL2.Func([IDL2.Text, IDL2.Vec(IDL2.Nat8)], [], [])
  });
};
function createAssetCanisterActor(config) {
  return Actor$1.createActor(assetCanister, config);
}
const esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  polling: index$1,
  Cbor: cbor,
  ActorCallError: ActorCallError$1,
  QueryCallRejectedError: QueryCallRejectedError$1,
  UpdateCallRejectedError: UpdateCallRejectedError$1,
  get CanisterInstallMode() {
    return CanisterInstallMode$1;
  },
  Actor: Actor$1,
  get ReplicaRejectCode() {
    return ReplicaRejectCode$1;
  },
  Expiry: Expiry$1,
  makeNonceTransform: makeNonceTransform$1,
  makeExpiryTransform,
  get RequestStatusResponseStatus() {
    return RequestStatusResponseStatus$1;
  },
  HttpAgent: HttpAgent$1,
  get ProxyMessageKind() {
    return ProxyMessageKind$1;
  },
  ProxyStubAgent,
  ProxyAgent,
  getDefaultAgent: getDefaultAgent$1,
  SignIdentity,
  AnonymousIdentity: AnonymousIdentity$1,
  createIdentityDescriptor,
  isIdentityDescriptor,
  UnverifiedCertificateError,
  hashTreeToString,
  Certificate: Certificate$1,
  reconstruct: reconstruct$1,
  lookupPathEx,
  lookup_path: lookup_path$1,
  get SubmitRequestType() {
    return SubmitRequestType$1;
  },
  createAssetCanisterActor,
  getManagementCanister: getManagementCanister$1,
  toHex: toHex$1,
  hash: hash$1,
  requestIdOf: requestIdOf$1,
  get verify() {
    return verify$1;
  },
  blsVerify: blsVerify$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$5 = /* @__PURE__ */ getAugmentedNamespace(esm);
const require$$4 = /* @__PURE__ */ getAugmentedNamespace(esm$1);
var browserPonyfill = { exports: {} };
(function(module2, exports2) {
  var global2 = typeof self !== "undefined" ? self : commonjsGlobal;
  var __self__ = function() {
    function F2() {
      this.fetch = false;
      this.DOMException = global2.DOMException;
    }
    F2.prototype = global2;
    return new F2();
  }();
  (function(self2) {
    (function(exports3) {
      var support = {
        searchParams: "URLSearchParams" in self2,
        iterable: "Symbol" in self2 && "iterator" in Symbol,
        blob: "FileReader" in self2 && "Blob" in self2 && function() {
          try {
            new Blob();
            return true;
          } catch (e2) {
            return false;
          }
        }(),
        formData: "FormData" in self2,
        arrayBuffer: "ArrayBuffer" in self2
      };
      function isDataView(obj) {
        return obj && DataView.prototype.isPrototypeOf(obj);
      }
      if (support.arrayBuffer) {
        var viewClasses = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ];
        var isArrayBufferView2 = ArrayBuffer.isView || function(obj) {
          return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
        };
      }
      function normalizeName(name) {
        if (typeof name !== "string") {
          name = String(name);
        }
        if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
          throw new TypeError("Invalid character in header field name");
        }
        return name.toLowerCase();
      }
      function normalizeValue(value2) {
        if (typeof value2 !== "string") {
          value2 = String(value2);
        }
        return value2;
      }
      function iteratorFor(items) {
        var iterator = {
          next: function() {
            var value2 = items.shift();
            return { done: value2 === void 0, value: value2 };
          }
        };
        if (support.iterable) {
          iterator[Symbol.iterator] = function() {
            return iterator;
          };
        }
        return iterator;
      }
      function Headers(headers) {
        this.map = {};
        if (headers instanceof Headers) {
          headers.forEach(function(value2, name) {
            this.append(name, value2);
          }, this);
        } else if (Array.isArray(headers)) {
          headers.forEach(function(header) {
            this.append(header[0], header[1]);
          }, this);
        } else if (headers) {
          Object.getOwnPropertyNames(headers).forEach(function(name) {
            this.append(name, headers[name]);
          }, this);
        }
      }
      Headers.prototype.append = function(name, value2) {
        name = normalizeName(name);
        value2 = normalizeValue(value2);
        var oldValue = this.map[name];
        this.map[name] = oldValue ? oldValue + ", " + value2 : value2;
      };
      Headers.prototype["delete"] = function(name) {
        delete this.map[normalizeName(name)];
      };
      Headers.prototype.get = function(name) {
        name = normalizeName(name);
        return this.has(name) ? this.map[name] : null;
      };
      Headers.prototype.has = function(name) {
        return this.map.hasOwnProperty(normalizeName(name));
      };
      Headers.prototype.set = function(name, value2) {
        this.map[normalizeName(name)] = normalizeValue(value2);
      };
      Headers.prototype.forEach = function(callback, thisArg) {
        for (var name in this.map) {
          if (this.map.hasOwnProperty(name)) {
            callback.call(thisArg, this.map[name], name, this);
          }
        }
      };
      Headers.prototype.keys = function() {
        var items = [];
        this.forEach(function(value2, name) {
          items.push(name);
        });
        return iteratorFor(items);
      };
      Headers.prototype.values = function() {
        var items = [];
        this.forEach(function(value2) {
          items.push(value2);
        });
        return iteratorFor(items);
      };
      Headers.prototype.entries = function() {
        var items = [];
        this.forEach(function(value2, name) {
          items.push([name, value2]);
        });
        return iteratorFor(items);
      };
      if (support.iterable) {
        Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
      }
      function consumed(body) {
        if (body.bodyUsed) {
          return Promise.reject(new TypeError("Already read"));
        }
        body.bodyUsed = true;
      }
      function fileReaderReady(reader) {
        return new Promise(function(resolve, reject) {
          reader.onload = function() {
            resolve(reader.result);
          };
          reader.onerror = function() {
            reject(reader.error);
          };
        });
      }
      function readBlobAsArrayBuffer(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsArrayBuffer(blob);
        return promise;
      }
      function readBlobAsText(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsText(blob);
        return promise;
      }
      function readArrayBufferAsText(buf) {
        var view = new Uint8Array(buf);
        var chars = new Array(view.length);
        for (var i2 = 0; i2 < view.length; i2++) {
          chars[i2] = String.fromCharCode(view[i2]);
        }
        return chars.join("");
      }
      function bufferClone(buf) {
        if (buf.slice) {
          return buf.slice(0);
        } else {
          var view = new Uint8Array(buf.byteLength);
          view.set(new Uint8Array(buf));
          return view.buffer;
        }
      }
      function Body() {
        this.bodyUsed = false;
        this._initBody = function(body) {
          this._bodyInit = body;
          if (!body) {
            this._bodyText = "";
          } else if (typeof body === "string") {
            this._bodyText = body;
          } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
            this._bodyBlob = body;
          } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
            this._bodyFormData = body;
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this._bodyText = body.toString();
          } else if (support.arrayBuffer && support.blob && isDataView(body)) {
            this._bodyArrayBuffer = bufferClone(body.buffer);
            this._bodyInit = new Blob([this._bodyArrayBuffer]);
          } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView2(body))) {
            this._bodyArrayBuffer = bufferClone(body);
          } else {
            this._bodyText = body = Object.prototype.toString.call(body);
          }
          if (!this.headers.get("content-type")) {
            if (typeof body === "string") {
              this.headers.set("content-type", "text/plain;charset=UTF-8");
            } else if (this._bodyBlob && this._bodyBlob.type) {
              this.headers.set("content-type", this._bodyBlob.type);
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
            }
          }
        };
        if (support.blob) {
          this.blob = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return Promise.resolve(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as blob");
            } else {
              return Promise.resolve(new Blob([this._bodyText]));
            }
          };
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
            } else {
              return this.blob().then(readBlobAsArrayBuffer);
            }
          };
        }
        this.text = function() {
          var rejected = consumed(this);
          if (rejected) {
            return rejected;
          }
          if (this._bodyBlob) {
            return readBlobAsText(this._bodyBlob);
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
          } else if (this._bodyFormData) {
            throw new Error("could not read FormData body as text");
          } else {
            return Promise.resolve(this._bodyText);
          }
        };
        if (support.formData) {
          this.formData = function() {
            return this.text().then(decode2);
          };
        }
        this.json = function() {
          return this.text().then(JSON.parse);
        };
        return this;
      }
      var methods2 = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function normalizeMethod(method2) {
        var upcased = method2.toUpperCase();
        return methods2.indexOf(upcased) > -1 ? upcased : method2;
      }
      function Request(input, options) {
        options = options || {};
        var body = options.body;
        if (input instanceof Request) {
          if (input.bodyUsed) {
            throw new TypeError("Already read");
          }
          this.url = input.url;
          this.credentials = input.credentials;
          if (!options.headers) {
            this.headers = new Headers(input.headers);
          }
          this.method = input.method;
          this.mode = input.mode;
          this.signal = input.signal;
          if (!body && input._bodyInit != null) {
            body = input._bodyInit;
            input.bodyUsed = true;
          }
        } else {
          this.url = String(input);
        }
        this.credentials = options.credentials || this.credentials || "same-origin";
        if (options.headers || !this.headers) {
          this.headers = new Headers(options.headers);
        }
        this.method = normalizeMethod(options.method || this.method || "GET");
        this.mode = options.mode || this.mode || null;
        this.signal = options.signal || this.signal;
        this.referrer = null;
        if ((this.method === "GET" || this.method === "HEAD") && body) {
          throw new TypeError("Body not allowed for GET or HEAD requests");
        }
        this._initBody(body);
      }
      Request.prototype.clone = function() {
        return new Request(this, { body: this._bodyInit });
      };
      function decode2(body) {
        var form = new FormData();
        body.trim().split("&").forEach(function(bytes2) {
          if (bytes2) {
            var split = bytes2.split("=");
            var name = split.shift().replace(/\+/g, " ");
            var value2 = split.join("=").replace(/\+/g, " ");
            form.append(decodeURIComponent(name), decodeURIComponent(value2));
          }
        });
        return form;
      }
      function parseHeaders2(rawHeaders) {
        var headers = new Headers();
        var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
        preProcessedHeaders.split(/\r?\n/).forEach(function(line2) {
          var parts = line2.split(":");
          var key = parts.shift().trim();
          if (key) {
            var value2 = parts.join(":").trim();
            headers.append(key, value2);
          }
        });
        return headers;
      }
      Body.call(Request.prototype);
      function Response2(bodyInit, options) {
        if (!options) {
          options = {};
        }
        this.type = "default";
        this.status = options.status === void 0 ? 200 : options.status;
        this.ok = this.status >= 200 && this.status < 300;
        this.statusText = "statusText" in options ? options.statusText : "OK";
        this.headers = new Headers(options.headers);
        this.url = options.url || "";
        this._initBody(bodyInit);
      }
      Body.call(Response2.prototype);
      Response2.prototype.clone = function() {
        return new Response2(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new Headers(this.headers),
          url: this.url
        });
      };
      Response2.error = function() {
        var response = new Response2(null, { status: 0, statusText: "" });
        response.type = "error";
        return response;
      };
      var redirectStatuses = [301, 302, 303, 307, 308];
      Response2.redirect = function(url2, status) {
        if (redirectStatuses.indexOf(status) === -1) {
          throw new RangeError("Invalid status code");
        }
        return new Response2(null, { status, headers: { location: url2 } });
      };
      exports3.DOMException = self2.DOMException;
      try {
        new exports3.DOMException();
      } catch (err) {
        exports3.DOMException = function(message, name) {
          this.message = message;
          this.name = name;
          var error = Error(message);
          this.stack = error.stack;
        };
        exports3.DOMException.prototype = Object.create(Error.prototype);
        exports3.DOMException.prototype.constructor = exports3.DOMException;
      }
      function fetch2(input, init2) {
        return new Promise(function(resolve, reject) {
          var request2 = new Request(input, init2);
          if (request2.signal && request2.signal.aborted) {
            return reject(new exports3.DOMException("Aborted", "AbortError"));
          }
          var xhr2 = new XMLHttpRequest();
          function abortXhr() {
            xhr2.abort();
          }
          xhr2.onload = function() {
            var options = {
              status: xhr2.status,
              statusText: xhr2.statusText,
              headers: parseHeaders2(xhr2.getAllResponseHeaders() || "")
            };
            options.url = "responseURL" in xhr2 ? xhr2.responseURL : options.headers.get("X-Request-URL");
            var body = "response" in xhr2 ? xhr2.response : xhr2.responseText;
            resolve(new Response2(body, options));
          };
          xhr2.onerror = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr2.ontimeout = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr2.onabort = function() {
            reject(new exports3.DOMException("Aborted", "AbortError"));
          };
          xhr2.open(request2.method, request2.url, true);
          if (request2.credentials === "include") {
            xhr2.withCredentials = true;
          } else if (request2.credentials === "omit") {
            xhr2.withCredentials = false;
          }
          if ("responseType" in xhr2 && support.blob) {
            xhr2.responseType = "blob";
          }
          request2.headers.forEach(function(value2, name) {
            xhr2.setRequestHeader(name, value2);
          });
          if (request2.signal) {
            request2.signal.addEventListener("abort", abortXhr);
            xhr2.onreadystatechange = function() {
              if (xhr2.readyState === 4) {
                request2.signal.removeEventListener("abort", abortXhr);
              }
            };
          }
          xhr2.send(typeof request2._bodyInit === "undefined" ? null : request2._bodyInit);
        });
      }
      fetch2.polyfill = true;
      if (!self2.fetch) {
        self2.fetch = fetch2;
        self2.Headers = Headers;
        self2.Request = Request;
        self2.Response = Response2;
      }
      exports3.Headers = Headers;
      exports3.Request = Request;
      exports3.Response = Response2;
      exports3.fetch = fetch2;
      Object.defineProperty(exports3, "__esModule", { value: true });
      return exports3;
    })({});
  })(__self__);
  __self__.fetch.ponyfill = true;
  delete __self__.fetch.polyfill;
  var ctx = __self__;
  exports2 = ctx.fetch;
  exports2.default = ctx.fetch;
  exports2.fetch = ctx.fetch;
  exports2.Headers = ctx.Headers;
  exports2.Request = ctx.Request;
  exports2.Response = ctx.Response;
  module2.exports = exports2;
})(browserPonyfill, browserPonyfill.exports);
var ext = {};
var ext_did = {};
Object.defineProperty(ext_did, "__esModule", { value: true });
ext_did.init = void 0;
ext_did.default = ({ IDL: IDL2 }) => {
  const TokenIndex = IDL2.Nat32;
  const AccountIdentifier = IDL2.Text;
  const TokenIdentifier = IDL2.Text;
  const Balance = IDL2.Nat;
  const Time = IDL2.Int;
  const SubAccount = IDL2.Vec(IDL2.Nat8);
  const Memo = IDL2.Vec(IDL2.Nat8);
  const Listing = IDL2.Record({
    locked: IDL2.Opt(Time),
    seller: IDL2.Principal,
    price: IDL2.Nat64
  });
  const User = IDL2.Variant({
    principal: IDL2.Principal,
    address: AccountIdentifier
  });
  const CommonError = IDL2.Variant({
    InvalidToken: TokenIdentifier,
    Other: IDL2.Text
  });
  const BalanceRequest = IDL2.Record({
    token: TokenIdentifier,
    user: User
  });
  const BalanceResult = IDL2.Variant({ ok: Balance, err: CommonError });
  const DetailsResult = IDL2.Variant({
    ok: IDL2.Tuple(AccountIdentifier, IDL2.Opt(Listing)),
    err: CommonError
  });
  const TokensResult = IDL2.Variant({
    ok: IDL2.Vec(TokenIndex),
    err: CommonError
  });
  const TokenExtResult = IDL2.Variant({
    ok: IDL2.Vec(IDL2.Tuple(TokenIndex, IDL2.Opt(Listing), IDL2.Opt(IDL2.Vec(IDL2.Nat8)))),
    err: CommonError
  });
  const TransferRequest = IDL2.Record({
    to: User,
    token: TokenIdentifier,
    notify: IDL2.Bool,
    from: User,
    memo: Memo,
    subaccount: IDL2.Opt(SubAccount),
    amount: Balance,
    fee: IDL2.Nat
  });
  const TransferResult = IDL2.Variant({
    ok: Balance,
    err: IDL2.Variant({
      CannotNotify: AccountIdentifier,
      InsufficientBalance: IDL2.Null,
      InvalidToken: TokenIdentifier,
      Rejected: IDL2.Null,
      Unauthorized: AccountIdentifier,
      Other: IDL2.Text
    })
  });
  const Metadata = IDL2.Variant({
    fungible: IDL2.Record({
      decimals: IDL2.Nat8,
      metadata: IDL2.Opt(IDL2.Vec(IDL2.Nat8)),
      name: IDL2.Text,
      symbol: IDL2.Text
    }),
    nonfungible: IDL2.Record({ metadata: IDL2.Opt(IDL2.Vec(IDL2.Nat8)) })
  });
  const MetadataResult = IDL2.Variant({ ok: Metadata, err: CommonError });
  const SupplyResult = IDL2.Variant({ ok: Balance, err: CommonError });
  return IDL2.Service({
    extensions: IDL2.Func([], [IDL2.Vec(IDL2.Text)], ["query"]),
    balance: IDL2.Func([BalanceRequest], [BalanceResult], ["query"]),
    details: IDL2.Func([TokenIdentifier], [DetailsResult], ["query"]),
    tokens: IDL2.Func([AccountIdentifier], [TokensResult], ["query"]),
    tokens_ext: IDL2.Func([AccountIdentifier], [TokenExtResult], ["query"]),
    transfer: IDL2.Func([TransferRequest], [TransferResult], []),
    metadata: IDL2.Func([TokenIdentifier], [MetadataResult], ["query"]),
    supply: IDL2.Func([TokenIdentifier], [SupplyResult], ["query"])
  });
};
const init$d = () => {
  return [];
};
ext_did.init = init$d;
var _default = {};
Object.defineProperty(_default, "__esModule", { value: true });
class NFT {
  constructor(canisterId, agent) {
    this.agent = agent;
    this.canisterId = canisterId;
  }
}
_default.default = NFT;
var account = {};
var cryptoJs = { exports: {} };
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var core = { exports: {} };
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasRequiredCore;
function requireCore() {
  if (hasRequiredCore)
    return core.exports;
  hasRequiredCore = 1;
  (function(module2, exports2) {
    (function(root2, factory) {
      {
        module2.exports = factory();
      }
    })(commonjsGlobal, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined$1) {
        var crypto2;
        if (typeof window !== "undefined" && window.crypto) {
          crypto2 = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto2 = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto2 = globalThis.crypto;
        }
        if (!crypto2 && typeof window !== "undefined" && window.msCrypto) {
          crypto2 = window.msCrypto;
        }
        if (!crypto2 && typeof commonjsGlobal !== "undefined" && commonjsGlobal.crypto) {
          crypto2 = commonjsGlobal.crypto;
        }
        if (!crypto2 && typeof commonjsRequire === "function") {
          try {
            crypto2 = require$$0;
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto2) {
            if (typeof crypto2.getRandomValues === "function") {
              try {
                return crypto2.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto2.randomBytes === "function") {
              try {
                return crypto2.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create2 = Object.create || function() {
          function F2() {
          }
          return function(obj) {
            var subtype;
            F2.prototype = obj;
            subtype = new F2();
            F2.prototype = null;
            return subtype;
          };
        }();
        var C2 = {};
        var C_lib = C2.lib = {};
        var Base = C_lib.Base = function() {
          return {
            extend: function(overrides) {
              var subtype = create2(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            init: function() {
            },
            mixIn: function(properties2) {
              for (var propertyName in properties2) {
                if (properties2.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties2[propertyName];
                }
              }
              if (properties2.hasOwnProperty("toString")) {
                this.toString = properties2.toString;
              }
            },
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined$1) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          toString: function(encoder2) {
            return (encoder2 || Hex).stringify(this);
          },
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i2 = 0; i2 < thatSigBytes; i2++) {
                var thatByte = thatWords[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
                thisWords[thisSigBytes + i2 >>> 2] |= thatByte << 24 - (thisSigBytes + i2) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          clone: function() {
            var clone2 = Base.clone.call(this);
            clone2.words = this.words.slice(0);
            return clone2;
          },
          random: function(nBytes) {
            var words = [];
            for (var i2 = 0; i2 < nBytes; i2 += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C2.enc = {};
        var Hex = C_enc.Hex = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i2 = 0; i2 < sigBytes; i2++) {
              var bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i2 = 0; i2 < hexStrLength; i2 += 2) {
              words[i2 >>> 3] |= parseInt(hexStr.substr(i2, 2), 16) << 24 - i2 % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2++) {
              var bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i2 = 0; i2 < latin1StrLength; i2++) {
              words[i2 >>> 2] |= (latin1Str.charCodeAt(i2) & 255) << 24 - i2 % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e2) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          _append: function(data2) {
            if (typeof data2 == "string") {
              data2 = Utf8.parse(data2);
            }
            this._data.concat(data2);
            this._nDataBytes += data2.sigBytes;
          },
          _process: function(doFlush) {
            var processedWords;
            var data2 = this._data;
            var dataWords = data2.words;
            var dataSigBytes = data2.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data2.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          clone: function() {
            var clone2 = Base.clone.call(this);
            clone2._data = this._data.clone();
            return clone2;
          },
          _minBufferSize: 0
        });
        C_lib.Hasher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash2 = this._doFinalize();
            return hash2;
          },
          blockSize: 512 / 32,
          _createHelper: function(hasher3) {
            return function(message, cfg) {
              return new hasher3.init(cfg).finalize(message);
            };
          },
          _createHmacHelper: function(hasher3) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher3, key).finalize(message);
            };
          }
        });
        var C_algo = C2.algo = {};
        return C2;
      }(Math);
      return CryptoJS;
    });
  })(core);
  return core.exports;
}
var x64Core = { exports: {} };
var hasRequiredX64Core;
function requireX64Core() {
  if (hasRequiredX64Core)
    return x64Core.exports;
  hasRequiredX64Core = 1;
  (function(module2, exports2) {
    (function(root2, factory) {
      {
        module2.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function(undefined$1) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var Base = C_lib.Base;
        var X32WordArray = C_lib.WordArray;
        var C_x64 = C2.x64 = {};
        C_x64.Word = Base.extend({
          init: function(high, low) {
            this.high = high;
            this.low = low;
          }
        });
        C_x64.WordArray = Base.extend({
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined$1) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 8;
            }
          },
          toX32: function() {
            var x64Words = this.words;
            var x64WordsLength = x64Words.length;
            var x32Words = [];
            for (var i2 = 0; i2 < x64WordsLength; i2++) {
              var x64Word = x64Words[i2];
              x32Words.push(x64Word.high);
              x32Words.push(x64Word.low);
            }
            return X32WordArray.create(x32Words, this.sigBytes);
          },
          clone: function() {
            var clone2 = Base.clone.call(this);
            var words = clone2.words = this.words.slice(0);
            var wordsLength = words.length;
            for (var i2 = 0; i2 < wordsLength; i2++) {
              words[i2] = words[i2].clone();
            }
            return clone2;
          }
        });
      })();
      return CryptoJS;
    });
  })(x64Core);
  return x64Core.exports;
}
var libTypedarrays = { exports: {} };
var hasRequiredLibTypedarrays;
function requireLibTypedarrays() {
  if (hasRequiredLibTypedarrays)
    return libTypedarrays.exports;
  hasRequiredLibTypedarrays = 1;
  (function(module2, exports2) {
    (function(root2, factory) {
      {
        module2.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        if (typeof ArrayBuffer != "function") {
          return;
        }
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var superInit = WordArray.init;
        var subInit = WordArray.init = function(typedArray) {
          if (typedArray instanceof ArrayBuffer) {
            typedArray = new Uint8Array(typedArray);
          }
          if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
          }
          if (typedArray instanceof Uint8Array) {
            var typedArrayByteLength = typedArray.byteLength;
            var words = [];
            for (var i2 = 0; i2 < typedArrayByteLength; i2++) {
              words[i2 >>> 2] |= typedArray[i2] << 24 - i2 % 4 * 8;
            }
            superInit.call(this, words, typedArrayByteLength);
          } else {
            superInit.apply(this, arguments);
          }
        };
        subInit.prototype = WordArray;
      })();
      return CryptoJS.lib.WordArray;
    });
  })(libTypedarrays);
  return libTypedarrays.exports;
}
var encUtf16 = { exports: {} };
var hasRequiredEncUtf16;
function requireEncUtf16() {
  if (hasRequiredEncUtf16)
    return encUtf16.exports;
  hasRequiredEncUtf16 = 1;
  (function(module2, exports2) {
    (function(root2, factory) {
      {
        module2.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C2.enc;
        C_enc.Utf16 = C_enc.Utf16BE = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2 += 2) {
              var codePoint = words[i2 >>> 2] >>> 16 - i2 % 4 * 8 & 65535;
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i2 = 0; i2 < utf16StrLength; i2++) {
              words[i2 >>> 1] |= utf16Str.charCodeAt(i2) << 16 - i2 % 2 * 16;
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        C_enc.Utf16LE = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2 += 2) {
              var codePoint = swapEndian(words[i2 >>> 2] >>> 16 - i2 % 4 * 8 & 65535);
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i2 = 0; i2 < utf16StrLength; i2++) {
              words[i2 >>> 1] |= swapEndian(utf16Str.charCodeAt(i2) << 16 - i2 % 2 * 16);
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        function swapEndian(word) {
          return word << 8 & 4278255360 | word >>> 8 & 16711935;
        }
      })();
      return CryptoJS.enc.Utf16;
    });
  })(encUtf16);
  return encUtf16.exports;
}
var encBase64 = { exports: {} };
var hasRequiredEncBase64;
function requireEncBase64() {
  if (hasRequiredEncBase64)
    return encBase64.exports;
  hasRequiredEncBase64 = 1;
  (function(module2, exports2) {
    (function(root2, factory) {
      {
        module2.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C2.enc;
        C_enc.Base64 = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map2 = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2 += 3) {
              var byte1 = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              var byte2 = words[i2 + 1 >>> 2] >>> 24 - (i2 + 1) % 4 * 8 & 255;
              var byte3 = words[i2 + 2 >>> 2] >>> 24 - (i2 + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i2 + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map2.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map2.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          parse: function(base64Str) {
            var base64StrLength = base64Str.length;
            var map2 = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map2.length; j++) {
                reverseMap[map2.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map2.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i2 = 0; i2 < base64StrLength; i2++) {
            if (i2 % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i2 - 1)] << i2 % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i2)] >>> 6 - i2 % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS.enc.Base64;
    });
  })(encBase64);
  return encBase64.exports;
}
var encBase64url = { exports: {} };
var hasRequiredEncBase64url;
function requireEncBase64url() {
  if (hasRequiredEncBase64url)
    return encBase64url.exports;
  hasRequiredEncBase64url = 1;
  (function(module2, exports2) {
    (function(root2, factory) {
      {
        module2.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C2.enc;
        C_enc.Base64url = {
          stringify: function(wordArray, urlSafe = true) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map2 = urlSafe ? this._safe_map : this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2 += 3) {
              var byte1 = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              var byte2 = words[i2 + 1 >>> 2] >>> 24 - (i2 + 1) % 4 * 8 & 255;
              var byte3 = words[i2 + 2 >>> 2] >>> 24 - (i2 + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i2 + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map2.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map2.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          parse: function(base64Str, urlSafe = true) {
            var base64StrLength = base64Str.length;
            var map2 = urlSafe ? this._safe_map : this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map2.length; j++) {
                reverseMap[map2.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map2.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i2 = 0; i2 < base64StrLength; i2++) {
            if (i2 % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i2 - 1)] << i2 % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i2)] >>> 6 - i2 % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS.enc.Base64url;
    });
  })(encBase64url);
  return encBase64url.exports;
}
var md5 = { exports: {} };
var hasRequiredMd5;
function requireMd5() {
  if (hasRequiredMd5)
    return md5.exports;
  hasRequiredMd5 = 1;
  (function(module2, exports2) {
    (function(root2, factory) {
      {
        module2.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function(Math2) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C2.algo;
        var T2 = [];
        (function() {
          for (var i2 = 0; i2 < 64; i2++) {
            T2[i2] = Math2.abs(Math2.sin(i2 + 1)) * 4294967296 | 0;
          }
        })();
        var MD5 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M2, offset) {
            for (var i2 = 0; i2 < 16; i2++) {
              var offset_i = offset + i2;
              var M_offset_i = M2[offset_i];
              M2[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H2 = this._hash.words;
            var M_offset_0 = M2[offset + 0];
            var M_offset_1 = M2[offset + 1];
            var M_offset_2 = M2[offset + 2];
            var M_offset_3 = M2[offset + 3];
            var M_offset_4 = M2[offset + 4];
            var M_offset_5 = M2[offset + 5];
            var M_offset_6 = M2[offset + 6];
            var M_offset_7 = M2[offset + 7];
            var M_offset_8 = M2[offset + 8];
            var M_offset_9 = M2[offset + 9];
            var M_offset_10 = M2[offset + 10];
            var M_offset_11 = M2[offset + 11];
            var M_offset_12 = M2[offset + 12];
            var M_offset_13 = M2[offset + 13];
            var M_offset_14 = M2[offset + 14];
            var M_offset_15 = M2[offset + 15];
            var a = H2[0];
            var b2 = H2[1];
            var c2 = H2[2];
            var d2 = H2[3];
            a = FF(a, b2, c2, d2, M_offset_0, 7, T2[0]);
            d2 = FF(d2, a, b2, c2, M_offset_1, 12, T2[1]);
            c2 = FF(c2, d2, a, b2, M_offset_2, 17, T2[2]);
            b2 = FF(b2, c2, d2, a, M_offset_3, 22, T2[3]);
            a = FF(a, b2, c2, d2, M_offset_4, 7, T2[4]);
            d2 = FF(d2, a, b2, c2, M_offset_5, 12, T2[5]);
            c2 = FF(c2, d2, a, b2, M_offset_6, 17, T2[6]);
            b2 = FF(b2, c2, d2, a, M_offset_7, 22, T2[7]);
            a = FF(a, b2, c2, d2, M_offset_8, 7, T2[8]);
            d2 = FF(d2, a, b2, c2, M_offset_9, 12, T2[9]);
            c2 = FF(c2, d2, a, b2, M_offset_10, 17, T2[10]);
            b2 = FF(b2, c2, d2, a, M_offset_11, 22, T2[11]);
            a = FF(a, b2, c2, d2, M_offset_12, 7, T2[12]);
            d2 = FF(d2, a, b2, c2, M_offset_13, 12, T2[13]);
            c2 = FF(c2, d2, a, b2, M_offset_14, 17, T2[14]);
            b2 = FF(b2, c2, d2, a, M_offset_15, 22, T2[15]);
            a = GG(a, b2, c2, d2, M_offset_1, 5, T2[16]);
            d2 = GG(d2, a, b2, c2, M_offset_6, 9, T2[17]);
            c2 = GG(c2, d2, a, b2, M_offset_11, 14, T2[18]);
            b2 = GG(b2, c2, d2, a, M_offset_0, 20, T2[19]);
            a = GG(a, b2, c2, d2, M_offset_5, 5, T2[20]);
            d2 = GG(d2, a, b2, c2, M_offset_10, 9, T2[21]);
            c2 = GG(c2, d2, a, b2, M_offset_15, 14, T2[22]);
            b2 = GG(b2, c2, d2, a, M_offset_4, 20, T2[23]);
            a = GG(a, b2, c2, d2, M_offset_9, 5, T2[24]);
            d2 = GG(d2, a, b2, c2, M_offset_14, 9, T2[25]);
            c2 = GG(c2, d2, a, b2, M_offset_3, 14, T2[26]);
            b2 = GG(b2, c2, d2, a, M_offset_8, 20, T2[27]);
            a = GG(a, b2, c2, d2, M_offset_13, 5, T2[28]);
            d2 = GG(d2, a, b2, c2, M_offset_2, 9, T2[29]);
            c2 = GG(c2, d2, a, b2, M_offset_7, 14, T2[30]);
            b2 = GG(b2, c2, d2, a, M_offset_12, 20, T2[31]);
            a = HH(a, b2, c2, d2, M_offset_5, 4, T2[32]);
            d2 = HH(d2, a, b2, c2, M_offset_8, 11, T2[33]);
            c2 = HH(c2, d2, a, b2, M_offset_11, 16, T2[34]);
            b2 = HH(b2, c2, d2, a, M_offset_14, 23, T2[35]);
            a = HH(a, b2, c2, d2, M_offset_1, 4, T2[36]);
            d2 = HH(d2, a, b2, c2, M_offset_4, 11, T2[37]);
            c2 = HH(c2, d2, a, b2, M_offset_7, 16, T2[38]);
            b2 = HH(b2, c2, d2, a, M_offset_10, 23, T2[39]);
            a = HH(a, b2, c2, d2, M_offset_13, 4, T2[40]);
            d2 = HH(d2, a, b2, c2, M_offset_0, 11, T2[41]);
            c2 = HH(c2, d2, a, b2, M_offset_3, 16, T2[42]);
            b2 = HH(b2, c2, d2, a, M_offset_6, 23, T2[43]);
            a = HH(a, b2, c2, d2, M_offset_9, 4, T2[44]);
            d2 = HH(d2, a, b2, c2, M_offset_12, 11, T2[45]);
            c2 = HH(c2, d2, a, b2, M_offset_15, 16, T2[46]);
            b2 = HH(b2, c2, d2, a, M_offset_2, 23, T2[47]);
            a = II(a, b2, c2, d2, M_offset_0, 6, T2[48]);
            d2 = II(d2, a, b2, c2, M_offset_7, 10, T2[49]);
            c2 = II(c2, d2, a, b2, M_offset_14, 15, T2[50]);
            b2 = II(b2, c2, d2, a, M_offset_5, 21, T2[51]);
            a = II(a, b2, c2, d2, M_offset_12, 6, T2[52]);
            d2 = II(d2, a, b2, c2, M_offset_3, 10, T2[53]);
            c2 = II(c2, d2, a, b2, M_offset_10, 15, T2[54]);
            b2 = II(b2, c2, d2, a, M_offset_1, 21, T2[55]);
            a = II(a, b2, c2, d2, M_offset_8, 6, T2[56]);
            d2 = II(d2, a, b2, c2, M_offset_15, 10, T2[57]);
            c2 = II(c2, d2, a, b2, M_offset_6, 15, T2[58]);
            b2 = II(b2, c2, d2, a, M_offset_13, 21, T2[59]);
            a = II(a, b2, c2, d2, M_offset_4, 6, T2[60]);
            d2 = II(d2, a, b2, c2, M_offset_11, 10, T2[61]);
            c2 = II(c2, d2, a, b2, M_offset_2, 15, T2[62]);
            b2 = II(b2, c2, d2, a, M_offset_9, 21, T2[63]);
            H2[0] = H2[0] + a | 0;
            H2[1] = H2[1] + b2 | 0;
            H2[2] = H2[2] + c2 | 0;
            H2[3] = H2[3] + d2 | 0;
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data2.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash2 = this._hash;
            var H2 = hash2.words;
            for (var i2 = 0; i2 < 4; i2++) {
              var H_i = H2[i2];
              H2[i2] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash2;
          },
          clone: function() {
            var clone2 = Hasher.clone.call(this);
            clone2._hash = this._hash.clone();
            return clone2;
          }
        });
        function FF(a, b2, c2, d2, x2, s, t2) {
          var n2 = a + (b2 & c2 | ~b2 & d2) + x2 + t2;
          return (n2 << s | n2 >>> 32 - s) + b2;
        }
        function GG(a, b2, c2, d2, x2, s, t2) {
          var n2 = a + (b2 & d2 | c2 & ~d2) + x2 + t2;
          return (n2 << s | n2 >>> 32 - s) + b2;
        }
        function HH(a, b2, c2, d2, x2, s, t2) {
          var n2 = a + (b2 ^ c2 ^ d2) + x2 + t2;
          return (n2 << s | n2 >>> 32 - s) + b2;
        }
        function II(a, b2, c2, d2, x2, s, t2) {
          var n2 = a + (c2 ^ (b2 | ~d2)) + x2 + t2;
          return (n2 << s | n2 >>> 32 - s) + b2;
        }
        C2.MD5 = Hasher._createHelper(MD5);
        C2.HmacMD5 = Hasher._createHmacHelper(MD5);
      })(Math);
      return CryptoJS.MD5;
    });
  })(md5);
  return md5.exports;
}
var sha1 = { exports: {} };
var hasRequiredSha1;
function requireSha1() {
  if (hasRequiredSha1)
    return sha1.exports;
  hasRequiredSha1 = 1;
  (function(module2, exports2) {
    (function(root2, factory) {
      {
        module2.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C2.algo;
        var W2 = [];
        var SHA1 = C_algo.SHA1 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(M2, offset) {
            var H2 = this._hash.words;
            var a = H2[0];
            var b2 = H2[1];
            var c2 = H2[2];
            var d2 = H2[3];
            var e2 = H2[4];
            for (var i2 = 0; i2 < 80; i2++) {
              if (i2 < 16) {
                W2[i2] = M2[offset + i2] | 0;
              } else {
                var n2 = W2[i2 - 3] ^ W2[i2 - 8] ^ W2[i2 - 14] ^ W2[i2 - 16];
                W2[i2] = n2 << 1 | n2 >>> 31;
              }
              var t2 = (a << 5 | a >>> 27) + e2 + W2[i2];
              if (i2 < 20) {
                t2 += (b2 & c2 | ~b2 & d2) + 1518500249;
              } else if (i2 < 40) {
                t2 += (b2 ^ c2 ^ d2) + 1859775393;
              } else if (i2 < 60) {
                t2 += (b2 & c2 | b2 & d2 | c2 & d2) - 1894007588;
              } else {
                t2 += (b2 ^ c2 ^ d2) - 899497514;
              }
              e2 = d2;
              d2 = c2;
              c2 = b2 << 30 | b2 >>> 2;
              b2 = a;
              a = t2;
            }
            H2[0] = H2[0] + a | 0;
            H2[1] = H2[1] + b2 | 0;
            H2[2] = H2[2] + c2 | 0;
            H2[3] = H2[3] + d2 | 0;
            H2[4] = H2[4] + e2 | 0;
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data2.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone2 = Hasher.clone.call(this);
            clone2._hash = this._hash.clone();
            return clone2;
          }
        });
        C2.SHA1 = Hasher._createHelper(SHA1);
        C2.HmacSHA1 = Hasher._createHmacHelper(SHA1);
      })();
      return CryptoJS.SHA1;
    });
  })(sha1);
  return sha1.exports;
}
var sha256 = { exports: {} };
var hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256)
    return sha256.exports;
  hasRequiredSha256 = 1;
  (function(module2, exports2) {
    (function(root2, factory) {
      {
        module2.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function(Math2) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C2.algo;
        var H2 = [];
        var K2 = [];
        (function() {
          function isPrime(n3) {
            var sqrtN = Math2.sqrt(n3);
            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n3 % factor)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n3) {
            return (n3 - (n3 | 0)) * 4294967296 | 0;
          }
          var n2 = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n2)) {
              if (nPrime < 8) {
                H2[nPrime] = getFractionalBits(Math2.pow(n2, 1 / 2));
              }
              K2[nPrime] = getFractionalBits(Math2.pow(n2, 1 / 3));
              nPrime++;
            }
            n2++;
          }
        })();
        var W2 = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H2.slice(0));
          },
          _doProcessBlock: function(M2, offset) {
            var H3 = this._hash.words;
            var a = H3[0];
            var b2 = H3[1];
            var c2 = H3[2];
            var d2 = H3[3];
            var e2 = H3[4];
            var f2 = H3[5];
            var g2 = H3[6];
            var h2 = H3[7];
            for (var i2 = 0; i2 < 64; i2++) {
              if (i2 < 16) {
                W2[i2] = M2[offset + i2] | 0;
              } else {
                var gamma0x = W2[i2 - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W2[i2 - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W2[i2] = gamma0 + W2[i2 - 7] + gamma1 + W2[i2 - 16];
              }
              var ch2 = e2 & f2 ^ ~e2 & g2;
              var maj = a & b2 ^ a & c2 ^ b2 & c2;
              var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
              var sigma1 = (e2 << 26 | e2 >>> 6) ^ (e2 << 21 | e2 >>> 11) ^ (e2 << 7 | e2 >>> 25);
              var t1 = h2 + sigma1 + ch2 + K2[i2] + W2[i2];
              var t2 = sigma0 + maj;
              h2 = g2;
              g2 = f2;
              f2 = e2;
              e2 = d2 + t1 | 0;
              d2 = c2;
              c2 = b2;
              b2 = a;
              a = t1 + t2 | 0;
            }
            H3[0] = H3[0] + a | 0;
            H3[1] = H3[1] + b2 | 0;
            H3[2] = H3[2] + c2 | 0;
            H3[3] = H3[3] + d2 | 0;
            H3[4] = H3[4] + e2 | 0;
            H3[5] = H3[5] + f2 | 0;
            H3[6] = H3[6] + g2 | 0;
            H3[7] = H3[7] + h2 | 0;
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data2.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone2 = Hasher.clone.call(this);
            clone2._hash = this._hash.clone();
            return clone2;
          }
        });
        C2.SHA256 = Hasher._createHelper(SHA256);
        C2.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      return CryptoJS.SHA256;
    });
  })(sha256);
  return sha256.exports;
}
var sha224 = { exports: {} };
var hasRequiredSha224;
function requireSha224() {
  if (hasRequiredSha224)
    return sha224.exports;
  hasRequiredSha224 = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireSha256());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var C_algo = C2.algo;
        var SHA256 = C_algo.SHA256;
        var SHA224 = C_algo.SHA224 = SHA256.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              3238371032,
              914150663,
              812702999,
              4144912697,
              4290775857,
              1750603025,
              1694076839,
              3204075428
            ]);
          },
          _doFinalize: function() {
            var hash2 = SHA256._doFinalize.call(this);
            hash2.sigBytes -= 4;
            return hash2;
          }
        });
        C2.SHA224 = SHA256._createHelper(SHA224);
        C2.HmacSHA224 = SHA256._createHmacHelper(SHA224);
      })();
      return CryptoJS.SHA224;
    });
  })(sha224);
  return sha224.exports;
}
var sha512 = { exports: {} };
var hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512)
    return sha512.exports;
  hasRequiredSha512 = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireX64Core());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var Hasher = C_lib.Hasher;
        var C_x64 = C2.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C2.algo;
        function X64Word_create() {
          return X64Word.create.apply(X64Word, arguments);
        }
        var K2 = [
          X64Word_create(1116352408, 3609767458),
          X64Word_create(1899447441, 602891725),
          X64Word_create(3049323471, 3964484399),
          X64Word_create(3921009573, 2173295548),
          X64Word_create(961987163, 4081628472),
          X64Word_create(1508970993, 3053834265),
          X64Word_create(2453635748, 2937671579),
          X64Word_create(2870763221, 3664609560),
          X64Word_create(3624381080, 2734883394),
          X64Word_create(310598401, 1164996542),
          X64Word_create(607225278, 1323610764),
          X64Word_create(1426881987, 3590304994),
          X64Word_create(1925078388, 4068182383),
          X64Word_create(2162078206, 991336113),
          X64Word_create(2614888103, 633803317),
          X64Word_create(3248222580, 3479774868),
          X64Word_create(3835390401, 2666613458),
          X64Word_create(4022224774, 944711139),
          X64Word_create(264347078, 2341262773),
          X64Word_create(604807628, 2007800933),
          X64Word_create(770255983, 1495990901),
          X64Word_create(1249150122, 1856431235),
          X64Word_create(1555081692, 3175218132),
          X64Word_create(1996064986, 2198950837),
          X64Word_create(2554220882, 3999719339),
          X64Word_create(2821834349, 766784016),
          X64Word_create(2952996808, 2566594879),
          X64Word_create(3210313671, 3203337956),
          X64Word_create(3336571891, 1034457026),
          X64Word_create(3584528711, 2466948901),
          X64Word_create(113926993, 3758326383),
          X64Word_create(338241895, 168717936),
          X64Word_create(666307205, 1188179964),
          X64Word_create(773529912, 1546045734),
          X64Word_create(1294757372, 1522805485),
          X64Word_create(1396182291, 2643833823),
          X64Word_create(1695183700, 2343527390),
          X64Word_create(1986661051, 1014477480),
          X64Word_create(2177026350, 1206759142),
          X64Word_create(2456956037, 344077627),
          X64Word_create(2730485921, 1290863460),
          X64Word_create(2820302411, 3158454273),
          X64Word_create(3259730800, 3505952657),
          X64Word_create(3345764771, 106217008),
          X64Word_create(3516065817, 3606008344),
          X64Word_create(3600352804, 1432725776),
          X64Word_create(4094571909, 1467031594),
          X64Word_create(275423344, 851169720),
          X64Word_create(430227734, 3100823752),
          X64Word_create(506948616, 1363258195),
          X64Word_create(659060556, 3750685593),
          X64Word_create(883997877, 3785050280),
          X64Word_create(958139571, 3318307427),
          X64Word_create(1322822218, 3812723403),
          X64Word_create(1537002063, 2003034995),
          X64Word_create(1747873779, 3602036899),
          X64Word_create(1955562222, 1575990012),
          X64Word_create(2024104815, 1125592928),
          X64Word_create(2227730452, 2716904306),
          X64Word_create(2361852424, 442776044),
          X64Word_create(2428436474, 593698344),
          X64Word_create(2756734187, 3733110249),
          X64Word_create(3204031479, 2999351573),
          X64Word_create(3329325298, 3815920427),
          X64Word_create(3391569614, 3928383900),
          X64Word_create(3515267271, 566280711),
          X64Word_create(3940187606, 3454069534),
          X64Word_create(4118630271, 4000239992),
          X64Word_create(116418474, 1914138554),
          X64Word_create(174292421, 2731055270),
          X64Word_create(289380356, 3203993006),
          X64Word_create(460393269, 320620315),
          X64Word_create(685471733, 587496836),
          X64Word_create(852142971, 1086792851),
          X64Word_create(1017036298, 365543100),
          X64Word_create(1126000580, 2618297676),
          X64Word_create(1288033470, 3409855158),
          X64Word_create(1501505948, 4234509866),
          X64Word_create(1607167915, 987167468),
          X64Word_create(1816402316, 1246189591)
        ];
        var W2 = [];
        (function() {
          for (var i2 = 0; i2 < 80; i2++) {
            W2[i2] = X64Word_create();
          }
        })();
        var SHA512 = C_algo.SHA512 = Hasher.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(1779033703, 4089235720),
              new X64Word.init(3144134277, 2227873595),
              new X64Word.init(1013904242, 4271175723),
              new X64Word.init(2773480762, 1595750129),
              new X64Word.init(1359893119, 2917565137),
              new X64Word.init(2600822924, 725511199),
              new X64Word.init(528734635, 4215389547),
              new X64Word.init(1541459225, 327033209)
            ]);
          },
          _doProcessBlock: function(M2, offset) {
            var H2 = this._hash.words;
            var H0 = H2[0];
            var H1 = H2[1];
            var H22 = H2[2];
            var H3 = H2[3];
            var H4 = H2[4];
            var H5 = H2[5];
            var H6 = H2[6];
            var H7 = H2[7];
            var H0h = H0.high;
            var H0l = H0.low;
            var H1h = H1.high;
            var H1l = H1.low;
            var H2h = H22.high;
            var H2l = H22.low;
            var H3h = H3.high;
            var H3l = H3.low;
            var H4h = H4.high;
            var H4l = H4.low;
            var H5h = H5.high;
            var H5l = H5.low;
            var H6h = H6.high;
            var H6l = H6.low;
            var H7h = H7.high;
            var H7l = H7.low;
            var ah2 = H0h;
            var al2 = H0l;
            var bh2 = H1h;
            var bl2 = H1l;
            var ch2 = H2h;
            var cl2 = H2l;
            var dh2 = H3h;
            var dl2 = H3l;
            var eh2 = H4h;
            var el2 = H4l;
            var fh2 = H5h;
            var fl2 = H5l;
            var gh2 = H6h;
            var gl2 = H6l;
            var hh2 = H7h;
            var hl2 = H7l;
            for (var i2 = 0; i2 < 80; i2++) {
              var Wil;
              var Wih;
              var Wi2 = W2[i2];
              if (i2 < 16) {
                Wih = Wi2.high = M2[offset + i2 * 2] | 0;
                Wil = Wi2.low = M2[offset + i2 * 2 + 1] | 0;
              } else {
                var gamma0x = W2[i2 - 15];
                var gamma0xh = gamma0x.high;
                var gamma0xl = gamma0x.low;
                var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                var gamma1x = W2[i2 - 2];
                var gamma1xh = gamma1x.high;
                var gamma1xl = gamma1x.low;
                var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                var Wi7 = W2[i2 - 7];
                var Wi7h = Wi7.high;
                var Wi7l = Wi7.low;
                var Wi16 = W2[i2 - 16];
                var Wi16h = Wi16.high;
                var Wi16l = Wi16.low;
                Wil = gamma0l + Wi7l;
                Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                Wil = Wil + gamma1l;
                Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                Wil = Wil + Wi16l;
                Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                Wi2.high = Wih;
                Wi2.low = Wil;
              }
              var chh = eh2 & fh2 ^ ~eh2 & gh2;
              var chl = el2 & fl2 ^ ~el2 & gl2;
              var majh = ah2 & bh2 ^ ah2 & ch2 ^ bh2 & ch2;
              var majl = al2 & bl2 ^ al2 & cl2 ^ bl2 & cl2;
              var sigma0h = (ah2 >>> 28 | al2 << 4) ^ (ah2 << 30 | al2 >>> 2) ^ (ah2 << 25 | al2 >>> 7);
              var sigma0l = (al2 >>> 28 | ah2 << 4) ^ (al2 << 30 | ah2 >>> 2) ^ (al2 << 25 | ah2 >>> 7);
              var sigma1h = (eh2 >>> 14 | el2 << 18) ^ (eh2 >>> 18 | el2 << 14) ^ (eh2 << 23 | el2 >>> 9);
              var sigma1l = (el2 >>> 14 | eh2 << 18) ^ (el2 >>> 18 | eh2 << 14) ^ (el2 << 23 | eh2 >>> 9);
              var Ki2 = K2[i2];
              var Kih = Ki2.high;
              var Kil = Ki2.low;
              var t1l = hl2 + sigma1l;
              var t1h = hh2 + sigma1h + (t1l >>> 0 < hl2 >>> 0 ? 1 : 0);
              var t1l = t1l + chl;
              var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
              var t1l = t1l + Kil;
              var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
              var t1l = t1l + Wil;
              var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
              var t2l = sigma0l + majl;
              var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
              hh2 = gh2;
              hl2 = gl2;
              gh2 = fh2;
              gl2 = fl2;
              fh2 = eh2;
              fl2 = el2;
              el2 = dl2 + t1l | 0;
              eh2 = dh2 + t1h + (el2 >>> 0 < dl2 >>> 0 ? 1 : 0) | 0;
              dh2 = ch2;
              dl2 = cl2;
              ch2 = bh2;
              cl2 = bl2;
              bh2 = ah2;
              bl2 = al2;
              al2 = t1l + t2l | 0;
              ah2 = t1h + t2h + (al2 >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
            }
            H0l = H0.low = H0l + al2;
            H0.high = H0h + ah2 + (H0l >>> 0 < al2 >>> 0 ? 1 : 0);
            H1l = H1.low = H1l + bl2;
            H1.high = H1h + bh2 + (H1l >>> 0 < bl2 >>> 0 ? 1 : 0);
            H2l = H22.low = H2l + cl2;
            H22.high = H2h + ch2 + (H2l >>> 0 < cl2 >>> 0 ? 1 : 0);
            H3l = H3.low = H3l + dl2;
            H3.high = H3h + dh2 + (H3l >>> 0 < dl2 >>> 0 ? 1 : 0);
            H4l = H4.low = H4l + el2;
            H4.high = H4h + eh2 + (H4l >>> 0 < el2 >>> 0 ? 1 : 0);
            H5l = H5.low = H5l + fl2;
            H5.high = H5h + fh2 + (H5l >>> 0 < fl2 >>> 0 ? 1 : 0);
            H6l = H6.low = H6l + gl2;
            H6.high = H6h + gh2 + (H6l >>> 0 < gl2 >>> 0 ? 1 : 0);
            H7l = H7.low = H7l + hl2;
            H7.high = H7h + hh2 + (H7l >>> 0 < hl2 >>> 0 ? 1 : 0);
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
            data2.sigBytes = dataWords.length * 4;
            this._process();
            var hash2 = this._hash.toX32();
            return hash2;
          },
          clone: function() {
            var clone2 = Hasher.clone.call(this);
            clone2._hash = this._hash.clone();
            return clone2;
          },
          blockSize: 1024 / 32
        });
        C2.SHA512 = Hasher._createHelper(SHA512);
        C2.HmacSHA512 = Hasher._createHmacHelper(SHA512);
      })();
      return CryptoJS.SHA512;
    });
  })(sha512);
  return sha512.exports;
}
var sha384 = { exports: {} };
var hasRequiredSha384;
function requireSha384() {
  if (hasRequiredSha384)
    return sha384.exports;
  hasRequiredSha384 = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireX64Core(), requireSha512());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_x64 = C2.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C2.algo;
        var SHA512 = C_algo.SHA512;
        var SHA384 = C_algo.SHA384 = SHA512.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(3418070365, 3238371032),
              new X64Word.init(1654270250, 914150663),
              new X64Word.init(2438529370, 812702999),
              new X64Word.init(355462360, 4144912697),
              new X64Word.init(1731405415, 4290775857),
              new X64Word.init(2394180231, 1750603025),
              new X64Word.init(3675008525, 1694076839),
              new X64Word.init(1203062813, 3204075428)
            ]);
          },
          _doFinalize: function() {
            var hash2 = SHA512._doFinalize.call(this);
            hash2.sigBytes -= 16;
            return hash2;
          }
        });
        C2.SHA384 = SHA512._createHelper(SHA384);
        C2.HmacSHA384 = SHA512._createHmacHelper(SHA384);
      })();
      return CryptoJS.SHA384;
    });
  })(sha384);
  return sha384.exports;
}
var sha3 = { exports: {} };
var hasRequiredSha3;
function requireSha3() {
  if (hasRequiredSha3)
    return sha3.exports;
  hasRequiredSha3 = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireX64Core());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function(Math2) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_x64 = C2.x64;
        var X64Word = C_x64.Word;
        var C_algo = C2.algo;
        var RHO_OFFSETS = [];
        var PI_INDEXES = [];
        var ROUND_CONSTANTS = [];
        (function() {
          var x2 = 1, y2 = 0;
          for (var t2 = 0; t2 < 24; t2++) {
            RHO_OFFSETS[x2 + 5 * y2] = (t2 + 1) * (t2 + 2) / 2 % 64;
            var newX = y2 % 5;
            var newY = (2 * x2 + 3 * y2) % 5;
            x2 = newX;
            y2 = newY;
          }
          for (var x2 = 0; x2 < 5; x2++) {
            for (var y2 = 0; y2 < 5; y2++) {
              PI_INDEXES[x2 + 5 * y2] = y2 + (2 * x2 + 3 * y2) % 5 * 5;
            }
          }
          var LFSR = 1;
          for (var i2 = 0; i2 < 24; i2++) {
            var roundConstantMsw = 0;
            var roundConstantLsw = 0;
            for (var j = 0; j < 7; j++) {
              if (LFSR & 1) {
                var bitPosition = (1 << j) - 1;
                if (bitPosition < 32) {
                  roundConstantLsw ^= 1 << bitPosition;
                } else {
                  roundConstantMsw ^= 1 << bitPosition - 32;
                }
              }
              if (LFSR & 128) {
                LFSR = LFSR << 1 ^ 113;
              } else {
                LFSR <<= 1;
              }
            }
            ROUND_CONSTANTS[i2] = X64Word.create(roundConstantMsw, roundConstantLsw);
          }
        })();
        var T2 = [];
        (function() {
          for (var i2 = 0; i2 < 25; i2++) {
            T2[i2] = X64Word.create();
          }
        })();
        var SHA3 = C_algo.SHA3 = Hasher.extend({
          cfg: Hasher.cfg.extend({
            outputLength: 512
          }),
          _doReset: function() {
            var state = this._state = [];
            for (var i2 = 0; i2 < 25; i2++) {
              state[i2] = new X64Word.init();
            }
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          },
          _doProcessBlock: function(M2, offset) {
            var state = this._state;
            var nBlockSizeLanes = this.blockSize / 2;
            for (var i2 = 0; i2 < nBlockSizeLanes; i2++) {
              var M2i = M2[offset + 2 * i2];
              var M2i1 = M2[offset + 2 * i2 + 1];
              M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
              M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
              var lane = state[i2];
              lane.high ^= M2i1;
              lane.low ^= M2i;
            }
            for (var round2 = 0; round2 < 24; round2++) {
              for (var x2 = 0; x2 < 5; x2++) {
                var tMsw = 0, tLsw = 0;
                for (var y2 = 0; y2 < 5; y2++) {
                  var lane = state[x2 + 5 * y2];
                  tMsw ^= lane.high;
                  tLsw ^= lane.low;
                }
                var Tx = T2[x2];
                Tx.high = tMsw;
                Tx.low = tLsw;
              }
              for (var x2 = 0; x2 < 5; x2++) {
                var Tx4 = T2[(x2 + 4) % 5];
                var Tx1 = T2[(x2 + 1) % 5];
                var Tx1Msw = Tx1.high;
                var Tx1Lsw = Tx1.low;
                var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                for (var y2 = 0; y2 < 5; y2++) {
                  var lane = state[x2 + 5 * y2];
                  lane.high ^= tMsw;
                  lane.low ^= tLsw;
                }
              }
              for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                var tMsw;
                var tLsw;
                var lane = state[laneIndex];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                var rhoOffset = RHO_OFFSETS[laneIndex];
                if (rhoOffset < 32) {
                  tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                  tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                } else {
                  tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                  tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                }
                var TPiLane = T2[PI_INDEXES[laneIndex]];
                TPiLane.high = tMsw;
                TPiLane.low = tLsw;
              }
              var T0 = T2[0];
              var state0 = state[0];
              T0.high = state0.high;
              T0.low = state0.low;
              for (var x2 = 0; x2 < 5; x2++) {
                for (var y2 = 0; y2 < 5; y2++) {
                  var laneIndex = x2 + 5 * y2;
                  var lane = state[laneIndex];
                  var TLane = T2[laneIndex];
                  var Tx1Lane = T2[(x2 + 1) % 5 + 5 * y2];
                  var Tx2Lane = T2[(x2 + 2) % 5 + 5 * y2];
                  lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                  lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                }
              }
              var lane = state[0];
              var roundConstant = ROUND_CONSTANTS[round2];
              lane.high ^= roundConstant.high;
              lane.low ^= roundConstant.low;
            }
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            var blockSizeBits = this.blockSize * 32;
            dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
            dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
            data2.sigBytes = dataWords.length * 4;
            this._process();
            var state = this._state;
            var outputLengthBytes = this.cfg.outputLength / 8;
            var outputLengthLanes = outputLengthBytes / 8;
            var hashWords = [];
            for (var i2 = 0; i2 < outputLengthLanes; i2++) {
              var lane = state[i2];
              var laneMsw = lane.high;
              var laneLsw = lane.low;
              laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
              laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
              hashWords.push(laneLsw);
              hashWords.push(laneMsw);
            }
            return new WordArray.init(hashWords, outputLengthBytes);
          },
          clone: function() {
            var clone2 = Hasher.clone.call(this);
            var state = clone2._state = this._state.slice(0);
            for (var i2 = 0; i2 < 25; i2++) {
              state[i2] = state[i2].clone();
            }
            return clone2;
          }
        });
        C2.SHA3 = Hasher._createHelper(SHA3);
        C2.HmacSHA3 = Hasher._createHmacHelper(SHA3);
      })(Math);
      return CryptoJS.SHA3;
    });
  })(sha3);
  return sha3.exports;
}
var ripemd160 = { exports: {} };
var hasRequiredRipemd160;
function requireRipemd160() {
  if (hasRequiredRipemd160)
    return ripemd160.exports;
  hasRequiredRipemd160 = 1;
  (function(module2, exports2) {
    (function(root2, factory) {
      {
        module2.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      /** @preserve
      			(c) 2012 by Cdric Mesnil. All rights reserved.
      
      			Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
      
      			    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
      			    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
      
      			THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
      			*/
      (function(Math2) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C2.algo;
        var _zl = WordArray.create([
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          7,
          4,
          13,
          1,
          10,
          6,
          15,
          3,
          12,
          0,
          9,
          5,
          2,
          14,
          11,
          8,
          3,
          10,
          14,
          4,
          9,
          15,
          8,
          1,
          2,
          7,
          0,
          6,
          13,
          11,
          5,
          12,
          1,
          9,
          11,
          10,
          0,
          8,
          12,
          4,
          13,
          3,
          7,
          15,
          14,
          5,
          6,
          2,
          4,
          0,
          5,
          9,
          7,
          12,
          2,
          10,
          14,
          1,
          3,
          8,
          11,
          6,
          15,
          13
        ]);
        var _zr = WordArray.create([
          5,
          14,
          7,
          0,
          9,
          2,
          11,
          4,
          13,
          6,
          15,
          8,
          1,
          10,
          3,
          12,
          6,
          11,
          3,
          7,
          0,
          13,
          5,
          10,
          14,
          15,
          8,
          12,
          4,
          9,
          1,
          2,
          15,
          5,
          1,
          3,
          7,
          14,
          6,
          9,
          11,
          8,
          12,
          2,
          10,
          0,
          4,
          13,
          8,
          6,
          4,
          1,
          3,
          11,
          15,
          0,
          5,
          12,
          2,
          13,
          9,
          7,
          10,
          14,
          12,
          15,
          10,
          4,
          1,
          5,
          8,
          7,
          6,
          2,
          13,
          14,
          0,
          3,
          9,
          11
        ]);
        var _sl = WordArray.create([
          11,
          14,
          15,
          12,
          5,
          8,
          7,
          9,
          11,
          13,
          14,
          15,
          6,
          7,
          9,
          8,
          7,
          6,
          8,
          13,
          11,
          9,
          7,
          15,
          7,
          12,
          15,
          9,
          11,
          7,
          13,
          12,
          11,
          13,
          6,
          7,
          14,
          9,
          13,
          15,
          14,
          8,
          13,
          6,
          5,
          12,
          7,
          5,
          11,
          12,
          14,
          15,
          14,
          15,
          9,
          8,
          9,
          14,
          5,
          6,
          8,
          6,
          5,
          12,
          9,
          15,
          5,
          11,
          6,
          8,
          13,
          12,
          5,
          12,
          13,
          14,
          11,
          8,
          5,
          6
        ]);
        var _sr = WordArray.create([
          8,
          9,
          9,
          11,
          13,
          15,
          15,
          5,
          7,
          7,
          8,
          11,
          14,
          14,
          12,
          6,
          9,
          13,
          15,
          7,
          12,
          8,
          9,
          11,
          7,
          7,
          12,
          7,
          6,
          15,
          13,
          11,
          9,
          7,
          15,
          11,
          8,
          6,
          6,
          14,
          12,
          13,
          5,
          14,
          13,
          13,
          7,
          5,
          15,
          5,
          8,
          11,
          14,
          14,
          6,
          14,
          6,
          9,
          12,
          9,
          12,
          5,
          15,
          8,
          8,
          5,
          12,
          9,
          12,
          5,
          14,
          6,
          8,
          13,
          6,
          5,
          15,
          13,
          11,
          11
        ]);
        var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
        var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
        var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
          _doReset: function() {
            this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          },
          _doProcessBlock: function(M2, offset) {
            for (var i2 = 0; i2 < 16; i2++) {
              var offset_i = offset + i2;
              var M_offset_i = M2[offset_i];
              M2[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H2 = this._hash.words;
            var hl2 = _hl.words;
            var hr = _hr.words;
            var zl = _zl.words;
            var zr = _zr.words;
            var sl2 = _sl.words;
            var sr = _sr.words;
            var al2, bl2, cl2, dl2, el2;
            var ar, br, cr, dr, er;
            ar = al2 = H2[0];
            br = bl2 = H2[1];
            cr = cl2 = H2[2];
            dr = dl2 = H2[3];
            er = el2 = H2[4];
            var t2;
            for (var i2 = 0; i2 < 80; i2 += 1) {
              t2 = al2 + M2[offset + zl[i2]] | 0;
              if (i2 < 16) {
                t2 += f1(bl2, cl2, dl2) + hl2[0];
              } else if (i2 < 32) {
                t2 += f2(bl2, cl2, dl2) + hl2[1];
              } else if (i2 < 48) {
                t2 += f3(bl2, cl2, dl2) + hl2[2];
              } else if (i2 < 64) {
                t2 += f4(bl2, cl2, dl2) + hl2[3];
              } else {
                t2 += f5(bl2, cl2, dl2) + hl2[4];
              }
              t2 = t2 | 0;
              t2 = rotl(t2, sl2[i2]);
              t2 = t2 + el2 | 0;
              al2 = el2;
              el2 = dl2;
              dl2 = rotl(cl2, 10);
              cl2 = bl2;
              bl2 = t2;
              t2 = ar + M2[offset + zr[i2]] | 0;
              if (i2 < 16) {
                t2 += f5(br, cr, dr) + hr[0];
              } else if (i2 < 32) {
                t2 += f4(br, cr, dr) + hr[1];
              } else if (i2 < 48) {
                t2 += f3(br, cr, dr) + hr[2];
              } else if (i2 < 64) {
                t2 += f2(br, cr, dr) + hr[3];
              } else {
                t2 += f1(br, cr, dr) + hr[4];
              }
              t2 = t2 | 0;
              t2 = rotl(t2, sr[i2]);
              t2 = t2 + er | 0;
              ar = er;
              er = dr;
              dr = rotl(cr, 10);
              cr = br;
              br = t2;
            }
            t2 = H2[1] + cl2 + dr | 0;
            H2[1] = H2[2] + dl2 + er | 0;
            H2[2] = H2[3] + el2 + ar | 0;
            H2[3] = H2[4] + al2 + br | 0;
            H2[4] = H2[0] + bl2 + cr | 0;
            H2[0] = t2;
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
            data2.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash2 = this._hash;
            var H2 = hash2.words;
            for (var i2 = 0; i2 < 5; i2++) {
              var H_i = H2[i2];
              H2[i2] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash2;
          },
          clone: function() {
            var clone2 = Hasher.clone.call(this);
            clone2._hash = this._hash.clone();
            return clone2;
          }
        });
        function f1(x2, y2, z2) {
          return x2 ^ y2 ^ z2;
        }
        function f2(x2, y2, z2) {
          return x2 & y2 | ~x2 & z2;
        }
        function f3(x2, y2, z2) {
          return (x2 | ~y2) ^ z2;
        }
        function f4(x2, y2, z2) {
          return x2 & z2 | y2 & ~z2;
        }
        function f5(x2, y2, z2) {
          return x2 ^ (y2 | ~z2);
        }
        function rotl(x2, n2) {
          return x2 << n2 | x2 >>> 32 - n2;
        }
        C2.RIPEMD160 = Hasher._createHelper(RIPEMD160);
        C2.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
      })();
      return CryptoJS.RIPEMD160;
    });
  })(ripemd160);
  return ripemd160.exports;
}
var hmac = { exports: {} };
var hasRequiredHmac;
function requireHmac() {
  if (hasRequiredHmac)
    return hmac.exports;
  hasRequiredHmac = 1;
  (function(module2, exports2) {
    (function(root2, factory) {
      {
        module2.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var Base = C_lib.Base;
        var C_enc = C2.enc;
        var Utf8 = C_enc.Utf8;
        var C_algo = C2.algo;
        C_algo.HMAC = Base.extend({
          init: function(hasher3, key) {
            hasher3 = this._hasher = new hasher3.init();
            if (typeof key == "string") {
              key = Utf8.parse(key);
            }
            var hasherBlockSize = hasher3.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;
            if (key.sigBytes > hasherBlockSizeBytes) {
              key = hasher3.finalize(key);
            }
            key.clamp();
            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone();
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;
            for (var i2 = 0; i2 < hasherBlockSize; i2++) {
              oKeyWords[i2] ^= 1549556828;
              iKeyWords[i2] ^= 909522486;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
            this.reset();
          },
          reset: function() {
            var hasher3 = this._hasher;
            hasher3.reset();
            hasher3.update(this._iKey);
          },
          update: function(messageUpdate) {
            this._hasher.update(messageUpdate);
            return this;
          },
          finalize: function(messageUpdate) {
            var hasher3 = this._hasher;
            var innerHash = hasher3.finalize(messageUpdate);
            hasher3.reset();
            var hmac2 = hasher3.finalize(this._oKey.clone().concat(innerHash));
            return hmac2;
          }
        });
      })();
    });
  })(hmac);
  return hmac.exports;
}
var pbkdf2 = { exports: {} };
var hasRequiredPbkdf2;
function requirePbkdf2() {
  if (hasRequiredPbkdf2)
    return pbkdf2.exports;
  hasRequiredPbkdf2 = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireSha1(), requireHmac());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C2.algo;
        var SHA1 = C_algo.SHA1;
        var HMAC = C_algo.HMAC;
        var PBKDF2 = C_algo.PBKDF2 = Base.extend({
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: SHA1,
            iterations: 1
          }),
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          compute: function(password, salt) {
            var cfg = this.cfg;
            var hmac2 = HMAC.create(cfg.hasher, password);
            var derivedKey = WordArray.create();
            var blockIndex = WordArray.create([1]);
            var derivedKeyWords = derivedKey.words;
            var blockIndexWords = blockIndex.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              var block = hmac2.update(salt).finalize(blockIndex);
              hmac2.reset();
              var blockWords = block.words;
              var blockWordsLength = blockWords.length;
              var intermediate = block;
              for (var i2 = 1; i2 < iterations; i2++) {
                intermediate = hmac2.finalize(intermediate);
                hmac2.reset();
                var intermediateWords = intermediate.words;
                for (var j = 0; j < blockWordsLength; j++) {
                  blockWords[j] ^= intermediateWords[j];
                }
              }
              derivedKey.concat(block);
              blockIndexWords[0]++;
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C2.PBKDF2 = function(password, salt, cfg) {
          return PBKDF2.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.PBKDF2;
    });
  })(pbkdf2);
  return pbkdf2.exports;
}
var evpkdf = { exports: {} };
var hasRequiredEvpkdf;
function requireEvpkdf() {
  if (hasRequiredEvpkdf)
    return evpkdf.exports;
  hasRequiredEvpkdf = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireSha1(), requireHmac());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C2.algo;
        var MD5 = C_algo.MD5;
        var EvpKDF = C_algo.EvpKDF = Base.extend({
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: MD5,
            iterations: 1
          }),
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          compute: function(password, salt) {
            var block;
            var cfg = this.cfg;
            var hasher3 = cfg.hasher.create();
            var derivedKey = WordArray.create();
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              if (block) {
                hasher3.update(block);
              }
              block = hasher3.update(password).finalize(salt);
              hasher3.reset();
              for (var i2 = 1; i2 < iterations; i2++) {
                block = hasher3.finalize(block);
                hasher3.reset();
              }
              derivedKey.concat(block);
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C2.EvpKDF = function(password, salt, cfg) {
          return EvpKDF.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.EvpKDF;
    });
  })(evpkdf);
  return evpkdf.exports;
}
var cipherCore = { exports: {} };
var hasRequiredCipherCore;
function requireCipherCore() {
  if (hasRequiredCipherCore)
    return cipherCore.exports;
  hasRequiredCipherCore = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireEvpkdf());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.lib.Cipher || function(undefined$1) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
        var C_enc = C2.enc;
        C_enc.Utf8;
        var Base64 = C_enc.Base64;
        var C_algo = C2.algo;
        var EvpKDF = C_algo.EvpKDF;
        var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          createEncryptor: function(key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
          },
          createDecryptor: function(key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
          },
          init: function(xformMode, key, cfg) {
            this.cfg = this.cfg.extend(cfg);
            this._xformMode = xformMode;
            this._key = key;
            this.reset();
          },
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          process: function(dataUpdate) {
            this._append(dataUpdate);
            return this._process();
          },
          finalize: function(dataUpdate) {
            if (dataUpdate) {
              this._append(dataUpdate);
            }
            var finalProcessedData = this._doFinalize();
            return finalProcessedData;
          },
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          _createHelper: function() {
            function selectCipherStrategy(key) {
              if (typeof key == "string") {
                return PasswordBasedCipher;
              } else {
                return SerializableCipher;
              }
            }
            return function(cipher) {
              return {
                encrypt: function(message, key, cfg) {
                  return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                },
                decrypt: function(ciphertext, key, cfg) {
                  return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                }
              };
            };
          }()
        });
        C_lib.StreamCipher = Cipher.extend({
          _doFinalize: function() {
            var finalProcessedBlocks = this._process(true);
            return finalProcessedBlocks;
          },
          blockSize: 1
        });
        var C_mode = C2.mode = {};
        var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
          createEncryptor: function(cipher, iv) {
            return this.Encryptor.create(cipher, iv);
          },
          createDecryptor: function(cipher, iv) {
            return this.Decryptor.create(cipher, iv);
          },
          init: function(cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
          }
        });
        var CBC = C_mode.CBC = function() {
          var CBC2 = BlockCipherMode.extend();
          CBC2.Encryptor = CBC2.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              xorBlock.call(this, words, offset, blockSize);
              cipher.encryptBlock(words, offset);
              this._prevBlock = words.slice(offset, offset + blockSize);
            }
          });
          CBC2.Decryptor = CBC2.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words.slice(offset, offset + blockSize);
              cipher.decryptBlock(words, offset);
              xorBlock.call(this, words, offset, blockSize);
              this._prevBlock = thisBlock;
            }
          });
          function xorBlock(words, offset, blockSize) {
            var block;
            var iv = this._iv;
            if (iv) {
              block = iv;
              this._iv = undefined$1;
            } else {
              block = this._prevBlock;
            }
            for (var i2 = 0; i2 < blockSize; i2++) {
              words[offset + i2] ^= block[i2];
            }
          }
          return CBC2;
        }();
        var C_pad = C2.pad = {};
        var Pkcs7 = C_pad.Pkcs7 = {
          pad: function(data2, blockSize) {
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - data2.sigBytes % blockSizeBytes;
            var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
            var paddingWords = [];
            for (var i2 = 0; i2 < nPaddingBytes; i2 += 4) {
              paddingWords.push(paddingWord);
            }
            var padding = WordArray.create(paddingWords, nPaddingBytes);
            data2.concat(padding);
          },
          unpad: function(data2) {
            var nPaddingBytes = data2.words[data2.sigBytes - 1 >>> 2] & 255;
            data2.sigBytes -= nPaddingBytes;
          }
        };
        C_lib.BlockCipher = Cipher.extend({
          cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
          }),
          reset: function() {
            var modeCreator;
            Cipher.reset.call(this);
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              modeCreator = mode.createEncryptor;
            } else {
              modeCreator = mode.createDecryptor;
              this._minBufferSize = 1;
            }
            if (this._mode && this._mode.__creator == modeCreator) {
              this._mode.init(this, iv && iv.words);
            } else {
              this._mode = modeCreator.call(mode, this, iv && iv.words);
              this._mode.__creator = modeCreator;
            }
          },
          _doProcessBlock: function(words, offset) {
            this._mode.processBlock(words, offset);
          },
          _doFinalize: function() {
            var finalProcessedBlocks;
            var padding = this.cfg.padding;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              padding.pad(this._data, this.blockSize);
              finalProcessedBlocks = this._process(true);
            } else {
              finalProcessedBlocks = this._process(true);
              padding.unpad(finalProcessedBlocks);
            }
            return finalProcessedBlocks;
          },
          blockSize: 128 / 32
        });
        var CipherParams = C_lib.CipherParams = Base.extend({
          init: function(cipherParams) {
            this.mixIn(cipherParams);
          },
          toString: function(formatter) {
            return (formatter || this.formatter).stringify(this);
          }
        });
        var C_format = C2.format = {};
        var OpenSSLFormatter = C_format.OpenSSL = {
          stringify: function(cipherParams) {
            var wordArray;
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;
            if (salt) {
              wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
            } else {
              wordArray = ciphertext;
            }
            return wordArray.toString(Base64);
          },
          parse: function(openSSLStr) {
            var salt;
            var ciphertext = Base64.parse(openSSLStr);
            var ciphertextWords = ciphertext.words;
            if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
              salt = WordArray.create(ciphertextWords.slice(2, 4));
              ciphertextWords.splice(0, 4);
              ciphertext.sigBytes -= 16;
            }
            return CipherParams.create({ ciphertext, salt });
          }
        };
        var SerializableCipher = C_lib.SerializableCipher = Base.extend({
          cfg: Base.extend({
            format: OpenSSLFormatter
          }),
          encrypt: function(cipher, message, key, cfg) {
            cfg = this.cfg.extend(cfg);
            var encryptor = cipher.createEncryptor(key, cfg);
            var ciphertext = encryptor.finalize(message);
            var cipherCfg = encryptor.cfg;
            return CipherParams.create({
              ciphertext,
              key,
              iv: cipherCfg.iv,
              algorithm: cipher,
              mode: cipherCfg.mode,
              padding: cipherCfg.padding,
              blockSize: cipher.blockSize,
              formatter: cfg.format
            });
          },
          decrypt: function(cipher, ciphertext, key, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
            return plaintext;
          },
          _parse: function(ciphertext, format2) {
            if (typeof ciphertext == "string") {
              return format2.parse(ciphertext, this);
            } else {
              return ciphertext;
            }
          }
        });
        var C_kdf = C2.kdf = {};
        var OpenSSLKdf = C_kdf.OpenSSL = {
          execute: function(password, keySize, ivSize, salt) {
            if (!salt) {
              salt = WordArray.random(64 / 8);
            }
            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
            key.sigBytes = keySize * 4;
            return CipherParams.create({ key, iv, salt });
          }
        };
        var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
          cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
          }),
          encrypt: function(cipher, message, password, cfg) {
            cfg = this.cfg.extend(cfg);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);
            cfg.iv = derivedParams.iv;
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
            ciphertext.mixIn(derivedParams);
            return ciphertext;
          },
          decrypt: function(cipher, ciphertext, password, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);
            cfg.iv = derivedParams.iv;
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
            return plaintext;
          }
        });
      }();
    });
  })(cipherCore);
  return cipherCore.exports;
}
var modeCfb = { exports: {} };
var hasRequiredModeCfb;
function requireModeCfb() {
  if (hasRequiredModeCfb)
    return modeCfb.exports;
  hasRequiredModeCfb = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.mode.CFB = function() {
        var CFB = CryptoJS.lib.BlockCipherMode.extend();
        CFB.Encryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = words.slice(offset, offset + blockSize);
          }
        });
        CFB.Decryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var thisBlock = words.slice(offset, offset + blockSize);
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = thisBlock;
          }
        });
        function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
          var keystream;
          var iv = this._iv;
          if (iv) {
            keystream = iv.slice(0);
            this._iv = void 0;
          } else {
            keystream = this._prevBlock;
          }
          cipher.encryptBlock(keystream, 0);
          for (var i2 = 0; i2 < blockSize; i2++) {
            words[offset + i2] ^= keystream[i2];
          }
        }
        return CFB;
      }();
      return CryptoJS.mode.CFB;
    });
  })(modeCfb);
  return modeCfb.exports;
}
var modeCtr = { exports: {} };
var hasRequiredModeCtr;
function requireModeCtr() {
  if (hasRequiredModeCtr)
    return modeCtr.exports;
  hasRequiredModeCtr = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.mode.CTR = function() {
        var CTR = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = CTR.Encryptor = CTR.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
            for (var i2 = 0; i2 < blockSize; i2++) {
              words[offset + i2] ^= keystream[i2];
            }
          }
        });
        CTR.Decryptor = Encryptor;
        return CTR;
      }();
      return CryptoJS.mode.CTR;
    });
  })(modeCtr);
  return modeCtr.exports;
}
var modeCtrGladman = { exports: {} };
var hasRequiredModeCtrGladman;
function requireModeCtrGladman() {
  if (hasRequiredModeCtrGladman)
    return modeCtrGladman.exports;
  hasRequiredModeCtrGladman = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      /** @preserve
       * Counter block mode compatible with  Dr Brian Gladman fileenc.c
       * derived from CryptoJS.mode.CTR
       * Jan Hruby jhruby.web@gmail.com
       */
      CryptoJS.mode.CTRGladman = function() {
        var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();
        function incWord(word) {
          if ((word >> 24 & 255) === 255) {
            var b1 = word >> 16 & 255;
            var b2 = word >> 8 & 255;
            var b3 = word & 255;
            if (b1 === 255) {
              b1 = 0;
              if (b2 === 255) {
                b2 = 0;
                if (b3 === 255) {
                  b3 = 0;
                } else {
                  ++b3;
                }
              } else {
                ++b2;
              }
            } else {
              ++b1;
            }
            word = 0;
            word += b1 << 16;
            word += b2 << 8;
            word += b3;
          } else {
            word += 1 << 24;
          }
          return word;
        }
        function incCounter(counter) {
          if ((counter[0] = incWord(counter[0])) === 0) {
            counter[1] = incWord(counter[1]);
          }
          return counter;
        }
        var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            incCounter(counter);
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            for (var i2 = 0; i2 < blockSize; i2++) {
              words[offset + i2] ^= keystream[i2];
            }
          }
        });
        CTRGladman.Decryptor = Encryptor;
        return CTRGladman;
      }();
      return CryptoJS.mode.CTRGladman;
    });
  })(modeCtrGladman);
  return modeCtrGladman.exports;
}
var modeOfb = { exports: {} };
var hasRequiredModeOfb;
function requireModeOfb() {
  if (hasRequiredModeOfb)
    return modeOfb.exports;
  hasRequiredModeOfb = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.mode.OFB = function() {
        var OFB = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = OFB.Encryptor = OFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var keystream = this._keystream;
            if (iv) {
              keystream = this._keystream = iv.slice(0);
              this._iv = void 0;
            }
            cipher.encryptBlock(keystream, 0);
            for (var i2 = 0; i2 < blockSize; i2++) {
              words[offset + i2] ^= keystream[i2];
            }
          }
        });
        OFB.Decryptor = Encryptor;
        return OFB;
      }();
      return CryptoJS.mode.OFB;
    });
  })(modeOfb);
  return modeOfb.exports;
}
var modeEcb = { exports: {} };
var hasRequiredModeEcb;
function requireModeEcb() {
  if (hasRequiredModeEcb)
    return modeEcb.exports;
  hasRequiredModeEcb = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.mode.ECB = function() {
        var ECB = CryptoJS.lib.BlockCipherMode.extend();
        ECB.Encryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.encryptBlock(words, offset);
          }
        });
        ECB.Decryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.decryptBlock(words, offset);
          }
        });
        return ECB;
      }();
      return CryptoJS.mode.ECB;
    });
  })(modeEcb);
  return modeEcb.exports;
}
var padAnsix923 = { exports: {} };
var hasRequiredPadAnsix923;
function requirePadAnsix923() {
  if (hasRequiredPadAnsix923)
    return padAnsix923.exports;
  hasRequiredPadAnsix923 = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.pad.AnsiX923 = {
        pad: function(data2, blockSize) {
          var dataSigBytes = data2.sigBytes;
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
          var lastBytePos = dataSigBytes + nPaddingBytes - 1;
          data2.clamp();
          data2.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
          data2.sigBytes += nPaddingBytes;
        },
        unpad: function(data2) {
          var nPaddingBytes = data2.words[data2.sigBytes - 1 >>> 2] & 255;
          data2.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Ansix923;
    });
  })(padAnsix923);
  return padAnsix923.exports;
}
var padIso10126 = { exports: {} };
var hasRequiredPadIso10126;
function requirePadIso10126() {
  if (hasRequiredPadIso10126)
    return padIso10126.exports;
  hasRequiredPadIso10126 = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.pad.Iso10126 = {
        pad: function(data2, blockSize) {
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - data2.sigBytes % blockSizeBytes;
          data2.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
        },
        unpad: function(data2) {
          var nPaddingBytes = data2.words[data2.sigBytes - 1 >>> 2] & 255;
          data2.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Iso10126;
    });
  })(padIso10126);
  return padIso10126.exports;
}
var padIso97971 = { exports: {} };
var hasRequiredPadIso97971;
function requirePadIso97971() {
  if (hasRequiredPadIso97971)
    return padIso97971.exports;
  hasRequiredPadIso97971 = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.pad.Iso97971 = {
        pad: function(data2, blockSize) {
          data2.concat(CryptoJS.lib.WordArray.create([2147483648], 1));
          CryptoJS.pad.ZeroPadding.pad(data2, blockSize);
        },
        unpad: function(data2) {
          CryptoJS.pad.ZeroPadding.unpad(data2);
          data2.sigBytes--;
        }
      };
      return CryptoJS.pad.Iso97971;
    });
  })(padIso97971);
  return padIso97971.exports;
}
var padZeropadding = { exports: {} };
var hasRequiredPadZeropadding;
function requirePadZeropadding() {
  if (hasRequiredPadZeropadding)
    return padZeropadding.exports;
  hasRequiredPadZeropadding = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.pad.ZeroPadding = {
        pad: function(data2, blockSize) {
          var blockSizeBytes = blockSize * 4;
          data2.clamp();
          data2.sigBytes += blockSizeBytes - (data2.sigBytes % blockSizeBytes || blockSizeBytes);
        },
        unpad: function(data2) {
          var dataWords = data2.words;
          var i2 = data2.sigBytes - 1;
          for (var i2 = data2.sigBytes - 1; i2 >= 0; i2--) {
            if (dataWords[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255) {
              data2.sigBytes = i2 + 1;
              break;
            }
          }
        }
      };
      return CryptoJS.pad.ZeroPadding;
    });
  })(padZeropadding);
  return padZeropadding.exports;
}
var padNopadding = { exports: {} };
var hasRequiredPadNopadding;
function requirePadNopadding() {
  if (hasRequiredPadNopadding)
    return padNopadding.exports;
  hasRequiredPadNopadding = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.pad.NoPadding = {
        pad: function() {
        },
        unpad: function() {
        }
      };
      return CryptoJS.pad.NoPadding;
    });
  })(padNopadding);
  return padNopadding.exports;
}
var formatHex = { exports: {} };
var hasRequiredFormatHex;
function requireFormatHex() {
  if (hasRequiredFormatHex)
    return formatHex.exports;
  hasRequiredFormatHex = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function(undefined$1) {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var CipherParams = C_lib.CipherParams;
        var C_enc = C2.enc;
        var Hex = C_enc.Hex;
        var C_format = C2.format;
        C_format.Hex = {
          stringify: function(cipherParams) {
            return cipherParams.ciphertext.toString(Hex);
          },
          parse: function(input) {
            var ciphertext = Hex.parse(input);
            return CipherParams.create({ ciphertext });
          }
        };
      })();
      return CryptoJS.format.Hex;
    });
  })(formatHex);
  return formatHex.exports;
}
var aes = { exports: {} };
var hasRequiredAes;
function requireAes() {
  if (hasRequiredAes)
    return aes.exports;
  hasRequiredAes = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C2.algo;
        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX_0 = [];
        var SUB_MIX_1 = [];
        var SUB_MIX_2 = [];
        var SUB_MIX_3 = [];
        var INV_SUB_MIX_0 = [];
        var INV_SUB_MIX_1 = [];
        var INV_SUB_MIX_2 = [];
        var INV_SUB_MIX_3 = [];
        (function() {
          var d2 = [];
          for (var i2 = 0; i2 < 256; i2++) {
            if (i2 < 128) {
              d2[i2] = i2 << 1;
            } else {
              d2[i2] = i2 << 1 ^ 283;
            }
          }
          var x2 = 0;
          var xi2 = 0;
          for (var i2 = 0; i2 < 256; i2++) {
            var sx = xi2 ^ xi2 << 1 ^ xi2 << 2 ^ xi2 << 3 ^ xi2 << 4;
            sx = sx >>> 8 ^ sx & 255 ^ 99;
            SBOX[x2] = sx;
            INV_SBOX[sx] = x2;
            var x22 = d2[x2];
            var x4 = d2[x22];
            var x8 = d2[x4];
            var t2 = d2[sx] * 257 ^ sx * 16843008;
            SUB_MIX_0[x2] = t2 << 24 | t2 >>> 8;
            SUB_MIX_1[x2] = t2 << 16 | t2 >>> 16;
            SUB_MIX_2[x2] = t2 << 8 | t2 >>> 24;
            SUB_MIX_3[x2] = t2;
            var t2 = x8 * 16843009 ^ x4 * 65537 ^ x22 * 257 ^ x2 * 16843008;
            INV_SUB_MIX_0[sx] = t2 << 24 | t2 >>> 8;
            INV_SUB_MIX_1[sx] = t2 << 16 | t2 >>> 16;
            INV_SUB_MIX_2[sx] = t2 << 8 | t2 >>> 24;
            INV_SUB_MIX_3[sx] = t2;
            if (!x2) {
              x2 = xi2 = 1;
            } else {
              x2 = x22 ^ d2[d2[d2[x8 ^ x22]]];
              xi2 ^= d2[d2[xi2]];
            }
          }
        })();
        var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
        var AES = C_algo.AES = BlockCipher.extend({
          _doReset: function() {
            var t2;
            if (this._nRounds && this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            var nRounds = this._nRounds = keySize + 6;
            var ksRows = (nRounds + 1) * 4;
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
              if (ksRow < keySize) {
                keySchedule[ksRow] = keyWords[ksRow];
              } else {
                t2 = keySchedule[ksRow - 1];
                if (!(ksRow % keySize)) {
                  t2 = t2 << 8 | t2 >>> 24;
                  t2 = SBOX[t2 >>> 24] << 24 | SBOX[t2 >>> 16 & 255] << 16 | SBOX[t2 >>> 8 & 255] << 8 | SBOX[t2 & 255];
                  t2 ^= RCON[ksRow / keySize | 0] << 24;
                } else if (keySize > 6 && ksRow % keySize == 4) {
                  t2 = SBOX[t2 >>> 24] << 24 | SBOX[t2 >>> 16 & 255] << 16 | SBOX[t2 >>> 8 & 255] << 8 | SBOX[t2 & 255];
                }
                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t2;
              }
            }
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
              var ksRow = ksRows - invKsRow;
              if (invKsRow % 4) {
                var t2 = keySchedule[ksRow];
              } else {
                var t2 = keySchedule[ksRow - 4];
              }
              if (invKsRow < 4 || ksRow <= 4) {
                invKeySchedule[invKsRow] = t2;
              } else {
                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t2 >>> 24]] ^ INV_SUB_MIX_1[SBOX[t2 >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t2 >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t2 & 255]];
              }
            }
          },
          encryptBlock: function(M2, offset) {
            this._doCryptBlock(M2, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
          },
          decryptBlock: function(M2, offset) {
            var t2 = M2[offset + 1];
            M2[offset + 1] = M2[offset + 3];
            M2[offset + 3] = t2;
            this._doCryptBlock(M2, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
            var t2 = M2[offset + 1];
            M2[offset + 1] = M2[offset + 3];
            M2[offset + 3] = t2;
          },
          _doCryptBlock: function(M2, offset, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
            var nRounds = this._nRounds;
            var s0 = M2[offset] ^ keySchedule[0];
            var s1 = M2[offset + 1] ^ keySchedule[1];
            var s2 = M2[offset + 2] ^ keySchedule[2];
            var s3 = M2[offset + 3] ^ keySchedule[3];
            var ksRow = 4;
            for (var round2 = 1; round2 < nRounds; round2++) {
              var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s2 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
              var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s2 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
              var t2 = SUB_MIX_02[s2 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
              var t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s2 & 255] ^ keySchedule[ksRow++];
              s0 = t0;
              s1 = t1;
              s2 = t2;
              s3 = t3;
            }
            var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s2 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
            var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s2 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
            var t2 = (SBOX2[s2 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
            var t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s2 & 255]) ^ keySchedule[ksRow++];
            M2[offset] = t0;
            M2[offset + 1] = t1;
            M2[offset + 2] = t2;
            M2[offset + 3] = t3;
          },
          keySize: 256 / 32
        });
        C2.AES = BlockCipher._createHelper(AES);
      })();
      return CryptoJS.AES;
    });
  })(aes);
  return aes.exports;
}
var tripledes = { exports: {} };
var hasRequiredTripledes;
function requireTripledes() {
  if (hasRequiredTripledes)
    return tripledes.exports;
  hasRequiredTripledes = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C2.algo;
        var PC1 = [
          57,
          49,
          41,
          33,
          25,
          17,
          9,
          1,
          58,
          50,
          42,
          34,
          26,
          18,
          10,
          2,
          59,
          51,
          43,
          35,
          27,
          19,
          11,
          3,
          60,
          52,
          44,
          36,
          63,
          55,
          47,
          39,
          31,
          23,
          15,
          7,
          62,
          54,
          46,
          38,
          30,
          22,
          14,
          6,
          61,
          53,
          45,
          37,
          29,
          21,
          13,
          5,
          28,
          20,
          12,
          4
        ];
        var PC2 = [
          14,
          17,
          11,
          24,
          1,
          5,
          3,
          28,
          15,
          6,
          21,
          10,
          23,
          19,
          12,
          4,
          26,
          8,
          16,
          7,
          27,
          20,
          13,
          2,
          41,
          52,
          31,
          37,
          47,
          55,
          30,
          40,
          51,
          45,
          33,
          48,
          44,
          49,
          39,
          56,
          34,
          53,
          46,
          42,
          50,
          36,
          29,
          32
        ];
        var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
        var SBOX_P = [
          {
            0: 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
          },
          {
            0: 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
          },
          {
            0: 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
          },
          {
            0: 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
          },
          {
            0: 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
          },
          {
            0: 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
          },
          {
            0: 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
          },
          {
            0: 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
          }
        ];
        var SBOX_MASK = [
          4160749569,
          528482304,
          33030144,
          2064384,
          129024,
          8064,
          504,
          2147483679
        ];
        var DES = C_algo.DES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keyBits = [];
            for (var i2 = 0; i2 < 56; i2++) {
              var keyBitPos = PC1[i2] - 1;
              keyBits[i2] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
            }
            var subKeys = this._subKeys = [];
            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
              var subKey = subKeys[nSubKey] = [];
              var bitShift = BIT_SHIFTS[nSubKey];
              for (var i2 = 0; i2 < 24; i2++) {
                subKey[i2 / 6 | 0] |= keyBits[(PC2[i2] - 1 + bitShift) % 28] << 31 - i2 % 6;
                subKey[4 + (i2 / 6 | 0)] |= keyBits[28 + (PC2[i2 + 24] - 1 + bitShift) % 28] << 31 - i2 % 6;
              }
              subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
              for (var i2 = 1; i2 < 7; i2++) {
                subKey[i2] = subKey[i2] >>> (i2 - 1) * 4 + 3;
              }
              subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
            }
            var invSubKeys = this._invSubKeys = [];
            for (var i2 = 0; i2 < 16; i2++) {
              invSubKeys[i2] = subKeys[15 - i2];
            }
          },
          encryptBlock: function(M2, offset) {
            this._doCryptBlock(M2, offset, this._subKeys);
          },
          decryptBlock: function(M2, offset) {
            this._doCryptBlock(M2, offset, this._invSubKeys);
          },
          _doCryptBlock: function(M2, offset, subKeys) {
            this._lBlock = M2[offset];
            this._rBlock = M2[offset + 1];
            exchangeLR.call(this, 4, 252645135);
            exchangeLR.call(this, 16, 65535);
            exchangeRL.call(this, 2, 858993459);
            exchangeRL.call(this, 8, 16711935);
            exchangeLR.call(this, 1, 1431655765);
            for (var round2 = 0; round2 < 16; round2++) {
              var subKey = subKeys[round2];
              var lBlock = this._lBlock;
              var rBlock = this._rBlock;
              var f2 = 0;
              for (var i2 = 0; i2 < 8; i2++) {
                f2 |= SBOX_P[i2][((rBlock ^ subKey[i2]) & SBOX_MASK[i2]) >>> 0];
              }
              this._lBlock = rBlock;
              this._rBlock = lBlock ^ f2;
            }
            var t2 = this._lBlock;
            this._lBlock = this._rBlock;
            this._rBlock = t2;
            exchangeLR.call(this, 1, 1431655765);
            exchangeRL.call(this, 8, 16711935);
            exchangeRL.call(this, 2, 858993459);
            exchangeLR.call(this, 16, 65535);
            exchangeLR.call(this, 4, 252645135);
            M2[offset] = this._lBlock;
            M2[offset + 1] = this._rBlock;
          },
          keySize: 64 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        function exchangeLR(offset, mask) {
          var t2 = (this._lBlock >>> offset ^ this._rBlock) & mask;
          this._rBlock ^= t2;
          this._lBlock ^= t2 << offset;
        }
        function exchangeRL(offset, mask) {
          var t2 = (this._rBlock >>> offset ^ this._lBlock) & mask;
          this._lBlock ^= t2;
          this._rBlock ^= t2 << offset;
        }
        C2.DES = BlockCipher._createHelper(DES);
        var TripleDES = C_algo.TripleDES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
              throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
            }
            var key1 = keyWords.slice(0, 2);
            var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
            var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);
            this._des1 = DES.createEncryptor(WordArray.create(key1));
            this._des2 = DES.createEncryptor(WordArray.create(key2));
            this._des3 = DES.createEncryptor(WordArray.create(key3));
          },
          encryptBlock: function(M2, offset) {
            this._des1.encryptBlock(M2, offset);
            this._des2.decryptBlock(M2, offset);
            this._des3.encryptBlock(M2, offset);
          },
          decryptBlock: function(M2, offset) {
            this._des3.decryptBlock(M2, offset);
            this._des2.encryptBlock(M2, offset);
            this._des1.decryptBlock(M2, offset);
          },
          keySize: 192 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        C2.TripleDES = BlockCipher._createHelper(TripleDES);
      })();
      return CryptoJS.TripleDES;
    });
  })(tripledes);
  return tripledes.exports;
}
var rc4 = { exports: {} };
var hasRequiredRc4;
function requireRc4() {
  if (hasRequiredRc4)
    return rc4.exports;
  hasRequiredRc4 = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C2.algo;
        var RC4 = C_algo.RC4 = StreamCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keySigBytes = key.sigBytes;
            var S2 = this._S = [];
            for (var i2 = 0; i2 < 256; i2++) {
              S2[i2] = i2;
            }
            for (var i2 = 0, j = 0; i2 < 256; i2++) {
              var keyByteIndex = i2 % keySigBytes;
              var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
              j = (j + S2[i2] + keyByte) % 256;
              var t2 = S2[i2];
              S2[i2] = S2[j];
              S2[j] = t2;
            }
            this._i = this._j = 0;
          },
          _doProcessBlock: function(M2, offset) {
            M2[offset] ^= generateKeystreamWord.call(this);
          },
          keySize: 256 / 32,
          ivSize: 0
        });
        function generateKeystreamWord() {
          var S2 = this._S;
          var i2 = this._i;
          var j = this._j;
          var keystreamWord = 0;
          for (var n2 = 0; n2 < 4; n2++) {
            i2 = (i2 + 1) % 256;
            j = (j + S2[i2]) % 256;
            var t2 = S2[i2];
            S2[i2] = S2[j];
            S2[j] = t2;
            keystreamWord |= S2[(S2[i2] + S2[j]) % 256] << 24 - n2 * 8;
          }
          this._i = i2;
          this._j = j;
          return keystreamWord;
        }
        C2.RC4 = StreamCipher._createHelper(RC4);
        var RC4Drop = C_algo.RC4Drop = RC4.extend({
          cfg: RC4.cfg.extend({
            drop: 192
          }),
          _doReset: function() {
            RC4._doReset.call(this);
            for (var i2 = this.cfg.drop; i2 > 0; i2--) {
              generateKeystreamWord.call(this);
            }
          }
        });
        C2.RC4Drop = StreamCipher._createHelper(RC4Drop);
      })();
      return CryptoJS.RC4;
    });
  })(rc4);
  return rc4.exports;
}
var rabbit = { exports: {} };
var hasRequiredRabbit;
function requireRabbit() {
  if (hasRequiredRabbit)
    return rabbit.exports;
  hasRequiredRabbit = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C2.algo;
        var S2 = [];
        var C_ = [];
        var G2 = [];
        var Rabbit = C_algo.Rabbit = StreamCipher.extend({
          _doReset: function() {
            var K2 = this._key.words;
            var iv = this.cfg.iv;
            for (var i2 = 0; i2 < 4; i2++) {
              K2[i2] = (K2[i2] << 8 | K2[i2] >>> 24) & 16711935 | (K2[i2] << 24 | K2[i2] >>> 8) & 4278255360;
            }
            var X2 = this._X = [
              K2[0],
              K2[3] << 16 | K2[2] >>> 16,
              K2[1],
              K2[0] << 16 | K2[3] >>> 16,
              K2[2],
              K2[1] << 16 | K2[0] >>> 16,
              K2[3],
              K2[2] << 16 | K2[1] >>> 16
            ];
            var C3 = this._C = [
              K2[2] << 16 | K2[2] >>> 16,
              K2[0] & 4294901760 | K2[1] & 65535,
              K2[3] << 16 | K2[3] >>> 16,
              K2[1] & 4294901760 | K2[2] & 65535,
              K2[0] << 16 | K2[0] >>> 16,
              K2[2] & 4294901760 | K2[3] & 65535,
              K2[1] << 16 | K2[1] >>> 16,
              K2[3] & 4294901760 | K2[0] & 65535
            ];
            this._b = 0;
            for (var i2 = 0; i2 < 4; i2++) {
              nextState.call(this);
            }
            for (var i2 = 0; i2 < 8; i2++) {
              C3[i2] ^= X2[i2 + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i22 & 4294901760;
              var i3 = i22 << 16 | i0 & 65535;
              C3[0] ^= i0;
              C3[1] ^= i1;
              C3[2] ^= i22;
              C3[3] ^= i3;
              C3[4] ^= i0;
              C3[5] ^= i1;
              C3[6] ^= i22;
              C3[7] ^= i3;
              for (var i2 = 0; i2 < 4; i2++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M2, offset) {
            var X2 = this._X;
            nextState.call(this);
            S2[0] = X2[0] ^ X2[5] >>> 16 ^ X2[3] << 16;
            S2[1] = X2[2] ^ X2[7] >>> 16 ^ X2[5] << 16;
            S2[2] = X2[4] ^ X2[1] >>> 16 ^ X2[7] << 16;
            S2[3] = X2[6] ^ X2[3] >>> 16 ^ X2[1] << 16;
            for (var i2 = 0; i2 < 4; i2++) {
              S2[i2] = (S2[i2] << 8 | S2[i2] >>> 24) & 16711935 | (S2[i2] << 24 | S2[i2] >>> 8) & 4278255360;
              M2[offset + i2] ^= S2[i2];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X2 = this._X;
          var C3 = this._C;
          for (var i2 = 0; i2 < 8; i2++) {
            C_[i2] = C3[i2];
          }
          C3[0] = C3[0] + 1295307597 + this._b | 0;
          C3[1] = C3[1] + 3545052371 + (C3[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C3[2] = C3[2] + 886263092 + (C3[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C3[3] = C3[3] + 1295307597 + (C3[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C3[4] = C3[4] + 3545052371 + (C3[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C3[5] = C3[5] + 886263092 + (C3[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C3[6] = C3[6] + 1295307597 + (C3[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C3[7] = C3[7] + 3545052371 + (C3[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C3[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i2 = 0; i2 < 8; i2++) {
            var gx = X2[i2] + C3[i2];
            var ga = gx & 65535;
            var gb2 = gx >>> 16;
            var gh2 = ((ga * ga >>> 17) + ga * gb2 >>> 15) + gb2 * gb2;
            var gl2 = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G2[i2] = gh2 ^ gl2;
          }
          X2[0] = G2[0] + (G2[7] << 16 | G2[7] >>> 16) + (G2[6] << 16 | G2[6] >>> 16) | 0;
          X2[1] = G2[1] + (G2[0] << 8 | G2[0] >>> 24) + G2[7] | 0;
          X2[2] = G2[2] + (G2[1] << 16 | G2[1] >>> 16) + (G2[0] << 16 | G2[0] >>> 16) | 0;
          X2[3] = G2[3] + (G2[2] << 8 | G2[2] >>> 24) + G2[1] | 0;
          X2[4] = G2[4] + (G2[3] << 16 | G2[3] >>> 16) + (G2[2] << 16 | G2[2] >>> 16) | 0;
          X2[5] = G2[5] + (G2[4] << 8 | G2[4] >>> 24) + G2[3] | 0;
          X2[6] = G2[6] + (G2[5] << 16 | G2[5] >>> 16) + (G2[4] << 16 | G2[4] >>> 16) | 0;
          X2[7] = G2[7] + (G2[6] << 8 | G2[6] >>> 24) + G2[5] | 0;
        }
        C2.Rabbit = StreamCipher._createHelper(Rabbit);
      })();
      return CryptoJS.Rabbit;
    });
  })(rabbit);
  return rabbit.exports;
}
var rabbitLegacy = { exports: {} };
var hasRequiredRabbitLegacy;
function requireRabbitLegacy() {
  if (hasRequiredRabbitLegacy)
    return rabbitLegacy.exports;
  hasRequiredRabbitLegacy = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C2 = CryptoJS;
        var C_lib = C2.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C2.algo;
        var S2 = [];
        var C_ = [];
        var G2 = [];
        var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
          _doReset: function() {
            var K2 = this._key.words;
            var iv = this.cfg.iv;
            var X2 = this._X = [
              K2[0],
              K2[3] << 16 | K2[2] >>> 16,
              K2[1],
              K2[0] << 16 | K2[3] >>> 16,
              K2[2],
              K2[1] << 16 | K2[0] >>> 16,
              K2[3],
              K2[2] << 16 | K2[1] >>> 16
            ];
            var C3 = this._C = [
              K2[2] << 16 | K2[2] >>> 16,
              K2[0] & 4294901760 | K2[1] & 65535,
              K2[3] << 16 | K2[3] >>> 16,
              K2[1] & 4294901760 | K2[2] & 65535,
              K2[0] << 16 | K2[0] >>> 16,
              K2[2] & 4294901760 | K2[3] & 65535,
              K2[1] << 16 | K2[1] >>> 16,
              K2[3] & 4294901760 | K2[0] & 65535
            ];
            this._b = 0;
            for (var i2 = 0; i2 < 4; i2++) {
              nextState.call(this);
            }
            for (var i2 = 0; i2 < 8; i2++) {
              C3[i2] ^= X2[i2 + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i22 & 4294901760;
              var i3 = i22 << 16 | i0 & 65535;
              C3[0] ^= i0;
              C3[1] ^= i1;
              C3[2] ^= i22;
              C3[3] ^= i3;
              C3[4] ^= i0;
              C3[5] ^= i1;
              C3[6] ^= i22;
              C3[7] ^= i3;
              for (var i2 = 0; i2 < 4; i2++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M2, offset) {
            var X2 = this._X;
            nextState.call(this);
            S2[0] = X2[0] ^ X2[5] >>> 16 ^ X2[3] << 16;
            S2[1] = X2[2] ^ X2[7] >>> 16 ^ X2[5] << 16;
            S2[2] = X2[4] ^ X2[1] >>> 16 ^ X2[7] << 16;
            S2[3] = X2[6] ^ X2[3] >>> 16 ^ X2[1] << 16;
            for (var i2 = 0; i2 < 4; i2++) {
              S2[i2] = (S2[i2] << 8 | S2[i2] >>> 24) & 16711935 | (S2[i2] << 24 | S2[i2] >>> 8) & 4278255360;
              M2[offset + i2] ^= S2[i2];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X2 = this._X;
          var C3 = this._C;
          for (var i2 = 0; i2 < 8; i2++) {
            C_[i2] = C3[i2];
          }
          C3[0] = C3[0] + 1295307597 + this._b | 0;
          C3[1] = C3[1] + 3545052371 + (C3[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C3[2] = C3[2] + 886263092 + (C3[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C3[3] = C3[3] + 1295307597 + (C3[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C3[4] = C3[4] + 3545052371 + (C3[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C3[5] = C3[5] + 886263092 + (C3[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C3[6] = C3[6] + 1295307597 + (C3[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C3[7] = C3[7] + 3545052371 + (C3[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C3[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i2 = 0; i2 < 8; i2++) {
            var gx = X2[i2] + C3[i2];
            var ga = gx & 65535;
            var gb2 = gx >>> 16;
            var gh2 = ((ga * ga >>> 17) + ga * gb2 >>> 15) + gb2 * gb2;
            var gl2 = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G2[i2] = gh2 ^ gl2;
          }
          X2[0] = G2[0] + (G2[7] << 16 | G2[7] >>> 16) + (G2[6] << 16 | G2[6] >>> 16) | 0;
          X2[1] = G2[1] + (G2[0] << 8 | G2[0] >>> 24) + G2[7] | 0;
          X2[2] = G2[2] + (G2[1] << 16 | G2[1] >>> 16) + (G2[0] << 16 | G2[0] >>> 16) | 0;
          X2[3] = G2[3] + (G2[2] << 8 | G2[2] >>> 24) + G2[1] | 0;
          X2[4] = G2[4] + (G2[3] << 16 | G2[3] >>> 16) + (G2[2] << 16 | G2[2] >>> 16) | 0;
          X2[5] = G2[5] + (G2[4] << 8 | G2[4] >>> 24) + G2[3] | 0;
          X2[6] = G2[6] + (G2[5] << 16 | G2[5] >>> 16) + (G2[4] << 16 | G2[4] >>> 16) | 0;
          X2[7] = G2[7] + (G2[6] << 8 | G2[6] >>> 24) + G2[5] | 0;
        }
        C2.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
      })();
      return CryptoJS.RabbitLegacy;
    });
  })(rabbitLegacy);
  return rabbitLegacy.exports;
}
(function(module2, exports2) {
  (function(root2, factory, undef) {
    {
      module2.exports = factory(requireCore(), requireX64Core(), requireLibTypedarrays(), requireEncUtf16(), requireEncBase64(), requireEncBase64url(), requireMd5(), requireSha1(), requireSha256(), requireSha224(), requireSha512(), requireSha384(), requireSha3(), requireRipemd160(), requireHmac(), requirePbkdf2(), requireEvpkdf(), requireCipherCore(), requireModeCfb(), requireModeCtr(), requireModeCtrGladman(), requireModeOfb(), requireModeEcb(), requirePadAnsix923(), requirePadIso10126(), requirePadIso97971(), requirePadZeropadding(), requirePadNopadding(), requireFormatHex(), requireAes(), requireTripledes(), requireRc4(), requireRabbit(), requireRabbitLegacy());
    }
  })(commonjsGlobal, function(CryptoJS) {
    return CryptoJS;
  });
})(cryptoJs);
var Buffer = buffer$1.Buffer;
var CRC_TABLE = [
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918e3,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
];
if (typeof Int32Array !== "undefined") {
  CRC_TABLE = new Int32Array(CRC_TABLE);
}
function ensureBuffer(input) {
  if (Buffer.isBuffer(input)) {
    return input;
  }
  var hasNewBufferAPI = typeof Buffer.alloc === "function" && typeof Buffer.from === "function";
  if (typeof input === "number") {
    return hasNewBufferAPI ? Buffer.alloc(input) : new Buffer(input);
  } else if (typeof input === "string") {
    return hasNewBufferAPI ? Buffer.from(input) : new Buffer(input);
  } else {
    throw new Error("input must be buffer, number, or string, received " + typeof input);
  }
}
function bufferizeInt(num) {
  var tmp = ensureBuffer(4);
  tmp.writeInt32BE(num, 0);
  return tmp;
}
function _crc32(buf, previous) {
  buf = ensureBuffer(buf);
  if (Buffer.isBuffer(previous)) {
    previous = previous.readUInt32BE(0);
  }
  var crc = ~~previous ^ -1;
  for (var n2 = 0; n2 < buf.length; n2++) {
    crc = CRC_TABLE[(crc ^ buf[n2]) & 255] ^ crc >>> 8;
  }
  return crc ^ -1;
}
function crc32() {
  return bufferizeInt(_crc32.apply(null, arguments));
}
crc32.signed = function() {
  return _crc32.apply(null, arguments);
};
crc32.unsigned = function() {
  return _crc32.apply(null, arguments) >>> 0;
};
var bufferCrc32 = crc32;
var __importDefault$8 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(account, "__esModule", { value: true });
account.getAccountId = void 0;
const crypto_js_1 = __importDefault$8(cryptoJs.exports);
const buffer_crc32_1 = __importDefault$8(bufferCrc32);
const ACCOUNT_DOMAIN_SEPERATOR = "\naccount-id";
const SUB_ACCOUNT_ZERO = buffer$1.Buffer.alloc(32);
const byteArrayToWordArray = (byteArray) => {
  const wordArray = [];
  let i2;
  for (i2 = 0; i2 < byteArray.length; i2 += 1) {
    wordArray[i2 / 4 | 0] |= byteArray[i2] << 24 - 8 * i2;
  }
  const result = crypto_js_1.default.lib.WordArray.create(wordArray, byteArray.length);
  return result;
};
const wordToByteArray = (word, length2) => {
  const byteArray = [];
  const xFF = 255;
  if (length2 > 0)
    byteArray.push(word >>> 24);
  if (length2 > 1)
    byteArray.push(word >>> 16 & xFF);
  if (length2 > 2)
    byteArray.push(word >>> 8 & xFF);
  if (length2 > 3)
    byteArray.push(word & xFF);
  return byteArray;
};
const wordArrayToByteArray = (wordArray, length2) => {
  if (wordArray.hasOwnProperty("sigBytes") && wordArray.hasOwnProperty("words")) {
    length2 = wordArray.sigBytes;
    wordArray = wordArray.words;
  }
  let result = [];
  let bytes2;
  let i2 = 0;
  while (length2 > 0) {
    bytes2 = wordToByteArray(wordArray[i2], Math.min(4, length2));
    length2 -= bytes2.length;
    result = [...result, bytes2];
    i2++;
  }
  return [].concat.apply([], result);
};
const intToHex = (val) => val < 0 ? (Number(val) >>> 0).toString(16) : Number(val).toString(16);
const generateChecksum = (hash2) => {
  const crc = buffer_crc32_1.default.unsigned(buffer$1.Buffer.from(hash2));
  const hex = intToHex(crc);
  return hex.padStart(8, "0");
};
const getAccountId = (principal, subAccount) => {
  const sha = crypto_js_1.default.algo.SHA224.create();
  sha.update(ACCOUNT_DOMAIN_SEPERATOR);
  sha.update(byteArrayToWordArray(principal.toUint8Array()));
  const subBuffer = buffer$1.Buffer.from(SUB_ACCOUNT_ZERO);
  if (subAccount) {
    subBuffer.writeUInt32BE(subAccount);
  }
  sha.update(byteArrayToWordArray(subBuffer));
  const hash2 = sha.finalize();
  const byteArray = wordArrayToByteArray(hash2, 28);
  const checksum = generateChecksum(byteArray);
  const val = checksum + hash2.toString();
  return val;
};
account.getAccountId = getAccountId;
account.default = {};
var number = {};
Object.defineProperty(number, "__esModule", { value: true });
number.from32bits = number.to32bits = void 0;
const to32bits = (num) => {
  const b2 = new ArrayBuffer(4);
  new DataView(b2).setUint32(0, num);
  return Array.from(new Uint8Array(b2));
};
number.to32bits = to32bits;
const from32bits = (ba) => {
  let value2;
  for (let i2 = 0; i2 < 4; i2 += 1) {
    value2 = value2 << 8 | ba[i2];
  }
  return value2;
};
number.from32bits = from32bits;
var canisters = {};
Object.defineProperty(canisters, "__esModule", { value: true });
canisters.NFT_CANISTERS = void 0;
canisters.NFT_CANISTERS = {
  WRAPPED_PUNKS: "bxdf4-baaaa-aaaah-qaruq-cai",
  WRAPPED_DRIP: "3db6u-aiaaa-aaaah-qbjbq-cai",
  IC_PUNKS: "qcg3w-tyaaa-aaaah-qakea-cai",
  IC_DRIP: "d3ttm-qaaaa-aaaai-qam4a-cai",
  ICP_BUNNY_MAIN: "xkbqi-2qaaa-aaaah-qbpqq-cai",
  ICP_BUNNY_STORAGE: [
    "efqhu-yqaaa-aaaaf-qaeda-cai",
    "ecrba-viaaa-aaaaf-qaedq-cai",
    "fp7fo-2aaaa-aaaaf-qaeea-cai",
    "fi6d2-xyaaa-aaaaf-qaeeq-cai",
    "fb5ig-bqaaa-aaaaf-qaefa-cai",
    "fg4os-miaaa-aaaaf-qaefq-cai",
    "ft377-naaaa-aaaaf-qaega-cai",
    "fu2zl-ayaaa-aaaaf-qaegq-cai",
    "f5zsx-wqaaa-aaaaf-qaeha-cai",
    "f2yud-3iaaa-aaaaf-qaehq-cai"
  ]
};
var standards = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.NFT = exports2.TOKEN = void 0;
  exports2.TOKEN = {
    dip20: "DIP20",
    xtc: "XTC",
    wicp: "WICP",
    ext: "EXT",
    icp: "ICP",
    rosetta: "ROSETTA"
  };
  exports2.NFT = {
    ext: "EXT",
    icpunks: "ICPunks",
    departuresLabs: "DepartureLabs",
    erc721: "ERC721",
    dip721: "DIP721",
    c3: "C3",
    nftOrigyn: "nftOrigyn"
  };
  exports2.default = {
    TOKEN: exports2.TOKEN,
    NFT: exports2.NFT
  };
})(standards);
var __awaiter$c = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve) {
      resolve(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __importDefault$7 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(ext, "__esModule", { value: true });
const agent_1$7 = require$$5;
const principal_1$6 = require$$4;
const ext_did_1 = __importDefault$7(ext_did);
const default_1$5 = __importDefault$7(_default);
const account_1$1 = account;
const number_1 = number;
const canisters_1$1 = canisters;
const standards_1$5 = standards;
const getTokenIdentifier = (canister, index2) => {
  const padding = buffer$1.Buffer.from("\ntid");
  const array2 = new Uint8Array([
    ...padding,
    ...principal_1$6.Principal.fromText(canister).toUint8Array(),
    ...(0, number_1.to32bits)(index2)
  ]);
  return principal_1$6.Principal.fromUint8Array(array2).toText();
};
const extImageUrl = (canisterId, index2, tokenIdentifier) => ({
  [canisters_1$1.NFT_CANISTERS.WRAPPED_PUNKS]: `https://${canisters_1$1.NFT_CANISTERS.IC_PUNKS}.raw.ic0.app/Token/${index2}`,
  [canisters_1$1.NFT_CANISTERS.WRAPPED_DRIP]: `https://${canisters_1$1.NFT_CANISTERS.IC_DRIP}.raw.ic0.app?tokenId=${index2}`
})[canisterId] || `https://${canisterId}.raw.ic0.app/?type=thumbnail&tokenid=${tokenIdentifier}`;
class EXT extends default_1$5.default {
  constructor(canisterId, agent) {
    super(canisterId, agent);
    this.standard = standards_1$5.NFT.ext;
    this.actor = agent_1$7.Actor.createActor(ext_did_1.default, {
      agent,
      canisterId
    });
  }
  getUserTokens(principal) {
    return __awaiter$c(this, void 0, void 0, function* () {
      const accountId = (0, account_1$1.getAccountId)(principal);
      const userTokensResult = yield this.actor.tokens_ext(accountId);
      if ("err" in userTokensResult)
        throw new Error(`${Object.keys(userTokensResult.err)[0]}: ${Object.values(userTokensResult.err)[0]}`);
      const tokens = userTokensResult.ok || [];
      return tokens.map((token2) => {
        const metadata = token2[2];
        const tokenIndex = token2[0];
        return this.serializeTokenData(metadata, getTokenIdentifier(this.canisterId, tokenIndex), tokenIndex);
      });
    });
  }
  getMetadata() {
    throw new Error("Method not implemented.");
  }
  transfer(to, tokenIndex) {
    return __awaiter$c(this, void 0, void 0, function* () {
      const tokenIdentifier = getTokenIdentifier(this.canisterId, tokenIndex);
      const from2 = yield this.agent.getPrincipal();
      const dummyMemmo = new Array(32).fill(0);
      const transferResult = yield this.actor.transfer({
        to: { principal: to },
        from: { principal: from2 },
        token: tokenIdentifier,
        amount: BigInt(1),
        memo: dummyMemmo,
        notify: false,
        subaccount: [],
        fee: BigInt(0)
      });
      if ("err" in transferResult)
        throw new Error(`${Object.keys(transferResult.err)[0]}: ${Object.values(transferResult.err)[0]}`);
    });
  }
  details(tokenIndex) {
    return __awaiter$c(this, void 0, void 0, function* () {
      const tokenIdentifier = getTokenIdentifier(this.canisterId, tokenIndex);
      const metadataResult = yield this.actor.metadata(tokenIdentifier);
      if ("err" in metadataResult)
        throw new Error(`${Object.keys(metadataResult.err)[0]}: ${Object.values(metadataResult.err)[0]}`);
      const { metadata = {} } = "nonfungible" in metadataResult.ok ? metadataResult.ok.nonfungible : {};
      return this.serializeTokenData(metadata, tokenIdentifier, tokenIndex);
    });
  }
  serializeTokenData(metadata, tokenIdentifier, tokenIndex) {
    return {
      id: tokenIdentifier,
      index: BigInt(tokenIndex),
      canister: this.canisterId,
      metadata: metadata.length ? metadata[0] : void 0,
      url: extImageUrl(this.canisterId, tokenIndex, tokenIdentifier),
      standard: this.standard
    };
  }
}
ext.default = EXT;
var ic_punks = {};
var icpunks_did = {};
Object.defineProperty(icpunks_did, "__esModule", { value: true });
icpunks_did.init = void 0;
icpunks_did.default = ({ IDL: IDL2 }) => {
  const Property = IDL2.Record({ value: IDL2.Text, name: IDL2.Text });
  const TokenDesc = IDL2.Record({
    id: IDL2.Nat,
    url: IDL2.Text,
    owner: IDL2.Principal,
    desc: IDL2.Text,
    name: IDL2.Text,
    properties: IDL2.Vec(Property)
  });
  const TokenIndex = IDL2.Nat;
  const ICPunk = IDL2.Service({
    data_of: IDL2.Func([TokenIndex], [TokenDesc], []),
    transfer_to: IDL2.Func([IDL2.Principal, TokenIndex], [IDL2.Bool], []),
    user_tokens: IDL2.Func([IDL2.Principal], [IDL2.Vec(IDL2.Nat)], [])
  });
  return ICPunk;
};
const init$c = ({ IDL: IDL2 }) => {
  return [IDL2.Text, IDL2.Text, IDL2.Nat, IDL2.Principal];
};
icpunks_did.init = init$c;
var __awaiter$b = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve) {
      resolve(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __importDefault$6 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(ic_punks, "__esModule", { value: true });
const agent_1$6 = require$$5;
const icpunks_did_1 = __importDefault$6(icpunks_did);
const default_1$4 = __importDefault$6(_default);
const canisters_1 = canisters;
const standards_1$4 = standards;
const getICPBunnyCanisterId = (index2) => canisters_1.NFT_CANISTERS.ICP_BUNNY_STORAGE[index2 % 10];
const imageUrl = (canisterId, index2, tokenDataUrl) => ({
  [canisters_1.NFT_CANISTERS.ICP_BUNNY_MAIN]: `https://${getICPBunnyCanisterId(index2)}.raw.ic0.app/Token/${index2}`
})[canisterId] || `https://${canisterId}.raw.ic0.app${tokenDataUrl}`;
class ICPUNKS extends default_1$4.default {
  constructor(canisterId, agent) {
    super(canisterId, agent);
    this.standard = standards_1$4.NFT.icpunks;
    this.serializeTokenData = (tokenData) => ({
      index: BigInt(tokenData.id),
      canister: this.canisterId,
      url: imageUrl(this.canisterId, Number.parseInt(tokenData.id.toString(), 10), tokenData.url),
      name: tokenData.name,
      metadata: tokenData,
      standard: this.standard
    });
    this.actor = agent_1$6.Actor.createActor(icpunks_did_1.default, {
      agent,
      canisterId
    });
  }
  getMetadata() {
    throw new Error("Method not implemented.");
  }
  getUserTokens(principal) {
    return __awaiter$b(this, void 0, void 0, function* () {
      const tokensIndexes = yield this.actor.user_tokens(principal);
      const tokensData = yield Promise.all(tokensIndexes.map((tokenIndex) => this.actor.data_of(tokenIndex)));
      return tokensData.map((token2) => this.serializeTokenData(token2));
    });
  }
  transfer(to, tokenIndex) {
    return __awaiter$b(this, void 0, void 0, function* () {
      const success = yield this.actor.transfer_to(to, BigInt(tokenIndex));
      if (!success) {
        throw new Error("Error transfering token");
      }
    });
  }
  details(tokenIndex) {
    return __awaiter$b(this, void 0, void 0, function* () {
      const tokenData = yield this.actor.data_of(BigInt(tokenIndex));
      return this.serializeTokenData(tokenData);
    });
  }
}
ic_punks.default = ICPUNKS;
var nft_origyn = {};
var nft_origyn_did = {};
Object.defineProperty(nft_origyn_did, "__esModule", { value: true });
nft_origyn_did.init = void 0;
nft_origyn_did.default = ({ IDL: IDL2 }) => {
  const CandyValue = IDL2.Rec();
  const Update = IDL2.Rec();
  const Principal2 = IDL2.Principal;
  IDL2.Record({
    "owner": Principal2,
    "storage_space": IDL2.Opt(IDL2.Nat)
  });
  const TokenIdentifier = IDL2.Text;
  const AccountIdentifier = IDL2.Text;
  const User = IDL2.Variant({
    "principal": IDL2.Principal,
    "address": AccountIdentifier
  });
  const BalanceRequest = IDL2.Record({
    "token": TokenIdentifier,
    "user": User
  });
  const Balance = IDL2.Nat;
  const CommonError = IDL2.Variant({
    "InvalidToken": TokenIdentifier,
    "Other": IDL2.Text
  });
  const BalanceResponse__1 = IDL2.Variant({
    "ok": Balance,
    "err": CommonError
  });
  const Property = IDL2.Record({
    "value": CandyValue,
    "name": IDL2.Text,
    "immutable": IDL2.Bool
  });
  CandyValue.fill(IDL2.Variant({
    "Int": IDL2.Int,
    "Nat": IDL2.Nat,
    "Empty": IDL2.Null,
    "Nat16": IDL2.Nat16,
    "Nat32": IDL2.Nat32,
    "Nat64": IDL2.Nat64,
    "Blob": IDL2.Vec(IDL2.Nat8),
    "Bool": IDL2.Bool,
    "Int8": IDL2.Int8,
    "Nat8": IDL2.Nat8,
    "Nats": IDL2.Variant({
      "thawed": IDL2.Vec(IDL2.Nat),
      "frozen": IDL2.Vec(IDL2.Nat)
    }),
    "Text": IDL2.Text,
    "Bytes": IDL2.Variant({
      "thawed": IDL2.Vec(IDL2.Nat8),
      "frozen": IDL2.Vec(IDL2.Nat8)
    }),
    "Int16": IDL2.Int16,
    "Int32": IDL2.Int32,
    "Int64": IDL2.Int64,
    "Option": IDL2.Opt(CandyValue),
    "Floats": IDL2.Variant({
      "thawed": IDL2.Vec(IDL2.Float64),
      "frozen": IDL2.Vec(IDL2.Float64)
    }),
    "Float": IDL2.Float64,
    "Principal": IDL2.Principal,
    "Array": IDL2.Variant({
      "thawed": IDL2.Vec(CandyValue),
      "frozen": IDL2.Vec(CandyValue)
    }),
    "Class": IDL2.Vec(Property)
  }));
  const Account = IDL2.Variant({
    "account_id": IDL2.Text,
    "principal": IDL2.Principal,
    "extensible": CandyValue
  });
  const ICTokenSpec = IDL2.Record({
    "fee": IDL2.Nat,
    "decimals": IDL2.Nat,
    "canister": IDL2.Principal,
    "standard": IDL2.Variant({
      "EXTFungible": IDL2.Null,
      "DIP20": IDL2.Null,
      "Ledger": IDL2.Null
    }),
    "symbol": IDL2.Text
  });
  const TokenSpec = IDL2.Variant({
    "ic": ICTokenSpec,
    "extensible": CandyValue
  });
  const EscrowRecord = IDL2.Record({
    "token": TokenSpec,
    "token_id": IDL2.Text,
    "seller": Account,
    "lock_to_date": IDL2.Opt(IDL2.Int),
    "buyer": Account,
    "amount": IDL2.Nat,
    "sale_id": IDL2.Opt(IDL2.Text)
  });
  const StakeRecord = IDL2.Record({
    "staker": Account,
    "token_id": IDL2.Text,
    "amount": IDL2.Nat
  });
  const BalanceResponse = IDL2.Record({
    "nfts": IDL2.Vec(IDL2.Text),
    "sales": IDL2.Vec(EscrowRecord),
    "stake": IDL2.Vec(StakeRecord),
    "multi_canister": IDL2.Opt(IDL2.Vec(IDL2.Principal)),
    "escrow": IDL2.Vec(EscrowRecord)
  });
  const Errors = IDL2.Variant({
    "nyi": IDL2.Null,
    "storage_configuration_error": IDL2.Null,
    "escrow_withdraw_payment_failed": IDL2.Null,
    "token_not_found": IDL2.Null,
    "owner_not_found": IDL2.Null,
    "content_not_found": IDL2.Null,
    "auction_ended": IDL2.Null,
    "out_of_range": IDL2.Null,
    "sale_id_does_not_match": IDL2.Null,
    "sale_not_found": IDL2.Null,
    "item_not_owned": IDL2.Null,
    "property_not_found": IDL2.Null,
    "validate_trx_wrong_host": IDL2.Null,
    "withdraw_too_large": IDL2.Null,
    "content_not_deserializable": IDL2.Null,
    "bid_too_low": IDL2.Null,
    "validate_deposit_wrong_amount": IDL2.Null,
    "existing_sale_found": IDL2.Null,
    "asset_mismatch": IDL2.Null,
    "escrow_cannot_be_removed": IDL2.Null,
    "deposit_burned": IDL2.Null,
    "cannot_restage_minted_token": IDL2.Null,
    "cannot_find_status_in_metadata": IDL2.Null,
    "receipt_data_mismatch": IDL2.Null,
    "validate_deposit_failed": IDL2.Null,
    "unauthorized_access": IDL2.Null,
    "item_already_minted": IDL2.Null,
    "no_escrow_found": IDL2.Null,
    "escrow_owner_not_the_owner": IDL2.Null,
    "improper_interface": IDL2.Null,
    "app_id_not_found": IDL2.Null,
    "token_non_transferable": IDL2.Null,
    "sale_not_over": IDL2.Null,
    "update_class_error": IDL2.Null,
    "malformed_metadata": IDL2.Null,
    "token_id_mismatch": IDL2.Null,
    "id_not_found_in_metadata": IDL2.Null,
    "auction_not_started": IDL2.Null,
    "library_not_found": IDL2.Null,
    "attempt_to_stage_system_data": IDL2.Null,
    "validate_deposit_wrong_buyer": IDL2.Null,
    "not_enough_storage": IDL2.Null,
    "sales_withdraw_payment_failed": IDL2.Null
  });
  const OrigynError = IDL2.Record({
    "text": IDL2.Text,
    "error": Errors,
    "number": IDL2.Nat32,
    "flag_point": IDL2.Text
  });
  const Result_19 = IDL2.Variant({
    "ok": BalanceResponse,
    "err": OrigynError
  });
  const Result_18 = IDL2.Variant({
    "ok": AccountIdentifier,
    "err": CommonError
  });
  const Result_17 = IDL2.Variant({ "ok": Account, "err": OrigynError });
  const EscrowReceipt = IDL2.Record({
    "token": TokenSpec,
    "token_id": IDL2.Text,
    "seller": Account,
    "buyer": Account,
    "amount": IDL2.Nat
  });
  const BidRequest = IDL2.Record({
    "escrow_receipt": EscrowReceipt,
    "sale_id": IDL2.Text
  });
  const TransactionID = IDL2.Variant({
    "nat": IDL2.Nat,
    "text": IDL2.Text,
    "extensible": CandyValue
  });
  const AuctionConfig = IDL2.Record({
    "start_price": IDL2.Nat,
    "token": TokenSpec,
    "reserve": IDL2.Opt(IDL2.Nat),
    "start_date": IDL2.Int,
    "min_increase": IDL2.Variant({
      "amount": IDL2.Nat,
      "percentage": IDL2.Float64
    }),
    "allow_list": IDL2.Opt(IDL2.Vec(IDL2.Principal)),
    "buy_now": IDL2.Opt(IDL2.Nat),
    "ending": IDL2.Variant({
      "waitForQuiet": IDL2.Record({
        "max": IDL2.Nat,
        "date": IDL2.Int,
        "fade": IDL2.Float64,
        "extention": IDL2.Nat64
      }),
      "date": IDL2.Int
    })
  });
  const PricingConfig = IDL2.Variant({
    "flat": IDL2.Record({ "token": TokenSpec, "amount": IDL2.Nat }),
    "extensible": IDL2.Variant({ "candyClass": IDL2.Null }),
    "instant": IDL2.Null,
    "auction": AuctionConfig,
    "dutch": IDL2.Record({
      "start_price": IDL2.Nat,
      "reserve": IDL2.Opt(IDL2.Nat),
      "decay_per_hour": IDL2.Float64
    })
  });
  const BidResponse = IDL2.Record({
    "token_id": IDL2.Text,
    "txn_type": IDL2.Variant({
      "escrow_deposit": IDL2.Record({
        "token": TokenSpec,
        "token_id": IDL2.Text,
        "trx_id": TransactionID,
        "seller": Account,
        "extensible": CandyValue,
        "buyer": Account,
        "amount": IDL2.Nat
      }),
      "canister_network_updated": IDL2.Record({
        "network": IDL2.Principal,
        "extensible": CandyValue
      }),
      "escrow_withdraw": IDL2.Record({
        "fee": IDL2.Nat,
        "token": TokenSpec,
        "token_id": IDL2.Text,
        "trx_id": TransactionID,
        "seller": Account,
        "extensible": CandyValue,
        "buyer": Account,
        "amount": IDL2.Nat
      }),
      "canister_managers_updated": IDL2.Record({
        "managers": IDL2.Vec(IDL2.Principal),
        "extensible": CandyValue
      }),
      "auction_bid": IDL2.Record({
        "token": TokenSpec,
        "extensible": CandyValue,
        "buyer": Account,
        "amount": IDL2.Nat,
        "sale_id": IDL2.Text
      }),
      "burn": IDL2.Null,
      "data": IDL2.Null,
      "sale_ended": IDL2.Record({
        "token": TokenSpec,
        "seller": Account,
        "extensible": CandyValue,
        "buyer": Account,
        "amount": IDL2.Nat,
        "sale_id": IDL2.Opt(IDL2.Text)
      }),
      "mint": IDL2.Record({
        "to": Account,
        "from": Account,
        "sale": IDL2.Opt(IDL2.Record({ "token": TokenSpec, "amount": IDL2.Nat })),
        "extensible": CandyValue
      }),
      "extensible": CandyValue,
      "owner_transfer": IDL2.Record({
        "to": Account,
        "from": Account,
        "extensible": CandyValue
      }),
      "sale_opened": IDL2.Record({
        "pricing": PricingConfig,
        "extensible": CandyValue,
        "sale_id": IDL2.Text
      }),
      "canister_owner_updated": IDL2.Record({
        "owner": IDL2.Principal,
        "extensible": CandyValue
      }),
      "sale_withdraw": IDL2.Record({
        "fee": IDL2.Nat,
        "token": TokenSpec,
        "token_id": IDL2.Text,
        "trx_id": TransactionID,
        "seller": Account,
        "extensible": CandyValue,
        "buyer": Account,
        "amount": IDL2.Nat
      })
    }),
    "timestamp": IDL2.Int,
    "index": IDL2.Nat
  });
  const Result_16 = IDL2.Variant({ "ok": BidResponse, "err": OrigynError });
  const canister_id2 = IDL2.Principal;
  const definite_canister_settings = IDL2.Record({
    "freezing_threshold": IDL2.Nat,
    "controllers": IDL2.Opt(IDL2.Vec(IDL2.Principal)),
    "memory_allocation": IDL2.Nat,
    "compute_allocation": IDL2.Nat
  });
  const canister_status = IDL2.Record({
    "status": IDL2.Variant({
      "stopped": IDL2.Null,
      "stopping": IDL2.Null,
      "running": IDL2.Null
    }),
    "memory_size": IDL2.Nat,
    "cycles": IDL2.Nat,
    "settings": definite_canister_settings,
    "module_hash": IDL2.Opt(IDL2.Vec(IDL2.Nat8))
  });
  const ChunkRequest = IDL2.Record({
    "token_id": IDL2.Text,
    "chunk": IDL2.Opt(IDL2.Nat),
    "library_id": IDL2.Text
  });
  const AllocationRecordStable = IDL2.Record({
    "allocated_space": IDL2.Nat,
    "token_id": IDL2.Text,
    "available_space": IDL2.Nat,
    "canister": IDL2.Principal,
    "chunks": IDL2.Vec(IDL2.Nat),
    "library_id": IDL2.Text
  });
  const ChunkContent = IDL2.Variant({
    "remote": IDL2.Record({
      "args": ChunkRequest,
      "canister": IDL2.Principal
    }),
    "chunk": IDL2.Record({
      "total_chunks": IDL2.Nat,
      "content": IDL2.Vec(IDL2.Nat8),
      "storage_allocation": AllocationRecordStable,
      "current_chunk": IDL2.Opt(IDL2.Nat)
    })
  });
  const Result_15 = IDL2.Variant({ "ok": ChunkContent, "err": OrigynError });
  const CollectionInfo = IDL2.Record({
    "multi_canister_count": IDL2.Opt(IDL2.Nat),
    "managers": IDL2.Opt(IDL2.Vec(IDL2.Principal)),
    "owner": IDL2.Opt(IDL2.Principal),
    "metadata": IDL2.Opt(CandyValue),
    "logo": IDL2.Opt(IDL2.Text),
    "name": IDL2.Opt(IDL2.Text),
    "network": IDL2.Opt(IDL2.Principal),
    "fields": IDL2.Opt(IDL2.Vec(IDL2.Tuple(IDL2.Text, IDL2.Opt(IDL2.Nat), IDL2.Opt(IDL2.Nat)))),
    "token_ids_count": IDL2.Opt(IDL2.Nat),
    "available_space": IDL2.Opt(IDL2.Nat),
    "multi_canister": IDL2.Opt(IDL2.Vec(IDL2.Principal)),
    "token_ids": IDL2.Opt(IDL2.Vec(IDL2.Text)),
    "total_supply": IDL2.Opt(IDL2.Nat),
    "symbol": IDL2.Opt(IDL2.Text),
    "allocated_storage": IDL2.Opt(IDL2.Nat)
  });
  const Result_14 = IDL2.Variant({ "ok": CollectionInfo, "err": OrigynError });
  const CollectionUpdateItem = IDL2.Variant({
    "metadata": IDL2.Opt(CandyValue),
    "logo": IDL2.Opt(IDL2.Text),
    "name": IDL2.Opt(IDL2.Text),
    "symbol": IDL2.Opt(IDL2.Text)
  });
  const CollectionUpdateRequest = IDL2.Vec(CollectionUpdateItem);
  const Result_9 = IDL2.Variant({ "ok": IDL2.Bool, "err": OrigynError });
  const LogEntry = IDL2.Record({
    "data": CandyValue,
    "event": IDL2.Text,
    "timestamp": IDL2.Int,
    "caller": IDL2.Opt(IDL2.Principal)
  });
  const EndSaleResponse = IDL2.Record({
    "token_id": IDL2.Text,
    "txn_type": IDL2.Variant({
      "escrow_deposit": IDL2.Record({
        "token": TokenSpec,
        "token_id": IDL2.Text,
        "trx_id": TransactionID,
        "seller": Account,
        "extensible": CandyValue,
        "buyer": Account,
        "amount": IDL2.Nat
      }),
      "canister_network_updated": IDL2.Record({
        "network": IDL2.Principal,
        "extensible": CandyValue
      }),
      "escrow_withdraw": IDL2.Record({
        "fee": IDL2.Nat,
        "token": TokenSpec,
        "token_id": IDL2.Text,
        "trx_id": TransactionID,
        "seller": Account,
        "extensible": CandyValue,
        "buyer": Account,
        "amount": IDL2.Nat
      }),
      "canister_managers_updated": IDL2.Record({
        "managers": IDL2.Vec(IDL2.Principal),
        "extensible": CandyValue
      }),
      "auction_bid": IDL2.Record({
        "token": TokenSpec,
        "extensible": CandyValue,
        "buyer": Account,
        "amount": IDL2.Nat,
        "sale_id": IDL2.Text
      }),
      "burn": IDL2.Null,
      "data": IDL2.Null,
      "sale_ended": IDL2.Record({
        "token": TokenSpec,
        "seller": Account,
        "extensible": CandyValue,
        "buyer": Account,
        "amount": IDL2.Nat,
        "sale_id": IDL2.Opt(IDL2.Text)
      }),
      "mint": IDL2.Record({
        "to": Account,
        "from": Account,
        "sale": IDL2.Opt(IDL2.Record({ "token": TokenSpec, "amount": IDL2.Nat })),
        "extensible": CandyValue
      }),
      "extensible": CandyValue,
      "owner_transfer": IDL2.Record({
        "to": Account,
        "from": Account,
        "extensible": CandyValue
      }),
      "sale_opened": IDL2.Record({
        "pricing": PricingConfig,
        "extensible": CandyValue,
        "sale_id": IDL2.Text
      }),
      "canister_owner_updated": IDL2.Record({
        "owner": IDL2.Principal,
        "extensible": CandyValue
      }),
      "sale_withdraw": IDL2.Record({
        "fee": IDL2.Nat,
        "token": TokenSpec,
        "token_id": IDL2.Text,
        "trx_id": TransactionID,
        "seller": Account,
        "extensible": CandyValue,
        "buyer": Account,
        "amount": IDL2.Nat
      })
    }),
    "timestamp": IDL2.Int,
    "index": IDL2.Nat
  });
  const Result_13 = IDL2.Variant({
    "ok": EndSaleResponse,
    "err": OrigynError
  });
  const DepositDetail = IDL2.Record({
    "token": TokenSpec,
    "trx_id": TransactionID,
    "seller": Account,
    "buyer": Account,
    "amount": IDL2.Nat,
    "sale_id": IDL2.Opt(IDL2.Text)
  });
  const EscrowRequest = IDL2.Record({
    "token_id": IDL2.Text,
    "deposit": DepositDetail,
    "lock_to_date": IDL2.Opt(IDL2.Int)
  });
  const TransactionRecord = IDL2.Record({
    "token_id": IDL2.Text,
    "txn_type": IDL2.Variant({
      "escrow_deposit": IDL2.Record({
        "token": TokenSpec,
        "token_id": IDL2.Text,
        "trx_id": TransactionID,
        "seller": Account,
        "extensible": CandyValue,
        "buyer": Account,
        "amount": IDL2.Nat
      }),
      "canister_network_updated": IDL2.Record({
        "network": IDL2.Principal,
        "extensible": CandyValue
      }),
      "escrow_withdraw": IDL2.Record({
        "fee": IDL2.Nat,
        "token": TokenSpec,
        "token_id": IDL2.Text,
        "trx_id": TransactionID,
        "seller": Account,
        "extensible": CandyValue,
        "buyer": Account,
        "amount": IDL2.Nat
      }),
      "canister_managers_updated": IDL2.Record({
        "managers": IDL2.Vec(IDL2.Principal),
        "extensible": CandyValue
      }),
      "auction_bid": IDL2.Record({
        "token": TokenSpec,
        "extensible": CandyValue,
        "buyer": Account,
        "amount": IDL2.Nat,
        "sale_id": IDL2.Text
      }),
      "burn": IDL2.Null,
      "data": IDL2.Null,
      "sale_ended": IDL2.Record({
        "token": TokenSpec,
        "seller": Account,
        "extensible": CandyValue,
        "buyer": Account,
        "amount": IDL2.Nat,
        "sale_id": IDL2.Opt(IDL2.Text)
      }),
      "mint": IDL2.Record({
        "to": Account,
        "from": Account,
        "sale": IDL2.Opt(IDL2.Record({ "token": TokenSpec, "amount": IDL2.Nat })),
        "extensible": CandyValue
      }),
      "extensible": CandyValue,
      "owner_transfer": IDL2.Record({
        "to": Account,
        "from": Account,
        "extensible": CandyValue
      }),
      "sale_opened": IDL2.Record({
        "pricing": PricingConfig,
        "extensible": CandyValue,
        "sale_id": IDL2.Text
      }),
      "canister_owner_updated": IDL2.Record({
        "owner": IDL2.Principal,
        "extensible": CandyValue
      }),
      "sale_withdraw": IDL2.Record({
        "fee": IDL2.Nat,
        "token": TokenSpec,
        "token_id": IDL2.Text,
        "trx_id": TransactionID,
        "seller": Account,
        "extensible": CandyValue,
        "buyer": Account,
        "amount": IDL2.Nat
      })
    }),
    "timestamp": IDL2.Int,
    "index": IDL2.Nat
  });
  const EscrowResponse = IDL2.Record({
    "balance": IDL2.Nat,
    "receipt": EscrowReceipt,
    "transaction": TransactionRecord
  });
  const Result_12 = IDL2.Variant({ "ok": EscrowResponse, "err": OrigynError });
  const Result_2 = IDL2.Variant({ "ok": IDL2.Text, "err": OrigynError });
  const StorageMetrics = IDL2.Record({
    "available_space": IDL2.Nat,
    "allocated_storage": IDL2.Nat
  });
  const Result_11 = IDL2.Variant({ "ok": StorageMetrics, "err": OrigynError });
  const Result_10 = IDL2.Variant({
    "ok": IDL2.Vec(TransactionRecord),
    "err": OrigynError
  });
  const HeaderField = IDL2.Tuple(IDL2.Text, IDL2.Text);
  const HttpRequest = IDL2.Record({
    "url": IDL2.Text,
    "method": IDL2.Text,
    "body": IDL2.Vec(IDL2.Nat8),
    "headers": IDL2.Vec(HeaderField)
  });
  const HeaderField__1 = IDL2.Tuple(IDL2.Text, IDL2.Text);
  const StreamingCallbackToken = IDL2.Record({
    "key": IDL2.Text,
    "index": IDL2.Nat,
    "content_encoding": IDL2.Text
  });
  const StreamingStrategy = IDL2.Variant({
    "Callback": IDL2.Record({
      "token": StreamingCallbackToken,
      "callback": IDL2.Func([], [], [])
    })
  });
  const HTTPResponse = IDL2.Record({
    "body": IDL2.Vec(IDL2.Nat8),
    "headers": IDL2.Vec(HeaderField__1),
    "streaming_strategy": IDL2.Opt(StreamingStrategy),
    "status_code": IDL2.Nat16
  });
  const StreamingCallbackResponse = IDL2.Record({
    "token": IDL2.Opt(StreamingCallbackToken),
    "body": IDL2.Vec(IDL2.Nat8)
  });
  const ManageCommand = IDL2.Variant({
    "UpdateOwner": IDL2.Principal,
    "UpdateManagers": IDL2.Vec(IDL2.Principal),
    "UpdateNetwork": IDL2.Opt(IDL2.Principal)
  });
  const ManageStorageRequest = IDL2.Variant({
    "add_storage_canisters": IDL2.Vec(IDL2.Tuple(IDL2.Principal, IDL2.Nat, IDL2.Tuple(IDL2.Nat, IDL2.Nat, IDL2.Nat)))
  });
  const ManageStorageResponse = IDL2.Variant({
    "add_storage_canisters": IDL2.Tuple(IDL2.Nat, IDL2.Nat)
  });
  const Result_8 = IDL2.Variant({
    "ok": ManageStorageResponse,
    "err": OrigynError
  });
  const SalesConfig = IDL2.Record({
    "pricing": PricingConfig,
    "escrow_receipt": IDL2.Opt(EscrowReceipt)
  });
  const MarketTransferRequest = IDL2.Record({
    "token_id": IDL2.Text,
    "sales_config": SalesConfig
  });
  const MarketTransferRequestReponse = IDL2.Record({
    "token_id": IDL2.Text,
    "txn_type": IDL2.Variant({
      "escrow_deposit": IDL2.Record({
        "token": TokenSpec,
        "token_id": IDL2.Text,
        "trx_id": TransactionID,
        "seller": Account,
        "extensible": CandyValue,
        "buyer": Account,
        "amount": IDL2.Nat
      }),
      "canister_network_updated": IDL2.Record({
        "network": IDL2.Principal,
        "extensible": CandyValue
      }),
      "escrow_withdraw": IDL2.Record({
        "fee": IDL2.Nat,
        "token": TokenSpec,
        "token_id": IDL2.Text,
        "trx_id": TransactionID,
        "seller": Account,
        "extensible": CandyValue,
        "buyer": Account,
        "amount": IDL2.Nat
      }),
      "canister_managers_updated": IDL2.Record({
        "managers": IDL2.Vec(IDL2.Principal),
        "extensible": CandyValue
      }),
      "auction_bid": IDL2.Record({
        "token": TokenSpec,
        "extensible": CandyValue,
        "buyer": Account,
        "amount": IDL2.Nat,
        "sale_id": IDL2.Text
      }),
      "burn": IDL2.Null,
      "data": IDL2.Null,
      "sale_ended": IDL2.Record({
        "token": TokenSpec,
        "seller": Account,
        "extensible": CandyValue,
        "buyer": Account,
        "amount": IDL2.Nat,
        "sale_id": IDL2.Opt(IDL2.Text)
      }),
      "mint": IDL2.Record({
        "to": Account,
        "from": Account,
        "sale": IDL2.Opt(IDL2.Record({ "token": TokenSpec, "amount": IDL2.Nat })),
        "extensible": CandyValue
      }),
      "extensible": CandyValue,
      "owner_transfer": IDL2.Record({
        "to": Account,
        "from": Account,
        "extensible": CandyValue
      }),
      "sale_opened": IDL2.Record({
        "pricing": PricingConfig,
        "extensible": CandyValue,
        "sale_id": IDL2.Text
      }),
      "canister_owner_updated": IDL2.Record({
        "owner": IDL2.Principal,
        "extensible": CandyValue
      }),
      "sale_withdraw": IDL2.Record({
        "fee": IDL2.Nat,
        "token": TokenSpec,
        "token_id": IDL2.Text,
        "trx_id": TransactionID,
        "seller": Account,
        "extensible": CandyValue,
        "buyer": Account,
        "amount": IDL2.Nat
      })
    }),
    "timestamp": IDL2.Int,
    "index": IDL2.Nat
  });
  const Result_7 = IDL2.Variant({
    "ok": MarketTransferRequestReponse,
    "err": OrigynError
  });
  const Metadata = IDL2.Variant({
    "fungible": IDL2.Record({
      "decimals": IDL2.Nat8,
      "metadata": IDL2.Opt(IDL2.Vec(IDL2.Nat8)),
      "name": IDL2.Text,
      "symbol": IDL2.Text
    }),
    "nonfungible": IDL2.Record({ "metadata": IDL2.Opt(IDL2.Vec(IDL2.Nat8)) })
  });
  const Result_6 = IDL2.Variant({ "ok": Metadata, "err": CommonError });
  const AuctionStateStable = IDL2.Record({
    "status": IDL2.Variant({
      "closed": IDL2.Null,
      "open": IDL2.Null,
      "not_started": IDL2.Null
    }),
    "participants": IDL2.Vec(IDL2.Tuple(IDL2.Principal, IDL2.Int)),
    "current_bid_amount": IDL2.Nat,
    "winner": IDL2.Opt(Account),
    "end_date": IDL2.Int,
    "wait_for_quiet_count": IDL2.Opt(IDL2.Nat),
    "current_escrow": IDL2.Opt(EscrowReceipt),
    "allow_list": IDL2.Opt(IDL2.Vec(IDL2.Tuple(IDL2.Principal, IDL2.Bool))),
    "min_next_bid": IDL2.Nat,
    "config": PricingConfig
  });
  const SaleStatusStable = IDL2.Record({
    "token_id": IDL2.Text,
    "sale_type": IDL2.Variant({ "auction": AuctionStateStable }),
    "sale_id": IDL2.Text
  });
  const NFTInfoStable = IDL2.Record({
    "metadata": CandyValue,
    "current_sale": IDL2.Opt(SaleStatusStable)
  });
  const Result_5 = IDL2.Variant({ "ok": NFTInfoStable, "err": OrigynError });
  const NftError = IDL2.Variant({
    "UnauthorizedOperator": IDL2.Null,
    "SelfTransfer": IDL2.Null,
    "TokenNotFound": IDL2.Null,
    "UnauthorizedOwner": IDL2.Null,
    "TxNotFound": IDL2.Null,
    "SelfApprove": IDL2.Null,
    "OperatorNotFound": IDL2.Null,
    "ExistedNFT": IDL2.Null,
    "OwnerNotFound": IDL2.Null,
    "Other": IDL2.Text
  });
  const OwnerOfResponse = IDL2.Variant({
    "Ok": IDL2.Opt(IDL2.Principal),
    "Err": NftError
  });
  const OwnerTransferRequest = IDL2.Record({
    "to": Account,
    "token_id": IDL2.Text,
    "from": Account
  });
  const OwnerTransferResponse = IDL2.Record({
    "transaction": TransactionRecord,
    "assets": IDL2.Vec(CandyValue)
  });
  const Result_4 = IDL2.Variant({
    "ok": OwnerTransferResponse,
    "err": OrigynError
  });
  const StageChunkArg = IDL2.Record({
    "content": IDL2.Vec(IDL2.Nat8),
    "token_id": IDL2.Text,
    "chunk": IDL2.Nat,
    "filedata": CandyValue,
    "library_id": IDL2.Text
  });
  const StageLibraryResponse = IDL2.Record({ "canister": IDL2.Principal });
  const Result_3 = IDL2.Variant({
    "ok": StageLibraryResponse,
    "err": OrigynError
  });
  const Memo = IDL2.Vec(IDL2.Nat8);
  const SubAccount = IDL2.Vec(IDL2.Nat8);
  const TransferRequest = IDL2.Record({
    "to": User,
    "token": TokenIdentifier,
    "notify": IDL2.Bool,
    "from": User,
    "memo": Memo,
    "subaccount": IDL2.Opt(SubAccount),
    "amount": Balance
  });
  const TransferResponse = IDL2.Variant({
    "ok": Balance,
    "err": IDL2.Variant({
      "CannotNotify": AccountIdentifier,
      "InsufficientBalance": IDL2.Null,
      "InvalidToken": TokenIdentifier,
      "Rejected": IDL2.Null,
      "Unauthorized": AccountIdentifier,
      "Other": IDL2.Text
    })
  });
  const Result__1 = IDL2.Variant({ "Ok": IDL2.Nat, "Err": NftError });
  const UpdateMode = IDL2.Variant({
    "Set": CandyValue,
    "Lock": CandyValue,
    "Next": IDL2.Vec(Update)
  });
  Update.fill(IDL2.Record({ "mode": UpdateMode, "name": IDL2.Text }));
  const UpdateRequest = IDL2.Record({
    "id": IDL2.Text,
    "update": IDL2.Vec(Update)
  });
  const NFTUpdateRequest = IDL2.Variant({
    "update": IDL2.Record({
      "token_id": IDL2.Text,
      "update": UpdateRequest,
      "app_id": IDL2.Text
    }),
    "replace": IDL2.Record({ "token_id": IDL2.Text, "data": CandyValue })
  });
  const NFTUpdateResponse = IDL2.Bool;
  const Result_1 = IDL2.Variant({
    "ok": NFTUpdateResponse,
    "err": OrigynError
  });
  const WithdrawDescription = IDL2.Record({
    "token": TokenSpec,
    "token_id": IDL2.Text,
    "seller": Account,
    "withdraw_to": Account,
    "buyer": Account,
    "amount": IDL2.Nat
  });
  const WithdrawRequest = IDL2.Variant({
    "sale": WithdrawDescription,
    "escrow": WithdrawDescription
  });
  const WithdrawResponse = IDL2.Record({
    "token_id": IDL2.Text,
    "txn_type": IDL2.Variant({
      "escrow_deposit": IDL2.Record({
        "token": TokenSpec,
        "token_id": IDL2.Text,
        "trx_id": TransactionID,
        "seller": Account,
        "extensible": CandyValue,
        "buyer": Account,
        "amount": IDL2.Nat
      }),
      "canister_network_updated": IDL2.Record({
        "network": IDL2.Principal,
        "extensible": CandyValue
      }),
      "escrow_withdraw": IDL2.Record({
        "fee": IDL2.Nat,
        "token": TokenSpec,
        "token_id": IDL2.Text,
        "trx_id": TransactionID,
        "seller": Account,
        "extensible": CandyValue,
        "buyer": Account,
        "amount": IDL2.Nat
      }),
      "canister_managers_updated": IDL2.Record({
        "managers": IDL2.Vec(IDL2.Principal),
        "extensible": CandyValue
      }),
      "auction_bid": IDL2.Record({
        "token": TokenSpec,
        "extensible": CandyValue,
        "buyer": Account,
        "amount": IDL2.Nat,
        "sale_id": IDL2.Text
      }),
      "burn": IDL2.Null,
      "data": IDL2.Null,
      "sale_ended": IDL2.Record({
        "token": TokenSpec,
        "seller": Account,
        "extensible": CandyValue,
        "buyer": Account,
        "amount": IDL2.Nat,
        "sale_id": IDL2.Opt(IDL2.Text)
      }),
      "mint": IDL2.Record({
        "to": Account,
        "from": Account,
        "sale": IDL2.Opt(IDL2.Record({ "token": TokenSpec, "amount": IDL2.Nat })),
        "extensible": CandyValue
      }),
      "extensible": CandyValue,
      "owner_transfer": IDL2.Record({
        "to": Account,
        "from": Account,
        "extensible": CandyValue
      }),
      "sale_opened": IDL2.Record({
        "pricing": PricingConfig,
        "extensible": CandyValue,
        "sale_id": IDL2.Text
      }),
      "canister_owner_updated": IDL2.Record({
        "owner": IDL2.Principal,
        "extensible": CandyValue
      }),
      "sale_withdraw": IDL2.Record({
        "fee": IDL2.Nat,
        "token": TokenSpec,
        "token_id": IDL2.Text,
        "trx_id": TransactionID,
        "seller": Account,
        "extensible": CandyValue,
        "buyer": Account,
        "amount": IDL2.Nat
      })
    }),
    "timestamp": IDL2.Int,
    "index": IDL2.Nat
  });
  const Result = IDL2.Variant({ "ok": WithdrawResponse, "err": OrigynError });
  const Nft_Canister = IDL2.Service({
    "__advance_time": IDL2.Func([IDL2.Int], [IDL2.Int], []),
    "__set_time_mode": IDL2.Func([IDL2.Variant({ "test": IDL2.Null, "standard": IDL2.Null })], [IDL2.Bool], []),
    "balance": IDL2.Func([BalanceRequest], [BalanceResponse__1], ["query"]),
    "balanceEXT": IDL2.Func([BalanceRequest], [BalanceResponse__1], ["query"]),
    "balanceOfDip721": IDL2.Func([IDL2.Principal], [IDL2.Nat], ["query"]),
    "balance_of_nft_origyn": IDL2.Func([Account], [Result_19], ["query"]),
    "bearer": IDL2.Func([TokenIdentifier], [Result_18], ["query"]),
    "bearerEXT": IDL2.Func([TokenIdentifier], [Result_18], ["query"]),
    "bearer_batch_nft_origyn": IDL2.Func([IDL2.Vec(IDL2.Text)], [IDL2.Vec(Result_17)], ["query"]),
    "bearer_nft_origyn": IDL2.Func([IDL2.Text], [Result_17], ["query"]),
    "bid_nft_origyn": IDL2.Func([BidRequest], [Result_16], []),
    "canister_status": IDL2.Func([IDL2.Record({ "canister_id": canister_id2 })], [canister_status], []),
    "chunk_nft_origyn": IDL2.Func([ChunkRequest], [Result_15], ["query"]),
    "collection_nft_origyn": IDL2.Func([
      IDL2.Opt(IDL2.Vec(IDL2.Tuple(IDL2.Text, IDL2.Opt(IDL2.Nat), IDL2.Opt(IDL2.Nat))))
    ], [Result_14], ["query"]),
    "collection_update_origyn": IDL2.Func([CollectionUpdateRequest], [Result_9], []),
    "current_log": IDL2.Func([], [IDL2.Vec(LogEntry)], ["query"]),
    "cycles": IDL2.Func([], [IDL2.Nat], ["query"]),
    "end_sale_nft_origyn": IDL2.Func([IDL2.Text], [Result_13], []),
    "escrow_nft_origyn": IDL2.Func([EscrowRequest], [Result_12], []),
    "getEXTTokenIdentifier": IDL2.Func([IDL2.Text], [IDL2.Text], ["query"]),
    "get_access_key": IDL2.Func([], [Result_2], ["query"]),
    "get_canister_managers_nft_origyn": IDL2.Func([], [IDL2.Vec(Principal2)], ["query"]),
    "get_canister_network_nft_origyn": IDL2.Func([], [IDL2.Opt(Principal2)], ["query"]),
    "get_canister_owner_nft_origyn": IDL2.Func([], [Principal2], ["query"]),
    "get_nat_as_token_id_origyn": IDL2.Func([IDL2.Nat], [IDL2.Text], ["query"]),
    "get_owner_soulbound": IDL2.Func([CandyValue], [IDL2.Bool], []),
    "get_storage_metrics": IDL2.Func([], [Result_11], ["query"]),
    "get_token_id_as_nat_origyn": IDL2.Func([IDL2.Text], [IDL2.Nat], ["query"]),
    "harvest_log": IDL2.Func([IDL2.Nat], [IDL2.Vec(IDL2.Vec(LogEntry))], []),
    "history_nft_origyn": IDL2.Func([IDL2.Text, IDL2.Opt(IDL2.Nat), IDL2.Opt(IDL2.Nat)], [Result_10], ["query"]),
    "http_access_key": IDL2.Func([], [Result_2], []),
    "http_request": IDL2.Func([HttpRequest], [HTTPResponse], ["query"]),
    "http_request_streaming_callback": IDL2.Func([StreamingCallbackToken], [StreamingCallbackResponse], ["query"]),
    "log_history_page": IDL2.Func([IDL2.Nat], [IDL2.Vec(LogEntry)], ["query"]),
    "log_history_page_chunk": IDL2.Func([IDL2.Nat, IDL2.Nat, IDL2.Nat], [IDL2.Vec(LogEntry)], ["query"]),
    "log_history_size": IDL2.Func([], [IDL2.Nat], ["query"]),
    "manage_nft_origyn": IDL2.Func([ManageCommand], [Result_9], []),
    "manage_storage_nft_origyn": IDL2.Func([ManageStorageRequest], [Result_8], []),
    "market_transfer_batch_nft_origyn": IDL2.Func([IDL2.Vec(MarketTransferRequest)], [IDL2.Vec(Result_7)], []),
    "market_transfer_nft_origyn": IDL2.Func([MarketTransferRequest], [Result_7], []),
    "metadata": IDL2.Func([TokenIdentifier], [Result_6], ["query"]),
    "mint__batch_nft_origyn": IDL2.Func([IDL2.Vec(IDL2.Tuple(IDL2.Text, Account))], [IDL2.Vec(Result_2)], []),
    "mint_nft_origyn": IDL2.Func([IDL2.Text, Account], [Result_2], []),
    "nftStreamingCallback": IDL2.Func([StreamingCallbackToken], [StreamingCallbackResponse], ["query"]),
    "nft_batch_origyn": IDL2.Func([IDL2.Vec(IDL2.Text)], [IDL2.Vec(Result_5)], ["query"]),
    "nft_origyn": IDL2.Func([IDL2.Text], [Result_5], ["query"]),
    "nuke_log": IDL2.Func([], [], []),
    "ownerOf": IDL2.Func([IDL2.Nat], [OwnerOfResponse], ["query"]),
    "ownerOfDIP721": IDL2.Func([IDL2.Nat], [OwnerOfResponse], ["query"]),
    "owner_transfer_nft_origyn": IDL2.Func([OwnerTransferRequest], [Result_4], []),
    "set_log_harvester_id": IDL2.Func([IDL2.Principal], [], []),
    "stage_batch_nft_origyn": IDL2.Func([IDL2.Vec(IDL2.Record({ "metadata": CandyValue }))], [IDL2.Vec(Result_2)], []),
    "stage_library_nft_origyn": IDL2.Func([StageChunkArg], [Result_3], []),
    "stage_nft_origyn": IDL2.Func([IDL2.Record({ "metadata": CandyValue })], [Result_2], []),
    "transfer": IDL2.Func([TransferRequest], [TransferResponse], []),
    "transferEXT": IDL2.Func([TransferRequest], [TransferResponse], []),
    "transferFrom": IDL2.Func([IDL2.Principal, IDL2.Principal, IDL2.Nat], [Result__1], []),
    "transferFromDip721": IDL2.Func([IDL2.Principal, IDL2.Principal, IDL2.Nat], [Result__1], []),
    "update_app_nft_origyn": IDL2.Func([NFTUpdateRequest], [Result_1], []),
    "whoami": IDL2.Func([], [IDL2.Principal], ["query"]),
    "withdraw_nft_origyn": IDL2.Func([WithdrawRequest], [Result], [])
  });
  return Nft_Canister;
};
const init$b = ({ IDL: IDL2 }) => {
  const Principal2 = IDL2.Principal;
  const InitArgs = IDL2.Record({
    "owner": Principal2,
    "storage_space": IDL2.Opt(IDL2.Nat)
  });
  return [InitArgs];
};
nft_origyn_did.init = init$b;
var __awaiter$a = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve) {
      resolve(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __importDefault$5 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(nft_origyn, "__esModule", { value: true });
const agent_1$5 = require$$5;
const nft_origyn_did_1 = __importDefault$5(nft_origyn_did);
const default_1$3 = __importDefault$5(_default);
const standards_1$3 = standards;
class NFTOrigyn extends default_1$3.default {
  constructor(canisterId, agent) {
    super(canisterId, agent);
    this.standard = standards_1$3.NFT.nftOrigyn;
    this.serializeTokenData = (tokenData) => {
      if ("err" in tokenData)
        throw new Error(Object.keys(tokenData.err)[0]);
      const metadata = tokenData.ok.metadata;
      const tokenID = metadata.Class.find(({ name }) => name === "id").value.Text;
      return {
        index: tokenID,
        canister: this.canisterId,
        url: `https://${this.canisterId}.raw.ic0.app/-/${tokenID}`,
        name: tokenID,
        metadata,
        standard: this.standard
      };
    };
    this.actor = agent_1$5.Actor.createActor(nft_origyn_did_1.default, {
      agent,
      canisterId
    });
  }
  getUserTokens(principal) {
    return __awaiter$a(this, void 0, void 0, function* () {
      const tokensIndexes = yield this.actor.balance_of_nft_origyn({ principal });
      if ("err" in tokensIndexes) {
        throw new Error(Object.keys(tokensIndexes.err)[0]);
      }
      const tokensData = yield Promise.all(tokensIndexes.ok.nfts.map((item) => __awaiter$a(this, void 0, void 0, function* () {
        const userTokensResult = yield this.actor.nft_origyn(item);
        if ("err" in userTokensResult)
          throw new Error(Object.keys(userTokensResult.err)[0]);
        return { detail: userTokensResult, principal };
      })));
      return tokensData.map((token2) => this.serializeTokenData(token2.detail));
    });
  }
  getMetadata() {
    throw new Error("Method not implemented.");
  }
  transfer(to, tokenIndex) {
    return __awaiter$a(this, void 0, void 0, function* () {
      yield this.agent.getPrincipal();
      const balance = yield this.actor.balance_of_nft_origyn({ principal: to });
      if ("err" in balance) {
        throw new Error(Object.keys(balance.err)[0]);
      }
      const escrow = balance.ok.escrow.find(({ token_id }) => token_id === tokenIndex);
      if (!escrow) {
        throw new Error("No pending escrows for transfer.");
      }
      const transferResult = yield this.actor.market_transfer_nft_origyn({
        "token_id": tokenIndex,
        "sales_config": {
          pricing: { "instant": null },
          escrow_receipt: [escrow]
        }
      });
      if ("err" in transferResult)
        throw new Error(Object.keys(transferResult.err)[0]);
    });
  }
  details(tokenIndex) {
    return __awaiter$a(this, void 0, void 0, function* () {
      const tokenData = yield this.actor.nft_origyn(tokenIndex);
      return this.serializeTokenData(tokenData);
    });
  }
}
nft_origyn.default = NFTOrigyn;
var departure_labs = {};
var departure_labs_did = {};
Object.defineProperty(departure_labs_did, "__esModule", { value: true });
departure_labs_did.init = void 0;
departure_labs_did.default = ({ IDL: IDL2 }) => {
  const Property = IDL2.Rec();
  const Query = IDL2.Rec();
  const Update = IDL2.Rec();
  const Callback = IDL2.Func([], [], []);
  const StagedWrite = IDL2.Variant({
    "Init": IDL2.Record({ "size": IDL2.Nat, "callback": IDL2.Opt(Callback) }),
    "Chunk": IDL2.Record({
      "chunk": IDL2.Vec(IDL2.Nat8),
      "callback": IDL2.Opt(Callback)
    })
  });
  const AssetRequest = IDL2.Variant({
    "Put": IDL2.Record({
      "key": IDL2.Text,
      "contentType": IDL2.Text,
      "callback": IDL2.Opt(Callback),
      "payload": IDL2.Variant({
        "StagedData": IDL2.Null,
        "Payload": IDL2.Vec(IDL2.Nat8)
      })
    }),
    "Remove": IDL2.Record({ "key": IDL2.Text, "callback": IDL2.Opt(Callback) }),
    "StagedWrite": StagedWrite
  });
  const AuthorizeRequest = IDL2.Record({
    "p": IDL2.Principal,
    "id": IDL2.Text,
    "isAuthorized": IDL2.Bool
  });
  const Error2 = IDL2.Variant({
    "Immutable": IDL2.Null,
    "NotFound": IDL2.Null,
    "Unauthorized": IDL2.Null,
    "InvalidRequest": IDL2.Null,
    "AuthorizedPrincipalLimitReached": IDL2.Nat
  });
  const Result_1 = IDL2.Variant({ "ok": IDL2.Null, "err": Error2 });
  const ContractInfo = IDL2.Record({
    "nft_payload_size": IDL2.Nat,
    "memory_size": IDL2.Nat,
    "max_live_size": IDL2.Nat,
    "cycles": IDL2.Nat,
    "total_minted": IDL2.Nat,
    "heap_size": IDL2.Nat,
    "authorized_users": IDL2.Vec(IDL2.Principal)
  });
  const TopupCallback = IDL2.Func([], [], []);
  const Contract = IDL2.Variant({
    "ContractAuthorize": IDL2.Record({
      "isAuthorized": IDL2.Bool,
      "user": IDL2.Principal
    }),
    "Mint": IDL2.Record({ "id": IDL2.Text, "owner": IDL2.Principal })
  });
  const Token = IDL2.Variant({
    "Authorize": IDL2.Record({
      "id": IDL2.Text,
      "isAuthorized": IDL2.Bool,
      "user": IDL2.Principal
    }),
    "Transfer": IDL2.Record({
      "id": IDL2.Text,
      "to": IDL2.Principal,
      "from": IDL2.Principal
    })
  });
  const Message = IDL2.Record({
    "topupCallback": TopupCallback,
    "createdAt": IDL2.Int,
    "topupAmount": IDL2.Nat,
    "event": IDL2.Variant({ "ContractEvent": Contract, "TokenEvent": Token })
  });
  const Callback__1 = IDL2.Func([Message], [], []);
  const CallbackStatus = IDL2.Record({
    "failedCalls": IDL2.Nat,
    "failedCallsLimit": IDL2.Nat,
    "callback": IDL2.Opt(Callback__1),
    "noTopupCallLimit": IDL2.Nat,
    "callsSinceLastTopup": IDL2.Nat
  });
  const ContractMetadata = IDL2.Record({
    "name": IDL2.Text,
    "symbol": IDL2.Text
  });
  const HeaderField = IDL2.Tuple(IDL2.Text, IDL2.Text);
  const Request = IDL2.Record({
    "url": IDL2.Text,
    "method": IDL2.Text,
    "body": IDL2.Vec(IDL2.Nat8),
    "headers": IDL2.Vec(HeaderField)
  });
  const StreamingCallbackToken = IDL2.Record({
    "key": IDL2.Text,
    "index": IDL2.Nat,
    "content_encoding": IDL2.Text
  });
  const StreamingCallbackResponse = IDL2.Record({
    "token": IDL2.Opt(StreamingCallbackToken),
    "body": IDL2.Vec(IDL2.Nat8)
  });
  const StreamingCallback = IDL2.Func([StreamingCallbackToken], [StreamingCallbackResponse], ["query"]);
  const StreamingStrategy = IDL2.Variant({
    "Callback": IDL2.Record({
      "token": StreamingCallbackToken,
      "callback": StreamingCallback
    })
  });
  const Response2 = IDL2.Record({
    "body": IDL2.Vec(IDL2.Nat8),
    "headers": IDL2.Vec(HeaderField),
    "streaming_strategy": IDL2.Opt(StreamingStrategy),
    "status_code": IDL2.Nat16
  });
  const Value = IDL2.Variant({
    "Int": IDL2.Int,
    "Nat": IDL2.Nat,
    "Empty": IDL2.Null,
    "Bool": IDL2.Bool,
    "Text": IDL2.Text,
    "Float": IDL2.Float64,
    "Principal": IDL2.Principal,
    "Class": IDL2.Vec(Property)
  });
  Property.fill(IDL2.Record({ "value": Value, "name": IDL2.Text, "immutable": IDL2.Bool }));
  const Properties = IDL2.Vec(Property);
  const Egg = IDL2.Record({
    "contentType": IDL2.Text,
    "owner": IDL2.Opt(IDL2.Principal),
    "properties": Properties,
    "isPrivate": IDL2.Bool,
    "payload": IDL2.Variant({
      "StagedData": IDL2.Null,
      "Payload": IDL2.Vec(IDL2.Nat8)
    })
  });
  const Result_5 = IDL2.Variant({ "ok": IDL2.Principal, "err": Error2 });
  Query.fill(IDL2.Record({ "name": IDL2.Text, "next": IDL2.Vec(Query) }));
  const QueryMode = IDL2.Variant({ "All": IDL2.Null, "Some": IDL2.Vec(Query) });
  const QueryRequest = IDL2.Record({ "id": IDL2.Text, "mode": QueryMode });
  const Result = IDL2.Variant({ "ok": Properties, "err": Error2 });
  const Chunk = IDL2.Record({
    "data": IDL2.Vec(IDL2.Nat8),
    "totalPages": IDL2.Nat,
    "nextPage": IDL2.Opt(IDL2.Nat)
  });
  const PayloadResult = IDL2.Variant({
    "Complete": IDL2.Vec(IDL2.Nat8),
    "Chunk": Chunk
  });
  const PublicToken = IDL2.Record({
    "id": IDL2.Text,
    "contentType": IDL2.Text,
    "owner": IDL2.Principal,
    "createdAt": IDL2.Int,
    "properties": Properties,
    "payload": PayloadResult
  });
  const Result_4 = IDL2.Variant({ "ok": PublicToken, "err": Error2 });
  const Result_3 = IDL2.Variant({ "ok": Chunk, "err": Error2 });
  const Metadata = IDL2.Record({
    "id": IDL2.Text,
    "contentType": IDL2.Text,
    "owner": IDL2.Principal,
    "createdAt": IDL2.Int,
    "properties": Properties
  });
  const Result_2 = IDL2.Variant({ "ok": Metadata, "err": Error2 });
  const UpdateEventCallback = IDL2.Variant({
    "Set": Callback__1,
    "Remove": IDL2.Null
  });
  const UpdateMode = IDL2.Variant({ "Set": Value, "Next": IDL2.Vec(Update) });
  Update.fill(IDL2.Record({ "mode": UpdateMode, "name": IDL2.Text }));
  const UpdateRequest = IDL2.Record({
    "id": IDL2.Text,
    "update": IDL2.Vec(Update)
  });
  const Hub = IDL2.Service({
    "assetRequest": IDL2.Func([AssetRequest], [], []),
    "authorize": IDL2.Func([AuthorizeRequest], [Result_1], []),
    "balanceOf": IDL2.Func([IDL2.Principal], [IDL2.Vec(IDL2.Text)], []),
    "getAuthorized": IDL2.Func([IDL2.Text], [IDL2.Vec(IDL2.Principal)], ["query"]),
    "getContractInfo": IDL2.Func([], [ContractInfo], []),
    "getEventCallbackStatus": IDL2.Func([], [CallbackStatus], []),
    "getMetadata": IDL2.Func([], [ContractMetadata], ["query"]),
    "getTotalMinted": IDL2.Func([], [IDL2.Nat], ["query"]),
    "http_request": IDL2.Func([Request], [Response2], ["query"]),
    "http_request_streaming_callback": IDL2.Func([StreamingCallbackToken], [StreamingCallbackResponse], ["query"]),
    "init": IDL2.Func([IDL2.Vec(IDL2.Principal), ContractMetadata], [], []),
    "isAuthorized": IDL2.Func([IDL2.Text, IDL2.Principal], [IDL2.Bool], ["query"]),
    "listAssets": IDL2.Func([], [IDL2.Vec(IDL2.Tuple(IDL2.Text, IDL2.Text, IDL2.Nat))], ["query"]),
    "mint": IDL2.Func([Egg], [IDL2.Text], []),
    "nftStreamingCallback": IDL2.Func([StreamingCallbackToken], [StreamingCallbackResponse], ["query"]),
    "ownerOf": IDL2.Func([IDL2.Text], [Result_5], ["query"]),
    "queryProperties": IDL2.Func([QueryRequest], [Result], ["query"]),
    "staticStreamingCallback": IDL2.Func([StreamingCallbackToken], [StreamingCallbackResponse], ["query"]),
    "tokenByIndex": IDL2.Func([IDL2.Text], [Result_4], []),
    "tokenChunkByIndex": IDL2.Func([IDL2.Text, IDL2.Nat], [Result_3], []),
    "tokenMetadataByIndex": IDL2.Func([IDL2.Text], [Result_2], []),
    "transfer": IDL2.Func([IDL2.Principal, IDL2.Text], [Result_1], []),
    "updateContractOwners": IDL2.Func([IDL2.Principal, IDL2.Bool], [Result_1], []),
    "updateEventCallback": IDL2.Func([UpdateEventCallback], [], []),
    "updateProperties": IDL2.Func([UpdateRequest], [Result], []),
    "wallet_receive": IDL2.Func([], [], []),
    "writeStaged": IDL2.Func([StagedWrite], [], [])
  });
  return Hub;
};
const init$a = ({}) => {
  return [];
};
departure_labs_did.init = init$a;
var __awaiter$9 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve) {
      resolve(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __importDefault$4 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(departure_labs, "__esModule", { value: true });
const agent_1$4 = require$$5;
const departure_labs_did_1 = __importDefault$4(departure_labs_did);
const default_1$2 = __importDefault$4(_default);
const standards_1$2 = standards;
class DepartureLabs extends default_1$2.default {
  constructor(canisterId, agent) {
    super(canisterId, agent);
    this.standard = standards_1$2.NFT.departuresLabs;
    this.serializeTokenData = (tokenData) => ({
      index: BigInt(tokenData.id),
      canister: this.canisterId,
      url: `https://${this.canisterId}.raw.ic0.app/nft/${tokenData.id}`,
      metadata: tokenData,
      standard: this.standard
    });
    this.actor = agent_1$4.Actor.createActor(departure_labs_did_1.default, {
      agent,
      canisterId
    });
  }
  getMetadata() {
    throw new Error("Method not implemented.");
  }
  getUserTokens(principal) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const tokensIndexes = yield this.actor.balanceOf(principal);
      const tokensData = yield Promise.all(tokensIndexes.map((tokenIndex) => __awaiter$9(this, void 0, void 0, function* () {
        const userTokensResult = yield this.actor.tokenMetadataByIndex(tokenIndex);
        if ("err" in userTokensResult)
          throw new Error(Object.keys(userTokensResult.err)[0]);
        return userTokensResult.ok;
      })));
      return tokensData.map((token2) => this.serializeTokenData(token2));
    });
  }
  transfer(to, tokenIndex) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const transferResult = yield this.actor.transfer(to, tokenIndex.toString(10));
      if ("err" in transferResult)
        throw new Error(Object.keys(transferResult.err)[0]);
    });
  }
  details(tokenIndex) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const tokenData = yield this.actor.tokenMetadataByIndex(tokenIndex.toString(10));
      if ("err" in tokenData)
        throw new Error(Object.keys(tokenData.err)[0]);
      return this.serializeTokenData(tokenData.ok);
    });
  }
}
departure_labs.default = DepartureLabs;
var dip_721 = {};
var dip_721_did = {};
Object.defineProperty(dip_721_did, "__esModule", { value: true });
dip_721_did.default = ({ IDL: IDL2 }) => {
  const Vec2 = IDL2.Rec();
  IDL2.Record({
    "cap": IDL2.Opt(IDL2.Principal),
    "logo": IDL2.Opt(IDL2.Text),
    "name": IDL2.Opt(IDL2.Text),
    "custodians": IDL2.Opt(IDL2.Vec(IDL2.Principal)),
    "symbol": IDL2.Opt(IDL2.Text)
  });
  const NftError = IDL2.Variant({
    "UnauthorizedOperator": IDL2.Null,
    "SelfTransfer": IDL2.Null,
    "TokenNotFound": IDL2.Null,
    "UnauthorizedOwner": IDL2.Null,
    "SelfApprove": IDL2.Null,
    "OperatorNotFound": IDL2.Null,
    "ExistedNFT": IDL2.Null,
    "OwnerNotFound": IDL2.Null
  });
  const Result = IDL2.Variant({ "Ok": IDL2.Nat, "Err": NftError });
  const Result_1 = IDL2.Variant({ "Ok": IDL2.Bool, "Err": NftError });
  const ManualReply = IDL2.Record({
    "logo": IDL2.Opt(IDL2.Text),
    "name": IDL2.Opt(IDL2.Text),
    "created_at": IDL2.Nat64,
    "upgraded_at": IDL2.Nat64,
    "custodians": IDL2.Vec(IDL2.Principal),
    "symbol": IDL2.Opt(IDL2.Text)
  });
  Vec2.fill(IDL2.Vec(IDL2.Tuple(IDL2.Text, IDL2.Variant({
    "Nat64Content": IDL2.Nat64,
    "Nat32Content": IDL2.Nat32,
    "BoolContent": IDL2.Bool,
    "Nat8Content": IDL2.Nat8,
    "Int64Content": IDL2.Int64,
    "IntContent": IDL2.Int,
    "NatContent": IDL2.Nat,
    "Nat16Content": IDL2.Nat16,
    "Int32Content": IDL2.Int32,
    "Int8Content": IDL2.Int8,
    "FloatContent": IDL2.Float64,
    "Int16Content": IDL2.Int16,
    "BlobContent": IDL2.Vec(IDL2.Nat8),
    "NestedContent": Vec2,
    "Principal": IDL2.Principal,
    "TextContent": IDL2.Text
  }))));
  const GenericValue = IDL2.Variant({
    "Nat64Content": IDL2.Nat64,
    "Nat32Content": IDL2.Nat32,
    "BoolContent": IDL2.Bool,
    "Nat8Content": IDL2.Nat8,
    "Int64Content": IDL2.Int64,
    "IntContent": IDL2.Int,
    "NatContent": IDL2.Nat,
    "Nat16Content": IDL2.Nat16,
    "Int32Content": IDL2.Int32,
    "Int8Content": IDL2.Int8,
    "FloatContent": IDL2.Float64,
    "Int16Content": IDL2.Int16,
    "BlobContent": IDL2.Vec(IDL2.Nat8),
    "NestedContent": Vec2,
    "Principal": IDL2.Principal,
    "TextContent": IDL2.Text
  });
  const Result_2 = IDL2.Variant({
    "Ok": IDL2.Opt(IDL2.Principal),
    "Err": NftError
  });
  const ManualReply_1 = IDL2.Variant({
    "Ok": IDL2.Vec(IDL2.Nat),
    "Err": NftError
  });
  const TokenMetadata = IDL2.Record({
    "transferred_at": IDL2.Opt(IDL2.Nat64),
    "transferred_by": IDL2.Opt(IDL2.Principal),
    "owner": IDL2.Opt(IDL2.Principal),
    "operator": IDL2.Opt(IDL2.Principal),
    "approved_at": IDL2.Opt(IDL2.Nat64),
    "approved_by": IDL2.Opt(IDL2.Principal),
    "properties": IDL2.Vec(IDL2.Tuple(IDL2.Text, GenericValue)),
    "is_burned": IDL2.Bool,
    "token_identifier": IDL2.Nat,
    "burned_at": IDL2.Opt(IDL2.Nat64),
    "burned_by": IDL2.Opt(IDL2.Principal),
    "minted_at": IDL2.Nat64,
    "minted_by": IDL2.Principal
  });
  const ManualReply_2 = IDL2.Variant({
    "Ok": IDL2.Vec(TokenMetadata),
    "Err": NftError
  });
  const Stats = IDL2.Record({
    "cycles": IDL2.Nat,
    "total_transactions": IDL2.Nat,
    "total_unique_holders": IDL2.Nat,
    "total_supply": IDL2.Nat
  });
  const SupportedInterface = IDL2.Variant({
    "Burn": IDL2.Null,
    "Mint": IDL2.Null,
    "Approval": IDL2.Null
  });
  const ManualReply_3 = IDL2.Variant({ "Ok": TokenMetadata, "Err": NftError });
  return IDL2.Service({
    "approve": IDL2.Func([IDL2.Principal, IDL2.Nat], [Result], []),
    "balanceOf": IDL2.Func([IDL2.Principal], [Result], ["query"]),
    "burn": IDL2.Func([IDL2.Nat], [Result], []),
    "custodians": IDL2.Func([], [IDL2.Vec(IDL2.Principal)], ["query"]),
    "cycles": IDL2.Func([], [IDL2.Nat], ["query"]),
    "dfx_info": IDL2.Func([], [IDL2.Text], ["query"]),
    "dip721_approve": IDL2.Func([IDL2.Principal, IDL2.Nat], [Result], []),
    "dip721_balance_of": IDL2.Func([IDL2.Principal], [Result], ["query"]),
    "dip721_burn": IDL2.Func([IDL2.Nat], [Result], []),
    "dip721_custodians": IDL2.Func([], [IDL2.Vec(IDL2.Principal)], ["query"]),
    "dip721_cycles": IDL2.Func([], [IDL2.Nat], ["query"]),
    "dip721_is_approved_for_all": IDL2.Func([IDL2.Principal, IDL2.Principal], [Result_1], ["query"]),
    "dip721_logo": IDL2.Func([], [IDL2.Opt(IDL2.Text)], ["query"]),
    "dip721_metadata": IDL2.Func([], [ManualReply], ["query"]),
    "dip721_mint": IDL2.Func([IDL2.Principal, IDL2.Nat, IDL2.Vec(IDL2.Tuple(IDL2.Text, GenericValue))], [Result], []),
    "dip721_name": IDL2.Func([], [IDL2.Opt(IDL2.Text)], ["query"]),
    "dip721_operator_of": IDL2.Func([IDL2.Nat], [Result_2], ["query"]),
    "dip721_operator_token_identifiers": IDL2.Func([IDL2.Principal], [ManualReply_1], ["query"]),
    "dip721_operator_token_metadata": IDL2.Func([IDL2.Principal], [ManualReply_2], ["query"]),
    "dip721_owner_of": IDL2.Func([IDL2.Nat], [Result_2], ["query"]),
    "dip721_owner_token_identifiers": IDL2.Func([IDL2.Principal], [ManualReply_1], ["query"]),
    "dip721_owner_token_metadata": IDL2.Func([IDL2.Principal], [ManualReply_2], ["query"]),
    "dip721_set_approval_for_all": IDL2.Func([IDL2.Principal, IDL2.Bool], [Result], []),
    "dip721_set_custodians": IDL2.Func([IDL2.Vec(IDL2.Principal)], [], []),
    "dip721_set_logo": IDL2.Func([IDL2.Text], [], []),
    "dip721_set_name": IDL2.Func([IDL2.Text], [], []),
    "dip721_set_symbol": IDL2.Func([IDL2.Text], [], []),
    "dip721_stats": IDL2.Func([], [Stats], ["query"]),
    "dip721_supported_interfaces": IDL2.Func([], [IDL2.Vec(SupportedInterface)], ["query"]),
    "dip721_symbol": IDL2.Func([], [IDL2.Opt(IDL2.Text)], ["query"]),
    "dip721_token_metadata": IDL2.Func([IDL2.Nat], [ManualReply_3], ["query"]),
    "dip721_total_supply": IDL2.Func([], [IDL2.Nat], ["query"]),
    "dip721_total_transactions": IDL2.Func([], [IDL2.Nat], ["query"]),
    "dip721_total_unique_holders": IDL2.Func([], [IDL2.Nat], ["query"]),
    "dip721_transfer": IDL2.Func([IDL2.Principal, IDL2.Nat], [Result], []),
    "dip721_transfer_from": IDL2.Func([IDL2.Principal, IDL2.Principal, IDL2.Nat], [Result], []),
    "git_commit_hash": IDL2.Func([], [IDL2.Text], ["query"]),
    "isApprovedForAll": IDL2.Func([IDL2.Principal, IDL2.Principal], [Result_1], ["query"]),
    "logo": IDL2.Func([], [IDL2.Opt(IDL2.Text)], ["query"]),
    "metadata": IDL2.Func([], [ManualReply], ["query"]),
    "mint": IDL2.Func([IDL2.Principal, IDL2.Nat, IDL2.Vec(IDL2.Tuple(IDL2.Text, GenericValue))], [Result], []),
    "name": IDL2.Func([], [IDL2.Opt(IDL2.Text)], ["query"]),
    "operatorOf": IDL2.Func([IDL2.Nat], [Result_2], ["query"]),
    "operatorTokenIdentifiers": IDL2.Func([IDL2.Principal], [ManualReply_1], ["query"]),
    "operatorTokenMetadata": IDL2.Func([IDL2.Principal], [ManualReply_2], ["query"]),
    "ownerOf": IDL2.Func([IDL2.Nat], [Result_2], ["query"]),
    "ownerTokenIdentifiers": IDL2.Func([IDL2.Principal], [ManualReply_1], ["query"]),
    "ownerTokenMetadata": IDL2.Func([IDL2.Principal], [ManualReply_2], ["query"]),
    "rust_toolchain_info": IDL2.Func([], [IDL2.Text], ["query"]),
    "setApprovalForAll": IDL2.Func([IDL2.Principal, IDL2.Bool], [Result], []),
    "setCustodians": IDL2.Func([IDL2.Vec(IDL2.Principal)], [], []),
    "setLogo": IDL2.Func([IDL2.Text], [], []),
    "setName": IDL2.Func([IDL2.Text], [], []),
    "setSymbol": IDL2.Func([IDL2.Text], [], []),
    "stats": IDL2.Func([], [Stats], ["query"]),
    "supportedInterfaces": IDL2.Func([], [IDL2.Vec(SupportedInterface)], ["query"]),
    "symbol": IDL2.Func([], [IDL2.Opt(IDL2.Text)], ["query"]),
    "tokenMetadata": IDL2.Func([IDL2.Nat], [ManualReply_3], ["query"]),
    "totalSupply": IDL2.Func([], [IDL2.Nat], ["query"]),
    "totalTransactions": IDL2.Func([], [IDL2.Nat], ["query"]),
    "totalUniqueHolders": IDL2.Func([], [IDL2.Nat], ["query"]),
    "transfer": IDL2.Func([IDL2.Principal, IDL2.Nat], [Result], []),
    "transferFrom": IDL2.Func([IDL2.Principal, IDL2.Principal, IDL2.Nat], [Result], [])
  });
};
var __awaiter$8 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve) {
      resolve(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(dip_721, "__esModule", { value: true });
const agent_1$3 = require$$5;
const dip_721_did_1 = __importDefault$3(dip_721_did);
const default_1$1 = __importDefault$3(_default);
const standards_1$1 = standards;
const extractMetadataValue = (metadata) => {
  const metadataKey = Object.keys(metadata)[0];
  const value2 = metadata[metadataKey];
  return typeof value2 === "object" ? JSON.stringify(value2) : value2;
};
class ERC721 extends default_1$1.default {
  constructor(canisterId, agent) {
    super(canisterId, agent);
    this.standard = standards_1$1.NFT.dip721;
    this.actor = agent_1$3.Actor.createActor(dip_721_did_1.default, {
      agent,
      canisterId
    });
  }
  backwardsCompatibleGuard(legacyMethod, newMethod) {
    return (params = []) => __awaiter$8(this, void 0, void 0, function* () {
      let res;
      try {
        res = yield this.actor[newMethod](...params);
      } catch (err) {
        res = yield this.actor[legacyMethod](...params);
      }
      return res;
    });
  }
  getUserTokens(principal) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const guardedGetUserTokens = this.backwardsCompatibleGuard("ownerTokenMetadata", "dip721_owner_token_metadata");
      const userTokensResult = yield guardedGetUserTokens([principal]);
      const tokens = userTokensResult["Ok"] || [];
      if (!tokens.length)
        return [];
      const formattedTokenData = tokens.map((token2) => {
        var _a, _b;
        const tokenIndex = token2.token_identifier;
        const formatedMetadata = this.formatMetadata(token2);
        if (!formatedMetadata)
          return;
        const operator = (_b = (_a = token2.operator) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.toText();
        return this.serializeTokenData(formatedMetadata, tokenIndex, principal.toText(), operator);
      }).filter((token2) => token2);
      return formattedTokenData;
    });
  }
  transfer(to, tokenIndex) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const guardedTransfer = this.backwardsCompatibleGuard("transfer", "dip721_transfer");
      const transferResult = yield guardedTransfer([to, BigInt(tokenIndex)]);
      if ("Err" in transferResult)
        throw new Error(`${Object.keys(transferResult.Err)[0]}: ${Object.values(transferResult.Err)[0]}`);
    });
  }
  details(tokenIndex) {
    var _a, _b, _c, _d, _e, _f;
    return __awaiter$8(this, void 0, void 0, function* () {
      const guardedDetails = this.backwardsCompatibleGuard("tokenMetadata", "dip721_token_metadata");
      const metadataResult = yield guardedDetails([BigInt(tokenIndex)]);
      if ("Err" in metadataResult)
        throw new Error(`${Object.keys(metadataResult.Err)[0]}: ${Object.values(metadataResult.Err)[0]}`);
      const metadata = metadataResult === null || metadataResult === void 0 ? void 0 : metadataResult.Ok;
      const formatedMetadata = this.formatMetadata(metadata);
      const owner = (_c = (_b = (_a = metadata === null || metadata === void 0 ? void 0 : metadata.owner) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.toText) === null || _c === void 0 ? void 0 : _c.call(_b);
      const operator = (_f = (_e = (_d = metadata === null || metadata === void 0 ? void 0 : metadata.operator) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.toText) === null || _f === void 0 ? void 0 : _f.call(_e);
      return this.serializeTokenData(formatedMetadata, tokenIndex, owner, operator);
    });
  }
  getMetadata() {
    var _a;
    return __awaiter$8(this, void 0, void 0, function* () {
      const guardedGetMetadata = this.backwardsCompatibleGuard("metadata", "dip721_get_metadata");
      const metadata = yield guardedGetMetadata();
      return {
        icon: metadata === null || metadata === void 0 ? void 0 : metadata.logo[0],
        name: ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.name) === null || _a === void 0 ? void 0 : _a[0]) || "",
        standard: this.standard,
        canisterId: this.canisterId,
        tokens: [],
        description: ""
      };
    });
  }
  serializeTokenData(metadata, tokenIndex, owner, operator) {
    var _a, _b;
    return {
      index: BigInt(tokenIndex),
      canister: this.canisterId,
      metadata,
      owner,
      url: ((_b = (_a = metadata === null || metadata === void 0 ? void 0 : metadata.location) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b.TextContent) || "",
      standard: this.standard,
      operator
    };
  }
  formatMetadata(metadata) {
    const metadataResult = { properties: new Array() };
    if (!(metadata === null || metadata === void 0 ? void 0 : metadata.properties) || !Array.isArray(metadata.properties)) {
      console.warn(`Oops! Failed to format the metadata properties for token, field is missing or invalid. See ${JSON.stringify(metadata)}`);
      console.log(metadata);
      return;
    }
    metadata.properties.forEach((prop) => {
      const propertyName = prop[0];
      metadataResult[propertyName] = { value: prop[1] };
      const value2 = (() => {
        try {
          return extractMetadataValue(prop[1]);
        } catch (err) {
          console.warn(`Oops! Failed to extract metadata value for property ${propertyName}, is that a valid key value pair?`);
          console.error(err);
        }
      })();
      metadataResult.properties = [
        ...metadataResult.properties,
        { name: prop[0], value: value2 }
      ];
    });
    metadataResult.properties = metadataResult.properties.filter(({ name }) => !["location", "thumbnail", "contentHash", "contentType"].includes(name));
    return metadataResult;
  }
}
dip_721.default = ERC721;
var constants = {};
Object.defineProperty(constants, "__esModule", { value: true });
constants.KYASSHU_URL = constants.IC_HOST = void 0;
constants.IC_HOST = "https://ic0.app/";
constants.KYASSHU_URL = "https://kyasshu.fleek.co";
var nft_registry_did = {};
Object.defineProperty(nft_registry_did, "__esModule", { value: true });
nft_registry_did.init = void 0;
nft_registry_did.default = ({ IDL: IDL2 }) => {
  const detail_value = IDL2.Rec();
  detail_value.fill(IDL2.Variant({
    "I64": IDL2.Int64,
    "U64": IDL2.Nat64,
    "Vec": IDL2.Vec(detail_value),
    "Slice": IDL2.Vec(IDL2.Nat8),
    "Text": IDL2.Text,
    "True": IDL2.Null,
    "False": IDL2.Null,
    "Float": IDL2.Float64,
    "Principal": IDL2.Principal
  }));
  const nft_canister = IDL2.Record({
    "thumbnail": IDL2.Text,
    "name": IDL2.Text,
    "frontend": IDL2.Opt(IDL2.Text),
    "description": IDL2.Text,
    "details": IDL2.Vec(IDL2.Tuple(IDL2.Text, detail_value)),
    "principal_id": IDL2.Principal
  });
  const operation_error = IDL2.Variant({
    "NotAuthorized": IDL2.Null,
    "BadParameters": IDL2.Null,
    "Unknown": IDL2.Text,
    "NonExistentItem": IDL2.Null
  });
  const operation_response = IDL2.Variant({
    "Ok": IDL2.Opt(IDL2.Text),
    "Err": operation_error
  });
  return IDL2.Service({
    "add": IDL2.Func([nft_canister], [operation_response], []),
    "get": IDL2.Func([IDL2.Principal], [IDL2.Opt(nft_canister)], ["query"]),
    "get_all": IDL2.Func([], [IDL2.Vec(nft_canister)], ["query"]),
    "name": IDL2.Func([], [IDL2.Text], ["query"]),
    "remove": IDL2.Func([IDL2.Principal], [operation_response], []),
    "set_controller": IDL2.Func([IDL2.Principal], [operation_response], [])
  });
};
const init$9 = () => {
  return [];
};
nft_registry_did.init = init$9;
var standard_registry = {};
var registry_standard_did = {};
Object.defineProperty(registry_standard_did, "__esModule", { value: true });
registry_standard_did.init = void 0;
registry_standard_did.default = ({ IDL: IDL2 }) => {
  const detail_value = IDL2.Rec();
  detail_value.fill(IDL2.Variant({
    "I64": IDL2.Int64,
    "U64": IDL2.Nat64,
    "Vec": IDL2.Vec(detail_value),
    "Slice": IDL2.Vec(IDL2.Nat8),
    "Text": IDL2.Text,
    "True": IDL2.Null,
    "False": IDL2.Null,
    "Float": IDL2.Float64,
    "Principal": IDL2.Principal
  }));
  const metadata = IDL2.Record({
    "thumbnail": IDL2.Text,
    "name": IDL2.Text,
    "frontend": IDL2.Opt(IDL2.Text),
    "description": IDL2.Text,
    "principal_id": IDL2.Principal,
    "details": IDL2.Vec(IDL2.Tuple(IDL2.Text, detail_value))
  });
  const error = IDL2.Variant({
    "NotAuthorized": IDL2.Null,
    "BadParameters": IDL2.Null,
    "Unknown": IDL2.Text,
    "NonExistantCanister": IDL2.Null
  });
  const response = IDL2.Variant({ "Ok": IDL2.Opt(IDL2.Text), "Err": error });
  return IDL2.Service({
    "add": IDL2.Func([metadata], [response], []),
    "get": IDL2.Func([IDL2.Principal], [IDL2.Opt(metadata)], ["query"]),
    "name": IDL2.Func([], [IDL2.Text], ["query"]),
    "remove": IDL2.Func([IDL2.Principal], [response], [])
  });
};
const init$8 = () => {
  return [];
};
registry_standard_did.init = init$8;
var registry = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.formatMetadata = exports2.formatRegistryDetails = exports2.parseDetailValue = void 0;
  const BOOLEAN_DETAIL_TYPE = ["True", "False"];
  const parseDetailValue = (detailValue) => {
    const key = Object.keys(detailValue)[0];
    const value2 = BOOLEAN_DETAIL_TYPE.includes(key) ? Boolean(key) : Object.values(detailValue)[0];
    if (Array.isArray(value2)) {
      return value2.map((v2) => typeof value2 === "number" ? v2 : (0, exports2.parseDetailValue)(v2));
    }
    return value2;
  };
  exports2.parseDetailValue = parseDetailValue;
  const formatRegistryDetails = (details) => {
    const formattedDetails = {};
    for (const [key, detailValue] of details) {
      formattedDetails[key] = (0, exports2.parseDetailValue)(detailValue);
    }
    return formattedDetails;
  };
  exports2.formatRegistryDetails = formatRegistryDetails;
  const formatMetadata = (metadata) => Object.assign(Object.assign({}, metadata), { details: (0, exports2.formatRegistryDetails)(metadata.details) });
  exports2.formatMetadata = formatMetadata;
})(registry);
var __awaiter$7 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve) {
      resolve(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(standard_registry, "__esModule", { value: true });
const agent_1$2 = require$$5;
const principal_1$5 = require$$4;
const constants_1 = constants;
const registry_standard_did_1 = __importDefault$2(registry_standard_did);
const registry_1 = registry;
const cross_fetch_1$1 = __importDefault$2(browserPonyfill.exports);
const DEFAULT_AGENT = new agent_1$2.HttpAgent({ fetch: cross_fetch_1$1.default, host: constants_1.IC_HOST });
class Registry {
  constructor(canisterId, agent = DEFAULT_AGENT) {
    this.name = () => __awaiter$7(this, void 0, void 0, function* () {
      return this.actor.name();
    });
    this.add = (metadata) => __awaiter$7(this, void 0, void 0, function* () {
      return this.actor.add(metadata !== null && metadata !== void 0 ? metadata : []);
    });
    this.get = (principalId) => __awaiter$7(this, void 0, void 0, function* () {
      const data2 = yield this.actor.get(principal_1$5.Principal.fromText(principalId));
      if (data2.length === 0)
        return void 0;
      return (0, registry_1.formatMetadata)(data2[0]);
    });
    this.remove = (principalId) => __awaiter$7(this, void 0, void 0, function* () {
      return this.actor.remove(principal_1$5.Principal.fromText(principalId));
    });
    this.actor = agent_1$2.Actor.createActor(registry_standard_did_1.default, {
      agent,
      canisterId
    });
    this.canisterId = canisterId;
  }
}
standard_registry.default = Registry;
var actorFactory = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.generateActor = exports2.createExtendedActorClass = void 0;
  const agent_12 = require$$5;
  const principal_12 = require$$4;
  const createExtendedActorClass = (agent, methods2, canisterId, IDLFactory) => {
    class ExtendedActor extends agent_12.Actor.createActorClass(IDLFactory) {
      constructor() {
        const principalCanisterId = typeof canisterId === "string" ? principal_12.Principal.fromText(canisterId) : canisterId;
        super({ agent, canisterId: principalCanisterId });
        Object.keys(this).forEach((methodName) => {
          this[`_${methodName}`] = this[methodName];
        });
        Object.keys(methods2).forEach((methodName) => {
          this[methodName] = (...args) => methods2[methodName](this, ...args);
        });
      }
    }
    return ExtendedActor;
  };
  exports2.createExtendedActorClass = createExtendedActorClass;
  function generateActor({ agent, canisterId, IDL: IDL2 }) {
    return agent_12.Actor.createActor(IDL2, {
      agent,
      canisterId: principal_12.Principal.fromText(canisterId)
    });
  }
  exports2.generateActor = generateActor;
  exports2.default = { createExtendedActorClass: exports2.createExtendedActorClass, generateActor };
})(actorFactory);
var ccc = {};
var c3_did = {};
Object.defineProperty(c3_did, "__esModule", { value: true });
c3_did.init = void 0;
c3_did.default = ({ IDL: IDL2 }) => {
  const TokenIndex__1 = IDL2.Nat;
  const TokenIndex = IDL2.Nat;
  const TransferResponse = IDL2.Variant({
    "ok": TokenIndex,
    "err": IDL2.Variant({
      "ListOnMarketPlace": IDL2.Null,
      "NotAllowTransferToSelf": IDL2.Null,
      "NotOwnerOrNotApprove": IDL2.Null,
      "Other": IDL2.Null
    })
  });
  const TokenDetails = IDL2.Record({
    "id": IDL2.Nat,
    "rarityScore": IDL2.Float64
  });
  const GetTokenResponse = IDL2.Variant({
    "ok": TokenDetails,
    "err": IDL2.Variant({ "NotFoundIndex": IDL2.Null })
  });
  const C2NFT = IDL2.Service({
    "getAllNFT": IDL2.Func([IDL2.Principal], [IDL2.Vec(IDL2.Tuple(TokenIndex__1, IDL2.Principal))], ["query"]),
    "getNftStoreCIDByIndex": IDL2.Func([TokenIndex__1], [IDL2.Principal], ["query"]),
    "getTokenById": IDL2.Func([IDL2.Nat], [GetTokenResponse], ["query"]),
    "transferFrom": IDL2.Func([IDL2.Principal, IDL2.Principal, TokenIndex__1], [TransferResponse], [])
  });
  return C2NFT;
};
const init$7 = ({ IDL: IDL2 }) => {
  return [IDL2.Principal, IDL2.Principal, IDL2.Principal];
};
c3_did.init = init$7;
var __awaiter$6 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve) {
      resolve(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(ccc, "__esModule", { value: true });
const agent_1$1 = require$$5;
const c3_did_1 = __importDefault$1(c3_did);
const default_1 = __importDefault$1(_default);
const standards_1 = standards;
class CCC extends default_1.default {
  constructor(canisterId, agent) {
    super(canisterId, agent);
    this.standard = standards_1.NFT.c3;
    this.serializeTokenData = (tokenData, prinId) => {
      return {
        index: BigInt(tokenData.id),
        canister: this.canisterId,
        url: `https://${prinId.toText()}.raw.ic0.app/token/${tokenData.id}`,
        name: `${tokenData.id}`,
        metadata: tokenData,
        standard: this.standard
      };
    };
    this.actor = agent_1$1.Actor.createActor(c3_did_1.default, {
      agent,
      canisterId
    });
  }
  getMetadata() {
    throw new Error("Method not implemented.");
  }
  getUserTokens(principal) {
    return __awaiter$6(this, void 0, void 0, function* () {
      const tokensIndexes = yield this.actor.getAllNFT(principal);
      const tokensData = yield Promise.all(tokensIndexes.map((item) => __awaiter$6(this, void 0, void 0, function* () {
        const tokenIndex = item[0];
        const principal2 = item[1];
        const userTokensResult = yield this.actor.getTokenById(tokenIndex);
        if ("err" in userTokensResult)
          throw new Error(Object.keys(userTokensResult.err)[0]);
        return { detail: userTokensResult.ok, principal: principal2 };
      })));
      return tokensData.map((token2) => this.serializeTokenData(token2.detail, token2.principal));
    });
  }
  transfer(to, tokenIndex) {
    return __awaiter$6(this, void 0, void 0, function* () {
      const from2 = yield this.agent.getPrincipal();
      const transferResult = yield this.actor.transferFrom(from2, to, BigInt(tokenIndex));
      if ("err" in transferResult)
        throw new Error(Object.keys(transferResult.err)[0]);
    });
  }
  details(tokenIndex) {
    return __awaiter$6(this, void 0, void 0, function* () {
      const tokenData = yield this.actor.getTokenById(BigInt(tokenIndex));
      if ("err" in tokenData)
        throw new Error(Object.keys(tokenData.err)[0]);
      const prinId = yield this.actor.getNftStoreCIDByIndex(BigInt(tokenIndex));
      if (!prinId)
        throw new Error("Error tokenIndex");
      return this.serializeTokenData(tokenData.ok, prinId);
    });
  }
}
ccc.default = CCC;
(function(exports2) {
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value2) {
      return value2 instanceof P2 ? value2 : new P2(function(resolve) {
        resolve(value2);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.getCachedUserNFTs = exports2.getBatchedNFTs = exports2.getAllUserNFTs = exports2.getAllNFTS = exports2.getNFTInfo = exports2.getNFTActor = exports2.getUserCollectionTokens = exports2.NFTRegistry = void 0;
  const axios_1 = __importDefault2(axios$2.exports);
  const agent_12 = require$$5;
  const principal_12 = require$$4;
  const cross_fetch_12 = __importDefault2(browserPonyfill.exports);
  const ext_1 = __importDefault2(ext);
  const ic_punks_1 = __importDefault2(ic_punks);
  const nft_origyn_1 = __importDefault2(nft_origyn);
  const departure_labs_1 = __importDefault2(departure_labs);
  const dip_721_1 = __importDefault2(dip_721);
  const standards_12 = standards;
  const constants_12 = constants;
  const nft_registry_did_1 = __importDefault2(nft_registry_did);
  const standard_registry_1 = __importDefault2(standard_registry);
  const actorFactory_1 = actorFactory;
  const registry_12 = registry;
  const ccc_1 = __importDefault2(ccc);
  const CANISTER_ID = "ctqxp-yyaaa-aaaah-abbda-cai";
  const BATCH_AMOUNT = 5;
  const NFT_STANDARDS = {
    [standards_12.NFT.ext]: ext_1.default,
    [standards_12.NFT.icpunks]: ic_punks_1.default,
    [standards_12.NFT.nftOrigyn]: nft_origyn_1.default,
    [standards_12.NFT.departuresLabs]: departure_labs_1.default,
    [standards_12.NFT.erc721]: dip_721_1.default,
    [standards_12.NFT.dip721]: dip_721_1.default,
    [standards_12.NFT.c3]: ccc_1.default
  };
  const DEFAULT_AGENT2 = new agent_12.HttpAgent({ fetch: cross_fetch_12.default, host: constants_12.IC_HOST });
  class NFTRegistry extends standard_registry_1.default {
    constructor(agent) {
      super(CANISTER_ID, agent);
      this.getAll = () => __awaiter2(this, void 0, void 0, function* () {
        const canistersMetadata = yield this.actor.get_all();
        return canistersMetadata.map(registry_12.formatMetadata);
      });
      this.actor = (0, actorFactory_1.generateActor)({ agent: agent || DEFAULT_AGENT2, canisterId: CANISTER_ID, IDL: nft_registry_did_1.default });
    }
  }
  exports2.NFTRegistry = NFTRegistry;
  const getUserCollectionTokens = (collection, user, agent = DEFAULT_AGENT2, callback = () => {
  }) => __awaiter2(void 0, void 0, void 0, function* () {
    try {
      const NFTActor = (0, exports2.getNFTActor)({
        canisterId: collection.principal_id.toString(),
        agent,
        standard: collection.standard
      });
      const details = yield NFTActor.getUserTokens(user);
      const collectionDetails = {
        name: collection.name,
        canisterId: collection.principal_id.toString(),
        standard: collection.standard,
        description: collection.description,
        icon: collection.icon,
        tokens: details.map((detail) => Object.assign(Object.assign({}, detail), { collection: collection.name }))
      };
      if (callback) {
        yield callback === null || callback === void 0 ? void 0 : callback(collectionDetails);
      }
      return collectionDetails;
    } catch (e2) {
      console.error(e2);
      return {
        name: collection.name,
        canisterId: collection.principal_id.toString(),
        standard: collection.standard,
        tokens: []
      };
    }
  });
  exports2.getUserCollectionTokens = getUserCollectionTokens;
  const standardNormaliser = ({ standard }) => {
    const userStandardNormalised = standard.toUpperCase();
    const systemStandardNormalised = standards_12.NFT.dip721.toUpperCase();
    const startsWithDip721 = userStandardNormalised.startsWith(systemStandardNormalised);
    const hasSuffix = userStandardNormalised.split(systemStandardNormalised).filter((v2) => v2).length > 0;
    const hasDeprecatedDip721Term = startsWithDip721 && hasSuffix;
    if (hasDeprecatedDip721Term) {
      console.warn(`Warning! Use the term DIP721, not ${standard}, suffixed and others are being deprecated and support will be dropped soon!`);
      return standards_12.NFT.dip721;
    }
    return userStandardNormalised;
  };
  const getNFTActor = ({ canisterId, agent, standard }) => {
    const standardNormalised = standardNormaliser({
      standard
    });
    if (!(standardNormalised in NFT_STANDARDS)) {
      console.error(`Standard ${standardNormalised} is not implemented`);
      throw new Error(`standard is not supported: ${standardNormalised}`);
    }
    return new NFT_STANDARDS[standardNormalised](canisterId, agent);
  };
  exports2.getNFTActor = getNFTActor;
  const getNFTInfo = ({ nftCanisterId, agent = DEFAULT_AGENT2 }) => __awaiter2(void 0, void 0, void 0, function* () {
    const registry2 = new NFTRegistry(agent);
    const result = yield registry2.get(nftCanisterId);
    if (!result)
      return result;
    return Object.assign(Object.assign({}, result), { icon: result.thumbnail, standard: result.details.standard });
  });
  exports2.getNFTInfo = getNFTInfo;
  const getAllNFTS = ({ agent = DEFAULT_AGENT2 } = {}) => __awaiter2(void 0, void 0, void 0, function* () {
    const registry2 = new NFTRegistry(agent);
    const allNFTs = yield registry2.getAll();
    return allNFTs.map((nft2) => Object.assign(Object.assign({}, nft2), { icon: nft2.thumbnail, standard: nft2.details.standard }));
  });
  exports2.getAllNFTS = getAllNFTS;
  const getAllUserNFTs = ({ user, agent = DEFAULT_AGENT2 }) => __awaiter2(void 0, void 0, void 0, function* () {
    const NFTCollections = yield (0, exports2.getAllNFTS)({ agent });
    const userPrincipal = user instanceof principal_12.Principal ? user : principal_12.Principal.fromText(user);
    const result = yield Promise.all(NFTCollections.map((collection) => (0, exports2.getUserCollectionTokens)(collection, userPrincipal, agent)));
    return result.filter((element) => element.tokens.length);
  });
  exports2.getAllUserNFTs = getAllUserNFTs;
  const getBatchedNFTs = ({ principal, callback, batchSize = BATCH_AMOUNT, onFinish, agent = DEFAULT_AGENT2 }) => __awaiter2(void 0, void 0, void 0, function* () {
    const NFTCollections = yield (0, exports2.getAllNFTS)({ agent });
    let result = [];
    for (let i2 = 0; i2 < NFTCollections.length; i2 += batchSize) {
      const batch = NFTCollections.slice(i2, i2 + batchSize);
      const batchResult = yield Promise.all(batch.map((collection) => (0, exports2.getUserCollectionTokens)(collection, principal, agent, callback)));
      result = [...result, ...batchResult];
    }
    if (onFinish) {
      yield onFinish === null || onFinish === void 0 ? void 0 : onFinish(result);
    }
    return result.filter((element) => {
      var _a;
      return (_a = element === null || element === void 0 ? void 0 : element.tokens) === null || _a === void 0 ? void 0 : _a.length;
    });
  });
  exports2.getBatchedNFTs = getBatchedNFTs;
  const getCachedUserNFTs = ({ userPID, refresh }) => __awaiter2(void 0, void 0, void 0, function* () {
    const url2 = `${constants_12.KYASSHU_URL}/dab/user/nfts/${userPID}`;
    const result = yield axios_1.default.get(url2, { params: { refresh } });
    return result.data;
  });
  exports2.getCachedUserNFTs = getCachedUserNFTs;
  exports2.default = {
    getBatchedNFTs: exports2.getBatchedNFTs,
    getNFTActor: exports2.getNFTActor,
    getNFTInfo: exports2.getNFTInfo,
    getAllNFTS: exports2.getAllNFTS,
    getAllUserNFTs: exports2.getAllUserNFTs,
    getCachedUserNFTs: exports2.getCachedUserNFTs
  };
})(nfts_registry);
var canister_registry = {};
var canister_registry_did = {};
Object.defineProperty(canister_registry_did, "__esModule", { value: true });
canister_registry_did.init = void 0;
canister_registry_did.default = ({ IDL: IDL2 }) => {
  const detail_value = IDL2.Rec();
  detail_value.fill(IDL2.Variant({
    "I64": IDL2.Int64,
    "U64": IDL2.Nat64,
    "Vec": IDL2.Vec(detail_value),
    "Slice": IDL2.Vec(IDL2.Nat8),
    "Text": IDL2.Text,
    "True": IDL2.Null,
    "False": IDL2.Null,
    "Float": IDL2.Float64,
    "Principal": IDL2.Principal
  }));
  const canister_metadata = IDL2.Record({
    "thumbnail": IDL2.Text,
    "name": IDL2.Text,
    "frontend": IDL2.Opt(IDL2.Text),
    "description": IDL2.Text,
    "principal_id": IDL2.Principal,
    "details": IDL2.Vec(IDL2.Tuple(IDL2.Text, detail_value))
  });
  const operation_error = IDL2.Variant({
    "NotAuthorized": IDL2.Null,
    "BadParameters": IDL2.Null,
    "Unknown": IDL2.Text,
    "NonExistentItem": IDL2.Null
  });
  const operation_response = IDL2.Variant({
    "Ok": IDL2.Opt(IDL2.Text),
    "Err": operation_error
  });
  return IDL2.Service({
    "add": IDL2.Func([canister_metadata], [operation_response], []),
    "get": IDL2.Func([IDL2.Principal], [IDL2.Opt(canister_metadata)], ["query"]),
    "get_all": IDL2.Func([], [IDL2.Vec(canister_metadata)], ["query"]),
    "name": IDL2.Func([], [IDL2.Text], ["query"]),
    "remove": IDL2.Func([IDL2.Principal], [operation_response], [])
  });
};
const init$6 = () => {
  return [];
};
canister_registry_did.init = init$6;
(function(exports2) {
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value2) {
      return value2 instanceof P2 ? value2 : new P2(function(resolve) {
        resolve(value2);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.getAll = exports2.getMultipleCanisterInfo = exports2.getCanisterInfo = exports2.CanisterRegistry = void 0;
  const agent_12 = require$$5;
  const cross_fetch_12 = __importDefault2(browserPonyfill.exports);
  const canister_registry_did_1 = __importDefault2(canister_registry_did);
  const constants_12 = constants;
  const standard_registry_1 = __importDefault2(standard_registry);
  const actorFactory_1 = actorFactory;
  const registry_12 = registry;
  const principal_12 = require$$4;
  const CANISTER_ID = "curr3-vaaaa-aaaah-abbdq-cai";
  const DEFAULT_AGENT2 = new agent_12.HttpAgent({ fetch: cross_fetch_12.default, host: constants_12.IC_HOST });
  const formatBackwardsCompatible = (metadata) => {
    if (!metadata) {
      return metadata;
    }
    const { thumbnail, name, description, frontend, details } = metadata;
    return { url: (frontend === null || frontend === void 0 ? void 0 : frontend[0]) || "", name, description, version: Number(details.version), logo_url: thumbnail };
  };
  class CanisterRegistry extends standard_registry_1.default {
    constructor(agent) {
      super(CANISTER_ID, agent);
      this.getAll = () => __awaiter2(this, void 0, void 0, function* () {
        const canistersMetadata = yield this.actor.get_all();
        return canistersMetadata.map(registry_12.formatMetadata);
      });
      this.actor = (0, actorFactory_1.generateActor)({ agent: agent || DEFAULT_AGENT2, canisterId: CANISTER_ID, IDL: canister_registry_did_1.default });
    }
  }
  exports2.CanisterRegistry = CanisterRegistry;
  const getCanisterInfo = ({ canisterId, agent = DEFAULT_AGENT2 }) => __awaiter2(void 0, void 0, void 0, function* () {
    const canisterRegistry = new CanisterRegistry(agent);
    const canister = yield canisterRegistry.get(principal_12.Principal.from(canisterId).toString());
    const formattedCanister = formatBackwardsCompatible(canister);
    return formattedCanister && Object.assign(Object.assign({}, formattedCanister), { canisterId: canisterId.toString() });
  });
  exports2.getCanisterInfo = getCanisterInfo;
  const getMultipleCanisterInfo = ({ canisterIds, agent = DEFAULT_AGENT2 }) => __awaiter2(void 0, void 0, void 0, function* () {
    const canistersMetadata = yield Promise.all(canisterIds.map((canisterId) => (0, exports2.getCanisterInfo)({ canisterId, agent })));
    if (canistersMetadata.length === 0)
      return [];
    return canistersMetadata.filter((canister) => !!canister);
  });
  exports2.getMultipleCanisterInfo = getMultipleCanisterInfo;
  const getAll = (agent) => __awaiter2(void 0, void 0, void 0, function* () {
    const allCanisters = yield new CanisterRegistry(agent).getAll();
    return allCanisters.map(formatBackwardsCompatible);
  });
  exports2.getAll = getAll;
  exports2.default = {
    getCanisterInfo: exports2.getCanisterInfo,
    getMultipleCanisterInfo: exports2.getMultipleCanisterInfo,
    getAll: (agent) => new CanisterRegistry(agent).getAll
  };
})(canister_registry);
var token_registry = {};
var token_registry_did = {};
Object.defineProperty(token_registry_did, "__esModule", { value: true });
token_registry_did.init = void 0;
token_registry_did.default = ({ IDL: IDL2 }) => {
  const detail_value = IDL2.Rec();
  detail_value.fill(IDL2.Variant({
    "I64": IDL2.Int64,
    "U64": IDL2.Nat64,
    "Vec": IDL2.Vec(detail_value),
    "Slice": IDL2.Vec(IDL2.Nat8),
    "Text": IDL2.Text,
    "True": IDL2.Null,
    "False": IDL2.Null,
    "Float": IDL2.Float64,
    "Principal": IDL2.Principal
  }));
  const token2 = IDL2.Record({
    "thumbnail": IDL2.Text,
    "name": IDL2.Text,
    "frontend": IDL2.Opt(IDL2.Text),
    "description": IDL2.Text,
    "principal_id": IDL2.Principal,
    "details": IDL2.Vec(IDL2.Tuple(IDL2.Text, detail_value))
  });
  const operation_error = IDL2.Variant({
    "NotAuthorized": IDL2.Null,
    "BadParameters": IDL2.Null,
    "Unknown": IDL2.Text,
    "NonExistentItem": IDL2.Null
  });
  const operation_response = IDL2.Variant({
    "Ok": IDL2.Opt(IDL2.Text),
    "Err": operation_error
  });
  return IDL2.Service({
    "add": IDL2.Func([token2], [operation_response], []),
    "get": IDL2.Func([IDL2.Principal], [IDL2.Opt(token2)], ["query"]),
    "get_all": IDL2.Func([], [IDL2.Vec(token2)], ["query"]),
    "name": IDL2.Func([], [IDL2.Text], ["query"]),
    "remove": IDL2.Func([IDL2.Principal], [operation_response], []),
    "set_controller": IDL2.Func([IDL2.Principal], [operation_response], [])
  });
};
const init$5 = () => {
  return [];
};
token_registry_did.init = init$5;
var token_standards = {};
var methods = {};
var __awaiter$5 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve) {
      resolve(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
Object.defineProperty(methods, "__esModule", { value: true });
methods.parseAmountToSend = methods.getDecimalsFromMetadata = void 0;
const send$5 = (_actor, _params) => __awaiter$5(void 0, void 0, void 0, function* () {
  throw Error("Standard Not Implemented");
});
const getMetadata$5 = (_actor) => __awaiter$5(void 0, void 0, void 0, function* () {
  throw Error("Standard Not Implemented");
});
const getBalance$5 = (_actor, _user) => __awaiter$5(void 0, void 0, void 0, function* () {
  throw Error("Standard Not Implemented");
});
const burnXTC$5 = (_actor, _params) => __awaiter$5(void 0, void 0, void 0, function* () {
  throw Error("Standard Not Implemented");
});
const getDecimals$5 = (_actor) => __awaiter$5(void 0, void 0, void 0, function* () {
  throw Error("Standard Not Implemented");
});
const getDecimalsFromMetadata = (metadata) => {
  return "fungible" in metadata ? metadata.fungible.decimals : 0;
};
methods.getDecimalsFromMetadata = getDecimalsFromMetadata;
const parseAmountToSend = (amount, decimals) => {
  return BigInt(parseFloat(amount) * Math.pow(10, decimals));
};
methods.parseAmountToSend = parseAmountToSend;
methods.default = {
  send: send$5,
  getMetadata: getMetadata$5,
  getBalance: getBalance$5,
  burnXTC: burnXTC$5,
  getDecimals: getDecimals$5
};
var xtcMethods = {};
var __awaiter$4 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve) {
      resolve(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
Object.defineProperty(xtcMethods, "__esModule", { value: true });
const principal_1$4 = require$$4;
const methods_1$4 = methods;
const getMetadata$4 = (actor) => __awaiter$4(void 0, void 0, void 0, function* () {
  const metadataResult = yield actor._getMetadata();
  return {
    fungible: {
      symbol: metadataResult.symbol,
      decimals: metadataResult.decimals,
      name: metadataResult.name,
      logo: metadataResult.logo,
      fee: metadataResult.fee,
      totalSupply: metadataResult.totalSupply,
      owner: metadataResult.owner
    }
  };
});
const send$4 = (actor, { to, amount }) => __awaiter$4(void 0, void 0, void 0, function* () {
  const transferResult = yield actor._transferErc20(principal_1$4.Principal.fromText(to), amount);
  if ("Ok" in transferResult)
    return { transactionId: transferResult.Ok.toString() };
  throw new Error(Object.keys(transferResult.Err)[0]);
});
const getBalance$4 = (actor, user) => __awaiter$4(void 0, void 0, void 0, function* () {
  const decimals = yield getDecimals$4(actor);
  const value2 = (yield actor._balanceOf(user)).toString();
  return { value: value2, decimals };
});
const burnXTC$4 = (actor, { to, amount }) => __awaiter$4(void 0, void 0, void 0, function* () {
  const decimals = yield getDecimals$4(actor);
  const parsedAmount = (0, methods_1$4.parseAmountToSend)(amount, decimals);
  return actor._burn({ canister_id: to, amount: parsedAmount });
});
const getDecimals$4 = (actor) => __awaiter$4(void 0, void 0, void 0, function* () {
  return (0, methods_1$4.getDecimalsFromMetadata)(yield getMetadata$4(actor));
});
xtcMethods.default = {
  send: send$4,
  getMetadata: getMetadata$4,
  getBalance: getBalance$4,
  burnXTC: burnXTC$4,
  getDecimals: getDecimals$4
};
var extMethods = {};
var __awaiter$3 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve) {
      resolve(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
Object.defineProperty(extMethods, "__esModule", { value: true });
const agent_1 = require$$5;
const principal_1$3 = require$$4;
const methods_1$3 = methods;
const getMetadata$3 = (actor) => __awaiter$3(void 0, void 0, void 0, function* () {
  actor._balance;
  const token2 = agent_1.Actor.canisterIdOf(actor).toText();
  const extensions = yield actor._extensions();
  if (!extensions.includes("@ext/common"))
    throw new Error("The provided canister does not implement commont extension");
  const metadataResult = yield actor._metadata(token2);
  if ("ok" in metadataResult)
    return metadataResult.ok;
  throw new Error(Object.keys(metadataResult.err)[0]);
});
const send$3 = (actor, { to, from: from2, amount }) => __awaiter$3(void 0, void 0, void 0, function* () {
  const dummyMemmo = new Array(32).fill(0);
  const token2 = agent_1.Actor.canisterIdOf(actor).toText();
  const data2 = {
    to: { principal: principal_1$3.Principal.fromText(to) },
    from: { principal: principal_1$3.Principal.from(from2) },
    amount,
    token: token2,
    memo: dummyMemmo,
    notify: false,
    subaccount: [],
    fee: BigInt(0)
  };
  const transferResult = yield actor._transfer(data2);
  if ("ok" in transferResult)
    return { amount: transferResult.ok.toString() };
  throw new Error(Object.keys(transferResult.err)[0]);
});
const getBalance$3 = (actor, user) => __awaiter$3(void 0, void 0, void 0, function* () {
  const token2 = agent_1.Actor.canisterIdOf(actor).toText();
  const balanceResult = yield actor._balance({
    token: token2,
    user: { principal: user }
  });
  const decimals = yield getDecimals$3(actor);
  if ("ok" in balanceResult)
    return { value: balanceResult.ok.toString(), decimals };
  throw new Error(Object.keys(balanceResult.err)[0]);
});
const burnXTC$3 = (_actor, _params) => __awaiter$3(void 0, void 0, void 0, function* () {
  throw new Error("BURN NOT SUPPORTED");
});
const getDecimals$3 = (actor) => __awaiter$3(void 0, void 0, void 0, function* () {
  return (0, methods_1$3.getDecimalsFromMetadata)(yield getMetadata$3(actor));
});
extMethods.default = {
  send: send$3,
  getMetadata: getMetadata$3,
  getBalance: getBalance$3,
  burnXTC: burnXTC$3,
  getDecimals: getDecimals$3
};
var dip20Methods = {};
var __awaiter$2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve) {
      resolve(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
Object.defineProperty(dip20Methods, "__esModule", { value: true });
const principal_1$2 = require$$4;
const methods_1$2 = methods;
const getMetadata$2 = (actor) => __awaiter$2(void 0, void 0, void 0, function* () {
  const metadataResult = yield actor._getMetadata();
  return {
    fungible: {
      symbol: metadataResult.symbol,
      decimals: metadataResult.decimals,
      name: metadataResult.name,
      logo: metadataResult.logo,
      fee: metadataResult.fee,
      totalSupply: metadataResult.totalSupply,
      owner: metadataResult.owner
    }
  };
});
const send$2 = (actor, { to, amount }) => __awaiter$2(void 0, void 0, void 0, function* () {
  const transferResult = yield actor._transfer(principal_1$2.Principal.fromText(to), amount);
  if ("Ok" in transferResult)
    return { transactionId: transferResult.Ok.toString() };
  throw new Error(Object.keys(transferResult.Err)[0]);
});
const getBalance$2 = (actor, user) => __awaiter$2(void 0, void 0, void 0, function* () {
  const decimals = yield getDecimals$2(actor);
  const value2 = (yield actor._balanceOf(user)).toString();
  return { value: value2, decimals };
});
const burnXTC$2 = (_actor, _params) => __awaiter$2(void 0, void 0, void 0, function* () {
  throw new Error("BURN NOT SUPPORTED");
});
const getDecimals$2 = (actor) => __awaiter$2(void 0, void 0, void 0, function* () {
  return (0, methods_1$2.getDecimalsFromMetadata)(yield getMetadata$2(actor));
});
dip20Methods.default = {
  send: send$2,
  getMetadata: getMetadata$2,
  getBalance: getBalance$2,
  burnXTC: burnXTC$2,
  getDecimals: getDecimals$2
};
var xtc_did = {};
Object.defineProperty(xtc_did, "__esModule", { value: true });
xtc_did.init = void 0;
xtc_did.default = ({ IDL: IDL2 }) => {
  const TxError = IDL2.Variant({
    "InsufficientAllowance": IDL2.Null,
    "InsufficientBalance": IDL2.Null,
    "ErrorOperationStyle": IDL2.Null,
    "Unauthorized": IDL2.Null,
    "LedgerTrap": IDL2.Null,
    "ErrorTo": IDL2.Null,
    "Other": IDL2.Null,
    "BlockUsed": IDL2.Null,
    "AmountTooSmall": IDL2.Null
  });
  const TxReceipt = IDL2.Variant({ "Ok": IDL2.Nat, "Err": TxError });
  const TransactionId = IDL2.Nat64;
  const BurnError = IDL2.Variant({
    "InsufficientBalance": IDL2.Null,
    "InvalidTokenContract": IDL2.Null,
    "NotSufficientLiquidity": IDL2.Null
  });
  const BurnResult = IDL2.Variant({ "Ok": TransactionId, "Err": BurnError });
  const TransactionStatus = IDL2.Variant({
    "FAILED": IDL2.Null,
    "SUCCEEDED": IDL2.Null
  });
  const EventDetail = IDL2.Variant({
    "Approve": IDL2.Record({ "to": IDL2.Principal, "from": IDL2.Principal }),
    "Burn": IDL2.Record({ "to": IDL2.Principal, "from": IDL2.Principal }),
    "Mint": IDL2.Record({ "to": IDL2.Principal }),
    "CanisterCreated": IDL2.Record({
      "from": IDL2.Principal,
      "canister": IDL2.Principal
    }),
    "CanisterCalled": IDL2.Record({
      "from": IDL2.Principal,
      "method_name": IDL2.Text,
      "canister": IDL2.Principal
    }),
    "Transfer": IDL2.Record({ "to": IDL2.Principal, "from": IDL2.Principal }),
    "TransferFrom": IDL2.Record({
      "to": IDL2.Principal,
      "from": IDL2.Principal,
      "caller": IDL2.Principal
    })
  });
  const Event = IDL2.Record({
    "fee": IDL2.Nat64,
    "status": TransactionStatus,
    "kind": EventDetail,
    "cycles": IDL2.Nat64,
    "timestamp": IDL2.Nat64
  });
  const EventsConnection = IDL2.Record({
    "data": IDL2.Vec(Event),
    "next_offset": TransactionId,
    "next_canister_id": IDL2.Opt(IDL2.Principal)
  });
  const Metadata = IDL2.Record({
    "fee": IDL2.Nat,
    "decimals": IDL2.Nat8,
    "owner": IDL2.Principal,
    "logo": IDL2.Text,
    "name": IDL2.Text,
    "totalSupply": IDL2.Nat,
    "symbol": IDL2.Text
  });
  const Operation = IDL2.Variant({
    "transferFrom": IDL2.Null,
    "burn": IDL2.Null,
    "mint": IDL2.Null,
    "approve": IDL2.Null,
    "canisterCalled": IDL2.Null,
    "transfer": IDL2.Null,
    "canisterCreated": IDL2.Null
  });
  const Time = IDL2.Int;
  const TxRecord = IDL2.Record({
    "op": Operation,
    "to": IDL2.Principal,
    "fee": IDL2.Nat,
    "status": TransactionStatus,
    "from": IDL2.Principal,
    "timestamp": Time,
    "caller": IDL2.Opt(IDL2.Principal),
    "index": IDL2.Nat,
    "amount": IDL2.Nat
  });
  const MintError = IDL2.Variant({ "NotSufficientLiquidity": IDL2.Null });
  const MintResult = IDL2.Variant({ "Ok": TransactionId, "Err": MintError });
  const Stats = IDL2.Record({
    "fee": IDL2.Nat,
    "transfers_count": IDL2.Nat64,
    "balance": IDL2.Nat64,
    "mints_count": IDL2.Nat64,
    "transfers_from_count": IDL2.Nat64,
    "canisters_created_count": IDL2.Nat64,
    "supply": IDL2.Nat,
    "burns_count": IDL2.Nat64,
    "approvals_count": IDL2.Nat64,
    "proxy_calls_count": IDL2.Nat64,
    "history_events": IDL2.Nat64
  });
  const ResultCall = IDL2.Variant({
    "Ok": IDL2.Record({ "return": IDL2.Vec(IDL2.Nat8) }),
    "Err": IDL2.Text
  });
  const CreateResult = IDL2.Variant({
    "Ok": IDL2.Record({ "canister_id": IDL2.Principal }),
    "Err": IDL2.Text
  });
  const ResultSend = IDL2.Variant({ "Ok": IDL2.Null, "Err": IDL2.Text });
  return IDL2.Service({
    "allowance": IDL2.Func([IDL2.Principal, IDL2.Principal], [IDL2.Nat], ["query"]),
    "approve": IDL2.Func([IDL2.Principal, IDL2.Nat], [TxReceipt], []),
    "balance": IDL2.Func([IDL2.Opt(IDL2.Principal)], [IDL2.Nat64], []),
    "balanceOf": IDL2.Func([IDL2.Principal], [IDL2.Nat], ["query"]),
    "burn": IDL2.Func([IDL2.Record({ "canister_id": IDL2.Principal, "amount": IDL2.Nat64 })], [BurnResult], []),
    "decimals": IDL2.Func([], [IDL2.Nat8], ["query"]),
    "events": IDL2.Func([IDL2.Record({ "offset": IDL2.Opt(IDL2.Nat64), "limit": IDL2.Nat16 })], [EventsConnection], ["query"]),
    "getMetadata": IDL2.Func([], [Metadata], ["query"]),
    "getTransaction": IDL2.Func([IDL2.Nat], [TxRecord], []),
    "getTransactions": IDL2.Func([IDL2.Nat, IDL2.Nat], [IDL2.Vec(TxRecord)], []),
    "get_transaction": IDL2.Func([TransactionId], [IDL2.Opt(Event)], []),
    "halt": IDL2.Func([], [], []),
    "historySize": IDL2.Func([], [IDL2.Nat], ["query"]),
    "logo": IDL2.Func([], [IDL2.Text], ["query"]),
    "mint": IDL2.Func([IDL2.Principal, IDL2.Nat], [MintResult], []),
    "name": IDL2.Func([], [IDL2.Text], ["query"]),
    "nameErc20": IDL2.Func([], [IDL2.Text], ["query"]),
    "stats": IDL2.Func([], [Stats], ["query"]),
    "symbol": IDL2.Func([], [IDL2.Text], ["query"]),
    "totalSupply": IDL2.Func([], [IDL2.Nat], ["query"]),
    "transfer": IDL2.Func([IDL2.Principal, IDL2.Nat], [TxReceipt], []),
    "transferErc20": IDL2.Func([IDL2.Principal, IDL2.Nat], [TxReceipt], []),
    "transferFrom": IDL2.Func([IDL2.Principal, IDL2.Principal, IDL2.Nat], [TxReceipt], []),
    "wallet_balance": IDL2.Func([], [IDL2.Record({ "amount": IDL2.Nat64 })], ["query"]),
    "wallet_call": IDL2.Func([
      IDL2.Record({
        "args": IDL2.Vec(IDL2.Nat8),
        "cycles": IDL2.Nat64,
        "method_name": IDL2.Text,
        "canister": IDL2.Principal
      })
    ], [ResultCall], []),
    "wallet_create_canister": IDL2.Func([
      IDL2.Record({
        "controller": IDL2.Opt(IDL2.Principal),
        "cycles": IDL2.Nat64
      })
    ], [CreateResult], []),
    "wallet_create_wallet": IDL2.Func([
      IDL2.Record({
        "controller": IDL2.Opt(IDL2.Principal),
        "cycles": IDL2.Nat64
      })
    ], [CreateResult], []),
    "wallet_send": IDL2.Func([IDL2.Record({ "canister": IDL2.Principal, "amount": IDL2.Nat64 })], [ResultSend], [])
  });
};
const init$4 = () => {
  return [];
};
xtc_did.init = init$4;
var dip_20_did = {};
Object.defineProperty(dip_20_did, "__esModule", { value: true });
dip_20_did.init = void 0;
dip_20_did.default = ({ IDL: IDL2 }) => {
  const TxError = IDL2.Variant({
    "InsufficientAllowance": IDL2.Null,
    "InsufficientBalance": IDL2.Null,
    "ErrorOperationStyle": IDL2.Null,
    "Unauthorized": IDL2.Null,
    "LedgerTrap": IDL2.Null,
    "ErrorTo": IDL2.Null,
    "Other": IDL2.Null,
    "BlockUsed": IDL2.Null,
    "AmountTooSmall": IDL2.Null
  });
  const Result = IDL2.Variant({ "Ok": IDL2.Nat, "Err": TxError });
  const Metadata = IDL2.Record({
    "fee": IDL2.Nat,
    "decimals": IDL2.Nat8,
    "owner": IDL2.Principal,
    "logo": IDL2.Text,
    "name": IDL2.Text,
    "totalSupply": IDL2.Nat,
    "symbol": IDL2.Text
  });
  const TokenInfo = IDL2.Record({
    "holderNumber": IDL2.Nat64,
    "deployTime": IDL2.Nat64,
    "metadata": Metadata,
    "historySize": IDL2.Nat64,
    "cycles": IDL2.Nat64,
    "feeTo": IDL2.Principal
  });
  return IDL2.Service({
    "allowance": IDL2.Func([IDL2.Principal, IDL2.Principal], [IDL2.Nat], ["query"]),
    "approve": IDL2.Func([IDL2.Principal, IDL2.Nat], [Result], []),
    "balanceOf": IDL2.Func([IDL2.Principal], [IDL2.Nat], ["query"]),
    "decimals": IDL2.Func([], [IDL2.Nat8], ["query"]),
    "getAllowanceSize": IDL2.Func([], [IDL2.Nat64], ["query"]),
    "getBlockUsed": IDL2.Func([], [IDL2.Vec(IDL2.Nat64)], ["query"]),
    "getHolders": IDL2.Func([IDL2.Nat64, IDL2.Nat64], [IDL2.Vec(IDL2.Tuple(IDL2.Principal, IDL2.Nat))], ["query"]),
    "getMetadata": IDL2.Func([], [Metadata], ["query"]),
    "getTokenInfo": IDL2.Func([], [TokenInfo], ["query"]),
    "getUserApprovals": IDL2.Func([IDL2.Principal], [IDL2.Vec(IDL2.Tuple(IDL2.Principal, IDL2.Nat))], ["query"]),
    "historySize": IDL2.Func([], [IDL2.Nat64], ["query"]),
    "isBlockUsed": IDL2.Func([IDL2.Nat64], [IDL2.Bool], ["query"]),
    "logo": IDL2.Func([], [IDL2.Text], ["query"]),
    "mint": IDL2.Func([IDL2.Opt(IDL2.Vec(IDL2.Nat8)), IDL2.Nat64], [Result], []),
    "mintFor": IDL2.Func([IDL2.Opt(IDL2.Vec(IDL2.Nat8)), IDL2.Nat64, IDL2.Principal], [Result], []),
    "name": IDL2.Func([], [IDL2.Text], ["query"]),
    "owner": IDL2.Func([], [IDL2.Principal], ["query"]),
    "setFee": IDL2.Func([IDL2.Nat], [], []),
    "setFeeTo": IDL2.Func([IDL2.Principal], [], []),
    "setGenesis": IDL2.Func([], [Result], []),
    "setLogo": IDL2.Func([IDL2.Text], [], []),
    "setName": IDL2.Func([IDL2.Text], [], []),
    "setOwner": IDL2.Func([IDL2.Principal], [], []),
    "symbol": IDL2.Func([], [IDL2.Text], ["query"]),
    "totalSupply": IDL2.Func([], [IDL2.Nat], ["query"]),
    "transfer": IDL2.Func([IDL2.Principal, IDL2.Nat], [Result], []),
    "transferFrom": IDL2.Func([IDL2.Principal, IDL2.Principal, IDL2.Nat], [Result], []),
    "withdraw": IDL2.Func([IDL2.Nat64, IDL2.Text], [Result], [])
  });
};
const init$3 = ({ IDL: IDL2 }) => {
  return [
    IDL2.Text,
    IDL2.Text,
    IDL2.Text,
    IDL2.Nat8,
    IDL2.Nat,
    IDL2.Principal,
    IDL2.Nat,
    IDL2.Principal,
    IDL2.Principal
  ];
};
dip_20_did.init = init$3;
var ledger_did = {};
Object.defineProperty(ledger_did, "__esModule", { value: true });
ledger_did.init = void 0;
ledger_did.default = ({ IDL: IDL2 }) => {
  const AccountIdentifier = IDL2.Text;
  const Duration = IDL2.Record({ secs: IDL2.Nat64, nanos: IDL2.Nat32 });
  const ArchiveOptions = IDL2.Record({
    max_message_size_bytes: IDL2.Opt(IDL2.Nat32),
    node_max_memory_size_bytes: IDL2.Opt(IDL2.Nat32),
    controller_id: IDL2.Principal
  });
  const ICPTs = IDL2.Record({ e8s: IDL2.Nat64 });
  IDL2.Record({
    send_whitelist: IDL2.Vec(IDL2.Tuple(IDL2.Principal)),
    minting_account: AccountIdentifier,
    transaction_window: IDL2.Opt(Duration),
    max_message_size_bytes: IDL2.Opt(IDL2.Nat32),
    archive_options: IDL2.Opt(ArchiveOptions),
    initial_values: IDL2.Vec(IDL2.Tuple(AccountIdentifier, ICPTs))
  });
  const AccountBalanceArgs = IDL2.Record({ account: AccountIdentifier });
  const SubAccount = IDL2.Vec(IDL2.Nat8);
  const BlockHeight = IDL2.Nat64;
  const NotifyCanisterArgs = IDL2.Record({
    to_subaccount: IDL2.Opt(SubAccount),
    from_subaccount: IDL2.Opt(SubAccount),
    to_canister: IDL2.Principal,
    max_fee: ICPTs,
    block_height: BlockHeight
  });
  const Memo = IDL2.Nat64;
  const TimeStamp = IDL2.Record({ timestamp_nanos: IDL2.Nat64 });
  const SendArgs = IDL2.Record({
    to: AccountIdentifier,
    fee: ICPTs,
    memo: Memo,
    from_subaccount: IDL2.Opt(SubAccount),
    created_at_time: IDL2.Opt(TimeStamp),
    amount: ICPTs
  });
  return IDL2.Service({
    account_balance_dfx: IDL2.Func([AccountBalanceArgs], [ICPTs], ["query"]),
    notify_dfx: IDL2.Func([NotifyCanisterArgs], [], []),
    send_dfx: IDL2.Func([SendArgs], [BlockHeight], [])
  });
};
const init$2 = ({ IDL: IDL2 }) => {
  const AccountIdentifier = IDL2.Text;
  const Duration = IDL2.Record({ secs: IDL2.Nat64, nanos: IDL2.Nat32 });
  const ArchiveOptions = IDL2.Record({
    max_message_size_bytes: IDL2.Opt(IDL2.Nat32),
    node_max_memory_size_bytes: IDL2.Opt(IDL2.Nat32),
    controller_id: IDL2.Principal
  });
  const ICPTs = IDL2.Record({ e8s: IDL2.Nat64 });
  const LedgerCanisterInitPayload = IDL2.Record({
    send_whitelist: IDL2.Vec(IDL2.Tuple(IDL2.Principal)),
    minting_account: AccountIdentifier,
    transaction_window: IDL2.Opt(Duration),
    max_message_size_bytes: IDL2.Opt(IDL2.Nat32),
    archive_options: IDL2.Opt(ArchiveOptions),
    initial_values: IDL2.Vec(IDL2.Tuple(AccountIdentifier, ICPTs))
  });
  return [LedgerCanisterInitPayload];
};
ledger_did.init = init$2;
var wicp_did = {};
Object.defineProperty(wicp_did, "__esModule", { value: true });
wicp_did.init = void 0;
wicp_did.default = ({ IDL: IDL2 }) => {
  const TxError = IDL2.Variant({
    "InsufficientAllowance": IDL2.Null,
    "InsufficientBalance": IDL2.Null,
    "ErrorOperationStyle": IDL2.Null,
    "Unauthorized": IDL2.Null,
    "LedgerTrap": IDL2.Null,
    "ErrorTo": IDL2.Null,
    "Other": IDL2.Null,
    "BlockUsed": IDL2.Null,
    "AmountTooSmall": IDL2.Null
  });
  const TxReceipt = IDL2.Variant({ "Ok": IDL2.Nat, "Err": TxError });
  const Metadata = IDL2.Record({
    "fee": IDL2.Nat,
    "decimals": IDL2.Nat8,
    "owner": IDL2.Principal,
    "logo": IDL2.Text,
    "name": IDL2.Text,
    "totalSupply": IDL2.Nat,
    "symbol": IDL2.Text
  });
  const TokenInfo = IDL2.Record({
    "holderNumber": IDL2.Nat64,
    "deployTime": IDL2.Nat64,
    "metadata": Metadata,
    "historySize": IDL2.Nat64,
    "cycles": IDL2.Nat64,
    "feeTo": IDL2.Principal
  });
  return IDL2.Service({
    "allowance": IDL2.Func([IDL2.Principal, IDL2.Principal], [IDL2.Nat], ["query"]),
    "approve": IDL2.Func([IDL2.Principal, IDL2.Nat], [TxReceipt], []),
    "balanceOf": IDL2.Func([IDL2.Principal], [IDL2.Nat], ["query"]),
    "decimals": IDL2.Func([], [IDL2.Nat8], ["query"]),
    "getAllowanceSize": IDL2.Func([], [IDL2.Nat64], ["query"]),
    "getHolders": IDL2.Func([IDL2.Nat64, IDL2.Nat64], [IDL2.Vec(IDL2.Tuple(IDL2.Principal, IDL2.Nat))], ["query"]),
    "getLogo": IDL2.Func([], [IDL2.Text], ["query"]),
    "getMetadata": IDL2.Func([], [Metadata], ["query"]),
    "getTokenInfo": IDL2.Func([], [TokenInfo], ["query"]),
    "getUserApprovals": IDL2.Func([IDL2.Principal], [IDL2.Vec(IDL2.Tuple(IDL2.Principal, IDL2.Nat))], ["query"]),
    "historySize": IDL2.Func([], [IDL2.Nat64], ["query"]),
    "mint": IDL2.Func([IDL2.Opt(IDL2.Vec(IDL2.Nat8)), IDL2.Nat64], [TxReceipt], []),
    "name": IDL2.Func([], [IDL2.Text], ["query"]),
    "owner": IDL2.Func([], [IDL2.Principal], ["query"]),
    "setFee": IDL2.Func([IDL2.Nat], [], []),
    "setFeeTo": IDL2.Func([IDL2.Principal], [], []),
    "setLogo": IDL2.Func([IDL2.Text], [], []),
    "setName": IDL2.Func([IDL2.Text], [], []),
    "setOwner": IDL2.Func([IDL2.Principal], [], []),
    "symbol": IDL2.Func([], [IDL2.Text], ["query"]),
    "totalSupply": IDL2.Func([], [IDL2.Nat], ["query"]),
    "transfer": IDL2.Func([IDL2.Principal, IDL2.Nat], [TxReceipt], []),
    "transferFrom": IDL2.Func([IDL2.Principal, IDL2.Principal, IDL2.Nat], [TxReceipt], []),
    "withdraw": IDL2.Func([IDL2.Nat64, IDL2.Text], [TxReceipt], [])
  });
};
const init$1 = ({ IDL: IDL2 }) => {
  return [
    IDL2.Text,
    IDL2.Text,
    IDL2.Text,
    IDL2.Nat8,
    IDL2.Nat,
    IDL2.Principal,
    IDL2.Nat,
    IDL2.Principal,
    IDL2.Principal
  ];
};
wicp_did.init = init$1;
var wicpMethods = {};
var __awaiter$1 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve) {
      resolve(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
Object.defineProperty(wicpMethods, "__esModule", { value: true });
const principal_1$1 = require$$4;
const methods_1$1 = methods;
const getMetadata$1 = (actor) => __awaiter$1(void 0, void 0, void 0, function* () {
  const metadataResult = yield actor._getMetadata();
  return {
    fungible: {
      symbol: metadataResult.symbol,
      decimals: metadataResult.decimals,
      name: metadataResult.name,
      logo: metadataResult.logo,
      fee: metadataResult.fee,
      totalSupply: metadataResult.totalSupply,
      owner: metadataResult.owner
    }
  };
});
const send$1 = (actor, { to, amount }) => __awaiter$1(void 0, void 0, void 0, function* () {
  const transferResult = yield actor._transfer(principal_1$1.Principal.fromText(to), amount);
  if ("Ok" in transferResult)
    return { transactionId: transferResult.Ok.toString() };
  throw new Error(Object.keys(transferResult.Err)[0]);
});
const getBalance$1 = (actor, user) => __awaiter$1(void 0, void 0, void 0, function* () {
  const decimals = yield getDecimals$1(actor);
  const value2 = (yield actor._balanceOf(user)).toString();
  return { value: value2, decimals };
});
const burnXTC$1 = (_actor, _params) => __awaiter$1(void 0, void 0, void 0, function* () {
  throw new Error("BURN NOT SUPPORTED");
});
const getDecimals$1 = (actor) => __awaiter$1(void 0, void 0, void 0, function* () {
  return (0, methods_1$1.getDecimalsFromMetadata)(yield getMetadata$1(actor));
});
wicpMethods.default = {
  send: send$1,
  getMetadata: getMetadata$1,
  getBalance: getBalance$1,
  burnXTC: burnXTC$1,
  getDecimals: getDecimals$1
};
var rosettaMethods = {};
var validations = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.validateToken = exports2.validateCanisterId = exports2.validateAccountId = exports2.validatePrincipalId = exports2.isValidPrincipal = exports2.ALPHANUM_REGEX = exports2.PRINCIPAL_REGEX = exports2.CANISTER_MAX_LENGTH = void 0;
  const principal_12 = require$$4;
  exports2.CANISTER_MAX_LENGTH = 27;
  exports2.PRINCIPAL_REGEX = /(\w{5}-){10}\w{3}/;
  exports2.ALPHANUM_REGEX = /^[a-zA-Z0-9]+$/;
  const isValidPrincipal = (text) => principal_12.Principal.fromText(text).toText() === text;
  exports2.isValidPrincipal = isValidPrincipal;
  const validatePrincipalId = (text) => {
    try {
      return Boolean(exports2.PRINCIPAL_REGEX.test(text) && (0, exports2.isValidPrincipal)(text));
    } catch (e2) {
      return false;
    }
  };
  exports2.validatePrincipalId = validatePrincipalId;
  const validateAccountId = (text) => text.length === 64 && exports2.ALPHANUM_REGEX.test(text);
  exports2.validateAccountId = validateAccountId;
  const validateCanisterId = (text) => {
    try {
      return Boolean(text.length <= exports2.CANISTER_MAX_LENGTH && (0, exports2.isValidPrincipal)(text));
    } catch (e2) {
      return false;
    }
  };
  exports2.validateCanisterId = validateCanisterId;
  const validateToken = (metadata) => Boolean(!!metadata.decimal && !!metadata.name && !!metadata.symbol);
  exports2.validateToken = validateToken;
})(validations);
var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve) {
      resolve(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(rosettaMethods, "__esModule", { value: true });
const principal_1 = require$$4;
const cross_fetch_1 = __importDefault(browserPonyfill.exports);
const methods_1 = methods;
const account_1 = account;
const validations_1 = validations;
const DECIMALS = 8;
const NET_ID = {
  blockchain: "Internet Computer",
  network: "00000000000000020101"
};
const ROSETTA_URL = "https://rosetta-api.internetcomputer.org";
const getMetadata = (_actor) => __awaiter(void 0, void 0, void 0, function* () {
  return {
    fungible: {
      symbol: "ICP",
      decimals: DECIMALS,
      name: "ICP",
      fee: 1e4
    }
  };
});
const send = (actor, { to, amount, opts }) => __awaiter(void 0, void 0, void 0, function* () {
  const defaultArgs = {
    fee: BigInt(1e4),
    memo: BigInt(0)
  };
  const response = yield actor._send_dfx({
    to: (0, validations_1.isValidPrincipal)(to) ? (0, account_1.getAccountId)(principal_1.Principal.fromText(to)) : to,
    fee: { e8s: (opts === null || opts === void 0 ? void 0 : opts.fee) || defaultArgs.fee },
    amount: { e8s: amount },
    memo: (opts === null || opts === void 0 ? void 0 : opts.memo) ? BigInt(opts.memo) : defaultArgs.memo,
    from_subaccount: [],
    created_at_time: []
  });
  return { height: yield response.toString() };
});
const getBalance = (actor, user) => __awaiter(void 0, void 0, void 0, function* () {
  const accountId = (0, account_1.getAccountId)(user);
  const decimals = yield getDecimals();
  const response = yield (0, cross_fetch_1.default)(`${ROSETTA_URL}/account/balance`, {
    method: "POST",
    body: JSON.stringify({
      network_identifier: NET_ID,
      account_identifier: {
        address: accountId
      }
    }),
    headers: {
      "Content-Type": "application/json",
      Accept: "*/*"
    }
  });
  if (!response.ok) {
    return { value: "Error", decimals, error: response.statusText };
  }
  const { balances } = yield response.json();
  const [{ value: value2, currency }] = balances;
  return { value: value2, decimals: currency.decimals };
});
const burnXTC = (_actor, _params) => __awaiter(void 0, void 0, void 0, function* () {
  throw new Error("BURN NOT SUPPORTED");
});
const getDecimals = (actor) => __awaiter(void 0, void 0, void 0, function* () {
  return (0, methods_1.getDecimalsFromMetadata)(yield getMetadata());
});
rosettaMethods.default = {
  send,
  getMetadata,
  getBalance,
  burnXTC,
  getDecimals
};
var icpStandardMethods = {};
var hasRequiredIcpStandardMethods;
function requireIcpStandardMethods() {
  if (hasRequiredIcpStandardMethods)
    return icpStandardMethods;
  hasRequiredIcpStandardMethods = 1;
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value2) {
      return value2 instanceof P2 ? value2 : new P2(function(resolve) {
        resolve(value2);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(icpStandardMethods, "__esModule", { value: true });
  const principal_12 = require$$4;
  const agent_12 = require$$5;
  const methods_12 = methods;
  const account_12 = account;
  const validations_12 = validations;
  const registries_1 = requireRegistries();
  const getMetadata2 = (_actor) => __awaiter2(void 0, void 0, void 0, function* () {
    var _a, _b, _c;
    const agent = agent_12.Actor.agentOf(_actor);
    try {
      const tokenRegistry = new registries_1.TokenRegistry(agent);
      const token2 = yield tokenRegistry.get(agent_12.Actor.canisterIdOf(_actor).toString());
      const { fee = 2e-3, decimals = 8 } = (token2 === null || token2 === void 0 ? void 0 : token2.details) || {};
      const numberFee = Number((_a = fee === null || fee === void 0 ? void 0 : fee.toString) === null || _a === void 0 ? void 0 : _a.call(fee));
      const numberDecimals = Number((_b = decimals === null || decimals === void 0 ? void 0 : decimals.toString) === null || _b === void 0 ? void 0 : _b.call(decimals));
      const parsedFee = numberFee * Math.pow(10, numberDecimals);
      return {
        fungible: {
          symbol: ((_c = token2 === null || token2 === void 0 ? void 0 : token2.details) === null || _c === void 0 ? void 0 : _c.symbol) || "ICP",
          name: (token2 === null || token2 === void 0 ? void 0 : token2.name) || "ICP",
          decimals: numberDecimals,
          fee: parsedFee
        }
      };
    } catch (e2) {
      console.error("Error while fetching token metadata, falling back to default values", e2);
      return {
        fungible: {
          symbol: "ICP",
          name: "ICP",
          decimals: 8,
          fee: 1e4
        }
      };
    }
  });
  const send2 = (actor, { to, amount, opts }) => __awaiter2(void 0, void 0, void 0, function* () {
    const metadata = yield getMetadata2(actor);
    const { fee = 2e-3, decimals = BigInt(8) } = (metadata === null || metadata === void 0 ? void 0 : metadata.fungible) || {};
    const defaultArgs = {
      fee: BigInt(fee * Math.pow(10, parseInt(decimals.toString(), 10))),
      memo: BigInt(0)
    };
    const response = yield actor._send_dfx({
      to: (0, validations_12.validatePrincipalId)(to) ? (0, account_12.getAccountId)(principal_12.Principal.fromText(to)) : to,
      fee: { e8s: (opts === null || opts === void 0 ? void 0 : opts.fee) || defaultArgs.fee },
      amount: { e8s: amount },
      memo: (opts === null || opts === void 0 ? void 0 : opts.memo) ? BigInt(opts.memo) : defaultArgs.memo,
      from_subaccount: [],
      created_at_time: []
    });
    return { height: yield response.toString() };
  });
  const getBalance2 = (actor, user) => __awaiter2(void 0, void 0, void 0, function* () {
    try {
      const account2 = (0, account_12.getAccountId)(user);
      const balance = yield actor._account_balance_dfx({ account: account2 });
      return { value: balance.e8s.toString(), decimals: 8 };
    } catch (e2) {
      return {
        value: "Error",
        decimals: 8,
        error: "Error while fetching your balance"
      };
    }
  });
  const burnXTC2 = (_actor, _params) => __awaiter2(void 0, void 0, void 0, function* () {
    throw new Error("BURN NOT SUPPORTED");
  });
  const getDecimals2 = (actor) => __awaiter2(void 0, void 0, void 0, function* () {
    return (0, methods_12.getDecimalsFromMetadata)(yield getMetadata2(actor));
  });
  icpStandardMethods.default = {
    send: send2,
    getMetadata: getMetadata2,
    getBalance: getBalance2,
    burnXTC: burnXTC2,
    getDecimals: getDecimals2
  };
  return icpStandardMethods;
}
var hasRequiredToken_standards;
function requireToken_standards() {
  if (hasRequiredToken_standards)
    return token_standards;
  hasRequiredToken_standards = 1;
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value2) {
      return value2 instanceof P2 ? value2 : new P2(function(resolve) {
        resolve(value2);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(token_standards, "__esModule", { value: true });
  token_standards.parseBalance = token_standards.createTokenActor = void 0;
  const actorFactory_1 = actorFactory;
  const methods_12 = __importDefault2(methods);
  const xtcMethods_1 = __importDefault2(xtcMethods);
  const extMethods_1 = __importDefault2(extMethods);
  const dip20Methods_1 = __importDefault2(dip20Methods);
  const ext_did_12 = __importDefault2(ext_did);
  const xtc_did_1 = __importDefault2(xtc_did);
  const dip_20_did_1 = __importDefault2(dip_20_did);
  const ledger_did_1 = __importDefault2(ledger_did);
  const standards_12 = standards;
  const wicp_did_1 = __importDefault2(wicp_did);
  const wicpMethods_1 = __importDefault2(wicpMethods);
  const rosettaMethods_1 = __importDefault2(rosettaMethods);
  const icpStandardMethods_1 = __importDefault2(requireIcpStandardMethods());
  const getMethods = (standard) => ({
    [standards_12.TOKEN.xtc]: xtcMethods_1.default,
    [standards_12.TOKEN.ext]: extMethods_1.default,
    [standards_12.TOKEN.dip20]: dip20Methods_1.default,
    [standards_12.TOKEN.wicp]: wicpMethods_1.default,
    [standards_12.TOKEN.rosetta]: rosettaMethods_1.default,
    [standards_12.TOKEN.icp]: icpStandardMethods_1.default
  })[standard] || methods_12.default;
  const getIdl = (standard) => {
    const idl = {
      [standards_12.TOKEN.xtc]: xtc_did_1.default,
      [standards_12.TOKEN.ext]: ext_did_12.default,
      [standards_12.TOKEN.dip20]: dip_20_did_1.default,
      [standards_12.TOKEN.wicp]: wicp_did_1.default,
      [standards_12.TOKEN.rosetta]: ledger_did_1.default,
      [standards_12.TOKEN.icp]: ledger_did_1.default
    }[standard];
    if (!idl)
      throw new Error(`Standard ${standard} Not Implemented`);
    return idl;
  };
  const createTokenActor = (canisterId, agent, standard) => __awaiter2(void 0, void 0, void 0, function* () {
    const idl = getIdl(standard);
    const actor = new ((0, actorFactory_1.createExtendedActorClass)(agent, getMethods(standard), canisterId, idl))();
    return actor;
  });
  token_standards.createTokenActor = createTokenActor;
  const parseBalance = (balance) => {
    return (parseInt(balance.value, 10) / Math.pow(10, balance.decimals)).toString();
  };
  token_standards.parseBalance = parseBalance;
  token_standards.default = {};
  return token_standards;
}
var hasRequiredToken_registry;
function requireToken_registry() {
  if (hasRequiredToken_registry)
    return token_registry;
  hasRequiredToken_registry = 1;
  (function(exports2) {
    var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value2) {
        return value2 instanceof P2 ? value2 : new P2(function(resolve) {
          resolve(value2);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value2) {
          try {
            step(generator.next(value2));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value2) {
          try {
            step(generator["throw"](value2));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getTokens = exports2.TokenRegistry = exports2.getTokenActor = exports2.TOKEN_STANDARDS = void 0;
    const agent_12 = require$$5;
    const cross_fetch_12 = __importDefault2(browserPonyfill.exports);
    const token_registry_did_1 = __importDefault2(token_registry_did);
    const standard_registry_1 = __importDefault2(standard_registry);
    const actorFactory_1 = actorFactory;
    const registry_12 = registry;
    const constants_12 = constants;
    const token_standards_1 = requireToken_standards();
    const standards_12 = standards;
    const CANISTER_ID = "b7hhy-tyaaa-aaaah-abbja-cai";
    const DEFAULT_AGENT2 = new agent_12.HttpAgent({ fetch: cross_fetch_12.default, host: constants_12.IC_HOST });
    exports2.TOKEN_STANDARDS = Object.values(standards_12.TOKEN);
    const getTokenActor = ({ canisterId, agent, standard }) => {
      if (!exports2.TOKEN_STANDARDS.includes(standard)) {
        console.error(`Standard ${standard} is not implemented`);
        throw new Error(`standard is not supported: ${standard}`);
      }
      return (0, token_standards_1.createTokenActor)(canisterId, agent, standard);
    };
    exports2.getTokenActor = getTokenActor;
    class TokenRegistry extends standard_registry_1.default {
      constructor(agent) {
        super(CANISTER_ID, agent);
        this.getAll = () => __awaiter2(this, void 0, void 0, function* () {
          const tokenCanistersMetadata = yield this.actor.get_all();
          return tokenCanistersMetadata.map(registry_12.formatMetadata);
        });
        this.actor = (0, actorFactory_1.generateActor)({
          agent: agent || DEFAULT_AGENT2,
          canisterId: CANISTER_ID,
          IDL: token_registry_did_1.default
        });
      }
    }
    exports2.TokenRegistry = TokenRegistry;
    const getTokens = ({ agent = DEFAULT_AGENT2 } = {}) => __awaiter2(void 0, void 0, void 0, function* () {
      const tokenRegistry = new TokenRegistry(agent);
      const tokenCanisters = yield tokenRegistry.getAll();
      return tokenCanisters.map((token2) => Object.assign(Object.assign({}, token2), { logo: token2.thumbnail, name: token2.name, description: token2.description, website: token2.frontend.length ? token2.frontend[0] : "", principal_id: token2.principal_id, standard: token2.details.standard, total_supply: [token2.details.total_supply], symbol: token2.details.symbol }));
    });
    exports2.getTokens = getTokens;
    exports2.default = {
      getTokenActor: exports2.getTokenActor,
      getTokens: exports2.getTokens,
      addToken: ({ agent, tokenInfo }) => __awaiter2(void 0, void 0, void 0, function* () {
        return new TokenRegistry(agent).add(tokenInfo);
      }),
      removeToken: ({ agent, canisterId }) => __awaiter2(void 0, void 0, void 0, function* () {
        return new TokenRegistry(agent).remove(canisterId);
      })
    };
  })(token_registry);
  return token_registry;
}
var address_book = {};
var address_book_did = {};
Object.defineProperty(address_book_did, "__esModule", { value: true });
const addressBookIDL = ({ IDL: IDL2 }) => {
  const valueType = IDL2.Variant({
    "PrincipalId": IDL2.Principal,
    "AccountId": IDL2.Text,
    "Icns": IDL2.Text
  });
  const address = IDL2.Record({
    "name": IDL2.Text,
    "description": IDL2.Opt(IDL2.Text),
    "emoji": IDL2.Opt(IDL2.Text),
    "value": valueType
  });
  const operation_error = IDL2.Variant({
    "NotAuthorized": IDL2.Null,
    "BadParameters": IDL2.Null,
    "Unknown": IDL2.Text,
    "NonExistentItem": IDL2.Null
  });
  const operation_response = IDL2.Variant({
    "Ok": IDL2.Null,
    "Err": operation_error
  });
  return IDL2.Service({
    "add": IDL2.Func([address], [operation_response], []),
    "get_all": IDL2.Func([], [IDL2.Vec(address)], []),
    "name": IDL2.Func([], [IDL2.Text], ["query"]),
    "remove": IDL2.Func([IDL2.Text], [operation_response], [])
  });
};
address_book_did.default = addressBookIDL;
(function(exports2) {
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value2) {
      return value2 instanceof P2 ? value2 : new P2(function(resolve) {
        resolve(value2);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.removeAddress = exports2.addAddress = exports2.getAddresses = exports2.getAddressBookActor = void 0;
  const agent_12 = require$$5;
  const address_book_did_1 = __importDefault2(address_book_did);
  const CANISTER_ID = "i73cm-daaaa-aaaah-abhea-cai";
  const getAddressBookActor = (agent) => {
    const actor = agent_12.Actor.createActor(address_book_did_1.default, { agent, canisterId: CANISTER_ID });
    return actor;
  };
  exports2.getAddressBookActor = getAddressBookActor;
  const getAddresses = (agent) => __awaiter2(void 0, void 0, void 0, function* () {
    const actor = (0, exports2.getAddressBookActor)(agent);
    const addresses = yield actor.get_all();
    return addresses.map((address) => ({
      name: address.name,
      description: address.description,
      emoji: address.emoji,
      value: address.value
    }));
  });
  exports2.getAddresses = getAddresses;
  const addAddress = (agent, newAddress) => __awaiter2(void 0, void 0, void 0, function* () {
    const actor = (0, exports2.getAddressBookActor)(agent);
    const addResponse = yield actor.add({
      name: newAddress.name,
      description: newAddress.description,
      emoji: newAddress.emoji,
      value: newAddress.value
    });
    return addResponse;
  });
  exports2.addAddress = addAddress;
  const removeAddress = (agent, addressName) => __awaiter2(void 0, void 0, void 0, function* () {
    const actor = (0, exports2.getAddressBookActor)(agent);
    const removeResponse = yield actor.remove(addressName);
    return removeResponse;
  });
  exports2.removeAddress = removeAddress;
  exports2.default = {
    getAddressBookActor: exports2.getAddressBookActor,
    getAddresses: exports2.getAddresses,
    addAddress: exports2.addAddress,
    removeAddress: exports2.removeAddress
  };
})(address_book);
var hasRequiredRegistries;
function requireRegistries() {
  if (hasRequiredRegistries)
    return registries;
  hasRequiredRegistries = 1;
  (function(exports2) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m2[k2];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
          __createBinding(exports3, m2, p2);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(nfts_registry, exports2);
    __exportStar(canister_registry, exports2);
    __exportStar(requireToken_registry(), exports2);
    __exportStar(address_book, exports2);
  })(registries);
  return registries;
}
var nft = {};
Object.defineProperty(nft, "__esModule", { value: true });
var token = {};
Object.defineProperty(token, "__esModule", { value: true });
(function(exports2) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o[k22] = m2[k2];
  });
  var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v2) {
    Object.defineProperty(o, "default", { enumerable: true, value: v2 });
  } : function(o, v2) {
    o["default"] = v2;
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding(exports3, m2, p2);
  };
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.HttpAgent = exports2.Principal = exports2.standards = exports2.TokenInterfaces = exports2.NFTInterfaces = void 0;
  __exportStar(requireRegistries(), exports2);
  __exportStar(nft, exports2);
  __exportStar(token, exports2);
  exports2.NFTInterfaces = __importStar2(nft);
  exports2.TokenInterfaces = __importStar2(token);
  var standards_12 = standards;
  Object.defineProperty(exports2, "standards", { enumerable: true, get: function() {
    return __importDefault2(standards_12).default;
  } });
  var principal_12 = require$$4;
  Object.defineProperty(exports2, "Principal", { enumerable: true, get: function() {
    return principal_12.Principal;
  } });
  var agent_12 = require$$5;
  Object.defineProperty(exports2, "HttpAgent", { enumerable: true, get: function() {
    return agent_12.HttpAgent;
  } });
})(dist);
const clone = (obj) => {
  const cloneObj = structuredClone(obj);
  return cloneObj;
};
const getRemoteBoxes = (remoteItems) => {
  const remoteBoxes = [...Array(tradeBoxNum).keys()].map((i2) => {
    var _a;
    return {
      id: i2,
      item: (_a = remoteItems.find((item) => item.slot === i2)) != null ? _a : null
    };
  });
  return remoteBoxes;
};
const getInventoryBoxes = (inventoryItems) => {
  const inventoryBoxes = [...Array(inventoryBoxNum).keys()].map((i2) => {
    var _a;
    return {
      id: i2,
      item: (_a = inventoryItems.find((item) => item.slot === i2)) != null ? _a : null
    };
  });
  return inventoryBoxes;
};
const getUserTokens = async ({
  agent,
  user
}) => {
  let collections;
  try {
    collections = await dist.getAllUserNFTs({
      agent,
      user
    });
  } catch (e2) {
    console.log(e2);
  }
  console.log("collections: ", collections);
  const newTokens = {};
  let slot = 0;
  collections.forEach((collection) => {
    if (!collection.name.toLowerCase().includes("cipher")) {
      collection.tokens.forEach((token2) => {
        var _a, _b;
        let newToken = {
          id: slot.toString(),
          canister_id: token2.canister,
          collection: token2.collection,
          index: token2.index.toString(),
          slot
        };
        const jsonMetadata = (_b = (_a = token2.metadata) == null ? void 0 : _a.json) == null ? void 0 : _b.value.TextContent;
        token2.url.match(/\.(jpeg|jpg|gif|png)$/) != null;
        if (jsonMetadata) {
          const parseMetadata = JSON.parse(jsonMetadata);
          newToken.name = parseMetadata.name;
          newToken.url = collection.icon;
        } else {
          newToken.name = token2.collection;
          newToken.url = collection.icon;
        }
        newTokens[slot] = newToken;
        slot++;
      });
    }
  });
  console.log("newTokens: ", newTokens);
  return newTokens;
};
const getExtension = (url2) => {
  const extension = url2.split(".").pop().toLowerCase();
  return extension;
};
const isImage = (url2) => {
  if (!url2)
    return false;
  const imageExtensions = ["apng", "avif", "gif", "jpg", "jpeg", "jfif", "pjpeg", "pjp", "png", "svg", "webp", "bmp", "ico", "cur", "tif", "tiff"];
  const extension = getExtension(url2);
  const flag = imageExtensions.indexOf(extension) >= 0;
  return flag;
};
const isMedia = (url2) => {
  if (!url2)
    return false;
  const mediaExtensions = ["mp4", "mov", "wav", "mp3", "ogg", "webm", "avi"];
  const extension = getExtension(url2);
  const flag = mediaExtensions.indexOf(extension) >= 0;
  return flag;
};
const isModel = (url2) => {
  if (!url2)
    return false;
  const modelExtensions = ["glb"];
  const extension = getExtension(url2);
  const flag = modelExtensions.indexOf(extension) >= 0;
  return flag;
};
const existItems = (boxes) => {
  if (!boxes || !boxes.length)
    return false;
  const flag = !!boxes.filter((box) => {
    var _a;
    return (_a = box == null ? void 0 : box.item) == null ? void 0 : _a.canister_id;
  }).length;
  return flag;
};
const createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace2) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace2 != null ? replace2 : typeof nextState !== "object") ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => listeners.clear();
  const api = { setState, getState, subscribe, destroy };
  state = createState(setState, getState, api);
  return api;
};
const createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;
var withSelector = { exports: {} };
var withSelector_production_min = {};
var shim = { exports: {} };
var useSyncExternalStoreShim_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var e$1 = react.exports;
function h$2(a, b2) {
  return a === b2 && (0 !== a || 1 / a === 1 / b2) || a !== a && b2 !== b2;
}
var k$1 = "function" === typeof Object.is ? Object.is : h$2, l$1 = e$1.useState, m$1 = e$1.useEffect, n$2 = e$1.useLayoutEffect, p$2 = e$1.useDebugValue;
function q$2(a, b2) {
  var d2 = b2(), f2 = l$1({ inst: { value: d2, getSnapshot: b2 } }), c2 = f2[0].inst, g2 = f2[1];
  n$2(function() {
    c2.value = d2;
    c2.getSnapshot = b2;
    r$2(c2) && g2({ inst: c2 });
  }, [a, d2, b2]);
  m$1(function() {
    r$2(c2) && g2({ inst: c2 });
    return a(function() {
      r$2(c2) && g2({ inst: c2 });
    });
  }, [a]);
  p$2(d2);
  return d2;
}
function r$2(a) {
  var b2 = a.getSnapshot;
  a = a.value;
  try {
    var d2 = b2();
    return !k$1(a, d2);
  } catch (f2) {
    return true;
  }
}
function t$2(a, b2) {
  return b2();
}
var u$1 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t$2 : q$2;
useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e$1.useSyncExternalStore ? e$1.useSyncExternalStore : u$1;
(function(module2) {
  {
    module2.exports = useSyncExternalStoreShim_production_min;
  }
})(shim);
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var h$1 = react.exports, n$1 = shim.exports;
function p$1(a, b2) {
  return a === b2 && (0 !== a || 1 / a === 1 / b2) || a !== a && b2 !== b2;
}
var q$1 = "function" === typeof Object.is ? Object.is : p$1, r$1 = n$1.useSyncExternalStore, t$1 = h$1.useRef, u = h$1.useEffect, v$1 = h$1.useMemo, w$1 = h$1.useDebugValue;
withSelector_production_min.useSyncExternalStoreWithSelector = function(a, b2, e2, l2, g2) {
  var c2 = t$1(null);
  if (null === c2.current) {
    var f2 = { hasValue: false, value: null };
    c2.current = f2;
  } else
    f2 = c2.current;
  c2 = v$1(function() {
    function a2(a3) {
      if (!c3) {
        c3 = true;
        d3 = a3;
        a3 = l2(a3);
        if (void 0 !== g2 && f2.hasValue) {
          var b3 = f2.value;
          if (g2(b3, a3))
            return k2 = b3;
        }
        return k2 = a3;
      }
      b3 = k2;
      if (q$1(d3, a3))
        return b3;
      var e3 = l2(a3);
      if (void 0 !== g2 && g2(b3, e3))
        return b3;
      d3 = a3;
      return k2 = e3;
    }
    var c3 = false, d3, k2, m2 = void 0 === e2 ? null : e2;
    return [function() {
      return a2(b2());
    }, null === m2 ? void 0 : function() {
      return a2(m2());
    }];
  }, [b2, e2, l2, g2]);
  var d2 = r$1(a, c2[0], c2[1]);
  u(function() {
    f2.hasValue = true;
    f2.value = d2;
  }, [d2]);
  w$1(d2);
  return d2;
};
(function(module2) {
  {
    module2.exports = withSelector_production_min;
  }
})(withSelector);
const useSyncExternalStoreExports = /* @__PURE__ */ getDefaultExportFromCjs(withSelector.exports);
const { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports;
function useStore$1(api, selector = api.getState, equalityFn) {
  const slice2 = useSyncExternalStoreWithSelector(
    api.subscribe,
    api.getState,
    api.getServerState || api.getState,
    selector,
    equalityFn
  );
  react.exports.useDebugValue(slice2);
  return slice2;
}
const createImpl = (createState) => {
  const api = typeof createState === "function" ? createStore(createState) : createState;
  const useBoundStore = (selector, equalityFn) => useStore$1(api, selector, equalityFn);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
const create = (createState) => createState ? createImpl(createState) : createImpl;
const initRemoteBoxes = [...Array(tradeBoxNum).keys()].map((i2) => {
  return {
    id: i2,
    item: null
  };
});
const initLocalBoxes = [...Array(tradeBoxNum).keys()].map((i2) => {
  return {
    id: i2,
    item: null
  };
});
const initInventoryBoxes = [...Array(inventoryBoxNum).keys()].map((i2) => {
  return {
    id: i2,
    type: "all",
    item: null
  };
});
const useStore = create((set) => ({
  plugActor: null,
  setPlugActor: (newVal) => set((state) => ({
    plugActor: newVal
  })),
  isCreator: false,
  setIsCreator: (newVal) => set((state) => ({
    isCreator: newVal
  })),
  localUser: null,
  setLocalUser: (newVal) => set((state) => ({
    localUser: newVal
  })),
  curTradeId: null,
  setCurTradeId: (newVal) => set((state) => ({
    curTradeId: newVal
  })),
  tradeData: null,
  setTradeData: (newVal) => set((state) => ({
    tradeData: newVal
  })),
  tradeStarted: false,
  setTradeStarted: (newVal) => set((state) => ({
    tradeStarted: newVal
  })),
  remoteBoxes: clone(initRemoteBoxes),
  setRemoteBoxes: (newVal) => set((state) => ({
    remoteBoxes: newVal
  })),
  localBoxes: clone(initLocalBoxes),
  setLocalBoxes: (newVal) => set((state) => ({
    localBoxes: newVal
  })),
  inventoryBoxes: initInventoryBoxes,
  setInventoryBoxes: (newVal) => set((state) => ({
    inventoryBoxes: newVal
  })),
  accepted: false,
  setAccepted: (newVal) => set((state) => ({
    accepted: newVal
  })),
  boxNumPerPage: pageBoxNum,
  setBoxNumPerPage: (newVal) => set((state) => ({
    boxNumPerPage: newVal
  })),
  curPage: 1,
  setCurPage: (newVal) => set((state) => ({
    curPage: newVal
  })),
  selItem: null,
  setSelItem: (newVal) => set((state) => ({
    selItem: newVal
  })),
  loading: false,
  setLoading: (newVal) => set((state) => ({
    loading: newVal
  })),
  authenticated: false,
  setAuthenticated: (newVal) => set((state) => ({
    authenticated: newVal
  })),
  principal: null,
  setPrincipal: (newVal) => set((state) => ({
    principal: newVal
  }))
}));
var ReplicaRejectCode;
(function(ReplicaRejectCode2) {
  ReplicaRejectCode2[ReplicaRejectCode2["SysFatal"] = 1] = "SysFatal";
  ReplicaRejectCode2[ReplicaRejectCode2["SysTransient"] = 2] = "SysTransient";
  ReplicaRejectCode2[ReplicaRejectCode2["DestinationInvalid"] = 3] = "DestinationInvalid";
  ReplicaRejectCode2[ReplicaRejectCode2["CanisterReject"] = 4] = "CanisterReject";
  ReplicaRejectCode2[ReplicaRejectCode2["CanisterError"] = 5] = "CanisterError";
})(ReplicaRejectCode || (ReplicaRejectCode = {}));
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  const links = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep) => {
    dep = assetsURL(dep);
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    const isBaseRelative = !!importerUrl;
    if (isBaseRelative) {
      for (let i2 = links.length - 1; i2 >= 0; i2--) {
        const link2 = links[i2];
        if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
          return;
        }
      }
    } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule());
};
class AgentError extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    Object.setPrototypeOf(this, AgentError.prototype);
  }
}
function concat$1(...buffers) {
  const result = new Uint8Array(buffers.reduce((acc, curr) => acc + curr.byteLength, 0));
  let index2 = 0;
  for (const b2 of buffers) {
    result.set(new Uint8Array(b2), index2);
    index2 += b2.byteLength;
  }
  return result;
}
class PipeArrayBuffer {
  constructor(buffer2, length2 = (buffer2 === null || buffer2 === void 0 ? void 0 : buffer2.byteLength) || 0) {
    this._buffer = buffer2 || new ArrayBuffer(0);
    this._view = new Uint8Array(this._buffer, 0, length2);
  }
  get buffer() {
    return this._view.slice();
  }
  get byteLength() {
    return this._view.byteLength;
  }
  read(num) {
    const result = this._view.subarray(0, num);
    this._view = this._view.subarray(num);
    return result.slice().buffer;
  }
  readUint8() {
    const result = this._view[0];
    this._view = this._view.subarray(1);
    return result;
  }
  write(buf) {
    const b2 = new Uint8Array(buf);
    const offset = this._view.byteLength;
    if (this._view.byteOffset + this._view.byteLength + b2.byteLength >= this._buffer.byteLength) {
      this.alloc(b2.byteLength);
    } else {
      this._view = new Uint8Array(this._buffer, this._view.byteOffset, this._view.byteLength + b2.byteLength);
    }
    this._view.set(b2, offset);
  }
  get end() {
    return this._view.byteLength === 0;
  }
  alloc(amount) {
    const b2 = new ArrayBuffer((this._buffer.byteLength + amount) * 1.2 | 0);
    const v2 = new Uint8Array(b2, 0, this._view.byteLength + amount);
    v2.set(this._view);
    this._buffer = b2;
    this._view = v2;
  }
}
function idlHash(s) {
  const utf8encoder = new TextEncoder();
  const array2 = utf8encoder.encode(s);
  let h2 = 0;
  for (const c2 of array2) {
    h2 = (h2 * 223 + c2) % 2 ** 32;
  }
  return h2;
}
function idlLabelToId(label) {
  if (/^_\d+_$/.test(label) || /^_0x[0-9a-fA-F]+_$/.test(label)) {
    const num = +label.slice(1, -1);
    if (Number.isSafeInteger(num) && num >= 0 && num < 2 ** 32) {
      return num;
    }
  }
  return idlHash(label);
}
function eob() {
  throw new Error("unexpected end of buffer");
}
function safeRead(pipe, num) {
  if (pipe.byteLength < num) {
    eob();
  }
  return pipe.read(num);
}
function safeReadUint8(pipe) {
  const byte = pipe.readUint8();
  if (byte === void 0) {
    eob();
  }
  return byte;
}
function lebEncode(value2) {
  if (typeof value2 === "number") {
    value2 = BigInt(value2);
  }
  if (value2 < BigInt(0)) {
    throw new Error("Cannot leb encode negative values.");
  }
  const byteLength2 = (value2 === BigInt(0) ? 0 : Math.ceil(Math.log2(Number(value2)))) + 1;
  const pipe = new PipeArrayBuffer(new ArrayBuffer(byteLength2), 0);
  while (true) {
    const i2 = Number(value2 & BigInt(127));
    value2 /= BigInt(128);
    if (value2 === BigInt(0)) {
      pipe.write(new Uint8Array([i2]));
      break;
    } else {
      pipe.write(new Uint8Array([i2 | 128]));
    }
  }
  return pipe.buffer;
}
function lebDecode(pipe) {
  let weight = BigInt(1);
  let value2 = BigInt(0);
  let byte;
  do {
    byte = safeReadUint8(pipe);
    value2 += BigInt(byte & 127).valueOf() * weight;
    weight *= BigInt(128);
  } while (byte >= 128);
  return value2;
}
function slebEncode(value2) {
  if (typeof value2 === "number") {
    value2 = BigInt(value2);
  }
  const isNeg = value2 < BigInt(0);
  if (isNeg) {
    value2 = -value2 - BigInt(1);
  }
  const byteLength2 = (value2 === BigInt(0) ? 0 : Math.ceil(Math.log2(Number(value2)))) + 1;
  const pipe = new PipeArrayBuffer(new ArrayBuffer(byteLength2), 0);
  while (true) {
    const i2 = getLowerBytes(value2);
    value2 /= BigInt(128);
    if (isNeg && value2 === BigInt(0) && (i2 & 64) !== 0 || !isNeg && value2 === BigInt(0) && (i2 & 64) === 0) {
      pipe.write(new Uint8Array([i2]));
      break;
    } else {
      pipe.write(new Uint8Array([i2 | 128]));
    }
  }
  function getLowerBytes(num) {
    const bytes2 = num % BigInt(128);
    if (isNeg) {
      return Number(BigInt(128) - bytes2 - BigInt(1));
    } else {
      return Number(bytes2);
    }
  }
  return pipe.buffer;
}
function slebDecode(pipe) {
  const pipeView = new Uint8Array(pipe.buffer);
  let len2 = 0;
  for (; len2 < pipeView.byteLength; len2++) {
    if (pipeView[len2] < 128) {
      if ((pipeView[len2] & 64) === 0) {
        return lebDecode(pipe);
      }
      break;
    }
  }
  const bytes2 = new Uint8Array(safeRead(pipe, len2 + 1));
  let value2 = BigInt(0);
  for (let i2 = bytes2.byteLength - 1; i2 >= 0; i2--) {
    value2 = value2 * BigInt(128) + BigInt(128 - (bytes2[i2] & 127) - 1);
  }
  return -value2 - BigInt(1);
}
function writeUIntLE(value2, byteLength2) {
  if (BigInt(value2) < BigInt(0)) {
    throw new Error("Cannot write negative values.");
  }
  return writeIntLE(value2, byteLength2);
}
function writeIntLE(value2, byteLength2) {
  value2 = BigInt(value2);
  const pipe = new PipeArrayBuffer(new ArrayBuffer(Math.min(1, byteLength2)), 0);
  let i2 = 0;
  let mul = BigInt(256);
  let sub = BigInt(0);
  let byte = Number(value2 % mul);
  pipe.write(new Uint8Array([byte]));
  while (++i2 < byteLength2) {
    if (value2 < 0 && sub === BigInt(0) && byte !== 0) {
      sub = BigInt(1);
    }
    byte = Number((value2 / mul - sub) % BigInt(256));
    pipe.write(new Uint8Array([byte]));
    mul *= BigInt(256);
  }
  return pipe.buffer;
}
function readUIntLE(pipe, byteLength2) {
  let val = BigInt(safeReadUint8(pipe));
  let mul = BigInt(1);
  let i2 = 0;
  while (++i2 < byteLength2) {
    mul *= BigInt(256);
    const byte = BigInt(safeReadUint8(pipe));
    val = val + mul * byte;
  }
  return val;
}
function readIntLE(pipe, byteLength2) {
  let val = readUIntLE(pipe, byteLength2);
  const mul = BigInt(2) ** (BigInt(8) * BigInt(byteLength2 - 1) + BigInt(7));
  if (val >= mul) {
    val -= mul * BigInt(2);
  }
  return val;
}
function iexp2(n2) {
  const nBig = BigInt(n2);
  if (n2 < 0) {
    throw new RangeError("Input must be non-negative");
  }
  return BigInt(1) << nBig;
}
const magicNumber = "DIDL";
const toReadableString_max = 400;
function zipWith(xs, ys, f2) {
  return xs.map((x2, i2) => f2(x2, ys[i2]));
}
class TypeTable {
  constructor() {
    this._typs = [];
    this._idx = /* @__PURE__ */ new Map();
  }
  has(obj) {
    return this._idx.has(obj.name);
  }
  add(type, buf) {
    const idx = this._typs.length;
    this._idx.set(type.name, idx);
    this._typs.push(buf);
  }
  merge(obj, knot) {
    const idx = this._idx.get(obj.name);
    const knotIdx = this._idx.get(knot);
    if (idx === void 0) {
      throw new Error("Missing type index for " + obj);
    }
    if (knotIdx === void 0) {
      throw new Error("Missing type index for " + knot);
    }
    this._typs[idx] = this._typs[knotIdx];
    this._typs.splice(knotIdx, 1);
    this._idx.delete(knot);
  }
  encode() {
    const len2 = lebEncode(this._typs.length);
    const buf = concat$1(...this._typs);
    return concat$1(len2, buf);
  }
  indexOf(typeName) {
    if (!this._idx.has(typeName)) {
      throw new Error("Missing type index for " + typeName);
    }
    return slebEncode(this._idx.get(typeName) || 0);
  }
}
class Visitor {
  visitType(t2, data2) {
    throw new Error("Not implemented");
  }
  visitPrimitive(t2, data2) {
    return this.visitType(t2, data2);
  }
  visitEmpty(t2, data2) {
    return this.visitPrimitive(t2, data2);
  }
  visitBool(t2, data2) {
    return this.visitPrimitive(t2, data2);
  }
  visitNull(t2, data2) {
    return this.visitPrimitive(t2, data2);
  }
  visitReserved(t2, data2) {
    return this.visitPrimitive(t2, data2);
  }
  visitText(t2, data2) {
    return this.visitPrimitive(t2, data2);
  }
  visitNumber(t2, data2) {
    return this.visitPrimitive(t2, data2);
  }
  visitInt(t2, data2) {
    return this.visitNumber(t2, data2);
  }
  visitNat(t2, data2) {
    return this.visitNumber(t2, data2);
  }
  visitFloat(t2, data2) {
    return this.visitPrimitive(t2, data2);
  }
  visitFixedInt(t2, data2) {
    return this.visitNumber(t2, data2);
  }
  visitFixedNat(t2, data2) {
    return this.visitNumber(t2, data2);
  }
  visitPrincipal(t2, data2) {
    return this.visitPrimitive(t2, data2);
  }
  visitConstruct(t2, data2) {
    return this.visitType(t2, data2);
  }
  visitVec(t2, ty, data2) {
    return this.visitConstruct(t2, data2);
  }
  visitOpt(t2, ty, data2) {
    return this.visitConstruct(t2, data2);
  }
  visitRecord(t2, fields, data2) {
    return this.visitConstruct(t2, data2);
  }
  visitTuple(t2, components, data2) {
    const fields = components.map((ty, i2) => [`_${i2}_`, ty]);
    return this.visitRecord(t2, fields, data2);
  }
  visitVariant(t2, fields, data2) {
    return this.visitConstruct(t2, data2);
  }
  visitRec(t2, ty, data2) {
    return this.visitConstruct(ty, data2);
  }
  visitFunc(t2, data2) {
    return this.visitConstruct(t2, data2);
  }
  visitService(t2, data2) {
    return this.visitConstruct(t2, data2);
  }
}
class Type {
  display() {
    return this.name;
  }
  valueToString(x2) {
    return toReadableString(x2);
  }
  buildTypeTable(typeTable) {
    if (!typeTable.has(this)) {
      this._buildTypeTableImpl(typeTable);
    }
  }
}
class PrimitiveType extends Type {
  checkType(t2) {
    if (this.name !== t2.name) {
      throw new Error(`type mismatch: type on the wire ${t2.name}, expect type ${this.name}`);
    }
    return t2;
  }
  _buildTypeTableImpl(typeTable) {
    return;
  }
}
class ConstructType extends Type {
  checkType(t2) {
    if (t2 instanceof RecClass) {
      const ty = t2.getType();
      if (typeof ty === "undefined") {
        throw new Error("type mismatch with uninitialized type");
      }
      return ty;
    }
    throw new Error(`type mismatch: type on the wire ${t2.name}, expect type ${this.name}`);
  }
  encodeType(typeTable) {
    return typeTable.indexOf(this.name);
  }
}
class EmptyClass extends PrimitiveType {
  accept(v2, d2) {
    return v2.visitEmpty(this, d2);
  }
  covariant(x2) {
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x2)}`);
  }
  encodeValue() {
    throw new Error("Empty cannot appear as a function argument");
  }
  valueToString() {
    throw new Error("Empty cannot appear as a value");
  }
  encodeType() {
    return slebEncode(-17);
  }
  decodeValue() {
    throw new Error("Empty cannot appear as an output");
  }
  get name() {
    return "empty";
  }
}
class UnknownClass extends Type {
  checkType(t2) {
    throw new Error("Method not implemented for unknown.");
  }
  accept(v2, d2) {
    throw v2.visitType(this, d2);
  }
  covariant(x2) {
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x2)}`);
  }
  encodeValue() {
    throw new Error("Unknown cannot appear as a function argument");
  }
  valueToString() {
    throw new Error("Unknown cannot appear as a value");
  }
  encodeType() {
    throw new Error("Unknown cannot be serialized");
  }
  decodeValue(b2, t2) {
    let decodedValue = t2.decodeValue(b2, t2);
    if (Object(decodedValue) !== decodedValue) {
      decodedValue = Object(decodedValue);
    }
    let typeFunc;
    if (t2 instanceof RecClass) {
      typeFunc = () => t2.getType();
    } else {
      typeFunc = () => t2;
    }
    Object.defineProperty(decodedValue, "type", {
      value: typeFunc,
      writable: true,
      enumerable: false,
      configurable: true
    });
    return decodedValue;
  }
  _buildTypeTableImpl() {
    throw new Error("Unknown cannot be serialized");
  }
  get name() {
    return "Unknown";
  }
}
class BoolClass extends PrimitiveType {
  accept(v2, d2) {
    return v2.visitBool(this, d2);
  }
  covariant(x2) {
    if (typeof x2 === "boolean")
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x2)}`);
  }
  encodeValue(x2) {
    return new Uint8Array([x2 ? 1 : 0]);
  }
  encodeType() {
    return slebEncode(-2);
  }
  decodeValue(b2, t2) {
    this.checkType(t2);
    switch (safeReadUint8(b2)) {
      case 0:
        return false;
      case 1:
        return true;
      default:
        throw new Error("Boolean value out of range");
    }
  }
  get name() {
    return "bool";
  }
}
class NullClass extends PrimitiveType {
  accept(v2, d2) {
    return v2.visitNull(this, d2);
  }
  covariant(x2) {
    if (x2 === null)
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x2)}`);
  }
  encodeValue() {
    return new ArrayBuffer(0);
  }
  encodeType() {
    return slebEncode(-1);
  }
  decodeValue(b2, t2) {
    this.checkType(t2);
    return null;
  }
  get name() {
    return "null";
  }
}
class ReservedClass extends PrimitiveType {
  accept(v2, d2) {
    return v2.visitReserved(this, d2);
  }
  covariant(x2) {
    return true;
  }
  encodeValue() {
    return new ArrayBuffer(0);
  }
  encodeType() {
    return slebEncode(-16);
  }
  decodeValue(b2, t2) {
    if (t2.name !== this.name) {
      t2.decodeValue(b2, t2);
    }
    return null;
  }
  get name() {
    return "reserved";
  }
}
class TextClass extends PrimitiveType {
  accept(v2, d2) {
    return v2.visitText(this, d2);
  }
  covariant(x2) {
    if (typeof x2 === "string")
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x2)}`);
  }
  encodeValue(x2) {
    const buf = new TextEncoder().encode(x2);
    const len2 = lebEncode(buf.byteLength);
    return concat$1(len2, buf);
  }
  encodeType() {
    return slebEncode(-15);
  }
  decodeValue(b2, t2) {
    this.checkType(t2);
    const len2 = lebDecode(b2);
    const buf = safeRead(b2, Number(len2));
    const decoder2 = new TextDecoder("utf8", { fatal: true });
    return decoder2.decode(buf);
  }
  get name() {
    return "text";
  }
  valueToString(x2) {
    return '"' + x2 + '"';
  }
}
class IntClass extends PrimitiveType {
  accept(v2, d2) {
    return v2.visitInt(this, d2);
  }
  covariant(x2) {
    if (typeof x2 === "bigint" || Number.isInteger(x2))
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x2)}`);
  }
  encodeValue(x2) {
    return slebEncode(x2);
  }
  encodeType() {
    return slebEncode(-4);
  }
  decodeValue(b2, t2) {
    this.checkType(t2);
    return slebDecode(b2);
  }
  get name() {
    return "int";
  }
  valueToString(x2) {
    return x2.toString();
  }
}
class NatClass extends PrimitiveType {
  accept(v2, d2) {
    return v2.visitNat(this, d2);
  }
  covariant(x2) {
    if (typeof x2 === "bigint" && x2 >= BigInt(0) || Number.isInteger(x2) && x2 >= 0)
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x2)}`);
  }
  encodeValue(x2) {
    return lebEncode(x2);
  }
  encodeType() {
    return slebEncode(-3);
  }
  decodeValue(b2, t2) {
    this.checkType(t2);
    return lebDecode(b2);
  }
  get name() {
    return "nat";
  }
  valueToString(x2) {
    return x2.toString();
  }
}
class FloatClass extends PrimitiveType {
  constructor(_bits) {
    super();
    this._bits = _bits;
    if (_bits !== 32 && _bits !== 64) {
      throw new Error("not a valid float type");
    }
  }
  accept(v2, d2) {
    return v2.visitFloat(this, d2);
  }
  covariant(x2) {
    if (typeof x2 === "number" || x2 instanceof Number)
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x2)}`);
  }
  encodeValue(x2) {
    const buf = new ArrayBuffer(this._bits / 8);
    const view = new DataView(buf);
    if (this._bits === 32) {
      view.setFloat32(0, x2, true);
    } else {
      view.setFloat64(0, x2, true);
    }
    return buf;
  }
  encodeType() {
    const opcode = this._bits === 32 ? -13 : -14;
    return slebEncode(opcode);
  }
  decodeValue(b2, t2) {
    this.checkType(t2);
    const bytes2 = safeRead(b2, this._bits / 8);
    const view = new DataView(bytes2);
    if (this._bits === 32) {
      return view.getFloat32(0, true);
    } else {
      return view.getFloat64(0, true);
    }
  }
  get name() {
    return "float" + this._bits;
  }
  valueToString(x2) {
    return x2.toString();
  }
}
class FixedIntClass extends PrimitiveType {
  constructor(_bits) {
    super();
    this._bits = _bits;
  }
  accept(v2, d2) {
    return v2.visitFixedInt(this, d2);
  }
  covariant(x2) {
    const min = iexp2(this._bits - 1) * BigInt(-1);
    const max = iexp2(this._bits - 1) - BigInt(1);
    let ok2 = false;
    if (typeof x2 === "bigint") {
      ok2 = x2 >= min && x2 <= max;
    } else if (Number.isInteger(x2)) {
      const v2 = BigInt(x2);
      ok2 = v2 >= min && v2 <= max;
    } else {
      ok2 = false;
    }
    if (ok2)
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x2)}`);
  }
  encodeValue(x2) {
    return writeIntLE(x2, this._bits / 8);
  }
  encodeType() {
    const offset = Math.log2(this._bits) - 3;
    return slebEncode(-9 - offset);
  }
  decodeValue(b2, t2) {
    this.checkType(t2);
    const num = readIntLE(b2, this._bits / 8);
    if (this._bits <= 32) {
      return Number(num);
    } else {
      return num;
    }
  }
  get name() {
    return `int${this._bits}`;
  }
  valueToString(x2) {
    return x2.toString();
  }
}
class FixedNatClass extends PrimitiveType {
  constructor(_bits) {
    super();
    this._bits = _bits;
  }
  accept(v2, d2) {
    return v2.visitFixedNat(this, d2);
  }
  covariant(x2) {
    const max = iexp2(this._bits);
    let ok2 = false;
    if (typeof x2 === "bigint" && x2 >= BigInt(0)) {
      ok2 = x2 < max;
    } else if (Number.isInteger(x2) && x2 >= 0) {
      const v2 = BigInt(x2);
      ok2 = v2 < max;
    } else {
      ok2 = false;
    }
    if (ok2)
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x2)}`);
  }
  encodeValue(x2) {
    return writeUIntLE(x2, this._bits / 8);
  }
  encodeType() {
    const offset = Math.log2(this._bits) - 3;
    return slebEncode(-5 - offset);
  }
  decodeValue(b2, t2) {
    this.checkType(t2);
    const num = readUIntLE(b2, this._bits / 8);
    if (this._bits <= 32) {
      return Number(num);
    } else {
      return num;
    }
  }
  get name() {
    return `nat${this._bits}`;
  }
  valueToString(x2) {
    return x2.toString();
  }
}
class VecClass extends ConstructType {
  constructor(_type) {
    super();
    this._type = _type;
    this._blobOptimization = false;
    if (_type instanceof FixedNatClass && _type._bits === 8) {
      this._blobOptimization = true;
    }
  }
  accept(v2, d2) {
    return v2.visitVec(this, this._type, d2);
  }
  covariant(x2) {
    const bits = this._type instanceof FixedNatClass ? this._type._bits : this._type instanceof FixedIntClass ? this._type._bits : 0;
    if (ArrayBuffer.isView(x2) && bits == x2.BYTES_PER_ELEMENT * 8 || Array.isArray(x2) && x2.every((v2, idx) => {
      try {
        return this._type.covariant(v2);
      } catch (e2) {
        throw new Error(`Invalid ${this.display()} argument: 

index ${idx} -> ${e2.message}`);
      }
    }))
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x2)}`);
  }
  encodeValue(x2) {
    const len2 = lebEncode(x2.length);
    if (this._blobOptimization) {
      return concat$1(len2, new Uint8Array(x2));
    }
    if (ArrayBuffer.isView(x2)) {
      return concat$1(len2, new Uint8Array(x2.buffer));
    }
    const buf = new PipeArrayBuffer(new ArrayBuffer(len2.byteLength + x2.length), 0);
    buf.write(len2);
    for (const d2 of x2) {
      const encoded = this._type.encodeValue(d2);
      buf.write(new Uint8Array(encoded));
    }
    return buf.buffer;
  }
  _buildTypeTableImpl(typeTable) {
    this._type.buildTypeTable(typeTable);
    const opCode = slebEncode(-19);
    const buffer2 = this._type.encodeType(typeTable);
    typeTable.add(this, concat$1(opCode, buffer2));
  }
  decodeValue(b2, t2) {
    const vec = this.checkType(t2);
    if (!(vec instanceof VecClass)) {
      throw new Error("Not a vector type");
    }
    const len2 = Number(lebDecode(b2));
    if (this._type instanceof FixedNatClass) {
      if (this._type._bits == 8) {
        return new Uint8Array(b2.read(len2));
      }
      if (this._type._bits == 16) {
        return new Uint16Array(b2.read(len2 * 2));
      }
      if (this._type._bits == 32) {
        return new Uint32Array(b2.read(len2 * 4));
      }
      if (this._type._bits == 64) {
        return new BigUint64Array(b2.read(len2 * 8));
      }
    }
    if (this._type instanceof FixedIntClass) {
      if (this._type._bits == 8) {
        return new Int8Array(b2.read(len2));
      }
      if (this._type._bits == 16) {
        return new Int16Array(b2.read(len2 * 2));
      }
      if (this._type._bits == 32) {
        return new Int32Array(b2.read(len2 * 4));
      }
      if (this._type._bits == 64) {
        return new BigInt64Array(b2.read(len2 * 8));
      }
    }
    const rets = [];
    for (let i2 = 0; i2 < len2; i2++) {
      rets.push(this._type.decodeValue(b2, vec._type));
    }
    return rets;
  }
  get name() {
    return `vec ${this._type.name}`;
  }
  display() {
    return `vec ${this._type.display()}`;
  }
  valueToString(x2) {
    const elements = x2.map((e2) => this._type.valueToString(e2));
    return "vec {" + elements.join("; ") + "}";
  }
}
class OptClass extends ConstructType {
  constructor(_type) {
    super();
    this._type = _type;
  }
  accept(v2, d2) {
    return v2.visitOpt(this, this._type, d2);
  }
  covariant(x2) {
    try {
      if (Array.isArray(x2) && (x2.length === 0 || x2.length === 1 && this._type.covariant(x2[0])))
        return true;
    } catch (e2) {
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x2)} 

-> ${e2.message}`);
    }
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x2)}`);
  }
  encodeValue(x2) {
    if (x2.length === 0) {
      return new Uint8Array([0]);
    } else {
      return concat$1(new Uint8Array([1]), this._type.encodeValue(x2[0]));
    }
  }
  _buildTypeTableImpl(typeTable) {
    this._type.buildTypeTable(typeTable);
    const opCode = slebEncode(-18);
    const buffer2 = this._type.encodeType(typeTable);
    typeTable.add(this, concat$1(opCode, buffer2));
  }
  decodeValue(b2, t2) {
    const opt = this.checkType(t2);
    if (!(opt instanceof OptClass)) {
      throw new Error("Not an option type");
    }
    switch (safeReadUint8(b2)) {
      case 0:
        return [];
      case 1:
        return [this._type.decodeValue(b2, opt._type)];
      default:
        throw new Error("Not an option value");
    }
  }
  get name() {
    return `opt ${this._type.name}`;
  }
  display() {
    return `opt ${this._type.display()}`;
  }
  valueToString(x2) {
    if (x2.length === 0) {
      return "null";
    } else {
      return `opt ${this._type.valueToString(x2[0])}`;
    }
  }
}
class RecordClass extends ConstructType {
  constructor(fields = {}) {
    super();
    this._fields = Object.entries(fields).sort((a, b2) => idlLabelToId(a[0]) - idlLabelToId(b2[0]));
  }
  accept(v2, d2) {
    return v2.visitRecord(this, this._fields, d2);
  }
  tryAsTuple() {
    const res = [];
    for (let i2 = 0; i2 < this._fields.length; i2++) {
      const [key, type] = this._fields[i2];
      if (key !== `_${i2}_`) {
        return null;
      }
      res.push(type);
    }
    return res;
  }
  covariant(x2) {
    if (typeof x2 === "object" && this._fields.every(([k2, t2]) => {
      if (!x2.hasOwnProperty(k2)) {
        throw new Error(`Record is missing key "${k2}".`);
      }
      try {
        return t2.covariant(x2[k2]);
      } catch (e2) {
        throw new Error(`Invalid ${this.display()} argument: 

field ${k2} -> ${e2.message}`);
      }
    }))
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x2)}`);
  }
  encodeValue(x2) {
    const values2 = this._fields.map(([key]) => x2[key]);
    const bufs = zipWith(this._fields, values2, ([, c2], d2) => c2.encodeValue(d2));
    return concat$1(...bufs);
  }
  _buildTypeTableImpl(T2) {
    this._fields.forEach(([_2, value2]) => value2.buildTypeTable(T2));
    const opCode = slebEncode(-20);
    const len2 = lebEncode(this._fields.length);
    const fields = this._fields.map(([key, value2]) => concat$1(lebEncode(idlLabelToId(key)), value2.encodeType(T2)));
    T2.add(this, concat$1(opCode, len2, concat$1(...fields)));
  }
  decodeValue(b2, t2) {
    const record = this.checkType(t2);
    if (!(record instanceof RecordClass)) {
      throw new Error("Not a record type");
    }
    const x2 = {};
    let expectedRecordIdx = 0;
    let actualRecordIdx = 0;
    while (actualRecordIdx < record._fields.length) {
      const [hash2, type] = record._fields[actualRecordIdx];
      if (expectedRecordIdx >= this._fields.length) {
        type.decodeValue(b2, type);
        actualRecordIdx++;
        continue;
      }
      const [expectKey, expectType] = this._fields[expectedRecordIdx];
      const expectedId = idlLabelToId(this._fields[expectedRecordIdx][0]);
      const actualId = idlLabelToId(hash2);
      if (expectedId === actualId) {
        x2[expectKey] = expectType.decodeValue(b2, type);
        expectedRecordIdx++;
        actualRecordIdx++;
      } else if (actualId > expectedId) {
        if (expectType instanceof OptClass || expectType instanceof ReservedClass) {
          x2[expectKey] = [];
          expectedRecordIdx++;
        } else {
          throw new Error("Cannot find required field " + expectKey);
        }
      } else {
        type.decodeValue(b2, type);
        actualRecordIdx++;
      }
    }
    for (const [expectKey, expectType] of this._fields.slice(expectedRecordIdx)) {
      if (expectType instanceof OptClass || expectType instanceof ReservedClass) {
        x2[expectKey] = [];
      } else {
        throw new Error("Cannot find required field " + expectKey);
      }
    }
    return x2;
  }
  get name() {
    const fields = this._fields.map(([key, value2]) => key + ":" + value2.name);
    return `record {${fields.join("; ")}}`;
  }
  display() {
    const fields = this._fields.map(([key, value2]) => key + ":" + value2.display());
    return `record {${fields.join("; ")}}`;
  }
  valueToString(x2) {
    const values2 = this._fields.map(([key]) => x2[key]);
    const fields = zipWith(this._fields, values2, ([k2, c2], d2) => k2 + "=" + c2.valueToString(d2));
    return `record {${fields.join("; ")}}`;
  }
}
class TupleClass extends RecordClass {
  constructor(_components) {
    const x2 = {};
    _components.forEach((e2, i2) => x2["_" + i2 + "_"] = e2);
    super(x2);
    this._components = _components;
  }
  accept(v2, d2) {
    return v2.visitTuple(this, this._components, d2);
  }
  covariant(x2) {
    if (Array.isArray(x2) && x2.length >= this._fields.length && this._components.every((t2, i2) => {
      try {
        return t2.covariant(x2[i2]);
      } catch (e2) {
        throw new Error(`Invalid ${this.display()} argument: 

index ${i2} -> ${e2.message}`);
      }
    }))
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x2)}`);
  }
  encodeValue(x2) {
    const bufs = zipWith(this._components, x2, (c2, d2) => c2.encodeValue(d2));
    return concat$1(...bufs);
  }
  decodeValue(b2, t2) {
    const tuple = this.checkType(t2);
    if (!(tuple instanceof TupleClass)) {
      throw new Error("not a tuple type");
    }
    if (tuple._components.length < this._components.length) {
      throw new Error("tuple mismatch");
    }
    const res = [];
    for (const [i2, wireType] of tuple._components.entries()) {
      if (i2 >= this._components.length) {
        wireType.decodeValue(b2, wireType);
      } else {
        res.push(this._components[i2].decodeValue(b2, wireType));
      }
    }
    return res;
  }
  display() {
    const fields = this._components.map((value2) => value2.display());
    return `record {${fields.join("; ")}}`;
  }
  valueToString(values2) {
    const fields = zipWith(this._components, values2, (c2, d2) => c2.valueToString(d2));
    return `record {${fields.join("; ")}}`;
  }
}
class VariantClass extends ConstructType {
  constructor(fields = {}) {
    super();
    this._fields = Object.entries(fields).sort((a, b2) => idlLabelToId(a[0]) - idlLabelToId(b2[0]));
  }
  accept(v2, d2) {
    return v2.visitVariant(this, this._fields, d2);
  }
  covariant(x2) {
    if (typeof x2 === "object" && Object.entries(x2).length === 1 && this._fields.every(([k2, v2]) => {
      try {
        return !x2.hasOwnProperty(k2) || v2.covariant(x2[k2]);
      } catch (e2) {
        throw new Error(`Invalid ${this.display()} argument: 

variant ${k2} -> ${e2.message}`);
      }
    }))
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x2)}`);
  }
  encodeValue(x2) {
    for (let i2 = 0; i2 < this._fields.length; i2++) {
      const [name, type] = this._fields[i2];
      if (x2.hasOwnProperty(name)) {
        const idx = lebEncode(i2);
        const buf = type.encodeValue(x2[name]);
        return concat$1(idx, buf);
      }
    }
    throw Error("Variant has no data: " + x2);
  }
  _buildTypeTableImpl(typeTable) {
    this._fields.forEach(([, type]) => {
      type.buildTypeTable(typeTable);
    });
    const opCode = slebEncode(-21);
    const len2 = lebEncode(this._fields.length);
    const fields = this._fields.map(([key, value2]) => concat$1(lebEncode(idlLabelToId(key)), value2.encodeType(typeTable)));
    typeTable.add(this, concat$1(opCode, len2, ...fields));
  }
  decodeValue(b2, t2) {
    const variant = this.checkType(t2);
    if (!(variant instanceof VariantClass)) {
      throw new Error("Not a variant type");
    }
    const idx = Number(lebDecode(b2));
    if (idx >= variant._fields.length) {
      throw Error("Invalid variant index: " + idx);
    }
    const [wireHash, wireType] = variant._fields[idx];
    for (const [key, expectType] of this._fields) {
      if (idlLabelToId(wireHash) === idlLabelToId(key)) {
        const value2 = expectType.decodeValue(b2, wireType);
        return { [key]: value2 };
      }
    }
    throw new Error("Cannot find field hash " + wireHash);
  }
  get name() {
    const fields = this._fields.map(([key, type]) => key + ":" + type.name);
    return `variant {${fields.join("; ")}}`;
  }
  display() {
    const fields = this._fields.map(([key, type]) => key + (type.name === "null" ? "" : `:${type.display()}`));
    return `variant {${fields.join("; ")}}`;
  }
  valueToString(x2) {
    for (const [name, type] of this._fields) {
      if (x2.hasOwnProperty(name)) {
        const value2 = type.valueToString(x2[name]);
        if (value2 === "null") {
          return `variant {${name}}`;
        } else {
          return `variant {${name}=${value2}}`;
        }
      }
    }
    throw new Error("Variant has no data: " + x2);
  }
}
class RecClass extends ConstructType {
  constructor() {
    super(...arguments);
    this._id = RecClass._counter++;
    this._type = void 0;
  }
  accept(v2, d2) {
    if (!this._type) {
      throw Error("Recursive type uninitialized.");
    }
    return v2.visitRec(this, this._type, d2);
  }
  fill(t2) {
    this._type = t2;
  }
  getType() {
    return this._type;
  }
  covariant(x2) {
    if (this._type ? this._type.covariant(x2) : false)
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x2)}`);
  }
  encodeValue(x2) {
    if (!this._type) {
      throw Error("Recursive type uninitialized.");
    }
    return this._type.encodeValue(x2);
  }
  _buildTypeTableImpl(typeTable) {
    if (!this._type) {
      throw Error("Recursive type uninitialized.");
    }
    typeTable.add(this, new Uint8Array([]));
    this._type.buildTypeTable(typeTable);
    typeTable.merge(this, this._type.name);
  }
  decodeValue(b2, t2) {
    if (!this._type) {
      throw Error("Recursive type uninitialized.");
    }
    return this._type.decodeValue(b2, t2);
  }
  get name() {
    return `rec_${this._id}`;
  }
  display() {
    if (!this._type) {
      throw Error("Recursive type uninitialized.");
    }
    return `\u03BC${this.name}.${this._type.name}`;
  }
  valueToString(x2) {
    if (!this._type) {
      throw Error("Recursive type uninitialized.");
    }
    return this._type.valueToString(x2);
  }
}
RecClass._counter = 0;
function decodePrincipalId(b2) {
  const x2 = safeReadUint8(b2);
  if (x2 !== 1) {
    throw new Error("Cannot decode principal");
  }
  const len2 = Number(lebDecode(b2));
  return Principal$3.fromUint8Array(new Uint8Array(safeRead(b2, len2)));
}
class PrincipalClass extends PrimitiveType {
  accept(v2, d2) {
    return v2.visitPrincipal(this, d2);
  }
  covariant(x2) {
    if (x2 && x2._isPrincipal)
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x2)}`);
  }
  encodeValue(x2) {
    const buf = x2.toUint8Array();
    const len2 = lebEncode(buf.byteLength);
    return concat$1(new Uint8Array([1]), len2, buf);
  }
  encodeType() {
    return slebEncode(-24);
  }
  decodeValue(b2, t2) {
    this.checkType(t2);
    return decodePrincipalId(b2);
  }
  get name() {
    return "principal";
  }
  valueToString(x2) {
    return `${this.name} "${x2.toText()}"`;
  }
}
class FuncClass extends ConstructType {
  constructor(argTypes, retTypes, annotations = []) {
    super();
    this.argTypes = argTypes;
    this.retTypes = retTypes;
    this.annotations = annotations;
  }
  static argsToString(types, v2) {
    if (types.length !== v2.length) {
      throw new Error("arity mismatch");
    }
    return "(" + types.map((t2, i2) => t2.valueToString(v2[i2])).join(", ") + ")";
  }
  accept(v2, d2) {
    return v2.visitFunc(this, d2);
  }
  covariant(x2) {
    if (Array.isArray(x2) && x2.length === 2 && x2[0] && x2[0]._isPrincipal && typeof x2[1] === "string")
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x2)}`);
  }
  encodeValue([principal, methodName]) {
    const buf = principal.toUint8Array();
    const len2 = lebEncode(buf.byteLength);
    const canister = concat$1(new Uint8Array([1]), len2, buf);
    const method2 = new TextEncoder().encode(methodName);
    const methodLen = lebEncode(method2.byteLength);
    return concat$1(new Uint8Array([1]), canister, methodLen, method2);
  }
  _buildTypeTableImpl(T2) {
    this.argTypes.forEach((arg) => arg.buildTypeTable(T2));
    this.retTypes.forEach((arg) => arg.buildTypeTable(T2));
    const opCode = slebEncode(-22);
    const argLen = lebEncode(this.argTypes.length);
    const args = concat$1(...this.argTypes.map((arg) => arg.encodeType(T2)));
    const retLen = lebEncode(this.retTypes.length);
    const rets = concat$1(...this.retTypes.map((arg) => arg.encodeType(T2)));
    const annLen = lebEncode(this.annotations.length);
    const anns = concat$1(...this.annotations.map((a) => this.encodeAnnotation(a)));
    T2.add(this, concat$1(opCode, argLen, args, retLen, rets, annLen, anns));
  }
  decodeValue(b2) {
    const x2 = safeReadUint8(b2);
    if (x2 !== 1) {
      throw new Error("Cannot decode function reference");
    }
    const canister = decodePrincipalId(b2);
    const mLen = Number(lebDecode(b2));
    const buf = safeRead(b2, mLen);
    const decoder2 = new TextDecoder("utf8", { fatal: true });
    const method2 = decoder2.decode(buf);
    return [canister, method2];
  }
  get name() {
    const args = this.argTypes.map((arg) => arg.name).join(", ");
    const rets = this.retTypes.map((arg) => arg.name).join(", ");
    const annon = " " + this.annotations.join(" ");
    return `(${args}) -> (${rets})${annon}`;
  }
  valueToString([principal, str]) {
    return `func "${principal.toText()}".${str}`;
  }
  display() {
    const args = this.argTypes.map((arg) => arg.display()).join(", ");
    const rets = this.retTypes.map((arg) => arg.display()).join(", ");
    const annon = " " + this.annotations.join(" ");
    return `(${args}) \u2192 (${rets})${annon}`;
  }
  encodeAnnotation(ann) {
    if (ann === "query") {
      return new Uint8Array([1]);
    } else if (ann === "oneway") {
      return new Uint8Array([2]);
    } else {
      throw new Error("Illegal function annotation");
    }
  }
}
class ServiceClass extends ConstructType {
  constructor(fields) {
    super();
    this._fields = Object.entries(fields).sort((a, b2) => idlLabelToId(a[0]) - idlLabelToId(b2[0]));
  }
  accept(v2, d2) {
    return v2.visitService(this, d2);
  }
  covariant(x2) {
    if (x2 && x2._isPrincipal)
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x2)}`);
  }
  encodeValue(x2) {
    const buf = x2.toUint8Array();
    const len2 = lebEncode(buf.length);
    return concat$1(new Uint8Array([1]), len2, buf);
  }
  _buildTypeTableImpl(T2) {
    this._fields.forEach(([_2, func]) => func.buildTypeTable(T2));
    const opCode = slebEncode(-23);
    const len2 = lebEncode(this._fields.length);
    const meths = this._fields.map(([label, func]) => {
      const labelBuf = new TextEncoder().encode(label);
      const labelLen = lebEncode(labelBuf.length);
      return concat$1(labelLen, labelBuf, func.encodeType(T2));
    });
    T2.add(this, concat$1(opCode, len2, ...meths));
  }
  decodeValue(b2) {
    return decodePrincipalId(b2);
  }
  get name() {
    const fields = this._fields.map(([key, value2]) => key + ":" + value2.name);
    return `service {${fields.join("; ")}}`;
  }
  valueToString(x2) {
    return `service "${x2.toText()}"`;
  }
}
function toReadableString(x2) {
  const str = JSON.stringify(x2, (_key, value2) => typeof value2 === "bigint" ? `BigInt(${value2})` : value2);
  return str && str.length > toReadableString_max ? str.substring(0, toReadableString_max - 3) + "..." : str;
}
function encode$1(argTypes, args) {
  if (args.length < argTypes.length) {
    throw Error("Wrong number of message arguments");
  }
  const typeTable = new TypeTable();
  argTypes.forEach((t2) => t2.buildTypeTable(typeTable));
  const magic = new TextEncoder().encode(magicNumber);
  const table = typeTable.encode();
  const len2 = lebEncode(args.length);
  const typs = concat$1(...argTypes.map((t2) => t2.encodeType(typeTable)));
  const vals = concat$1(...zipWith(argTypes, args, (t2, x2) => {
    try {
      t2.covariant(x2);
    } catch (e2) {
      const err = new Error(e2.message + "\n\n");
      throw err;
    }
    return t2.encodeValue(x2);
  }));
  return concat$1(magic, table, len2, typs, vals);
}
function decode$1(retTypes, bytes2) {
  const b2 = new PipeArrayBuffer(bytes2);
  if (bytes2.byteLength < magicNumber.length) {
    throw new Error("Message length smaller than magic number");
  }
  const magicBuffer = safeRead(b2, magicNumber.length);
  const magic = new TextDecoder().decode(magicBuffer);
  if (magic !== magicNumber) {
    throw new Error("Wrong magic number: " + JSON.stringify(magic));
  }
  function readTypeTable(pipe) {
    const typeTable = [];
    const len2 = Number(lebDecode(pipe));
    for (let i2 = 0; i2 < len2; i2++) {
      const ty = Number(slebDecode(pipe));
      switch (ty) {
        case -18:
        case -19: {
          const t2 = Number(slebDecode(pipe));
          typeTable.push([ty, t2]);
          break;
        }
        case -20:
        case -21: {
          const fields = [];
          let objectLength = Number(lebDecode(pipe));
          let prevHash;
          while (objectLength--) {
            const hash2 = Number(lebDecode(pipe));
            if (hash2 >= Math.pow(2, 32)) {
              throw new Error("field id out of 32-bit range");
            }
            if (typeof prevHash === "number" && prevHash >= hash2) {
              throw new Error("field id collision or not sorted");
            }
            prevHash = hash2;
            const t2 = Number(slebDecode(pipe));
            fields.push([hash2, t2]);
          }
          typeTable.push([ty, fields]);
          break;
        }
        case -22: {
          const args = [];
          let argLength = Number(lebDecode(pipe));
          while (argLength--) {
            args.push(Number(slebDecode(pipe)));
          }
          const returnValues = [];
          let returnValuesLength = Number(lebDecode(pipe));
          while (returnValuesLength--) {
            returnValues.push(Number(slebDecode(pipe)));
          }
          const annotations = [];
          let annotationLength = Number(lebDecode(pipe));
          while (annotationLength--) {
            const annotation = Number(lebDecode(pipe));
            switch (annotation) {
              case 1: {
                annotations.push("query");
                break;
              }
              case 2: {
                annotations.push("oneway");
                break;
              }
              default:
                throw new Error("unknown annotation");
            }
          }
          typeTable.push([ty, [args, returnValues, annotations]]);
          break;
        }
        case -23: {
          let servLength = Number(lebDecode(pipe));
          const methods2 = [];
          while (servLength--) {
            const nameLength = Number(lebDecode(pipe));
            const funcName = new TextDecoder().decode(safeRead(pipe, nameLength));
            const funcType = slebDecode(pipe);
            methods2.push([funcName, funcType]);
          }
          typeTable.push([ty, methods2]);
          break;
        }
        default:
          throw new Error("Illegal op_code: " + ty);
      }
    }
    const rawList = [];
    const length2 = Number(lebDecode(pipe));
    for (let i2 = 0; i2 < length2; i2++) {
      rawList.push(Number(slebDecode(pipe)));
    }
    return [typeTable, rawList];
  }
  const [rawTable, rawTypes] = readTypeTable(b2);
  if (rawTypes.length < retTypes.length) {
    throw new Error("Wrong number of return values");
  }
  const table = rawTable.map((_2) => Rec());
  function getType2(t2) {
    if (t2 < -24) {
      throw new Error("future value not supported");
    }
    if (t2 < 0) {
      switch (t2) {
        case -1:
          return Null;
        case -2:
          return Bool;
        case -3:
          return Nat;
        case -4:
          return Int;
        case -5:
          return Nat8;
        case -6:
          return Nat16;
        case -7:
          return Nat32;
        case -8:
          return Nat64;
        case -9:
          return Int8;
        case -10:
          return Int16;
        case -11:
          return Int32;
        case -12:
          return Int64;
        case -13:
          return Float32;
        case -14:
          return Float64;
        case -15:
          return Text;
        case -16:
          return Reserved;
        case -17:
          return Empty;
        case -24:
          return Principal;
        default:
          throw new Error("Illegal op_code: " + t2);
      }
    }
    if (t2 >= rawTable.length) {
      throw new Error("type index out of range");
    }
    return table[t2];
  }
  function buildType(entry) {
    switch (entry[0]) {
      case -19: {
        const ty = getType2(entry[1]);
        return Vec(ty);
      }
      case -18: {
        const ty = getType2(entry[1]);
        return Opt(ty);
      }
      case -20: {
        const fields = {};
        for (const [hash2, ty] of entry[1]) {
          const name = `_${hash2}_`;
          fields[name] = getType2(ty);
        }
        const record = Record(fields);
        const tuple = record.tryAsTuple();
        if (Array.isArray(tuple)) {
          return Tuple(...tuple);
        } else {
          return record;
        }
      }
      case -21: {
        const fields = {};
        for (const [hash2, ty] of entry[1]) {
          const name = `_${hash2}_`;
          fields[name] = getType2(ty);
        }
        return Variant(fields);
      }
      case -22: {
        const [args, returnValues, annotations] = entry[1];
        return Func(args.map((t2) => getType2(t2)), returnValues.map((t2) => getType2(t2)), annotations);
      }
      case -23: {
        const rec = {};
        const methods2 = entry[1];
        for (const [name, typeRef] of methods2) {
          let type = getType2(typeRef);
          if (type instanceof RecClass) {
            type = type.getType();
          }
          if (!(type instanceof FuncClass)) {
            throw new Error("Illegal service definition: services can only contain functions");
          }
          rec[name] = type;
        }
        return Service(rec);
      }
      default:
        throw new Error("Illegal op_code: " + entry[0]);
    }
  }
  rawTable.forEach((entry, i2) => {
    const t2 = buildType(entry);
    table[i2].fill(t2);
  });
  const types = rawTypes.map((t2) => getType2(t2));
  const output = retTypes.map((t2, i2) => {
    return t2.decodeValue(b2, types[i2]);
  });
  for (let ind = retTypes.length; ind < types.length; ind++) {
    types[ind].decodeValue(b2, types[ind]);
  }
  if (b2.byteLength > 0) {
    throw new Error("decode: Left-over bytes");
  }
  return output;
}
const Empty = new EmptyClass();
const Reserved = new ReservedClass();
const Unknown = new UnknownClass();
const Bool = new BoolClass();
const Null = new NullClass();
const Text = new TextClass();
const Int = new IntClass();
const Nat = new NatClass();
const Float32 = new FloatClass(32);
const Float64 = new FloatClass(64);
const Int8 = new FixedIntClass(8);
const Int16 = new FixedIntClass(16);
const Int32 = new FixedIntClass(32);
const Int64 = new FixedIntClass(64);
const Nat8 = new FixedNatClass(8);
const Nat16 = new FixedNatClass(16);
const Nat32 = new FixedNatClass(32);
const Nat64 = new FixedNatClass(64);
const Principal = new PrincipalClass();
function Tuple(...types) {
  return new TupleClass(types);
}
function Vec(t2) {
  return new VecClass(t2);
}
function Opt(t2) {
  return new OptClass(t2);
}
function Record(t2) {
  return new RecordClass(t2);
}
function Variant(fields) {
  return new VariantClass(fields);
}
function Rec() {
  return new RecClass();
}
function Func(args, ret, annotations = []) {
  return new FuncClass(args, ret, annotations);
}
function Service(t2) {
  return new ServiceClass(t2);
}
const IDL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Visitor,
  Type,
  PrimitiveType,
  ConstructType,
  EmptyClass,
  UnknownClass,
  BoolClass,
  NullClass,
  ReservedClass,
  TextClass,
  IntClass,
  NatClass,
  FloatClass,
  FixedIntClass,
  FixedNatClass,
  VecClass,
  OptClass,
  RecordClass,
  TupleClass,
  VariantClass,
  RecClass,
  PrincipalClass,
  FuncClass,
  ServiceClass,
  encode: encode$1,
  decode: decode$1,
  Empty,
  Reserved,
  Unknown,
  Bool,
  Null,
  Text,
  Int,
  Nat,
  Float32,
  Float64,
  Int8,
  Int16,
  Int32,
  Int64,
  Nat8,
  Nat16,
  Nat32,
  Nat64,
  Principal,
  Tuple,
  Vec,
  Opt,
  Record,
  Variant,
  Rec,
  Func,
  Service
}, Symbol.toStringTag, { value: "Module" }));
function concat(...buffers) {
  const result = new Uint8Array(buffers.reduce((acc, curr) => acc + curr.byteLength, 0));
  let index2 = 0;
  for (const b2 of buffers) {
    result.set(new Uint8Array(b2), index2);
    index2 += b2.byteLength;
  }
  return result.buffer;
}
function toHex(buffer2) {
  return [...new Uint8Array(buffer2)].map((x2) => x2.toString(16).padStart(2, "0")).join("");
}
const hexRe = new RegExp(/^([0-9A-F]{2})*$/i);
function fromHex(hex) {
  if (!hexRe.test(hex)) {
    throw new Error("Invalid hexadecimal string.");
  }
  const buffer2 = [...hex].reduce((acc, curr, i2) => {
    acc[i2 / 2 | 0] = (acc[i2 / 2 | 0] || "") + curr;
    return acc;
  }, []).map((x2) => Number.parseInt(x2, 16));
  return new Uint8Array(buffer2).buffer;
}
function compare(b1, b2) {
  if (b1.byteLength !== b2.byteLength) {
    return b1.byteLength - b2.byteLength;
  }
  const u1 = new Uint8Array(b1);
  const u2 = new Uint8Array(b2);
  for (let i2 = 0; i2 < u1.length; i2++) {
    if (u1[i2] !== u2[i2]) {
      return u1[i2] - u2[i2];
    }
  }
  return 0;
}
function hash(data2) {
  return sha256$1.exports.sha256.create().update(new Uint8Array(data2)).arrayBuffer();
}
function hashValue(value2) {
  if (value2 instanceof src$1.Tagged) {
    return hashValue(value2.value);
  } else if (typeof value2 === "string") {
    return hashString(value2);
  } else if (typeof value2 === "number") {
    return hash(lebEncode(value2));
  } else if (value2 instanceof ArrayBuffer || ArrayBuffer.isView(value2)) {
    return hash(value2);
  } else if (Array.isArray(value2)) {
    const vals = value2.map(hashValue);
    return hash(concat(...vals));
  } else if (value2 && typeof value2 === "object" && value2._isPrincipal) {
    return hash(value2.toUint8Array());
  } else if (typeof value2 === "object" && value2 !== null && typeof value2.toHash === "function") {
    return hashValue(value2.toHash());
  } else if (typeof value2 === "bigint") {
    return hash(lebEncode(value2));
  }
  throw Object.assign(new Error(`Attempt to hash a value of unsupported type: ${value2}`), {
    value: value2
  });
}
const hashString = (value2) => {
  const encoded = new TextEncoder().encode(value2);
  return hash(encoded);
};
function requestIdOf(request2) {
  const hashed = Object.entries(request2).filter(([, value2]) => value2 !== void 0).map(([key, value2]) => {
    const hashedKey = hashString(key);
    const hashedValue = hashValue(value2);
    return [hashedKey, hashedValue];
  });
  const traversed = hashed;
  const sorted = traversed.sort(([k1], [k2]) => {
    return compare(k1, k2);
  });
  const concatenated = concat(...sorted.map((x2) => concat(...x2)));
  const requestId = hash(concatenated);
  return requestId;
}
globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
        t2[p2[i2]] = s[p2[i2]];
    }
  return t2;
};
new TextEncoder().encode("\nic-request");
class AnonymousIdentity {
  getPrincipal() {
    return Principal$3.anonymous();
  }
  async transformRequest(request2) {
    return Object.assign(Object.assign({}, request2), { body: { content: request2.body } });
  }
}
class PrincipalEncoder {
  get name() {
    return "Principal";
  }
  get priority() {
    return 0;
  }
  match(value2) {
    return value2 && value2._isPrincipal === true;
  }
  encode(v2) {
    return src.value.bytes(v2.toUint8Array());
  }
}
class BufferEncoder {
  get name() {
    return "Buffer";
  }
  get priority() {
    return 1;
  }
  match(value2) {
    return value2 instanceof ArrayBuffer || ArrayBuffer.isView(value2);
  }
  encode(v2) {
    return src.value.bytes(new Uint8Array(v2));
  }
}
class BigIntEncoder {
  get name() {
    return "BigInt";
  }
  get priority() {
    return 1;
  }
  match(value2) {
    return typeof value2 === `bigint`;
  }
  encode(v2) {
    if (v2 > BigInt(0)) {
      return src.value.tagged(2, src.value.bytes(fromHex(v2.toString(16))));
    } else {
      return src.value.tagged(3, src.value.bytes(fromHex((BigInt("-1") * v2).toString(16))));
    }
  }
}
const serializer = src.SelfDescribeCborSerializer.withDefaultEncoders(true);
serializer.addEncoder(new PrincipalEncoder());
serializer.addEncoder(new BufferEncoder());
serializer.addEncoder(new BigIntEncoder());
var CborTag;
(function(CborTag2) {
  CborTag2[CborTag2["Uint64LittleEndian"] = 71] = "Uint64LittleEndian";
  CborTag2[CborTag2["Semantic"] = 55799] = "Semantic";
})(CborTag || (CborTag = {}));
function encode(value2) {
  return serializer.serialize(value2);
}
function decodePositiveBigInt(buf) {
  const len2 = buf.byteLength;
  let res = BigInt(0);
  for (let i2 = 0; i2 < len2; i2++) {
    res = res * BigInt(256) + BigInt(buf[i2]);
  }
  return res;
}
class Uint8ArrayDecoder extends src$1.Decoder {
  createByteString(raw2) {
    return concat(...raw2);
  }
  createByteStringFromHeap(start, end) {
    if (start === end) {
      return new ArrayBuffer(0);
    }
    return new Uint8Array(this._heap.slice(start, end));
  }
}
function decode(input) {
  const buffer2 = new Uint8Array(input);
  const decoder2 = new Uint8ArrayDecoder({
    size: buffer2.byteLength,
    tags: {
      2: (val) => decodePositiveBigInt(val),
      3: (val) => -decodePositiveBigInt(val),
      [CborTag.Semantic]: (value2) => value2
    }
  });
  return decoder2.decodeFirst(buffer2);
}
var SubmitRequestType;
(function(SubmitRequestType2) {
  SubmitRequestType2["Call"] = "call";
})(SubmitRequestType || (SubmitRequestType = {}));
function makeNonce() {
  const buffer2 = new ArrayBuffer(16);
  const view = new DataView(buffer2);
  const now = BigInt(+Date.now());
  const randHi = Math.floor(Math.random() * 4294967295);
  const randLo = Math.floor(Math.random() * 4294967295);
  if (typeof view.setBigUint64 === "function") {
    view.setBigUint64(0, now);
  } else {
    const TWO_TO_THE_32 = BigInt(1) << BigInt(32);
    view.setUint32(0, Number(now >> BigInt(32)));
    view.setUint32(4, Number(now % TWO_TO_THE_32));
  }
  view.setUint32(8, randHi);
  view.setUint32(12, randLo);
  return buffer2;
}
const NANOSECONDS_PER_MILLISECONDS = BigInt(1e6);
const REPLICA_PERMITTED_DRIFT_MILLISECONDS = BigInt(60 * 1e3);
class Expiry {
  constructor(deltaInMSec) {
    this._value = (BigInt(Date.now()) + BigInt(deltaInMSec) - REPLICA_PERMITTED_DRIFT_MILLISECONDS) * NANOSECONDS_PER_MILLISECONDS;
  }
  toCBOR() {
    return src.value.u64(this._value.toString(16), 16);
  }
  toHash() {
    return lebEncode(this._value);
  }
}
function makeNonceTransform(nonceFn = makeNonce) {
  return async (request2) => {
    if (request2.endpoint === "call") {
      request2.body.nonce = nonceFn();
    }
  };
}
var RequestStatusResponseStatus;
(function(RequestStatusResponseStatus2) {
  RequestStatusResponseStatus2["Received"] = "received";
  RequestStatusResponseStatus2["Processing"] = "processing";
  RequestStatusResponseStatus2["Replied"] = "replied";
  RequestStatusResponseStatus2["Rejected"] = "rejected";
  RequestStatusResponseStatus2["Unknown"] = "unknown";
  RequestStatusResponseStatus2["Done"] = "done";
})(RequestStatusResponseStatus || (RequestStatusResponseStatus = {}));
const DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS = 5 * 60 * 1e3;
const IC_ROOT_KEY = "308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100814c0e6ec71fab583b08bd81373c255c3c371b2e84863c98a4f1e08b74235d14fb5d9c0cd546d9685f913a0c0b2cc5341583bf4b4392e467db96d65b9bb4cb717112f8472e0d5a4d14505ffd7484b01291091c5f87b98883463f98091a0baaae";
const IC0_DOMAIN = "ic0.app";
const IC0_SUB_DOMAIN = ".ic0.app";
class HttpDefaultFetchError extends AgentError {
  constructor(message) {
    super(message);
    this.message = message;
  }
}
class IdentityInvalidError extends AgentError {
  constructor(message) {
    super(message);
    this.message = message;
  }
}
function getDefaultFetch() {
  let defaultFetch;
  if (typeof window !== "undefined") {
    if (window.fetch) {
      defaultFetch = window.fetch.bind(window);
    } else {
      throw new HttpDefaultFetchError("Fetch implementation was not available. You appear to be in a browser context, but window.fetch was not present.");
    }
  } else if (typeof global !== "undefined") {
    if (global.fetch) {
      defaultFetch = global.fetch.bind(global);
    } else {
      throw new HttpDefaultFetchError("Fetch implementation was not available. You appear to be in a Node.js context, but global.fetch was not available.");
    }
  } else if (typeof self !== "undefined") {
    if (self.fetch) {
      defaultFetch = self.fetch.bind(self);
    }
  }
  if (defaultFetch) {
    return defaultFetch;
  }
  throw new HttpDefaultFetchError("Fetch implementation was not available. Please provide fetch to the HttpAgent constructor, or ensure it is available in the window or global context.");
}
class HttpAgent {
  constructor(options = {}) {
    this.rootKey = fromHex(IC_ROOT_KEY);
    this._pipeline = [];
    this._timeDiffMsecs = 0;
    this._rootKeyFetched = false;
    this._retryTimes = 3;
    this._isAgent = true;
    if (options.source) {
      if (!(options.source instanceof HttpAgent)) {
        throw new Error("An Agent's source can only be another HttpAgent");
      }
      this._pipeline = [...options.source._pipeline];
      this._identity = options.source._identity;
      this._fetch = options.source._fetch;
      this._host = options.source._host;
      this._credentials = options.source._credentials;
    } else {
      this._fetch = options.fetch || getDefaultFetch() || fetch.bind(global);
    }
    if (options.host !== void 0) {
      if (!options.host.match(/^[a-z]+:/) && typeof window !== "undefined") {
        this._host = new URL(window.location.protocol + "//" + options.host);
      } else {
        this._host = new URL(options.host);
      }
    } else if (options.source !== void 0) {
      this._host = options.source._host;
    } else {
      const location = typeof window !== "undefined" ? window.location : void 0;
      if (!location) {
        throw new Error("Must specify a host to connect to.");
      }
      this._host = new URL(location + "");
    }
    if (options.retryTimes !== void 0) {
      this._retryTimes = options.retryTimes;
    }
    if (this._host.hostname.endsWith(IC0_SUB_DOMAIN)) {
      this._host.hostname = IC0_DOMAIN;
    }
    if (options.credentials) {
      const { name, password } = options.credentials;
      this._credentials = `${name}${password ? ":" + password : ""}`;
    }
    this._identity = Promise.resolve(options.identity || new AnonymousIdentity());
    if (!options.disableNonce) {
      this.addTransform(makeNonceTransform(makeNonce));
    }
  }
  isLocal() {
    const hostname = this._host.hostname;
    return hostname === "127.0.0.1" || hostname.endsWith("localhost");
  }
  addTransform(fn, priority = fn.priority || 0) {
    const i2 = this._pipeline.findIndex((x2) => (x2.priority || 0) < priority);
    this._pipeline.splice(i2 >= 0 ? i2 : this._pipeline.length, 0, Object.assign(fn, { priority }));
  }
  async getPrincipal() {
    if (!this._identity) {
      throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");
    }
    return (await this._identity).getPrincipal();
  }
  async call(canisterId, options, identity) {
    const id2 = await (identity !== void 0 ? await identity : await this._identity);
    if (!id2) {
      throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");
    }
    const canister = Principal$3.from(canisterId);
    const ecid = options.effectiveCanisterId ? Principal$3.from(options.effectiveCanisterId) : canister;
    const sender = id2.getPrincipal() || Principal$3.anonymous();
    let ingress_expiry = new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS);
    if (Math.abs(this._timeDiffMsecs) > 1e3 * 30) {
      ingress_expiry = new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS + this._timeDiffMsecs);
    }
    const submit = {
      request_type: SubmitRequestType.Call,
      canister_id: canister,
      method_name: options.methodName,
      arg: options.arg,
      sender,
      ingress_expiry
    };
    let transformedRequest = await this._transform({
      request: {
        body: null,
        method: "POST",
        headers: Object.assign({ "Content-Type": "application/cbor" }, this._credentials ? { Authorization: "Basic " + btoa(this._credentials) } : {})
      },
      endpoint: "call",
      body: submit
    });
    transformedRequest = await id2.transformRequest(transformedRequest);
    const body = encode(transformedRequest.body);
    const request2 = this._requestAndRetry(() => this._fetch("" + new URL(`/api/v2/canister/${ecid.toText()}/call`, this._host), Object.assign(Object.assign({}, transformedRequest.request), { body })));
    const [response, requestId] = await Promise.all([request2, requestIdOf(submit)]);
    return {
      requestId,
      response: {
        ok: response.ok,
        status: response.status,
        statusText: response.statusText
      }
    };
  }
  async _requestAndRetry(request2, tries = 0) {
    if (tries > this._retryTimes && this._retryTimes !== 0) {
      throw new Error(`AgentError: Exceeded configured limit of ${this._retryTimes} retry attempts. Please check your network connection or try again in a few moments`);
    }
    const response = await request2();
    if (!response.ok) {
      const responseText = await response.clone().text();
      const errorMessage = `Server returned an error:
  Code: ${response.status} (${response.statusText})
  Body: ${responseText}
`;
      if (this._retryTimes > tries) {
        console.warn(errorMessage + `  Retrying request.`);
        return await this._requestAndRetry(request2, tries + 1);
      } else {
        throw new Error(errorMessage);
      }
    }
    return response;
  }
  async query(canisterId, fields, identity) {
    const id2 = await (identity !== void 0 ? await identity : await this._identity);
    if (!id2) {
      throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");
    }
    const canister = typeof canisterId === "string" ? Principal$3.fromText(canisterId) : canisterId;
    const sender = (id2 === null || id2 === void 0 ? void 0 : id2.getPrincipal()) || Principal$3.anonymous();
    const request2 = {
      request_type: "query",
      canister_id: canister,
      method_name: fields.methodName,
      arg: fields.arg,
      sender,
      ingress_expiry: new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS)
    };
    let transformedRequest = await this._transform({
      request: {
        method: "POST",
        headers: Object.assign({ "Content-Type": "application/cbor" }, this._credentials ? { Authorization: "Basic " + btoa(this._credentials) } : {})
      },
      endpoint: "read",
      body: request2
    });
    transformedRequest = await (id2 === null || id2 === void 0 ? void 0 : id2.transformRequest(transformedRequest));
    const body = encode(transformedRequest.body);
    const response = await this._requestAndRetry(() => this._fetch("" + new URL(`/api/v2/canister/${canister.toText()}/query`, this._host), Object.assign(Object.assign({}, transformedRequest.request), { body })));
    return decode(await response.arrayBuffer());
  }
  async createReadStateRequest(fields, identity) {
    const id2 = await (identity !== void 0 ? await identity : await this._identity);
    if (!id2) {
      throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");
    }
    const sender = (id2 === null || id2 === void 0 ? void 0 : id2.getPrincipal()) || Principal$3.anonymous();
    const transformedRequest = await this._transform({
      request: {
        method: "POST",
        headers: Object.assign({ "Content-Type": "application/cbor" }, this._credentials ? { Authorization: "Basic " + btoa(this._credentials) } : {})
      },
      endpoint: "read_state",
      body: {
        request_type: "read_state",
        paths: fields.paths,
        sender,
        ingress_expiry: new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS)
      }
    });
    return id2 === null || id2 === void 0 ? void 0 : id2.transformRequest(transformedRequest);
  }
  async readState(canisterId, fields, identity, request2) {
    const canister = typeof canisterId === "string" ? Principal$3.fromText(canisterId) : canisterId;
    const transformedRequest = request2 !== null && request2 !== void 0 ? request2 : await this.createReadStateRequest(fields, identity);
    const body = encode(transformedRequest.body);
    const response = await this._fetch("" + new URL(`/api/v2/canister/${canister}/read_state`, this._host), Object.assign(Object.assign({}, transformedRequest.request), { body }));
    if (!response.ok) {
      throw new Error(`Server returned an error:
  Code: ${response.status} (${response.statusText})
  Body: ${await response.text()}
`);
    }
    return decode(await response.arrayBuffer());
  }
  async syncTime(canisterId) {
    const CanisterStatus = await __vitePreload(() => import("./index.dc0a8047.js"), true ? [] : void 0);
    const callTime = Date.now();
    try {
      if (!canisterId) {
        console.log("Syncing time with the IC. No canisterId provided, so falling back to ryjl3-tyaaa-aaaaa-aaaba-cai");
      }
      const status = await CanisterStatus.request({
        canisterId: canisterId !== null && canisterId !== void 0 ? canisterId : Principal$3.from("ryjl3-tyaaa-aaaaa-aaaba-cai"),
        agent: this,
        paths: ["time"]
      });
      const replicaTime = status.get("time");
      if (replicaTime) {
        this._timeDiffMsecs = Number(replicaTime) - Number(callTime);
      }
    } catch (error) {
      console.error("Caught exception while attempting to sync time:", error);
    }
  }
  async status() {
    const headers = this._credentials ? {
      Authorization: "Basic " + btoa(this._credentials)
    } : {};
    const response = await this._requestAndRetry(() => this._fetch("" + new URL(`/api/v2/status`, this._host), { headers }));
    return decode(await response.arrayBuffer());
  }
  async fetchRootKey() {
    if (!this._rootKeyFetched) {
      this.rootKey = (await this.status()).root_key;
      this._rootKeyFetched = true;
    }
    return this.rootKey;
  }
  invalidateIdentity() {
    this._identity = null;
  }
  replaceIdentity(identity) {
    this._identity = Promise.resolve(identity);
  }
  _transform(request2) {
    let p2 = Promise.resolve(request2);
    for (const fn of this._pipeline) {
      p2 = p2.then((r2) => fn(r2).then((r22) => r22 || r2));
    }
    return p2;
  }
}
var ProxyMessageKind;
(function(ProxyMessageKind2) {
  ProxyMessageKind2["Error"] = "err";
  ProxyMessageKind2["GetPrincipal"] = "gp";
  ProxyMessageKind2["GetPrincipalResponse"] = "gpr";
  ProxyMessageKind2["Query"] = "q";
  ProxyMessageKind2["QueryResponse"] = "qr";
  ProxyMessageKind2["Call"] = "c";
  ProxyMessageKind2["CallResponse"] = "cr";
  ProxyMessageKind2["ReadState"] = "rs";
  ProxyMessageKind2["ReadStateResponse"] = "rsr";
  ProxyMessageKind2["Status"] = "s";
  ProxyMessageKind2["StatusResponse"] = "sr";
})(ProxyMessageKind || (ProxyMessageKind = {}));
function getDefaultAgent() {
  const agent = typeof window === "undefined" ? typeof global === "undefined" ? typeof self === "undefined" ? void 0 : self.ic.agent : global.ic.agent : window.ic.agent;
  if (!agent) {
    throw new Error("No Agent could be found.");
  }
  return agent;
}
const managementCanisterIdl = ({ IDL: IDL2 }) => {
  const canister_id2 = IDL2.Principal;
  const definite_canister_settings = IDL2.Record({
    controllers: IDL2.Vec(IDL2.Principal),
    freezing_threshold: IDL2.Nat,
    memory_allocation: IDL2.Nat,
    compute_allocation: IDL2.Nat
  });
  const canister_settings = IDL2.Record({
    controllers: IDL2.Opt(IDL2.Vec(IDL2.Principal)),
    freezing_threshold: IDL2.Opt(IDL2.Nat),
    memory_allocation: IDL2.Opt(IDL2.Nat),
    compute_allocation: IDL2.Opt(IDL2.Nat)
  });
  const wasm_module = IDL2.Vec(IDL2.Nat8);
  return IDL2.Service({
    canister_status: IDL2.Func([IDL2.Record({ canister_id: canister_id2 })], [
      IDL2.Record({
        status: IDL2.Variant({
          stopped: IDL2.Null,
          stopping: IDL2.Null,
          running: IDL2.Null
        }),
        memory_size: IDL2.Nat,
        cycles: IDL2.Nat,
        settings: definite_canister_settings,
        module_hash: IDL2.Opt(IDL2.Vec(IDL2.Nat8))
      })
    ], []),
    create_canister: IDL2.Func([IDL2.Record({ settings: IDL2.Opt(canister_settings) })], [IDL2.Record({ canister_id: canister_id2 })], []),
    delete_canister: IDL2.Func([IDL2.Record({ canister_id: canister_id2 })], [], []),
    deposit_cycles: IDL2.Func([IDL2.Record({ canister_id: canister_id2 })], [], []),
    install_code: IDL2.Func([
      IDL2.Record({
        arg: IDL2.Vec(IDL2.Nat8),
        wasm_module,
        mode: IDL2.Variant({
          reinstall: IDL2.Null,
          upgrade: IDL2.Null,
          install: IDL2.Null
        }),
        canister_id: canister_id2
      })
    ], [], []),
    provisional_create_canister_with_cycles: IDL2.Func([
      IDL2.Record({
        settings: IDL2.Opt(canister_settings),
        amount: IDL2.Opt(IDL2.Nat)
      })
    ], [IDL2.Record({ canister_id: canister_id2 })], []),
    provisional_top_up_canister: IDL2.Func([IDL2.Record({ canister_id: canister_id2, amount: IDL2.Nat })], [], []),
    raw_rand: IDL2.Func([], [IDL2.Vec(IDL2.Nat8)], []),
    start_canister: IDL2.Func([IDL2.Record({ canister_id: canister_id2 })], [], []),
    stop_canister: IDL2.Func([IDL2.Record({ canister_id: canister_id2 })], [], []),
    uninstall_code: IDL2.Func([IDL2.Record({ canister_id: canister_id2 })], [], []),
    update_settings: IDL2.Func([
      IDL2.Record({
        canister_id: IDL2.Principal,
        settings: canister_settings
      })
    ], [], [])
  });
};
function getManagementCanister(config) {
  function transform2(_methodName, args, _callConfig) {
    const first = args[0];
    let effectiveCanisterId = Principal$3.fromHex("");
    if (first && typeof first === "object" && first.canister_id) {
      effectiveCanisterId = Principal$3.from(first.canister_id);
    }
    return { effectiveCanisterId };
  }
  return Actor.createActor(managementCanisterIdl, Object.assign(Object.assign(Object.assign({}, config), { canisterId: Principal$3.fromHex("") }), {
    callTransform: transform2,
    queryTransform: transform2
  }));
}
const wasmBytesBase64 = `AGFzbQEAAAABXg9gAn9/AGABfwBgAX8Bf2ADf39/AGACf38Bf2ADf39/AX9gBH9/f38AYAF/AX5gBX9/f39/AGAAAX9gBn9/f39/fwBgBn9/f39/fwF/YAJ/fwF+YAV/fn5+fgBgAAAD3wHdAQIAAAABAwoAAAAIBgQAAwEDAAEBAQAAAQAJAQMAAwEACAEDAwQAAwsADAIBAAEADQMEAAAAAgEBAAABAwABAQMEAAEBAQEBAQEAAAMBAgUABAEFBAEBAgIEAwQDAAAAAwAAAAABDgABAgAAAAEAAwMAAQMAAwYCAAAABAABAAABAQYBAwAAAgICAgIBAAMABAACAQAAAwAAAAAAAQEBAQIAAAEEAQMAAAABAAAEAgABAQEBAQEBAQEBBAQAAgMAAAABAAICAAIEBAEBAgICAgAEBQQEAgIJBwcHAQMDBAUBcAESEgUDAQARBgkBfwFBgIDAAAsHNwQGbWVtb3J5AgAIYmxzX2luaXQA1gEKYmxzX3ZlcmlmeQAnEV9fd2JpbmRnZW5fbWFsbG9jAGgJIQEAQQELEcgBQdoBTroBQH/XAdgBgAEcJVy7AccB2gHZAQr44QLdAd0hAg9/AX4jAEEQayIIJAACQAJAIABB9QFPBEBBgIB8QQhBCBCjAUEUQQgQowFqQRBBCBCjAWprQXdxQQNrIgJBAEEQQQgQowFBAnRrIgUgAiAFSRsgAE0NAiAAQQRqQQgQowEhBEHgu8AAKAIARQ0BQQAgBGshAQJAAkACf0EAIARBgAJJDQAaQR8gBEH///8HSw0AGiAEQQYgBEEIdmciAGt2QQFxIABBAXRrQT5qCyIHQQJ0Qey9wABqKAIAIgAEQCAEIAcQnwF0IQZBACECA0ACQCAAEMsBIgUgBEkNACAFIARrIgUgAU8NACAAIQIgBSIBDQBBACEBDAMLIABBFGooAgAiBSADIAUgACAGQR12QQRxakEQaigCACIARxsgAyAFGyEDIAZBAXQhBiAADQALIAMEQCADIQAMAgsgAg0CC0EAIQJBASAHdBCtAUHgu8AAKAIAcSIARQ0DIAAQwwFoQQJ0Qey9wABqKAIAIgBFDQMLA0AgACACIAAQywEiAiAETyACIARrIgMgAUlxIgUbIQIgAyABIAUbIQEgABCRASIADQALIAJFDQILIARB7L7AACgCACIATSABIAAgBGtPcQ0BIAIgBBDSASEAIAIQFwJAQRBBCBCjASABTQRAIAIgBBDFASAAIAEQoAEgAUGAAk8EQCAAIAEQFgwCCyABQQN2IgNBA3RB5LvAAGohAQJ/Qdy7wAAoAgAiBUEBIAN0IgNxBEAgASgCCAwBC0Hcu8AAIAMgBXI2AgAgAQshAyABIAA2AgggAyAANgIMIAAgATYCDCAAIAM2AggMAQsgAiABIARqEIUBCyACENQBIgFFDQEMAgtBECAAQQRqQRBBCBCjAUEFayAASxtBCBCjASEEAkACQAJAAn8CQAJAQdy7wAAoAgAiBSAEQQN2IgF2IgBBA3FFBEAgBEHsvsAAKAIATQ0HIAANAUHgu8AAKAIAIgBFDQcgABDDAWhBAnRB7L3AAGooAgAiAhDLASAEayEBIAIQkQEiAARAA0AgABDLASAEayIDIAEgASADSyIDGyEBIAAgAiADGyECIAAQkQEiAA0ACwsgAiAEENIBIQUgAhAXQRBBCBCjASABSw0FIAIgBBDFASAFIAEQoAFB7L7AACgCACIARQ0EIABBA3YiBkEDdEHku8AAaiEAQfS+wAAoAgAhA0Hcu8AAKAIAIgdBASAGdCIGcUUNAiAAKAIIDAMLAkAgAEF/c0EBcSABaiIAQQN0IgNB7LvAAGooAgAiAUEIaigCACICIANB5LvAAGoiA0cEQCACIAM2AgwgAyACNgIIDAELQdy7wAAgBUF+IAB3cTYCAAsgASAAQQN0EIUBIAEQ1AEhAQwHCwJAQQEgAUEfcSIBdBCtASAAIAF0cRDDAWgiAEEDdCIDQey7wABqKAIAIgJBCGooAgAiASADQeS7wABqIgNHBEAgASADNgIMIAMgATYCCAwBC0Hcu8AAQdy7wAAoAgBBfiAAd3E2AgALIAIgBBDFASACIAQQ0gEiBSAAQQN0IARrIgQQoAFB7L7AACgCACIABEAgAEEDdiIDQQN0QeS7wABqIQBB9L7AACgCACEBAn9B3LvAACgCACIGQQEgA3QiA3EEQCAAKAIIDAELQdy7wAAgAyAGcjYCACAACyEDIAAgATYCCCADIAE2AgwgASAANgIMIAEgAzYCCAtB9L7AACAFNgIAQey+wAAgBDYCACACENQBIQEMBgtB3LvAACAGIAdyNgIAIAALIQYgACADNgIIIAYgAzYCDCADIAA2AgwgAyAGNgIIC0H0vsAAIAU2AgBB7L7AACABNgIADAELIAIgASAEahCFAQsgAhDUASIBDQELAkACQAJAAkACQAJAAkACQCAEQey+wAAoAgAiAUsEQEHwvsAAKAIAIgAgBEsNAkEIQQgQowEgBGpBFEEIEKMBakEQQQgQowFqQYCABBCjASIBQRB2QAAhACAIQQA2AgggCEEAIAFBgIB8cSAAQX9GIgEbNgIEIAhBACAAQRB0IAEbNgIAIAgoAgAiAQ0BQQAhAQwJC0H0vsAAKAIAIQBBEEEIEKMBIAEgBGsiAUsEQEH0vsAAQQA2AgBB7L7AACgCACEBQey+wABBADYCACAAIAEQhQEgABDUASEBDAkLIAAgBBDSASECQey+wAAgATYCAEH0vsAAIAI2AgAgAiABEKABIAAgBBDFASAAENQBIQEMCAsgCCgCCCEFQfy+wAAgCCgCBCIDQfy+wAAoAgBqIgA2AgBBgL/AAEGAv8AAKAIAIgIgACAAIAJJGzYCAAJAAkBB+L7AACgCAARAQYS/wAAhAANAIAAQxgEgAUYNAiAAKAIIIgANAAsMAgtBmL/AACgCACIARSAAIAFLcg0DDAcLIAAQzQENACAAEM4BIAVHDQAgACgCACICQfi+wAAoAgAiBk0EfyACIAAoAgRqIAZLBUEACw0DC0GYv8AAQZi/wAAoAgAiACABIAAgAUkbNgIAIAEgA2ohAkGEv8AAIQACQAJAA0AgAiAAKAIARwRAIAAoAggiAA0BDAILCyAAEM0BDQAgABDOASAFRg0BC0H4vsAAKAIAIQJBhL/AACEAAkADQCACIAAoAgBPBEAgABDGASACSw0CCyAAKAIIIgANAAtBACEACyACIAAQxgEiD0EUQQgQowEiDmtBF2siABDUASIGQQgQowEgBmsgAGoiACAAQRBBCBCjASACakkbIgYQ1AEhByAGIA4Q0gEhAEEIQQgQowEhCUEUQQgQowEhC0EQQQgQowEhDEH4vsAAIAEgARDUASIKQQgQowEgCmsiDRDSASIKNgIAQfC+wAAgA0EIaiAMIAkgC2pqIA1qayIJNgIAIAogCUEBcjYCBEEIQQgQowEhC0EUQQgQowEhDEEQQQgQowEhDSAKIAkQ0gEgDSAMIAtBCGtqajYCBEGUv8AAQYCAgAE2AgAgBiAOEMUBQYS/wAApAgAhECAHQQhqQYy/wAApAgA3AgAgByAQNwIAQZC/wAAgBTYCAEGIv8AAIAM2AgBBhL/AACABNgIAQYy/wAAgBzYCAANAIABBBBDSASEBIABBBzYCBCAPIAEiAEEEaksNAAsgAiAGRg0HIAIgBiACayIAIAIgABDSARCDASAAQYACTwRAIAIgABAWDAgLIABBA3YiAUEDdEHku8AAaiEAAn9B3LvAACgCACIDQQEgAXQiAXEEQCAAKAIIDAELQdy7wAAgASADcjYCACAACyEBIAAgAjYCCCABIAI2AgwgAiAANgIMIAIgATYCCAwHCyAAKAIAIQUgACABNgIAIAAgACgCBCADajYCBCABENQBIgBBCBCjASECIAUQ1AEiA0EIEKMBIQYgASACIABraiICIAQQ0gEhASACIAQQxQEgBSAGIANraiIAIAIgBGprIQQgAEH4vsAAKAIARwRAQfS+wAAoAgAgAEYNBCAAKAIEQQNxQQFHDQUCQCAAEMsBIgNBgAJPBEAgABAXDAELIABBDGooAgAiBSAAQQhqKAIAIgZHBEAgBiAFNgIMIAUgBjYCCAwBC0Hcu8AAQdy7wAAoAgBBfiADQQN2d3E2AgALIAMgBGohBCAAIAMQ0gEhAAwFC0H4vsAAIAE2AgBB8L7AAEHwvsAAKAIAIARqIgA2AgAgASAAQQFyNgIEIAIQ1AEhAQwHC0HwvsAAIAAgBGsiATYCAEH4vsAAQfi+wAAoAgAiACAEENIBIgI2AgAgAiABQQFyNgIEIAAgBBDFASAAENQBIQEMBgtBmL/AACABNgIADAMLIAAgACgCBCADajYCBEHwvsAAKAIAIANqIQFB+L7AACgCACIAIAAQ1AEiAEEIEKMBIABrIgIQ0gEhAEHwvsAAIAEgAmsiATYCAEH4vsAAIAA2AgAgACABQQFyNgIEQQhBCBCjASECQRRBCBCjASEDQRBBCBCjASEFIAAgARDSASAFIAMgAkEIa2pqNgIEQZS/wABBgICAATYCAAwDC0H0vsAAIAE2AgBB7L7AAEHsvsAAKAIAIARqIgA2AgAgASAAEKABIAIQ1AEhAQwDCyABIAQgABCDASAEQYACTwRAIAEgBBAWIAIQ1AEhAQwDCyAEQQN2IgNBA3RB5LvAAGohAAJ/Qdy7wAAoAgAiBUEBIAN0IgNxBEAgACgCCAwBC0Hcu8AAIAMgBXI2AgAgAAshAyAAIAE2AgggAyABNgIMIAEgADYCDCABIAM2AgggAhDUASEBDAILQZy/wABB/x82AgBBkL/AACAFNgIAQYi/wAAgAzYCAEGEv8AAIAE2AgBB8LvAAEHku8AANgIAQfi7wABB7LvAADYCAEHsu8AAQeS7wAA2AgBBgLzAAEH0u8AANgIAQfS7wABB7LvAADYCAEGIvMAAQfy7wAA2AgBB/LvAAEH0u8AANgIAQZC8wABBhLzAADYCAEGEvMAAQfy7wAA2AgBBmLzAAEGMvMAANgIAQYy8wABBhLzAADYCAEGgvMAAQZS8wAA2AgBBlLzAAEGMvMAANgIAQai8wABBnLzAADYCAEGcvMAAQZS8wAA2AgBBsLzAAEGkvMAANgIAQaS8wABBnLzAADYCAEGsvMAAQaS8wAA2AgBBuLzAAEGsvMAANgIAQbS8wABBrLzAADYCAEHAvMAAQbS8wAA2AgBBvLzAAEG0vMAANgIAQci8wABBvLzAADYCAEHEvMAAQby8wAA2AgBB0LzAAEHEvMAANgIAQcy8wABBxLzAADYCAEHYvMAAQcy8wAA2AgBB1LzAAEHMvMAANgIAQeC8wABB1LzAADYCAEHcvMAAQdS8wAA2AgBB6LzAAEHcvMAANgIAQeS8wABB3LzAADYCAEHwvMAAQeS8wAA2AgBB+LzAAEHsvMAANgIAQey8wABB5LzAADYCAEGAvcAAQfS8wAA2AgBB9LzAAEHsvMAANgIAQYi9wABB/LzAADYCAEH8vMAAQfS8wAA2AgBBkL3AAEGEvcAANgIAQYS9wABB/LzAADYCAEGYvcAAQYy9wAA2AgBBjL3AAEGEvcAANgIAQaC9wABBlL3AADYCAEGUvcAAQYy9wAA2AgBBqL3AAEGcvcAANgIAQZy9wABBlL3AADYCAEGwvcAAQaS9wAA2AgBBpL3AAEGcvcAANgIAQbi9wABBrL3AADYCAEGsvcAAQaS9wAA2AgBBwL3AAEG0vcAANgIAQbS9wABBrL3AADYCAEHIvcAAQby9wAA2AgBBvL3AAEG0vcAANgIAQdC9wABBxL3AADYCAEHEvcAAQby9wAA2AgBB2L3AAEHMvcAANgIAQcy9wABBxL3AADYCAEHgvcAAQdS9wAA2AgBB1L3AAEHMvcAANgIAQei9wABB3L3AADYCAEHcvcAAQdS9wAA2AgBB5L3AAEHcvcAANgIAQQhBCBCjASECQRRBCBCjASEFQRBBCBCjASEGQfi+wAAgASABENQBIgBBCBCjASAAayIBENIBIgA2AgBB8L7AACADQQhqIAYgAiAFamogAWprIgE2AgAgACABQQFyNgIEQQhBCBCjASECQRRBCBCjASEDQRBBCBCjASEFIAAgARDSASAFIAMgAkEIa2pqNgIEQZS/wABBgICAATYCAAtBACEBQfC+wAAoAgAiACAETQ0AQfC+wAAgACAEayIBNgIAQfi+wABB+L7AACgCACIAIAQQ0gEiAjYCACACIAFBAXI2AgQgACAEEMUBIAAQ1AEhAQsgCEEQaiQAIAEL+A4BCX8jAEHADWsiAiQAAkACQAJAAkACQAJAAkACQAJAIAAoAoAGIgVBAUcEQCABKAKABiIGQQFGDQkgBkEDSw0BIAVBfnFBAkYNAiACIAAQjAEgAkGAAmoiBEE4ENABGiACQQE2ArgCIAJBwAJqQTgQ0AEaIAJB+AJqQQE2AgAgAkGAA2pBOBDQARogAkG4A2pBATYCACACQcADakE4ENABGiACQfgDakEBNgIAIAJBgARqQTgQ0AEaIAJBATYCuAQgAkHABGpBOBDQARogAkH4BGpBATYCACACQYAFakE4ENABGiACQbgFakEBNgIAIAJBwAVqQTgQ0AEaIAJB+AVqQQE2AgAgAkGABmoiB0E4ENABGiACQQE2ArgGIAJBwAZqQTgQ0AEaIAJB+AZqQQE2AgAgAkGAB2pBOBDQARogAkG4B2pBATYCACACQcAHakE4ENABGiACQfgHakEBNgIAIAJBgAhqIgMgABCMASACQYAKakE4ENABGiACQQE2ArgKIAJBwApqQTgQ0AEaIAJB+ApqQQE2AgAgAkGAC2pBOBDQARogAkG4C2pBATYCACACQcALakE4ENABGiACQfgLakEBNgIAIAIgARAYIAMgAEGAAmoiBhCXASADELABIAQgAxCWASAEIAEQGCADIAYQlgEgAyAAQYAEaiIFEJcBIAMQsAEgByADEJYBIAEoAoAGQQJGDQMgAkHADGoiAyABQYAFahBeIAJBgAZqIAMQpgEMBAsgACABEG0MCAsgAiAAEIwBIAJBgAJqQTgQ0AEaIAJBATYCuAIgAkHAAmpBOBDQARogAkH4AmpBATYCACACQYADakE4ENABGiACQbgDakEBNgIAIAJBwANqQTgQ0AEaIAJB+ANqQQE2AgAgAkGABGpBOBDQARogAkEBNgK4BCACQcAEakE4ENABGiACQfgEakEBNgIAIAJBgAVqQTgQ0AEaIAJBuAVqQQE2AgAgAkHABWpBOBDQARogAkH4BWpBATYCACACQYAGakE4ENABGiACQQE2ArgGIAJBwAZqQTgQ0AEaIAJB+AZqQQE2AgAgAkGAB2pBOBDQARogAkG4B2pBATYCACACQcAHakE4ENABGiACQfgHakEBNgIAIAIgARAYAkAgASgCgAZBBEYNACAAKAKABkEERg0AIAJBgARqIgMgAEGAAmoQlgEgAyABQYACahAYDAYLIAJBwAxqIgdBOBDQARogAkEBNgL4DCACQYANakE4ENABGiACQbgNakEBNgIAIAJBgAhqIgRBOBDQARogAkEBNgK4CCACQcAIakE4ENABGiACQfgIakEBNgIAIAJBgApqIgMgAEGAA2oiBRBeIAQgAxCZASADIAFBgANqIgYQXiAEIAMQESAHELYBIAEoAoAGQQRHDQMMBAsgACABEAMMBgsgAkHADGoiAyABQYAFahBeIAJBgAxqIgQgA0HAABDRARogAkGABmogBBCnAQsgAkGABmoQZCACQYAIaiIDIAIQlgEgAxArIAJBgAJqIgQgAxCXASAGIAQQlgEgAkGABGoiByADEJYBIAMgABCWASADIAUQlwEgAxCwASACQYAKaiIEIAEQlgEgBCABQYAEahCXASAEELABIAMgBBAYIAcgAxCXASADIAUQlgECQCABKAKABkECRwRAIAJBwAxqIgMgAUGABWoQXiACQYAIaiADEKYBDAELIAJBwAxqIgMgAUGABWoQXiACQYAMaiIBIANBwAAQ0QEaIAJBgAhqIAEQpwELIAJBgAhqIgEQZCACQYAKaiIDIAEQlgEgAxArIAUgAkGABGoQlgEgBSADEJcBIAJBgAZqIgQgAxCXASABEGQgBiABEJcBIAQQsAEgBBBkIAAgAhCWASAAIAQQlwEMAwsgAkGACmoiAyAFEF4gAkHADGoiBCADEJkBIAMgAUGAAmoQXiAEIAMQEQsgACgCgAZBBEcEQCACQYAKaiIDIABBgAJqEF4gAkHADGoiBCADEJkBIAMgBhBeIAQgAxARCyACQYAEaiIDIAJBwAxqIAJBgAhqEKUBIAMQZAsgAkGACGoiAyAAEIwBIAJBgApqIgQgARCMASADIABBgAJqIgUQlwEgAxCwASAEIAFBgAJqIggQlwEgBBCwASACQYACaiIJIAMQlgEgCSAEEBggAyAFEJYBIAMgAEGABGoiBhCXASADELABIAQgCBCWASAEIAFBgARqIggQlwEgBBCwASACQYAGaiIHIAMQlgEgByAEEBggAyACEJYBIAMQKyAEIAJBgARqIgoQlgEgBBArIAkgAxCXASAFIAkQlgEgBSAEEJcBIAcgBBCXASAKIAMQlwEgAyAAEJYBIAMgBhCXASADELABIAQgARCWASAEIAgQlwEgBBCwASADIAQQGCAKIAMQlwEgAyAGEJYBIAMgCBAYIAQgAxCWASAEECsgBiAKEJYBIAYgBBCXASAHIAQQlwEgAxBkIAUgAxCXASAHELABIAcQZCAAIAIQlgEgACAHEJcBCyAAQQU2AoAGIAAQnQELIAJBwA1qJAALqAsBEX8jAEGAC2siAiQAIAJBCGoQZyACQcgBaiIKQTgQ0AEaIAJBATYCgAIgAkGIAmoiD0E4ENABGiACQQE2AsACIAJByAJqIhBBOBDQARogAkEBNgKAAyACQYgDaiIJQTgQ0AEaIAJBATYCwAMgAkHIA2oiDkE4ENABGiACQQE2AoAEIAJBiARqIhFBARA5IAJByARqIgtBOBDQARogAkEBNgKABSACQYgFaiIEQTgQ0AEaIAJBATYCwAUgAkHIBWoiBSABEJABIAJBiAZqIgNBOBDQARogAkEBNgLABiACQcgGaiIGQTgQ0AEaIAJBATYCgAcgAkGIB2oiDEE4ENABGiACQQE2AsAHIAJByAdqIghBOBDQARogAkEBNgKACCAFEFYhEiACQcgJaiINQZCCwAAQSSACQYgKaiIHIA0QjgEgCiAHEK4BIA1ByILAABBJIAcgDRCOASAPIAcQrgEgBRBMIAVBCxA0IAMgBRCuASADIBEQdyADEEIgAyAFEEogBCAKEK4BIAQgAxBKIAMgERB3IAJBiAZqEEIgAyAPEEogAxBDIAJBiAZqEEIgCSADEK4BIA4gBRCuASAOIAkQSiAIIAkQrgEgCBBMIAYgBBCuASAGEEwgAyAKEK4BIAMgBhBKIAggAxB3IAgQQiAIIAkQSiAGIAQQSiADIA8QrgEgAyAGEEogCCADEHcgAkHIB2oQQiADIAgQrgEgAyAEEEogAyAMEFohCiAEIAMQrgEgBCAMEDMgBCAIEEogCSAEEEogDiAEEEogBSABEEogBiAEEK4BIAYQTCAEIAYQrgEgBCAFEEogBSADEK4BIAVBCxA0IA1BgIPAABBJIAcgDRCOASAQIAcQrgEgECAMEEogCSAOQQEgCmsiARByIAYgBCABEHIgAyAFIAEQciAMIBAgARByIAcgAyAMECMgCyAHEK4BIAsgBhBKIAsQViEBIAMgCxCuASADEEMgAkGIBmoQQiALIAMgASAScxByIAdBuIPAABBJIAJBiAhqIAcQjgFBOCEBA0AgAUGgBUZFBEAgAkGICGoiAyACQYgDahBKIAJByAlqIgQgAUG4g8AAahBJIAFBOGohASACQYgKaiIFIAQQjgEgAkGIBmoiBCAFEK4BIAMgBBB3IAMQQgwBCwsgAkHICGoiASACQYgDahCQASACQcgJaiIDQdiIwAAQSSACQYgKaiIEIAMQjgEgAkGIBmoiAyAEEK4BIAEgAxB3IAEQQkEAIQEDQCABQfgDRkUEQCACQcgIaiIDIAJBiANqEEogAkHICWoiBCABQZCJwABqEEkgAUE4aiEBIAJBiApqIgUgBBCOASACQYgGaiIEIAUQrgEgAyAEEHcgAxBCDAELCyACQYgKaiIBQYiNwAAQSSACQYgJaiABEI4BQQAhAQNAIAFByAZGRQRAIAJBiAlqIgMgAkGIA2oQSiACQcgJaiIEIAFBwI3AAGoQSSABQThqIQEgAkGICmoiBSAEEI4BIAJBiAZqIgQgBRCuASADIAQQdyADEEIMAQsLIAJByAlqIgEgAkGIA2oQkAEgAkHICmoiA0GIlMAAEEkgAkGICmoiBCADEI4BIAJBiAZqIgMgBBCuASABIAMQdyABEEJBACEBA0AgAUGQBkYEQCACQYgJaiIDIAJByARqEEogAkGIBmoiASACQYgIahCuASABIAJByAlqIgQQSiACQQhqIgUgARCuASABIAMQrgEgASACQcgIaiIDEEogAkHIAGogARCuASABIAMQrgEgASAEEEogAkGIAWogARCuASAAIAVBwAEQ0QEaIAJBgAtqJAAFIAJByAlqIgMgAkGIA2oQSiACQcgKaiIEIAFBwJTAAGoQSSABQThqIQEgAkGICmoiBSAEEI4BIAJBiAZqIgQgBRCuASADIAQQdyADEEIMAQsLC/oGAQx/IwBBgAlrIgMkACADQYAIaiICIAAQXiADIAIQXiACIABBgAFqIgoQXiADQYABaiIEIAIQXiACIAEQXiADIAIQESACIAFBgAFqIgsQXiAEIAIQEQJAIAEoAoAGIgJBAkYgACgCgAYiBEECRnJFBEAgA0GACGoiAiAAQYAFahBeIANBgAJqIgQgAhBeIAIgAUGABWoQXiAEIAIQEQwBCyACQQJGIARBAkZxRQRAIAJBAkYEQCADQYAIaiICIABBgAVqEF4gA0GAAmoiBCACEF4gAiABQYAFahBeIANBgAdqIgUgAkHAABDRARogBCAFEKoBDAILIANBgAhqIgIgAUGABWoQXiADQYACaiIEIAIQXiACIABBgAVqEF4gA0GAB2oiBSACQcAAENEBGiAEIAUQqgEMAQsgA0GACGoiAiAAQYAFahBeIANBgAdqIgQgAkHAABDRARogA0GABmoiBSAEEJABIAIgAUGABWoQXiAEIAJBwAAQ0QEaIAUgBBBKIANBgAJqQTgQ0AEiAkEBNgI4IAJBQGtBOBDQASACQfgAakEBNgIAIAIgBRCuARDBAQsgA0GACGoiAiAAEF4gA0GAA2oiBCACEF4gAiABEF4gA0GABGoiBSACEF4gAiAKEF4gBCACEJoBIAQQqQEgAiALEF4gBSACEJoBIAUQqQEgA0GABWoiByAEEF4gByAFEBEgA0GABmoiBiADEF4gBiADQYABaiIIEJoBIAYQNiAHIAYQmgEgAiAAEF4gBCACEJkBIAIgAEGABWoiDBBeIAQgAhCaASAEEKkBIAIgARBeIAUgAhCZASACIAFBgAVqIg0QXiAFIAIQmgEgBRCpASADQYAHaiIJIAQQXiAJIAUQESAGIAMQmQEgBiADQYACaiIBEJoBIAYQNiAJIAYQmgEgAiAKEF4gBCACEJkBIAIgDBBeIAQgAhCaASAEEKkBIAIgCxBeIAUgAhCZASACIA0QXiAFIAIQmgEgBRCpASACIAQQXiACIAUQESAGIAgQmQEgBiABEJoBIAYQNiACIAYQmgEgCBB8IAMgCBCaASAAIAMgBxClASABEHwgARCpASAAQYACaiIEQYABaiABEJkBIAQQtgEgAhCpASACEHwgAEGABGoiASACIAkQpQEgABCwASABELABIABBBDYCgAYgA0GACWokAAuHBwEFfyAAENUBIgAgABDLASICENIBIQECQAJAAkAgABDMAQ0AIAAoAgAhAwJAIAAQxAFFBEAgAiADaiECIAAgAxDTASIAQfS+wAAoAgBHDQEgASgCBEEDcUEDRw0CQey+wAAgAjYCACAAIAIgARCDAQ8LIAIgA2pBEGohAAwCCyADQYACTwRAIAAQFwwBCyAAQQxqKAIAIgQgAEEIaigCACIFRwRAIAUgBDYCDCAEIAU2AggMAQtB3LvAAEHcu8AAKAIAQX4gA0EDdndxNgIACwJAIAEQvAEEQCAAIAIgARCDAQwBCwJAAkACQEH4vsAAKAIAIAFHBEAgAUH0vsAAKAIARw0BQfS+wAAgADYCAEHsvsAAQey+wAAoAgAgAmoiATYCACAAIAEQoAEPC0H4vsAAIAA2AgBB8L7AAEHwvsAAKAIAIAJqIgE2AgAgACABQQFyNgIEIABB9L7AACgCAEYNAQwCCyABEMsBIgMgAmohAgJAIANBgAJPBEAgARAXDAELIAFBDGooAgAiBCABQQhqKAIAIgFHBEAgASAENgIMIAQgATYCCAwBC0Hcu8AAQdy7wAAoAgBBfiADQQN2d3E2AgALIAAgAhCgASAAQfS+wAAoAgBHDQJB7L7AACACNgIADAMLQey+wABBADYCAEH0vsAAQQA2AgALQZS/wAAoAgAgAU8NAUGAgHxBCEEIEKMBQRRBCBCjAWpBEEEIEKMBamtBd3FBA2siAEEAQRBBCBCjAUECdGsiASAAIAFJG0UNAUH4vsAAKAIARQ0BQQhBCBCjASEAQRRBCBCjASEBQRBBCBCjASECQQACQEHwvsAAKAIAIgQgAiABIABBCGtqaiICTQ0AQfi+wAAoAgAhAUGEv8AAIQACQANAIAEgACgCAE8EQCAAEMYBIAFLDQILIAAoAggiAA0AC0EAIQALIAAQzQENACAAQQxqKAIAGgwAC0EAEBlrRw0BQfC+wAAoAgBBlL/AACgCAE0NAUGUv8AAQX82AgAPCyACQYACSQ0BIAAgAhAWQZy/wABBnL/AACgCAEEBayIANgIAIAANABAZGg8LDwsgAkEDdiIDQQN0QeS7wABqIQECf0Hcu8AAKAIAIgJBASADdCIDcQRAIAEoAggMAQtB3LvAACACIANyNgIAIAELIQMgASAANgIIIAMgADYCDCAAIAE2AgwgACADNgIIC4kHAgV+EH8jAEGQAmsiCSQAIABB6AAQ0AEhEiAJQTBqIgBB4AEQ0AEaA0AgCEE4RgRAIAFBCGohFCACQQhqIRUgAiENIAEhE0EBIQsgCSkDMCIDIQYgCUE4aikDACIEIQcFIAlBIGogAiAIaikDACIDIANCP4cgASAIaikDACIDIANCP4cQLyAAIAlBKGopAwA3AwggACAJKQMgNwMAIABBEGohACAIQQhqIQgMAQsLA0AgEiAQQQN0aiADQv//////////A4M3AwAgBEIGhiADQjqIhCEDIARCOochBAJAAkACQCALQQdGBEBBByEKQQAhDkEGIQsMAQsgECALQQF2IgBrIQwgDSAAQQN0IhFrIRYgEyARayEXIAQgCUEwaiALQQR0aiIKQQhqKQMAIAd8IAopAwAiBCAGfCIGIARUrXwiB3wgAyAGfCIDIAZUrXwhBCALQQFqIQ9BMCEIIBQhCiAVIQ4DQCAAIAtPDQMgCCARRg0CIAxBB0kEQCAJQRBqIAggFmpBMGspAwAgDiARaikDAH0iBSAFQj+HIAogEWopAwAgCCAXakEwaykDAH0iBSAFQj+HEC8gCSkDECIFIAN8IgMgBVStIAlBGGopAwAgBHx8IQQgAEEBaiEAIAxBAWshDCAKQQhqIQogDkEIaiEOIAhBCGshCAwBCwsgDEEHQdSbwAAQOwALA0ACQCAKQQ1HBEAgCyAKQQF2Ig1rIQwgDiANQQN0IgBrIQggAEEIaiEAIAQgByAKQQR0IAlqQUBqIg9BCGopAwB9IAYgDykDACIEVK19Igd8IAYgBH0iBiADfCIDIAZUrXwhBCAKQQFqIQ8DQCANQQVLDQIgDEEGTQRAIAkgAiAIakEwaikDACAAIAJqKQMAfSIFIAVCP4cgACABaikDACABIAhqQTBqKQMAfSIFIAVCP4cQLyAJKQMAIgUgA3wiAyAFVK0gCUEIaikDACAEfHwhBCANQQFqIQ0gCEEIayEIIAxBAWshDCAAQQhqIQAMAQsLIAxBB0Hkm8AAEDsACyASIAM3A2ggCUGQAmokAA8LIBIgCkEDdGogA0L//////////wODNwMAIARCBoYgA0I6iIQhAyAOQQhqIQ4gC0EBaiELIARCOochBCAPIQoMAAsAC0EHQQdBxJvAABA7AAsgDUEIaiENIBNBCGohEyAQQQFqIRAgDyELDAALAAuqAwEBfyMAQdAGayIGJAAgBkHAABDQASIGQUBrQagCENABEEQDQCABBEAgBkFAa0EAEDwgAUEBayEBDAEFIAIEQCAGQUBrIAIgAxB0CwsLIAQEQCAGQUBrIAQgBRB0CyAGQZAGaiIDQgA3AAAgA0EYakIANwAAIANBEGpCADcAACADQQhqQgA3AAAgBkFAayIBKAIEIQQgASgCACEFQYABIQIDQCABIAIQPEEAIQIgASgCAEH/A3FBwANHDQALIAFB5ABqIAU2AgAgAUHgAGogBDYCACABEA9BACEEA0AgAkEgRgRAIAEQRAUgAiADaiABIAJBfHFqQQhqKAIAIARBf3NBGHF2OgAAIARBCGohBCACQQFqIQIMAQsLQQAhAQNAIAFBIEcEQCABIAZqIAZBkAZqIAFqLQAAOgAAIAFBAWohAQwBCwtBACEBAkACQANAAkAgAUEgRg0DIAFBwABGDQAgAUHAAEYNAiAAIAFqIAEgBmotAAA6AAAgAUEBaiEBDAELC0HAAEHAAEH8qsAAEDsAC0HAAEHAAEGMq8AAEDsACyAGQdAGaiQAC74EAQl/IwBBgAxrIgIkACACIAAQjAEgAkGAAmoiCUE4ENABGiACQQE2ArgCIAJBwAJqQTgQ0AEaIAJB+AJqQQE2AgAgAkGAA2pBOBDQARogAkG4A2pBATYCACACQcADakE4ENABGiACQfgDakEBNgIAIAJBgARqIgYgAEGAAmoiBxCMASACQYAGaiIFQTgQ0AEaIAJBATYCuAYgAkHABmpBOBDQARogAkH4BmpBATYCACACQYAHakE4ENABGiACQbgHakEBNgIAIAJBwAdqQTgQ0AEaIAJB+AdqQQE2AgAgAkGACGoiAyAAEIwBIAJBgApqIgQgARCMASACIAEQGCAGIAFBgAJqIggQGCADIAcQlwEgBCAIEJcBIAMQsAEgBBCwASAJIAMQlgEgCSAEEBggAyAHEJYBIAMgAEGABGoiChCXASAEIAgQlgEgBCABQYAEaiIIEJcBIAMQsAEgBBCwASAFIAMQlgEgBSAEEBggAyACEJYBIAMQKyAEIAYQlgEgBBArIAkgAxCXASAHIAkQlgEgByAEEJcBIAUgBBCXASAGIAMQlwEgAyAAEJYBIAMgChCXASADELABIAQgARCWASAEIAgQlwEgBBCwASADIAQQGCAGIAMQlwEgAyAKEJYBIAMgCBAYIAQgAxCWASAEECsgCiAGEJYBIAogBBCXASAFIAQQlwEgAxBkIAcgAxCXASAFELABIAUQZCAAIAIQlgEgACAFEJcBIABBBTYCgAYgABCdASACQYAMaiQAC4oEAQp/IwBBgAhrIgIkACACIAAQXiACIAEQESACQYABaiIHIABBgAFqIgkQXiAHIAFBgAFqIgQQESACQYACaiIGIABBgAJqIgoQXiAGIAFBgAJqIgsQESACQYADaiIIIAAQXiAIIAkQmgEgCBCpASACQYAEaiIFIAEQXiAFIAQQmgEgBRCpASAIIAUQESAFIAIQmQEgBSAHEJoBIAggBRB7IAgQqQEgBSAJEJkBIAUgChCaASAFEKkBIAJBgAVqIgMgBBBeIAMgCxCaASADEKkBIAUgAxARIAMgBxCZASADIAYQmgEgBSADEHsgBRCpASADIAAQmQEgAyAKEJoBIAMQqQEgAkGABmoiBCABEF4gBCALEJoBIAQQqQEgAyAEEBEgBCACEJkBIAQgBhCaASAEIAMQvwEgBBCpASADIAIQmQEgAyACEJoBIAIgAxCaASACEKkBIAZBDBCrASAGEHwgBhCpASACQYAHaiIBIAcQXiABIAYQmgEgARCpASAHIAYQeyAHEKkBIARBDBCrASAEEHwgBBCpASADIAQQmQEgAyAFEBEgBiAIEJkBIAYgBxARIAMgBhC/ASAEIAIQESAHIAEQESAEIAcQmgEgAiAIEBEgASAFEBEgASACEJoBIAAgAxCZASAAEKkBIAkgBBCZASAJEKkBIAogARCZASAKEKkBIAJBgAhqJAAL8gMBCn8jAEGABGsiAiQAIAIgABCQASACIAEQSiACQUBrIgYgAEFAayIJEJABIAYgAUFAayIEEEogAkGAAWoiByAAQYABaiIKEJABIAcgAUGAAWoiCxBKIAJBwAFqIgggABCQASAIIAkQdyAIEEIgAkGAAmoiBSABEJABIAUgBBB3IAUQQiAIIAUQSiAFIAIQrgEgBSAGEHcgCCAFEH4gAkHAAWoQQiAFIAkQrgEgBSAKEHcgAkGAAmoQQiACQcACaiIDIAQQkAEgAyALEHcgAxBCIAUgAxBKIAMgBhCuASADIAcQdyAFIAMQfiACQYACahBCIAMgABCuASADIAoQdyACQcACahBCIAJBgANqIgQgARCQASAEIAsQdyAEEEIgAyAEEEogBCACEK4BIAQgBxB3IAQgAxDCASACQYADahBCIAMgAhCuASADIAIQdyACIAMQdyACEEIgB0EMEDQgAkHAA2oiASAGEJABIAEgBxB3IAEQQiAGIAcQfiAGEEIgBEEMEDQgAyAEEK4BIAMgBRBKIAcgCBCuASAHIAYQSiADIAcQwgEgBCACEEogBiABEEogBCAGEHcgAiAIEEogASAFEEogASACEHcgACADEK4BIAAQQiAJIAQQrgEgCRBCIAogARCuASAKEEIgAkGABGokAAu/BQEJfyMAQYALayIHJAAgB0E4ENABIgVBATYCOCAFQUBrQTgQ0AEaIAVB+ABqQQE2AgAgBUGAAWpBOBDQARogBUG4AWpBATYCACAFQcABakE4ENABGiAFQfgBakEBNgIAIAVBgAJqIg1BOBDQARogBUEBNgK4AiAFQcACakE4ENABGiAFQfgCakEBNgIAIAVBgANqQTgQ0AEaIAVBuANqQQE2AgAgBUHAA2pBOBDQARogBUH4A2pBATYCACAFQYAEaiILQTgQ0AEaIAVBATYCuAQgBUHABGpBOBDQARogBUH4BGpBATYCACAFQYAFakE4ENABGiAFQbgFakEBNgIAIAVBwAVqQTgQ0AEaIAVB+AVqQQE2AgAgBUGABmoiCEE4ENABGiAFQQE2ArgGIAVBwAZqQTgQ0AEaIAVB+AZqQQE2AgAgBUGAB2oiCUE4ENABGiAFQQE2ArgHIAVBwAdqQTgQ0AEaIAVB+AdqQQE2AgAgBUGACGoiB0E4ENABGiAFQQE2ArgIIAVBwAhqQTgQ0AEaIAVB+AhqQQE2AgAjAEGAAmsiCiQAIApBgAFqIgYgARBeIAggBhCZASAGIAFBgAFqEF4gByAGEJkBIAYgAUGAAmoiDBBeIAogBhBeIAYgDBBeIAkgBhCZASAGIAJBgAFqIgwQXiAKIAYQESAGIAIQXiAJIAYQESAIIAkQeyAIEKkBIAcgChB7IAcQqQEgCiAIEJkBIAgQfCAIEKkBIAYgDBBeIAogBhARIAkgBxCZASAGIAIQXiAJIAYQESAJIAoQeyAJEKkBIAcQNiAHEKkBIAEgAhAIIApBgAJqJAAgByADEKoBIAggBBCqASAFQYAJaiIBIAggCRCVASAFIAEQlgEgASAHEKEBIAsgARCWASALEGQgACAFIA0gCxB1IABBAzYCgAYgBUGAC2okAAuJBQEIfyMAQYALayIFJAAgBUE4ENABIgRBATYCOCAEQUBrQTgQ0AEaIARB+ABqQQE2AgAgBEGAAWpBOBDQARogBEG4AWpBATYCACAEQcABakE4ENABGiAEQfgBakEBNgIAIARBgAJqIgtBOBDQARogBEEBNgK4AiAEQcACakE4ENABGiAEQfgCakEBNgIAIARBgANqQTgQ0AEaIARBuANqQQE2AgAgBEHAA2pBOBDQARogBEH4A2pBATYCACAEQYAEaiIKQTgQ0AEaIARBATYCuAQgBEHABGpBOBDQARogBEH4BGpBATYCACAEQYAFakE4ENABGiAEQbgFakEBNgIAIARBwAVqQTgQ0AEaIARB+AVqQQE2AgAgBEGABmoiBkE4ENABGiAEQQE2ArgGIARBwAZqQTgQ0AEaIARB+AZqQQE2AgAgBEGAB2oiBUE4ENABGiAEQQE2ArgHIARBwAdqQTgQ0AEaIARB+AdqQQE2AgAgBEGACGoiCEE4ENABGiAEQQE2ArgIIARBwAhqQTgQ0AEaIARB+AhqQQE2AgAjAEGAAmsiByQAIAdBgAFqIgkgARBeIAggCRCZASAJIAFBgAFqEF4gByAJEF4gCSABQYACahBeIAUgCRCZASAGIAcQmQEgBiAFEBEgCBAtIAcQLSAFEC0gBhC4ASAGEDYgBhCpASAGEHwgBhCpASAFQQwQqwEgCEEDEKsBIAUQfCAFEKkBIAUgBxB7IAUQqQEgARASIAdBgAJqJAAgCCACEKoBIAYgAxCqASAEQYAJaiIBIAYgBRCVASAEIAEQlgEgASAIEKEBIAogARCWASAKEGQgACAEIAsgChB1IABBAzYCgAYgBEGAC2okAAuBBQELfyMAQTBrIgIkACACQSRqQai1wAA2AgAgAkEDOgAoIAJCgICAgIAENwMIIAIgADYCICACQQA2AhggAkEANgIQAkACQAJAIAEoAggiCkUEQCABQRRqKAIAIgRFDQEgASgCACEDIAEoAhAhACAEQQFrQf////8BcUEBaiIHIQUDQCADQQRqKAIAIgQEQCACKAIgIAMoAgAgBCACKAIkKAIMEQUADQQLIAAoAgAgAkEIaiAAQQRqKAIAEQQADQMgAEEIaiEAIANBCGohAyAFQQFrIgUNAAsMAQsgAUEMaigCACIARQ0AIABBBXQhCyAAQQFrQf///z9xQQFqIQcgASgCACEDA0AgA0EEaigCACIABEAgAigCICADKAIAIAAgAigCJCgCDBEFAA0DCyACIAUgCmoiBEEcai0AADoAKCACIARBBGopAgBCIIk3AwggBEEYaigCACEGIAEoAhAhCEEAIQlBACEAAkACQAJAIARBFGooAgBBAWsOAgACAQsgBkEDdCAIaiIMKAIEQQ9HDQEgDCgCACgCACEGC0EBIQALIAIgBjYCFCACIAA2AhAgBEEQaigCACEAAkACQAJAIARBDGooAgBBAWsOAgACAQsgAEEDdCAIaiIGKAIEQQ9HDQEgBigCACgCACEAC0EBIQkLIAIgADYCHCACIAk2AhggCCAEKAIAQQN0aiIAKAIAIAJBCGogACgCBBEEAA0CIANBCGohAyALIAVBIGoiBUcNAAsLQQAhACAHIAEoAgRJIgNFDQEgAigCICABKAIAIAdBA3RqQQAgAxsiASgCACABKAIEIAIoAiQoAgwRBQBFDQELQQEhAAsgAkEwaiQAIAAL1wQBBH8gACABENIBIQICQAJAAkAgABDMAQ0AIAAoAgAhAwJAIAAQxAFFBEAgASADaiEBIAAgAxDTASIAQfS+wAAoAgBHDQEgAigCBEEDcUEDRw0CQey+wAAgATYCACAAIAEgAhCDAQ8LIAEgA2pBEGohAAwCCyADQYACTwRAIAAQFwwBCyAAQQxqKAIAIgQgAEEIaigCACIFRwRAIAUgBDYCDCAEIAU2AggMAQtB3LvAAEHcu8AAKAIAQX4gA0EDdndxNgIACyACELwBBEAgACABIAIQgwEMAgsCQEH4vsAAKAIAIAJHBEAgAkH0vsAAKAIARw0BQfS+wAAgADYCAEHsvsAAQey+wAAoAgAgAWoiATYCACAAIAEQoAEPC0H4vsAAIAA2AgBB8L7AAEHwvsAAKAIAIAFqIgE2AgAgACABQQFyNgIEIABB9L7AACgCAEcNAUHsvsAAQQA2AgBB9L7AAEEANgIADwsgAhDLASIDIAFqIQECQCADQYACTwRAIAIQFwwBCyACQQxqKAIAIgQgAkEIaigCACICRwRAIAIgBDYCDCAEIAI2AggMAQtB3LvAAEHcu8AAKAIAQX4gA0EDdndxNgIACyAAIAEQoAEgAEH0vsAAKAIARw0BQey+wAAgATYCAAsPCyABQYACTwRAIAAgARAWDwsgAUEDdiICQQN0QeS7wABqIQECf0Hcu8AAKAIAIgNBASACdCICcQRAIAEoAggMAQtB3LvAACACIANyNgIAIAELIQIgASAANgIIIAIgADYCDCAAIAE2AgwgACACNgIIC+UDAQN/IwBB0CJrIgMkACADQcAWaiIEQcitwAAQSSADQcgcaiIFQYCuwAAQSSADQQhqIAQgBRBLIANBiAFqQTgQ0AEaIANBwAFqQTgQ0AEaIANB+AFqED0CQCACEIYBBEAgABBVDAELIANB+ARqIgQQPSAEIAEQfSAEEEcgA0H4B2oiARBnIAEgAhB4IAEQRiADQcgcaiICIAEQkAEgA0G4CWogAhCQASACIANBuAhqEJABIANB+AlqIAIQkAEgA0G4CmoiARA9IANBuA1qEFUgASAEEH0gA0HAE2oiARA9IAEgBBB9IAEQogEgA0HAAWogA0GIAWoQUEECayECA0AgAkEBakEBTQRAIANBuA1qIgEQngEgACABQYgGENEBGgUgA0G4DWoQGiADQcAWaiADQbgKaiADQbgJaiADQfgJahALAkACQAJAIANBwAFqIAIQUyADQYgBaiACEFNrQQFqDgMBAgACCyADQcgcaiIBIANBuApqIANB+ARqIANBuAlqIANB+AlqEAogA0HAFmogARADDAELIANByBxqIgEgA0G4CmogA0HAE2ogA0G4CWogA0H4CWoQCiADQcAWaiABEAMLIAJBAWshAiADQbgNaiADQcAWahABDAELCwsgA0HQImokAAvBAwEVfwNAIANBwAFGBEACQCAAQShqIQsgAEEUaigCACIMIQggAEEQaigCACINIQIgAEEMaigCACIOIQEgACgCCCIPIQMgAEEYaigCACIQIQogAEEcaigCACIRIQQgAEEgaigCACISIQcgAEEkaigCACITIQYDQCAHIQkgBCEHIAohBCAFQYACRg0BIAEgAnEhFCABIAJzIRUgBSALaigCACAFQcCiwABqKAIAIAkgBEF/c3EgBCAHcXIgBmogBEEadyAEQRV3cyAEQQd3c2pqaiIGIAhqIQogBUEEaiEFIAIhCCABIQIgAyIBQR53IAFBE3dzIAFBCndzIBQgASAVcXNqIAZqIQMgCSEGDAALAAsFIAAgA2oiAkHoAGogAkEoaigCACACQcwAaigCACACQeAAaigCACIBQQ93IAFBDXdzIAFBCnZzamogAkEsaigCACIBQRl3IAFBDndzIAFBA3ZzajYCACADQQRqIQMMAQsLIAAgBiATajYCJCAAIAkgEmo2AiAgACAHIBFqNgIcIAAgBCAQajYCGCAAIAggDGo2AhQgACACIA1qNgIQIAAgASAOajYCDCAAIAMgD2o2AggL5AEBAn8jAEGAA2siAyQAIAMQPSAAIAEgAkEfdSIEIAJzIARBf3NqQQJtIgJBAWtBH3YQbyAAIAFBgANqIAJBAXNBAWtBH3YQbyAAIAFBgAZqIAJBAnNBAWtBH3YQbyAAIAFBgAlqIAJBA3NBAWtBH3YQbyAAIAFBgAxqIAJBBHNBAWtBH3YQbyAAIAFBgA9qIAJBBXNBAWtBH3YQbyAAIAFBgBJqIAJBBnNBAWtBH3YQbyAAIAFBgBVqIAJBB3NBAWtBH3YQbyADIAAQfSADEKIBIAAgAyAEQQFxEG8gA0GAA2okAAvlAwEIfyMAQZAGayICJAAgAEFAayEIAkAgAUH4AGooAgAgASgCOGqsIABB+ABqKAIAIgcgACgCOCIEaqx+Qv///w9XDQAgBEEBSgR/IAAQHiAAKAJ4BSAHC0EBTA0AIAgQHgsgAkHYpMAAEEkgAkE4aiIHQfAAENABGiACIQNBACECA0AgAkE4RgRAAkAgB0E4aiEEQQAhAgNAIAJBOEYNASACIARqIAIgA2opAwA3AwAgAkEIaiECDAALAAsFIAIgB2pCADcDACACQQhqIQIMAQsLIANBqAFqIgYgABBdIANB4AFqIgUgARBdIANBmAJqIgIgACABEAUgA0GIA2oiBCAIIAFBQGsiARAFIAYgCBBgIAYQQiAFIAEQYCAFEEIgA0H4A2oiCSAGIAUQBUEAIQEgA0HoBGoiBkHwABDQASEFA0AgAUHwAEcEQCABIAVqIAEgAmopAwA3AwAgAUEIaiEBDAELCyAGIAQQYkEAIQEDQCABQfAARwRAIAEgBGoiBSABIAdqKQMAIAUpAwB9NwMAIAFBCGohAQwBCwsgAiAEEGIgAhBIIAkgBhBjIAkQSCADQdgFaiIBIAIQayAAIAEQaiAAQQM2AjggASAJEGsgCCABEGogAEECNgJ4IANBkAZqJAALowIBCH8jAEGABmsiAiQAIAIgAEGAAWoiBxBeIAJBgAFqIgQgBxBeIAQQLSACQYACaiIFIAIQXiAFIABBgAJqIgMQESACQYADaiIBIAMQXiABEC0gAyAEEJkBIAMgBBCaASADEKkBIAMQuAEgAxC4ASADEKkBIAFBDBCrASABEHwgARCpASACQYAEaiIIIAEQXiAIIAMQESACQYAFaiIGIAQQXiAGIAEQmgEgBhCpASADIAUQESAFIAEQmQEgBSABEJoBIAEgBRCaASABEKkBIAQgARB7IAQQqQEgBiAEEBEgBiAIEJoBIAUgABCZASAFIAIQESAAIAQQmQEgABCpASAAIAUQESAAELgBIAAQqQEgByAGEJkBIAcQqQEgAkGABmokAAu8AgEGfyMAQYAIayIBJAAgASAAEIwBIAFBgAJqIgMgAEGABGoiBRCMASABQYAEaiIEIABBgAJqIgYQjAEgAUGABmoiAkE4ENABGiABQQE2ArgGIAFBwAZqQTgQ0AEaIAFB+AZqQQE2AgAgAUGAB2pBOBDQARogAUG4B2pBATYCACABQcAHakE4ENABGiABQfgHakEBNgIAIAAQISACIAAQlgEgAiAAEJcBIAAgAhCXASAAELABIAEQyQEgARCzASAAIAEQlwEgAxAhIAMQZCACIAMQlgEgAiADEJcBIAMgAhCXASADELABIAQQISACIAQQlgEgAiAEEJcBIAQgAhCXASAEELABIAYQsgEgBhCzASAFEMkBIAUQswEgBiADEJcBIAUgBBCXASAAQQU2AoAGIAAQnAEgAUGACGokAAv/AQEHfyMAQcACayIBJAAgASAAQUBrIgYQkAEgARBMIAFBQGsiAyAGEJABIAMgAEGAAWoiAhBKIAFBgAFqIgQgAhCQASAEEEwgAiABEK4BIAIgARB3IAIQQiACEIIBIAIQggEgAhBCIARBDBA0IAFBwAFqIgcgBBCQASAHIAIQSiABQYACaiIFIAEQkAEgBSAEEHcgBRBCIAIgAxBKIAMgBBCuASADIAQQdyAEIAMQdyABIAQQfiABEEIgBSABEEogBSAHEHcgAyAAEK4BIAMgBhBKIAAgARCuASAAEEIgACADEEogABCCASAAEEIgBiAFEK4BIAYQQiABQcACaiQAC84CAgd/An4CQAJAAkBBDSABQTpuIgJrIgRBDU0EQEEMIAJrIgNBDk8NASAAIAAgA0EDdGopAwBBOiABIAJBOmxrIgNrrSIKhyAAIARBA3RqKQMAIAOtIgmGhDcDaCAEQQ1rIQUgAEHgAGohBCACQQFqIQZBACACQQN0ayEHQQshAwNAAkAgA0ECaiAGTQRAIAFBrAZPDQEgACACQQN0aiAAKQMAIAmGQv//////////A4M3AwADQCACRQ0HIABCADcDACACQQFrIQIgAEEIaiEADAALAAsgAyAFakEOTw0EIAQgBCAHaiIIQQhrKQMAIAqHIAgpAwAgCYZC//////////8Dg4Q3AwAgA0EBayEDIARBCGshBAwBCwsgAkEOQYCywAAQOwALIARBDkHQscAAEDsACyADQQ5B4LHAABA7AAtBf0EOQfCxwAAQOwALC6cCAQR/IABCADcCECAAAn9BACABQYACSQ0AGkEfIAFB////B0sNABogAUEGIAFBCHZnIgNrdkEBcSADQQF0a0E+agsiBDYCHCAEQQJ0Qey9wABqIQMgACECAkACQAJAAkBB4LvAACgCACIAQQEgBHQiBXEEQCADKAIAIQMgBBCfASEAIAMQywEgAUcNASADIQAMAgtB4LvAACAAIAVyNgIAIAMgAjYCAAwDCyABIAB0IQQDQCADIARBHXZBBHFqQRBqIgUoAgAiAEUNAiAEQQF0IQQgACIDEMsBIAFHDQALCyAAKAIIIgEgAjYCDCAAIAI2AgggAiAANgIMIAIgATYCCCACQQA2AhgPCyAFIAI2AgALIAIgAzYCGCACIAI2AgggAiACNgIMC7YCAQV/IAAoAhghBAJAAkAgACAAKAIMRgRAIABBFEEQIABBFGoiASgCACIDG2ooAgAiAg0BQQAhAQwCCyAAKAIIIgIgACgCDCIBNgIMIAEgAjYCCAwBCyABIABBEGogAxshAwNAIAMhBSACIgFBFGoiAygCACICRQRAIAFBEGohAyABKAIQIQILIAINAAsgBUEANgIACwJAIARFDQACQCAAIAAoAhxBAnRB7L3AAGoiAigCAEcEQCAEQRBBFCAEKAIQIABGG2ogATYCACABDQEMAgsgAiABNgIAIAENAEHgu8AAQeC7wAAoAgBBfiAAKAIcd3E2AgAPCyABIAQ2AhggACgCECICBEAgASACNgIQIAIgATYCGAsgAEEUaigCACIARQ0AIAFBFGogADYCACAAIAE2AhgLC+UBAQZ/IwBBgARrIgIkACACIAAQXiACQYABaiIFIABBgAFqIgYQXiACQYACaiIDQTgQ0AEaIAJBATYCuAIgAkHAAmpBOBDQARogAkH4AmpBATYCACACQYADaiIEIAYQXiACIAEQESAFIAFBgAFqIgcQESADIAcQmQEgAyABEJoBIAQgABCaASADEKkBIAQQqQEgBCADEBEgAyACEJkBIAMQNiAEIAMQmgEgBBCpASADIAUQmQEgAxA2IAYgBBCZASAGIAMQmgEgBRB8IAAgBRCZASAAIAIQmgEgABCwASACQYAEaiQAC28BDH9BjL/AACgCACICRQRAQZy/wABB/x82AgBBAA8LQYS/wAAhBgNAIAIiASgCCCECIAEoAgQhAyABKAIAIQQgAUEMaigCABogASEGIAVBAWohBSACDQALQZy/wAAgBUH/HyAFQf8fSxs2AgBBAAuAAgEGfyMAQYAIayIBJAAgACgCgAZBAUcEQCABIAAQjAEgAUGAAmoiAiAAQYACaiIEEIwBIAFBgARqIgUgAEGABGoiAxCMASABQYAGaiIGIAAQjAEgARAhIAIgAxAYIAIQswEgAhCwASAFECEgBiAEEBggBhCzASADIAAQlwEgAyAEEJcBIAMQsAEgAxAhIAAgARCWASABIAIQlwEgARCwASABIAUQlwEgASAGEJcBIAEQsAEgARArIAIQZCAFEGQgACACEJcBIAQgBRCWASAEIAYQlwEgAyABEJcBIABBBEEFIAAoAoAGQX5xQQJGGzYCgAYgABCdAQsgAUGACGokAAuZAgEBfyMAQYANayIDJAAgAyABEGkgAxCdASADQYgGaiIBIAIQXSABEEIgA0HABmoiAiABEF0gAkEDECkaIAIQQiADQfgGaiADEGkCQCACEFdFBEAgA0HABmoQKkECayECA0AgAkEBakEBTQRAIANB+AZqIgEQnAEMAwUgA0H4BmoQEwJAAkACQCADQcAGaiACEFMgA0GIBmogAhBTa0EBag4DAQIAAgsgA0H4BmogAxAHDAELIAMQngEgA0H4BmogAxAHIAMQngELIAJBAWshAgwBCwALAAsgA0H4BmoiARC3ASABQYABahC2ASABQYACahCxASABQYAEahCxASABQQE2AoAGCyAAIAFBiAYQ0QEaIANBgA1qJAALhgICBH8BfiMAQTBrIgIkACABQQRqIQQgASgCBEUEQCABKAIAIQMgAkEQaiIFQQA2AgAgAkIBNwMIIAIgAkEIajYCFCACQShqIANBEGopAgA3AwAgAkEgaiADQQhqKQIANwMAIAIgAykCADcDGCACQRRqIAJBGGoQDBogBEEIaiAFKAIANgIAIAQgAikDCDcCAAsgAkEgaiIDIARBCGooAgA2AgAgAUEMakEANgIAIAQpAgAhBiABQgE3AgQgAiAGNwMYQQxBBBC5ASIBRQRAQQxBBBDPAQALIAEgAikDGDcCACABQQhqIAMoAgA2AgAgAEGEt8AANgIEIAAgATYCACACQTBqJAAL5AEBAn8jAEHAAWsiAyQAIAMQZyAAIAEgAkEfdSIEIAJzIARBf3NqQQJtIgJBAWtBH3YQbiAAIAFBwAFqIAJBAXNBAWtBH3YQbiAAIAFBgANqIAJBAnNBAWtBH3YQbiAAIAFBwARqIAJBA3NBAWtBH3YQbiAAIAFBgAZqIAJBBHNBAWtBH3YQbiAAIAFBwAdqIAJBBXNBAWtBH3YQbiAAIAFBgAlqIAJBBnNBAWtBH3YQbiAAIAFBwApqIAJBB3NBAWtBH3YQbiADIAAQeCADEKQBIAAgAyAEQQFxEG4gA0HAAWokAAvDAwIGfwN+IwBB8ABrIgEkACABQcCywAAQSSABQThqIAEQXSAAEEICQAJAAkAgAQJ/IAAoAjgiAkEQTARAIAJBAWsQNQwBCyABKQMwIghCAXwiByAIVA0BIAApAzAiCEKAgICAgICAgIB/USAHQn9RcQ0CIAFBOGoiAiAIIAd/pxApIQcgASABKQNoIAdCOoZ8NwNoIAAgAhBhIAAQQkECCyIEECgDQCAERQ0DQQAhAyABIAEpAwgiCEI5hkKAgICAgICAgAKDIAEpAwBCAYeEIgc3AwAgACkDACAHfSEHIABBCGohBSAAIAFBOGoiAkEBA38gAiADaiAHQv//////////A4M3AwAgB0I6hyEHIANBKEYEfyABIAEpAzBCAYciCDcDMCACIAApAzAgCH0gB3wiBzcDMCAHQj+IpwUgASADaiIGQQhqIAhCAYcgBkEQaikDACIIQjmGQoCAgICAgICAAoOEIgk3AwAgAyAFaikDACAHfCAJfSEHIANBCGohAwwBCwtrEDAgBEEBayEEDAALAAtB4LPAAEEZQcSzwAAQWQALQYC0wABBH0HEs8AAEFkACyAAQQE2AjggAUHwAGokAAvuAQECfyMAQbABayIDJAAgA0EwENABIQMCQAJAA0AgAkEwRgRAIANBMGogAxBwIAFBMGohAUEAIQIDQCACQTBGDQMgAkEwRg0EIAIgA2ogASACai0AADoAACACQQFqIQIMAAsACyACQeAARwRAIAIgA2ogASACai0AADoAACACQQFqIQIMAQsLQeAAQeAAQYCmwAAQOwALIANB8ABqIgEgAxBwIABBOBDQASIAQQE2AjggAEFAa0E4ENABIABB+ABqQQE2AgAgACABEK4BIANBMGoQrgEgA0GwAWokAA8LIAJBMGpB4ABBkKbAABA7AAuPAgEDfyMAQSBrIgUkAEEBIQZB2LvAAEHYu8AAKAIAIgdBAWo2AgACQEGgv8AALQAABEBBpL/AACgCAEEBaiEGDAELQaC/wABBAToAAAtBpL/AACAGNgIAAkACQCAHQQBIIAZBAktyDQAgBSAEOgAYIAUgAzYCFCAFIAI2AhBBzLvAACgCACICQQBIDQBBzLvAACACQQFqIgI2AgBBzLvAAEHUu8AAKAIAIgMEf0HQu8AAKAIAIAUgACABKAIQEQAAIAUgBSkDADcDCCAFQQhqIAMoAhQRAABBzLvAACgCAAUgAgtBAWs2AgAgBkEBSw0AIAQNAQsACyMAQRBrIgIkACACIAE2AgwgAiAANgIIAAucAQEEfyMAQYADayICJAAgAiAAEF4gAkGAAWoiASAAQYABaiIEEF4gAkGAAmoiAyAAEF4gAyAEEBEgAiAEEJoBIAEQfCABIAAQmgEgAhCpASABEKkBIAAgAhCZASAAIAEQESABIAMQmQEgARB8IAEgAxCaASABEKkBIAEQNiAAIAEQmgEgAxC4ASAEIAMQmQEgABCwASACQYADaiQAC7kBAQJ/IwBBIGsiAyQAAkAgASABIAJqIgFLDQAgAEEEaigCACICQQF0IgQgASABIARJGyIBQQggAUEISxshAQJAIAIEQCADQRhqQQE2AgAgAyACNgIUIAMgACgCADYCEAwBCyADQQA2AhALIAMgASADQRBqECYgAygCAARAIANBCGooAgAiAEUNASADKAIEIAAQzwEACyADKAIEIQIgAEEEaiABNgIAIAAgAjYCACADQSBqJAAPCxBlAAusAQECfyMAQYADayIDJAAgA0EIaiABEJABAkAgAgRAIANBCGogAhCuAQwBCyADQQhqEDoLIANByABqIgJB8LTAABBJIANBgAFqIAIQjgEgA0HAAWoiAiADQQhqIgQQkAEgAhBMIAIgARBKIAAgARCQASAAIAQQSiADQYACaiACEJABIAAQViEBIANBwAJqIgIgABCQASACEEMgAhBCIAAgAiABEHIgA0GAA2okAAueAQEFfyMAQYABayICJAAgAkE4ENABIgJBATYCOCACQUBrIgNBOBDQARogAkEBNgJ4IAIgABCuASACIAFBgAFqIgUQSiADIAEQrgEgAyAAQYABaiIGEEoCQCACIAMQWEUNACACIABBQGsQrgEgAiAFEEogAkFAayIAIAFBQGsQrgEgACAGEEogAiAAEFhFDQBBASEECyACQYABaiQAIAQLpwEBA38jAEEwayICJAAgAUEEaiEDIAEoAgRFBEAgASgCACEBIAJBEGoiBEEANgIAIAJCATcDCCACIAJBCGo2AhQgAkEoaiABQRBqKQIANwMAIAJBIGogAUEIaikCADcDACACIAEpAgA3AxggAkEUaiACQRhqEAwaIANBCGogBCgCADYCACADIAIpAwg3AgALIABBhLfAADYCBCAAIAM2AgAgAkEwaiQAC5UBAQJ/AkACQAJAAkACfwJAAkACf0EBIgMgAUEASA0AGiACKAIAIgRFDQEgAigCBCICDQQgAQ0CQQEMAwshA0EAIQEMBgsgAQ0AQQEMAQsgAUEBELkBCyICRQ0BDAILIAQgARCsASICDQELIAAgATYCBEEBIQEMAQsgACACNgIEQQAhAwsgACADNgIAIABBCGogATYCAAvvMwISfwV+IwBBMGsiDiQAIA5BEGogACABEFsgDiAOKAIUIgA2AhwgDiAOKAIQIgg2AhggDkEIaiACIAMQWyAOIA4oAgwiATYCJCAOIA4oAggiAzYCICAOIAQgBRBbIA4gDigCBCIFNgIsIA4gDigCACINNgIoIAAhBCMAQZAVayICJAAjAEGwBmsiCiQAIApBEGpBOBDQARogCkHQAGpBOBDQASEVIApBiAFqQQE2AgAgCkEBNgJIIApBkAFqIgBB2KTAABBJIAAQKiEPIApByAFqIhNBgAIQ0AEaIApByANqQYABENABGiMAQdAAayIRJAAgEUEQakHAABDQARogASEJQQAhACMAQYAEayIHJAAgB0EvakGBAhDQARogB0GwAmpBwAAQ0AEaIAdB8AJqQcAAENABGiAHQbADakHAABDQARogByAPQf8AakEDdkEBaiISQQF0IgFBCHQgAUGA/gNxQQh2cjsALCABQQFrQQV2QQFqIQsCQANAIAYgB2pBLmogADoAACAGQStGBEAgB0EsaiIGQS5qQSs6AAAgB0EgaiAGQS8QX0EAIQAgB0GwAmpBwAAgAyAJIAcoAiAgBygCJBAGIAdBADoA+AMgByALNgL0A0EAIAFrIRQgB0EBNgLwAyAGQSxqIRYMAgsgBkGBAkcEQCAGQcClwABqLQAAIQAgBkEBaiEGDAELCyAGQQNqQYQCQfCrwAAQOwALA0ACQCAHQRhqIQlBACEGQQAhCwJAIAdB8ANqIgMtAAgNACADKAIAIgsgAygCBCIXSw0AIAsgF08EQEEBIQYgA0EBOgAIDAELQQEhBiADIAtBAWo2AgALIAkgCzYCBCAJIAY2AgACQCAHKAIYBEAgBygCHCEDQQAhBgNAIAZBIEYEQCAHIAM6ACxBACEGAkACQANAIAZBK0YEQCAWQSs6AAAjAEEQayIDJAAgA0EIaiAHQbADakHAAEEgEIEBIAMoAgwhCSAHQRBqIgYgAygCCDYCACAGIAk2AgQgA0EQaiQAIAcoAhQhAyAHKAIQIQkgB0EIaiAHQSxqQS0QX0EAIQYgB0HwAmpBACAJIAMgBygCCCAHKAIMEAZBAEGAAiAAayIDIANBgAJLGyEDIAAgE2ohCSAAIBRqIQsDQCAGQSBGDQggBkHAAEYNBCADIAZGDQMgBiAJaiAHQfACaiAGai0AADoAACAGQQFqIgYgC2oNAAsgASEADAkLIAZBgwJHBEAgBiAHakEtaiAGQcClwABqLQAAOgAAIAZBAWohBgwBCwsgBkEBakGEAkGwrMAAEDsACyAAIAZqQYACQYCtwAAQOwALQcAAQcAAQfCswAAQOwALIAZBwABHBEAgB0HwAmogBmoiCSAJLQAAIAdBsAJqIAZqLQAAcyIJOgAAIAdBsANqIAZqIAk6AAAgBkEBaiEGDAELC0HAAEHAAEGgrMAAEDsACyAHQYAEaiQADAELIAAgBmohAAwBCwsgEUHQAGokACASQQN0IA9rIQlBACEAAkACQANAIABBAkcEQCAAQQFqIApByAFqIBBqIQZBACEDAkADQCADIBJGDQEgAyAQaiIHQf8BSw0EIANBgAFHBEAgCkHIA2ogA2ogAyAGai0AADoAACADQQFqIQMMAQsLQYABQYABQaClwAAQOwALIwBBEGsiAyQAIANBCGogCkHIA2pBgAEgEhCBASADKAIMIQYgCkEIaiIHIAMoAgg2AgAgByAGNgIEIANBEGokACAKKAIIIQMgCigCDCELIApBwAVqIg9B8AAQ0AEhBgNAIAsEQCAGQQgQFSAGIAYpAwAgAzEAAHw3AwAgC0EBayELIANBAWohAwwBCwsgCkGIBWohEyMAQeABayILJAAgDxBIIAsgCkGQAWoQLiALQfAAakHwABDQARogCyAJIgMQFQNAIAtB8ABqIQZBACEHA0AgB0HwAEcEQCAGIAdqIAcgD2opAwA3AwAgB0EIaiEHDAELCyAGIAsQYyAGEEhBACEHQgAhGCAGKQMIIA8pAwCFIhlCAYZCAYchG0F/IAspA9gBQj+Hp2usIRwDfiAHQfAARgR+IBgFIAcgD2oiESARKQMAIhogGYUgBiAHaikDACAahSAcg4UiGiAbhTcDACAYIBqFIRggB0EIaiEHDAELCxogAwRAQQAhBkEAIQdBACERAkACQANAIAZB6ABGBEAgC0HoAGogCykDaEIBhzcDACALQfAAaiEGA0AgB0UNBCAGQgA3AwAgB0EBayEHIAZBCGohBgwACwALIAZB8ABGDQEgBkHwAEcEQCAGIAtqIhQgFEEIaikDAEI5hkL//////////wODIBQpAwBCAYeENwMAIBFBAWohESAGQQhqIQYMAQsLQQ5BDkGgssAAEDsACyARQQ5BkLLAABA7AAsgA0EBayEDDAEFIBMgDxBdIAtB4AFqJAALCyAKQcgEaiIDIBMQjgEgCkEQaiAAQQZ0aiADQcAAENEBGiAQIBJqIRAhAAwBCwsgAiAKQRBqEAIgCkHIAWoiACAVEAIgAiAAEAkjAEGAAmsiACQAIABBCGoiAUHYgcAAEEkgAEFAayIDIAIgARC9ASACIAMQeCAAQYACaiQAIAIQRiAKQbAGaiQADAELIAdBgAJBkKXAABA7AAsgAkHAAWohASMAQeACayIAJAAgAEEwENABIgBBMGpB0IDAABBJAkACQAJAAkADQAJAIAxBMEYEQCAAIAAtAABBH3E6AAAgAEHoAGogABC+ASAEDQFBAEEAQZiBwAAQOwALIAQgDEYNAiAAIAxqIAggDGotAAA6AAAgDEEBaiEMDAELC0EAIQwgCCwAACIJQQBIDQIgCEEwaiEDIARBMCAEQTBLG0EwayEIA0AgDEEwRgRAIABBoAFqIgQgABC+ASMAQYABayIDJAAgARBnIAEgAEHoAGoQwAEgAUFAayIIIAQQwAEgAUGAAWoQygEgARBCIAMgARBPIANBQGsiBCAIEJABIAQQTCAEIAMQWEUEQCABEJIBCyADQYABaiQADAULIAggDEYNAiAAIAxqIAMgDGotAAA6AAAgDEEBaiEMDAALAAsgBCAEQYiBwAAQOwALIAxBMGogBEGogcAAEDsACyMAQcABayIDJAAgAEGgAWoiBBBnIANBOBDQASIDQQE2AjggBCAAQegAahDAASAEEEIgBEGAAWoQygEgA0FAayIIIAQQTwJAAkACQCAIIAMQWkEBRgRAIANBgAFqIgggA0FAayADECMgCBBWDQEMAgsgBBCSAQwCCyADQYABaiIIEEMgCBBCCyAEQUBrIANBgAFqEK4BCyADQcABaiQAIAlBIHEiA0EAIABB4AFqEE0iBEEBRxtBASADIARBAUdyGwRAIABBoAFqEKQBCyABIABBoAFqQcABENEBGgsgAEHgAmokAAJ/QQAhAyMAQcAFayIAJAACQCABEIYBDQAgAEEIaiIIQZCtwAAQSSAAQYAEaiIEQbiuwAAQSSAAQUBrIgkgBBCOASAAQYABaiIEEGcgBCABEHggBCAJEEogAEHAAmoiBCABIAgQvQEgASAEECQNACAAQYAEaiIEIABBwAJqIgEgAEEIahC9ASABIARBwAEQ0QEaIAEQpAEgAEGAAWogARAkRQ0AQQEhAwsgAEHABWokAEF/IANFDQAaIAJBwAFqEKQBIAJBgANqIQhBACEAIwBB4ARrIgEkACABQeAAENABIQECQCAFBEADQCAAQeAARgRAIAEgAS0AAEEfcToAACABQeAAaiABEB9BACEAAkAgDSwAACILQQBOBEAgDUHgAGohAyAFQeAAIAVB4ABLG0HgAGshBANAIABB4ABGBEAgAUHgAWoiACABEB8gCCABQeAAaiAAED8MAwsgACAERwRAIAAgAWogACADai0AADoAACAAQQFqIQAMAQsLIABB4ABqIAVB1KfAABA7AAsjAEHAAWsiAyQAIAFB4AFqIgAQPSADQTgQ0AEiDUEBNgI4IAAgAUHgAGoQmQEgAEGAAWoiDxC3ASAAQYACahC3ASAAEKkBIA1BQGsiBCAAEDgjAEHAAWsiAyQAIAMgBBBeIAMQpAEgAyAEEBEgA0GAAWoiBCADQcAAENEBGiAEIA0QWiEEIANBwAFqJAACQAJAAkAgBEEBRgRAIwBBwANrIgAkACANQUBrIgQQiAFFBEAgACAEQUBrIgcQkAEgAEFAayIDIAQQkAEgAEGAAWoiBSAEEJABIABBwAFqIgZBOBDQARogAEEBNgL4ASAAQYACaiIKQTgQ0AEaIABBATYCuAIgABBMIAMQTCAAIAMQdyAAEEIgAEHAAmoiCSAAIA0QIyADIAkQrgEgACADEK4BIAMgBBCuASADIAAQdyADEEIgAxA3IAAgBxCuASAAEDcgAyAKEFohDCAFIAoQrgEgBRBDIAUQQiAGIAMQrgEgBhBDIAYQQiADIAZBASAMayIMEHIgCiAFIAwQciAJIAMgChAjIAQgCRCuASAFIAMQrgEgBSAKEDMgBSAEEEogByAFEK4BIAcgABBKIAYgBBCuASAEIAcgDBByIAcgBiAMEHIgBBCJASEDIAkgBBBeIAkQNiAJEKkBIAQgCSADEI0BCyAAQcADaiQAIAQQiQENAQwCCyAAEJsBDAILIA1BQGsQNgsgDUFAayIAELUBIA8gABCZAQsgDUHAAWokAEEAIQACQCABQeACaiIDEIgBDQAgA0FAaxBNIgANACADEE0hAAsgC0EgcSIDQQAgAEEBRyIAG0EBIAAgA3IbBEAgAUHgAWoQogELIAggAUHgAWpBgAMQ0QEaCyABQeAEaiQADAMLIAAgBUcEQCAAIAFqIAAgDWotAAA6AAAgAEEBaiEADAELCyAFIAVBxKfAABA7AAtBAEEAQbSnwAAQOwALIwBBwAdrIg0kACANQcABaiIDQcitwAAQSSANQcAEaiIFQYCuwAAQSSANQQhqIgEgAyAFEEsgARA+IAEQqQEgDUGIAWoiCUGQrcAAEEkgAxA9IAMgCBB9IwBBgAFrIgAkACAAIAEQXiAAEC0gAxCkASADQYABaiIEEKQBIANBgAJqIgYQpAEgBhC1ASADIAAQESAEIAAQESAEIAEQESAAQYABaiQAQQAhBCMAQfA2ayIAJAAgAEE4ENABIgFBOGpBOBDQARogAUHwAGoQPSABQfADahA9IAFB8AZqED0CQAJAIAgQigFFBEAgAUHwIWoiBhA9IAFB8CRqIgcQPSABQfAnaiIKED0gAUHwKmoiDBA9IAFB8C1qIgsQPSABQfAwaiIPED0gAUHwM2oiABA9IAFB8B5qED0gAUHwCWoiECAGQYADENEBGiABQfAMaiAHQYADENEBGiABQfAPaiAKQYADENEBGiABQfASaiAMQYADENEBGiABQfAVaiALQYADENEBGiABQfAYaiAPQYADENEBGiABQfAbaiAAQYADENEBGiAAQecAENABGiABQfADaiIAIAgQfSAAEBIgECAIEH0MAQsgBSABQfAAakGAAxDRARoMAQsDQCAEQYAVRwRAIAFB8AZqIgAgAUHwCWogBGoiBhB9IAZBgANqIgYgABB9IAYgAUHwA2oQCCAEQYADaiEEDAELCyABQThqIgAgCRBqIAEpAzghGCAAQQEQkwEgABBCIAEpAzghGSABIAAQaiABQQEQkwEgARBCIAAgASAYQgKBpxAwIAFB8ANqIgQgCCAZQgKBpxBvIAFB8AZqIAQQfSAAECpBA2oiBkECdiIAQQFqIQhBACEEAkACQANAIAFBOGpBBRCPASEJIAQgCEYEQCAGQZgDTw0CIAFB8DNqIAhqIAk6AAAgAUHwAGogAUHwCWogCUEYdEEYdRAQDAMLIARB5wBHBEAgAUHwM2ogBGogCUEQayIHOgAAIAFBOGoiCSAHQRh0QRh1EJQBIAkQQiAJQQQQLCAEQQFqIQQMAQsLQecAQecAQaCowAAQOwALIAhB5wBBsKjAABA7AAsDQCAAQX9HBEAgAUHwA2oiCCABQfAJaiABQfAzaiAAaiwAABAQIABBAWshACABQfAAaiIEEBIgBBASIAQQEiAEEBIgBCAIEAgMAQsLIwBBgANrIgAkACAAED0gACABQfAGahB9IAAQogEgAUHwAGoiBCAAEAggAEGAA2okACAFIARBgAMQ0QEaCyABQfA2aiQAIAUQogEjAEGAAmsiACQAIAAgAxBeIABBgAFqIgEgBRBeIAAgBUGAAmoiBBARIAEgA0GAAmoiCBARAn8CQCAAIAEQegRAIAAgA0GAAWoQmQEgACAEEBEgAEGAAWoiASAFQYABahCZASABIAgQESAAIAEQeg0BC0EADAELQQELIQEgAEGAAmokACANQcAHaiQAQX8gAUUNABojAEHgA2siACQAIABBgAFqIgFBwKjAABBJIABBuAFqIgNB+KjAABBJIAAgASADEEsgAEHwAmoiAUGwqcAAEEkgAEGoA2oiA0HoqcAAEEkgAEHwAWoiBCABIAMQSyACQYAGaiIBIAAgBBA/IABB4ANqJAAgAkGACWohByACQYADaiEIIwBBkDRrIgAkACAAQYAoaiIDQcitwAAQSSAAQYguaiIEQYCuwAAQSSAAIAMgBBBLIABBgAFqQTgQ0AEaIABBuAFqQTgQ0AEaIABB8AFqED0CQCACQcABaiIEEIYBRQRAIAIQhgEEQCAHIAEgBBAODAILIABB8ARqIgMQPSADIAEQfSADEEcgAEHwB2oiBRBnIAUgBBB4IAUQRiAAQbAJaiIEED0gBCAIEH0gBBBHIABBsAxqIggQZyAIIAIQeCAIEEYgAEGILmoiASAFEJABIABB8A1qIAEQkAEgASAAQbAIahCQASAAQbAOaiABEJABIAEgCBCQASAAQfAOaiABEJABIAEgAEHwDGoQkAEgAEGwD2ogARCQASAAQfAPaiIBED0gAEHwEmoiBRA9IABB8BVqEFUgASADEH0gBSAEEH0gAEH4G2oiARA9IAEgAxB9IAEQogEgAEH4HmoiARA9IAEgBBB9IAEQogEgAEG4AWogAEGAAWoQUEECayEBA0AgAUEBakEBTQRAIABB8BVqIgEQngEgByABQYgGENEBGgwDBSAAQfAVaiIEEBogAEH4IWoiAyAAQfAPaiAAQfANaiAAQbAOahALIABBgChqIgUgAEHwEmogAEHwDmogAEGwD2oQCyADIAUQAyAEIAMQAQJAAkACQCAAQbgBaiABEFMgAEGAAWogARBTa0EBag4DAQIAAgsgAEGILmoiAyAAQfAPaiAAQfAEaiAAQfANaiAAQbAOahAKIABB+CFqIgQgA0GIBhDRARogAyAAQfASaiAAQbAJaiAAQfAOaiAAQbAPahAKIAQgAxADIABB8BVqIAQQAQwBCyAAQYguaiIDIABB8A9qIABB+BtqIABB8A1qIABBsA5qEAogAEH4IWoiBCADQYgGENEBGiADIABB8BJqIABB+B5qIABB8A5qIABBsA9qEAogBCADEAMgAEHwFWogBBABCyABQQFrIQEMAQsACwALIAcgCCACEA4LIABBkDRqJAAjAEHgH2siCCQAIAhB0BNqIgFByK3AABBJIAhB2BlqIg1BgK7AABBJIAggASANEEsgCEGAAWoiC0GQrcAAEEkgAkGID2oiACAHEGkgCEG4AWoiBSAAEGkjAEGACGsiAyQAIAMgBRCMASADQYACaiIJIAVBgAJqIg8QjAEgA0GABGoiCiAFEIwBIANBgAZqIgRBOBDQARogA0EBNgK4BiADQcAGakE4ENABGiADQfgGakEBNgIAIANBgAdqQTgQ0AEaIANBuAdqQQE2AgAgA0HAB2pBOBDQARogA0H4B2pBATYCACAFEJ0BIAMQISAJIAVBgARqIgwQGCAJEGQgAyAJEHkgAxCwASAJIAwQlgEgCRAhIAkQZCAKIA8QGCAJIAoQeSAJELABIAogDxCWASAKECEgBCAFEJYBIAQgDBAYIAogBBB5IAoQsAEgBCAPEJYBIAQgChAYIAQQZCAFIAMQGCAEIAUQlwEgDCAJEBggDBBkIAQgDBCXASAEELABIwBBgAJrIgYkACAGIAQQXiAGQYABaiIQIARBgAFqIhIQXiAGEC0gEBAtIBAQfCAQEKkBIAYgEBB7IAYQPiAEIAYQESAGEDYgBhCpASASIAYQESAGQYACaiQAIAUgAxCWASAFIAQQGCAPIAkQlgEgDyAEEBggDCAKEJYBIAwgBBAYIAVBBTYCgAYgA0GACGokACAAEJ4BIAAgBRAHIAUgABBtIAAgCBAyIAAgCBAyIAAgBRAHIAhBwAdqIgQgABBpIAQQEyAEIAAQByANIAAgCxAbIAhByA1qIgMgDRBpIAMQngEgASAAEGkgARCeASAAIAMQbSAAIAEQByANIAAgCxAbIAMgDRBtIAMQngEgASAAEG0gARCeASAAIAMQbSAAIAEQByANIAAgCxAbIAMgDRBtIAMQngEgASAAEG0gASAIEDIgACADEG0gACABEAcgDSAAIAsQGyADIA0QbSANIAMgCxAbIAMgDRBtIAEgABBtIAEgCBAyIAEgCBAyIAMgARAHIAEgABBtIAEQngEgACADEG0gACABEAcgACAEEAcgABCcASAIQeAfaiQAIAcgAEGIBhDRARpBACEAIwBBgAJrIgEkACABEGwCQCAHIAEQegR/IAdBgAFqIAFBgAFqEHoFQQALRQ0AIAdBgAJqEIcBRQ0AIAdBgARqEIcBIQALIAFBgAJqJABBACAADQAaQX8LIAJBkBVqJAAgDkEoahC0ASAOQSBqELQBIA5BGGoQtAEgDkEwaiQAC58BAgJ/BX4gAEEwaiICKQMAIAFBP3GtIgSGIQUgACkDKCIGQTogAWtBP3GtIgiHIQdBBiEBA38gAiAFIAeENwMAIAFBAU0EfyAAIAApAwAgBIZC//////////8DgzcDACAAKQMwQiSHpwUgAUEBayEBIAJBEGsiA0EIaiECIAYgBIZC//////////8DgyEHIAMpAwAiBiAIhyEFDAELCxoLiAECA34DfyMAQRBrIgUkAAN+IAZBOEYEfiAFQRBqJAAgAwUgBSAAIAZqIgcpAwAiAiACQj+HIAGsIgIgAkI/hxAvIAcgBSkDACIEIAN8IgJC//////////8DgzcDACACIARUrSAFQQhqKQMAIANCP4d8fEIGhiACQjqIhCEDIAZBCGohBgwBCwsLigECA38BfiMAQUBqIgIkACACQQhqIgEgABBdIAEQQiACQThqIQFBBiEDQdwCIQACQAJAA0AgA0EATgRAIAEpAwAiBEIAUg0CIAFBCGshASAAQTprIQAgA0EBayEDDAELC0EAIQAMAQsDQCAEUA0BIABBAWohACAEQgJ/IQQMAAsACyACQUBrJAAgAAuHAQEDfyMAQYACayIBJAAgABCwASABIAAQXiABQYABaiICQTgQ0AEaIAFBATYCuAEgAUHAAWpBOBDQARogAUH4AWpBATYCACABIABBgAFqIgMQmgEgARA2IAIgARCZASACIAMQmgEgAyABEJkBIAMgABCaASAAIAIQmQEgABCwASABQYACaiQAC30CBH4BfyABQT9xrSECQTogAWtBP3GtIQRBACEBIAApAwAiBSEDA38gAUEwRgR/IAAgACkDMCAChzcDMCAFQn8gAoZCf4WDpwUgACABaiIGIAMgAocgBkEIaikDACIDIASGQv//////////A4OENwMAIAFBCGohAQwBCwsaC2kBBH8jAEHAAWsiASQAIAEgABCQASABQUBrIgIgABCQASABQYABaiIDIABBQGsiBBCQASABIAQQdyACIAAQdyACEEIgBCACEEogAxBDIAAgAxB3IAEQQiAAEEIgACABEEogAUHAAWokAAuCAQIBfwF+IABB8AAQ0AEhAANAIAJBOEYEQAJAIAAgASkDMCIDQjqHNwM4IAAgA0L//////////wODNwMwIABBQGshAEEAIQIDQCACQTBGDQEgACACakIANwMAIAJBCGohAgwACwALBSAAIAJqIAEgAmopAwA3AwAgAkEIaiECDAELCwtuAQZ+IAAgA0L/////D4MiBSABQv////8PgyIGfiIHIAUgAUIgiCIIfiIJIAYgA0IgiCIGfnwiBUIghnwiCjcDACAAIAcgClatIAYgCH4gBSAJVK1CIIYgBUIgiIR8fCABIAR+IAIgA358fDcDCAtqAgF/BX4gASkDCCAAKQMAhSIGQgGGQgGHIQdBACACa6whCAN+IANBOEYEfiAFBSAAIANqIgIgAikDACIEIAaFIAEgA2opAwAgBIUgCIOFIgQgB4U3AwAgBCAFhSEFIANBCGohAwwBCwsaC18CAX8EfkIBIQNBMCECA38gAkF4RgR/IARCAYYgA3ynQQFrBSABIAJqKQMAIgUgACACaikDACIGfUI6hyADgyAEhCEEIAJBCGshAiAFIAaFQgF9QjqHIAODIQMMAQsLC2kBBH8jAEGAAmsiAiQAIAIgARBeIAJBgAFqIgMgARBeIAIQLSADIAIQESAAIAMQmAEgAEGAAmoiBCADEJgBIABBgARqIgUgAxCYASAEIAEQpgEgBSACEKYBIABBBTYCgAYgAkGAAmokAAtiAQJ/IwBBQGoiAiQAIAAQQiACIAAQkAECQCABBEAgACABEK4BDAELIAAQOgtBACEBA0AgA0UEQCAAEExBASABQQFqIAFBAUYiAxshAQwBCwsgACACEEogABAeIAJBQGskAAtnAQJ/IwBBQGoiAyQAAkAgASABQR91IgJqIAJzIgIgACgCOGxBgICAEE4EQCADIAIQOSAAIAMQSgwBCyAAIAIQKRogACAAKAI4IAJsNgI4CyABQQBIBEAgABBDIAAQQgsgA0FAayQAC2cAIABBAXYgAHIiAEECdiAAciIAQQR2IAByIgBBCHYgAHIiAEEQdiAAciIAIABBAXZB1arVqgVxayIAQQJ2QbPmzJkDcSAAQbPmzJkDcWoiAEEEdiAAakGPnrz4AHFBgYKECGxBGHYLYQEDfyMAQYABayIBJAAgASAAEJABIAFBQGsiAkE4ENABGiABQQE2AnggASAAQUBrIgMQdyABEEMgAiABEK4BIAIgAxB3IAMgARCuASADIAAQdyAAIAIQrgEgAUGAAWokAAtVAgJ/AX4jAEHwAGsiASQAIAFBwLLAABBJIAApAwAhAyABQThqIgIgABBdIABBARAsIAIgARBgIAIQQiACQQEQLCAAIAIgA0ICgacQMCABQfAAaiQAC5gBAQZ/IwBBwAFrIgMkACAAIAEQXiAAEC0gA0GIAWoiBkHop8AAEEkjAEFAaiIEJAAgA0EIaiICQTgQ0AEiBUEBNgI4IAVBQGtBOBDQASAFQfgAakEBNgIAIAQgBhCOASAFIAQQrgEQwQEgBEFAayQAIAIQqQEgAhB8IAIQqQEgACABEBEgACACEJoBIAAQtQEgA0HAAWokAAtZAQJ/IwBBQGoiAyQAIABBOBDQASIAQQE2AjgCQCABQQBOBEAgACABEJMBDAELIANBCGoiAkHAssAAEEkgAiABEJMBIAIQQiAAIAIQagsgABBUIANBQGskAAu9CAEKfyMAQYABayIHJAAgB0EIaiIDQcCywAAQSSADQQEQlAECQAJAA0AgAUEwRgRAIANBMGogAykDMEIBhzcDACADQThqIQEDQCACRQ0EIAFCADcDACACQQFrIQIgAUEIaiEBDAALAAsgAUE4Rg0BIAFBOEcEQCABIANqIAEgA2oiBEEIaikDAEI5hkL//////////wODIAQpAwBCAYeENwMAIAVBAWohBSABQQhqIQEMAQsLQQdBB0GEm8AAEDsACyAFQQdB9JrAABA7AAsgA0EBEJQBIANBARAsIAdBQGshBUEAIQIjAEGgCmsiASQAIAFBOBDQASIBQUBrQTgQ0AEhBiABQYABakE4ENABGiABQcABakE4ENABGiABQYACakE4ENABGiABQcACakE4ENABGiABQYADakE4ENABGiABQcADakE4ENABGiABQYAEakE4ENABGiABQcAEakE4ENABGiABQYAFakE4ENABGiABQcAFakE4ENABGiABQYAGakE4ENABGiABQcAGakE4ENABGiABQYAHakE4ENABGiABQcAHakE4ENABGiABQfgHakEBNgIAIAFBuAdqQQE2AgAgAUH4BmpBATYCACABQbgGakEBNgIAIAFB+AVqQQE2AgAgAUG4BWpBATYCACABQfgEakEBNgIAIAFBuARqQQE2AgAgAUH4A2pBATYCACABQbgDakEBNgIAIAFB+AJqQQE2AgAgAUG4AmpBATYCACABQfgBakEBNgIAIAFBuAFqQQE2AgAgAUH4AGpBATYCACABQQE2AjggAUGBCGpB5wAQ0AEaIAFB6AhqIgQgABCQASAEEEIgAUGoCWoiBCADEF0gBBBCIAQQKkEDaiIIQQJ2IgNBAWohCQJAA0AgAiAJRgRAIAEQygEgBiABQegIahCuASABQeAJakE4ENABGiABQQE2ApgKQYB5IQIMAgsgAUGoCWoiBCAEQQQQjwEiChCUASAEEEIgAkHnAEcEQCABQYEIaiACaiAKOgAAIAFBqAlqQQQQLCACQQFqIQIMAQsLQecAQecAQaC0wAAQOwALA0AgAgRAIAFB4AlqIgQgASACaiIGQcAHahCuASAGQYAIaiIGIAQQrgEgBiABQegIahBKIAJBQGshAgwBCwsCQAJAAkACQCAIQZwDSQRAIAFBgQhqIANqLAAAIgJBEE8NASAFIAEgAkEGdGoQkAEgA0EBayICQeYASyEEA0AgAkF/Rg0DIAUQTCAFEEwgBRBMIAUQTCAEDQQgAUGBCGogAmotAAAiA0EQSQRAIAUgASADQQZ0ahBKIAJBAWshAgwBCwsgA0EYdEEYdUEQQeC0wAAQOwALIANB5wBBsLTAABA7AAsgAkEQQcC0wAAQOwALIAUQHiABQaAKaiQADAELIAJB5wBB0LTAABA7AAsgACAFEK4BIAdBgAFqJAALbAEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBHGpBAjYCACADQSxqQQE2AgAgA0ICNwIMIANB2LjAADYCCCADQQE2AiQgAyADQSBqNgIYIAMgAzYCKCADIANBBGo2AiAgA0EIaiACEGYAC2UBAn8gACAAKAIAIgJBCGoiAzYCACAAIAJBA3ZBPHFqQShqIgIgAUH/AXEgAigCAEEIdHI2AgACQAJAIANFBEAgAEEANgIAIAAgACgCBEEBajYCBAwBCyADQf8DcQ0BCyAAEA8LC1wAIABBOBDQASIAQQE2AjggAEFAa0E4ENABGiAAQfgAakEBNgIAIABBgAFqEFEgAEGAAmpBOBDQARogAEG4AmpBATYCACAAQcACakE4ENABGiAAQfgCakEBNgIAC1sBA38jAEGAAWsiASQAIAAQqQEgASAAEJABIAFBQGsiAiAAQUBrIgMQkAEgARBMIAIQTCABIAIQdyABQQAQMyAAIAEQSiABEEMgARBCIAMgARBKIAFBgAFqJAALYQEBfyMAQYACayIDJAAgABA9IAAgARCZASAAQYABaiIBIAIQmQEgAEGAAmoQtwEgABCpASADIAAQOCADQYABaiICIAEQXiACEC0gAiADEHpFBEAgABCbAQsgA0GAAmokAAtUAQF/IwBBIGsiAiQAIAIgACgCADYCBCACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqIAJBCGoQDCACQSBqJAALZwAjAEEwayIBJABBpLvAAC0AAARAIAFBHGpBATYCACABQgI3AgwgAUGQtsAANgIIIAFBATYCJCABIAA2AiwgASABQSBqNgIYIAEgAUEsajYCICABQQhqQbi2wAAQZgALIAFBMGokAAtiAgF+An8gACkDACEBA34gACACaiIDIAFC//////////8DgzcDACABQjqHIQEgAkEoRgR+IAAgACkDMCABfCIBNwMwIAFCJIcFIAJBCGohAiADQQhqKQMAIAF8IQEMAQsLGgt8AQV/IwBBQGoiAyQAIANBCGoiAkHAssAAEEkgAiAAKAI4QQFrEDUiBBAoA0AgAUE4RwRAIAAgAWoiBSABIAJqKQMAIAUpAwB9NwMAIAFBCGohAQwBCwsgAEEBIARBAWp0IgI2AjggAkH///8PSgRAIAAQHgsgA0FAayQAC3sBAn8gAEEoaiECA0AgAUGAAkYEQCAAQufMp9DW0Ouzu383AgggAEIANwIAIABBIGpCq7OP/JGjs/DbADcCACAAQRhqQv+kuYjFkdqCm383AgAgAEEQakLy5rvjo6f9p6V/NwIABSABIAJqQQA2AgAgAUEEaiEBDAELCwtUACAAQTgQ0AEiAEEBNgI4IABBQGtBOBDQARogAEH4AGpBATYCACAAQYABakE4ENABGiAAQbgBakEBNgIAIABBwAFqQTgQ0AEaIABB+AFqQQE2AgALWAECfyMAQUBqIgEkAAJAIAAQhgENACABQQEQOSAAQYABaiICIAEQWA0AIAJBABAzIAAgAhBKIAAQHiAAQUBrIgAgAhBKIAAQHiACIAEQrgELIAFBQGskAAtZAQJ/IwBBgAFrIgEkAAJAIAAQigENACABEFEgAEGAAmoiAiABEHoNACACED4gACACEBEgABC1ASAAQYABaiIAIAIQESAAELUBIAIgARCZAQsgAUGAAWokAAtbAgF+An8gACkDACEBA0AgACACaiIDIAFC//////////8DgzcDACABQjqHIQEgAkHgAEYEQCAAIAApA2ggAXw3A2gFIAJBCGohAiADQQhqKQMAIAF8IQEMAQsLC08BAX8gAEE4ENABGgJAA0AgAkEHRwRAIAJBB0YNAiAAIAEpAwA3AwAgAEEIaiEAIAFBCGohASACQQFqIQIMAQsLDwtBB0EHQeSawAAQOwALVAECfyMAQbABayICJAAgATQCOCAANAI4fkL///8PVQRAIAAQHgsgAkEIaiIDIAAgARAFIAJB+ABqIgEgAxBrIAAgARBqIABBAjYCOCACQbABaiQAC1EBAn8jAEFAaiIDJAAgAEE4ENABIgBBATYCOCAAQUBrQTgQ0AEgAEH4AGpBATYCACADIAEQjgEgACADEK4BIAMgAhCOASADEK4BIANBQGskAAvwDAIRfwh+IwBBsAFrIg8kACAANAI4IhIgEn5C////D1YEQCAAEB4LIwBB0AFrIgEkACAPQQhqIgZBCGpB0AAQ0AEaIAFBwAFqIAApAwAiFyAXQj+HIhYgFyAWEC8gBiABKQPAASISQv//////////A4M3AwAgAUHIAWopAwAiFUIGhiASQjqIhCETIBVCOoghGCAAQQhqIgwhDSAAIQlBASEKQQEhBwJAA0AgCkEERgRAIABBGGohCiAAQRBqIQkgAEEoaiEMIAApAzAhF0EHIQUgAUHIAGohCwNAIAVBC0kEQCABQUBrIAVBA3QiCCAAakEwaykDACISIBJCP4cgFyAXQj+HIhYQLyAFQQFqIg1BAXYhByALKQMAIRUgASkDQCESIAkhAiAMIQQgBUEFayIOIQMDQCADIAdJBEAgASACKQMAIhQgFEI/hyAEKQMAIhQgFEI/hxAvIAEpAwAiFCASfCISIBRUrSABQQhqKQMAIBV8fCEVIAJBCGohAiAEQQhrIQQgA0EBaiEDDAELCyAGIAhqIBJCAYYiFCATfCITQv//////////A4M3AwAgAUEwaiAAIA5BA3RqKQMAIhkgGUI/hyAXIBYQLyATIBRUrSAVQgGGIBJCP4iEIBh8fCEYIAVBBGshAyAFQQJqIgVBAXYhCCABQThqKQMAIRUgASkDMCESIAohAiAMIQQDQCADIAhPBEAgAUEgaiAAIAdBA3RqKQMAIhYgFkI/hyIUIBYgFBAvIAYgDUEDdGogEkIBhiIUIBhCBoYgE0I6iIR8IhMgASkDIHwiFkL//////////wODNwMAIBMgFlatIAFBKGopAwAgEyAUVK0gFUIBhiASQj+IhCAYQjqHfHx8fCISQjqHIRggEkIGhiAWQjqIhCETIApBEGohCiAJQRBqIQkMAwUgAUEQaiACKQMAIhYgFkI/hyAEKQMAIhYgFkI/hxAvIAEpAxAiFiASfCISIBZUrSABQRhqKQMAIBV8fCEVIAJBCGohAiAEQQhrIQQgA0EBaiEDDAELAAsACwsgAUHQAGogFyAXQj+HIhIgACkDKCIVIBVCP4cQLyAGIBMgASkDUCIWQgGGIhR8IhVC//////////8DgzcDWCABQeAAaiAXIBIgFyASEC8gBiAUIBVWrSABQdgAaikDAEIBhiAWQj+IhCAYfHwiF0IGhiAVQjqIhCIVIAEpA2B8IhJC//////////8DgzcDYCAGIBIgFVStIAFB6ABqKQMAIBdCOod8fEIGhiASQjqIhDcDaCABQdABaiQADAILIAFBsAFqIAAgB0EDdCIOaikDACISIBJCP4cgFyAWEC8gB0EBaiIQQQF2IREgAUG4AWopAwAhFSABKQOwASESIAUhAyAMIQQgCSELIAghAgNAIANFBEAgBiAOaiASQgGGIhQgE3wiE0L//////////wODNwMAIAFBkAFqIAAgEEEDdCIOaikDACIZIBlCP4cgFyAWEC8gEyAUVK0gFUIBhiASQj+IhCAYfHwiEkI6hyEYIBJCBoYgE0I6iIQhFCAHQQJqIQsgAUGYAWopAwAhFUEAIQMgASkDkAEhEiAMIQIgDSEEA0AgAyAFakUEQCABQfAAaiAAIBFBA3RqKQMAIhMgE0I/hyIZIBMgGRAvIAYgDmogEkIBhiIZIBR8IhMgASkDcHwiFEL//////////wODNwMAIBMgFFatIAFB+ABqKQMAIBMgGVStIBVCAYYgEkI/iIQgGHx8fHwiEkI6hyEYIBJCBoYgFEI6iIQhEyANQRBqIQ0gBUEBaiEFIAlBEGohCSAIQQJqIQggCkEBaiEKIAshBwwECyADIAdqIhBBB0kEQCABQYABaiACKQMAIhMgE0I/hyAEKQMAIhMgE0I/hxAvIAEpA4ABIhMgEnwiEiATVK0gAUGIAWopAwAgFXx8IRUgAkEIaiECIARBCGshBCADQQFrIQMMAQsLIBBBB0GEnMAAEDsACyACQQdJBEAgAUGgAWogBCkDACIUIBRCP4cgCykDACIUIBRCP4cQLyABKQOgASIUIBJ8IhIgFFStIAFBqAFqKQMAIBV8fCEVIANBAWshAyAEQQhqIQQgC0EIayELIAJBAWshAgwBCwsLIAJBB0H0m8AAEDsACyAPQfgAaiICIAYQayAAIAIQaiAAQQI2AjggD0GwAWokAAtHAQJ/IwBB8ABrIgEkACAAEHZFBEAgAUHAssAAEEkgAUE4aiICIAAQhAEgASACEGEgARBCIAIgARAxIQILIAFB8ABqJAAgAgtPAQJ/IAIgACgCACIDQQRqKAIAIANBCGoiBCgCACIAa0sEQCADIAAgAhAiIAQoAgAhAAsgAygCACAAaiABIAIQ0QEaIAQgACACajYCAEEAC0wBA38jAEGAAWsiAiQAIAAgARCQASAAEEwgAkHIAGoiA0GAgMAAEEkgAkEIaiIEIAMQjgEgACABEEogACAEEHcgABAeIAJBgAFqJAALQQECfyMAQUBqIgIkACACQQhqIgNBkK3AABBJIAEgAxBqIAEQQiAAIAEQaiAAQQMQKRogABBCIAAQKiACQUBrJAALRwECfyMAQUBqIgEkACAAQTgQ0AEiAEEBNgI4IABBQGtBOBDQASAAQfgAakEBNgIAIAFBARA5IAAgARCuARDBASABQUBrJAALSwACQAJ/IAFBgIDEAEcEQEEBIAAoAhggASAAQRxqKAIAKAIQEQQADQEaCyACDQFBAAsPCyAAKAIYIAJBACAAQRxqKAIAKAIMEQUAC0MCAX8BfiABQTpuIQIgAUGVA00EQCAAIAJBA3RqKQMAQgEgAUH//wNxQTpwrSIDhoMgA4inDwsgAkEHQbSbwAAQOwALRQEDfyMAQeABayIBJAAgAUH4ssAAEEkgAUE4aiICIAAgARAFIAFBqAFqIgMgAhBrIAAgAxBqIABBAjYCOCABQeABaiQAC0ABAX8jAEGAAmsiASQAIAAQiwEgARBsIAAgARCWASAAQYACahCxASAAQYAEahCxASAAQQE2AoAGIAFBgAJqJAALPAICfwF+IwBBgAFrIgEkACABQQhqIgIgABCQASACEB4gAUHIAGogAhCEASABKQNIIAFBgAFqJABCAoGnCzwCAX8BfgN/IAFBOEYEfyACQgF9QoCAgICAgICABINCOoinBSAAIAFqKQMAIAKEIQIgAUEIaiEBDAELCws4AQF/IwBBgAFrIgIkACACIAAQkAEgAkFAayIAIAEQkAEgAhAeIAAQHiACIAAQMSACQYABaiQARQtHAQF/IwBBIGsiAyQAIANBFGpBADYCACADQZS4wAA2AhAgA0IBNwIEIAMgATYCHCADIAA2AhggAyADQRhqNgIAIAMgAhBmAAukAQICfwF+IwBBQGoiAiQAIAIgABCQASACEDogAQRAIAEgAhCuAQsgAhBMIAIgABBKIwBBgAFrIgEkACABQQhqIgAgAhCQASAAEB4gAUHIAGoiAyAAEIQBQQghAAN/IABBOEYEfyAEQgF9IAMpAwBCAYVCAX2DQjqIp0EBcQUgACADaikDACAEhCEEIABBCGohAAwBCwsgAUGAAWokACACQUBrJAALxQMBBn8jAEEgayIGJAAgBiACNgIYIAYgAjYCFCAGIAE2AhAgBkEQaiICKAIIIgEgAigCBEkEQAJAIwBBEGsiBSQAIwBBIGsiBCQAAkACQCABIAIoAgRNBEAgBEEIaiEDAkAgAigCBCIHBEAgAyAHNgIEIANBCGpBATYCACADIAIoAgA2AgAMAQsgA0EANgIACwJAAkAgBCgCCCIIBEAgBEEQaigCACEDIAQoAgwhBwJAAkAgAUUEQEEBIQMMAQsgA0EBRg0DIAFBARC5ASIDRQ0BIAMgCCABENEBGgsgCCAHEKgBDAULDAILIAVBADYCAAwECyAIIAEQrAEiAw0CCyAFIAE2AgQgBUEBNgIAIAVBCGpBATYCAAwCCyAEQRxqQQA2AgAgBEG0nMAANgIYIARCATcCDCAEQdicwAA2AgggBEEIakGsncAAEGYACyACIAE2AgQgAiADNgIAIAVBADYCAAsgBEEgaiQAAkAgBSgCAARAIAVBCGooAgAiAEUNASAFKAIEIAAQzwEACyAFQRBqJAAMAQsQZQALCyAGQQhqIgEgAigCCDYCBCABIAIoAgA2AgAgACAGKQMINwMAIAZBIGokAAtGAQJ/IAEoAgQhAiABKAIAIQNBCEEEELkBIgFFBEBBCEEEEM8BAAsgASACNgIEIAEgAzYCACAAQZS3wAA2AgQgACABNgIACzEBAX8gAEE4ENABIQADQCACQThHBEAgACACaiABIAJqKQMANwMAIAJBCGohAgwBCwsLNgEBfyAAQTgQ0AEiAEEBNgI4IABBQGtBOBDQASAAQfgAakEBNgIAIAAgARCuASABQUBrEK4BCzsBAX8jAEEQayIDJAAgA0EIaiABQYQCIAIQgQEgAygCDCEBIAAgAygCCDYCACAAIAE2AgQgA0EQaiQACwsAIAAgAUE4ENsBCwsAIAAgAUE4ENwBCwwAIAAgAUHwABDbAQsMACAAIAFB8AAQ3AELOQECfyMAQYABayIBJAAgASAAQYABaiICEF4gAiAAEJkBIAEQfCAAIAEQmQEgABCwASABQYABaiQACz8BAX8jAEEgayIAJAAgAEEcakEANgIAIABBzLfAADYCGCAAQgE3AgwgAEH8t8AANgIIIABBCGpBhLjAABBmAAu8AgEDfyMAQSBrIgIkACACQQE6ABggAiABNgIUIAIgADYCECACQZS4wAA2AgwgAkGUuMAANgIIIwBBEGsiACQAIAJBCGoiASgCDCICRQRAQcC1wABBK0HktsAAEFkACyABKAIIIgRFBEBBwLXAAEErQfS2wAAQWQALIAAgAjYCCCAAIAE2AgQgACAENgIAIAAoAgAhASAAKAIEIQIgACgCCCEEIwBBEGsiACQAIAFBFGooAgAhAwJAAn8CQAJAIAFBBGooAgAOAgABAwsgAw0CQQAhAUHAtcAADAELIAMNASABKAIAIgMoAgQhASADKAIACyEDIAAgATYCBCAAIAM2AgAgAEG4t8AAIAIoAgggBCACLQAQECAACyAAQQA2AgQgACABNgIAIABBpLfAACACKAIIIAQgAi0AEBAgAAswACAAQTgQ0AEiAEEBNgI4IABBQGtBARA5IABBgAFqQTgQ0AEaIABBuAFqQQE2AgALKwACQCAAQXxLDQAgAEUEQEEEDwsgACAAQX1JQQJ0ELkBIgBFDQAgAA8LAAs4ACAAEIsBIAAgARCWASAAQYACaiABQYACahCWASAAQYAEaiABQYAEahCWASAAIAEoAoAGNgKABgsoAQF/A0AgAkE4RwRAIAAgAmogASACaikDADcDACACQQhqIQIMAQsLC4QJAg1/Cn4jAEFAaiILJAAgC0EIaiIJQcCywAAQSSMAQZACayICJAAgAEEwENABIQogAkHoAGpB8AAQ0AEaIAJB4AFqQTAQ0AEaIAoQcSACIAEiDCkDACIQQv3/8//P///5AX5C//////////8DgyISNwPYASACQdgAaiASQgAgCSkDACIXIBdCP4ciGBAvIBAgAikDWCIPfCITIA9UrSACQeAAaikDACAQQj+HfHwiEEI6hyABKQMIIg9CP4d8IA8gEEIGhiATQjqIhCITfCIQIBNUrXwhD0EBIQBCACETAkACQANAAkAgAEEHRgRAQQYhB0EAIQhBByEADAELIABBAXYiAUEBaiEGIAggAWshAyABQQN0IgFBCGohBCAHIAFrIQUgAkHIAGogCSAAQQN0Ig1qKQMAIhUgFUI/hyIWIBJCABAvIAJB0ABqKQMAIBAgECATfCIRVq0gDyAUfHx8IBEgAikDSHwiDyARVK18IRAgAEEBaiEBA0AgACAGTQRAIAJB2AFqIA1qIA9C/f/z/8////kBfkL//////////wODIhE3AwAgAkE4aiARQgAgFyAYEC8gAkEoaiARQgAgFSAWEC8gAkHoAGogAEEEdGoiACACQTBqKQMAIhE3AwggACACKQMoIhU3AwAgDyACKQM4IhZ8Ig8gFlStIAJBQGspAwAgEHx8IhBCOocgDCABQQN0aikDACIWQj+HfCAWIBBCBoYgD0I6iIQiD3wiECAPVK18IQ8gEyAVfCITIBVUrSARIBR8fCEUIAdBCGohByAIQQFqIQggASEADAMLIANBB08NAyACQRhqIAQgCWopAwAgBSAJaikDAH0iESARQj+HIAJB2AFqIg4gBWopAwAgBCAOaikDAH0iESARQj+HEC8gAikDGCIRIA98Ig8gEVStIAJBIGopAwAgEHx8IRAgBkEBaiEGIARBCGohBCAFQQhrIQUgA0EBayEDDAALAAsLA0ACQAJAIABBDUcEQCAHIABBAXYiBmshAyAIIAZBA3QiAWshBCABQQhqIQUgDyAUfCAQIBN8Ig8gEFStfCEQIABBAWohAQNAIAZBBUsNAyADQQdPDQIgAkEIaiAFIAlqKQMAIAQgCWpBMGopAwB9IhIgEkI/hyACIARqQYgCaikDACACQdgBaiAFaikDAH0iEiASQj+HEC8gAikDCCISIA98Ig8gElStIAJBEGopAwAgEHx8IRAgBkEBaiEGIARBCGshBCADQQFrIQMgBUEIaiEFDAALAAsgCiAQQv//////////A4M3AzAgAkGQAmokAAwECyADQQdBpJzAABA7AAsgAEEDdCAKakE4ayAPQv//////////A4M3AwAgEEI6hyAMIAFBA3RqKQMAIhJCP4d8IBIgEEIGhiAPQjqIhCIPfCIQIA9UrXwhDyAUIABBBHQgAmpBCGoiAEEIaikDAH0gEyAAKQMAIhJUrX0hFCAIQQhqIQggB0EBaiEHIBMgEn0hEyABIQAMAAsACyADQQdBlJzAABA7AAsgC0FAayQACy4BAX8jAEGAAWsiASQAIAAQRSABEFEgACABEJkBIABBgAFqELYBIAFBgAFqJAALMwAgACABEJYBIABBgAJqIAFBgAJqEJYBIABBgARqIAFBgARqEJYBIAAgASgCgAY2AoAGCygAIAAgASACEHIgAEFAayABQUBrIAIQciAAQYABaiABQYABaiACEHILLQAgACABIAIQjQEgAEGAAWogAUGAAWogAhCNASAAQYACaiABQYACaiACEI0BCycBAn8jAEFAaiICJAAgAkEIaiIDIAEQvgEgACADEI4BIAJBQGskAAsiAQF/A0AgAUE4RwRAIAAgAWpCADcDACABQQhqIQEMAQsLCyUAIAAgASACEDAgAEEAIAJrIAAoAjgiACABKAI4c3EgAHM2AjgLJwAgACAAKAIEQQFxIAFyQQJyNgIEIAAgAWoiACAAKAIEQQFyNgIECyMAA0AgAgRAIAAgAS0AABA8IAJBAWshAiABQQFqIQEMAQsLCywAIAAQiwEgACABEJYBIABBgAJqIAIQlgEgAEGABGogAxCWASAAQQU2AoAGCyMBAX8jAEFAaiIBJAAgASAAEJABIAEQHiABEFcgAUFAayQACykAIAAgARBgIAAgACgCOCABKAI4aiIBNgI4IAFB////D0oEQCAAEB4LCyUAIAAgARCuASAAQUBrIAFBQGsQrgEgAEGAAWogAUGAAWoQrgELKAEBfyMAQYACayICJAAgAiABEIwBIAIQKyAAIAIQlwEgAkGAAmokAAscAQF/IAAgARBYBH8gAEFAayABQUBrEFgFQQALCycBAX8jAEGAAWsiAiQAIAIgARBeIAIQNiAAIAIQmgEgAkGAAWokAAtRAQN/IwBBgAFrIgEkACABIAAQXiMAQUBqIgIkACACIAAQkAEgACAAQUBrIgMQrgEgABBDIAMgAhCuASACQUBrJAAgACABEJoBIAFBgAFqJAALJwAgACABEJkBIABBgAFqIAFBgAFqEJkBIABBgAJqIAFBgAJqEJkBCyUBAX8jAEFAaiICJAAgAiABEJABIAIQQyAAIAIQdyACQUBrJAALHgACQCAAQQRqKAIARQ0AIAAoAgAiAEUNACAAEAQLCyABAX8CQCAAKAIEIgFFDQAgAEEIaigCAEUNACABEAQLC4MBACACIANJBEAjAEEwayIAJAAgACACNgIEIAAgAzYCACAAQRxqQQI2AgAgAEEsakEBNgIAIABCAjcCDCAAQYS7wAA2AgggAEEBNgIkIAAgAEEgajYCGCAAIABBBGo2AiggACAANgIgIABBCGpBlLvAABBmAAsgACADNgIEIAAgATYCAAtIAQJ/A0AgAUE4RwRAIAAgAWoiAiACKQMAQgGGNwMAIAFBCGohAQwBCwsgACAAKAI4QQF0IgE2AjggAUH///8PSgRAIAAQHgsLIwAgAiACKAIEQX5xNgIEIAAgAUEBcjYCBCAAIAFqIAE2AgALIgEBfyMAQfAAayICJAAgAiABEC4gACACEGsgAkHwAGokAAseACAAIAFBA3I2AgQgACABaiIAIAAoAgRBAXI2AgQLFgEBfyAAEHYEfyAAQYABahB2BUEACwsYAQF/IAAQiAEEfyAAQYABahCIAQVBAAsLFQEBfyAAEHYEfyAAQUBrEHYFQQALCxoBAX8gABBWIgEgAEFAaxBWIAFzIAAQdnFzCxgBAX8gABCIAQR/IABBgAJqEIgBBUEACwseACAAEEUgAEGAAmoQRSAAQYAEahBFIABBADYCgAYLHAAgABBFIAAgARCZASAAQYABaiABQYABahCZAQsYACAAIAEgAhByIABBQGsgAUFAayACEHILGgAgAEE4ENABIgBBATYCOCAAIAEQaiAAEFQLFAAgABBCIAAoAgBBfyABdEF/c3ELGQAgAEE4ENABIgAgARBqIAAgASgCODYCOAsZAQF/IAAoAhAiAQR/IAEFIABBFGooAgALCxgAIAAQwQEgAEFAaxDKASAAQYABahDBAQsUACAAEEIgACAAKQMAIAGsfDcDAAsUACAAEEIgACAAKQMAIAGsfTcDAAsYACAAEEUgACABEJkBIABBgAFqIAIQmQELGAAgACABEJkBIABBgAFqIAFBgAFqEJkBCxgAIAAgARCaASAAQYABaiABQYABahCaAQsYACAAEKQBIABBgAFqIgAQpAEgACABEBELFgAgACABEK4BIABBQGsgAUFAaxCuAQsUACAAIAEQdyAAQUBrIAFBQGsQdwsZACAAELYBIABBgAFqELcBIABBgAJqELYBCxkAIAAQrwEgAEGAAmoQrwEgAEGABGoQrwELGQAgABCwASAAQYACahCwASAAQYAEahCwAQsZACAAELIBIABBgAJqEMkBIABBgARqELIBCxIAQQBBGSAAQQF2ayAAQR9GGwsWACAAIAFBAXI2AgQgACABaiABNgIACxYAIAAQRSAAIAEQmQEgAEGAAWoQtgELFgAgAEGAAWoiABCpASAAEDYgABCpAQsQACAAIAFqQQFrQQAgAWtxCw8AIABBQGsiABBDIAAQQgsUACAAIAEQmQEgAEGAAWogAhCZAQsSACAAIAEQESAAQYABaiABEBELFAAgACABEKoBIABBgAFqIAEQqgELCwAgAQRAIAAQBAsLDQAgABBCIABBQGsQQgsRACAAIAEQSiAAQUBrIAEQSgsRACAAIAEQNCAAQUBrIAEQNAu+BQEHfwJ/AkACQEGAgHxBCEEIEKMBQRRBCBCjAWpBEEEIEKMBamtBd3FBA2siAkEAQRBBCBCjAUECdGsiBCACIARJGyABTQ0AQRAgAUEEakEQQQgQowFBBWsgAUsbQQgQowEhAiAAENUBIgQgBBDLASIFENIBIQMCQAJAAkACQAJAAkACQCAEEMQBRQRAIAIgBU0NASADQfi+wAAoAgBGDQIgA0H0vsAAKAIARg0DIAMQvAENByADEMsBIgYgBWoiByACSQ0HIAcgAmshBSAGQYACSQ0EIAMQFwwFCyAEEMsBIQMgAkGAAkkNBiADIAJrQYGACEkgAkEEaiADTXENBSAEKAIAGiACQR9qQYCABBCjARoMBgtBEEEIEKMBIAUgAmsiA0sNBCAEIAIQ0gEhBSAEIAIQcyAFIAMQcyAFIAMQDQwEC0HwvsAAKAIAIAVqIgUgAk0NBCAEIAIQ0gEhAyAEIAIQcyADIAUgAmsiAkEBcjYCBEHwvsAAIAI2AgBB+L7AACADNgIADAMLQey+wAAoAgAgBWoiBSACSQ0DAkBBEEEIEKMBIAUgAmsiA0sEQCAEIAUQc0EAIQNBACEFDAELIAQgAhDSASIFIAMQ0gEhBiAEIAIQcyAFIAMQoAEgBiAGKAIEQX5xNgIEC0H0vsAAIAU2AgBB7L7AACADNgIADAILIANBDGooAgAiCCADQQhqKAIAIgNHBEAgAyAINgIMIAggAzYCCAwBC0Hcu8AAQdy7wAAoAgBBfiAGQQN2d3E2AgALQRBBCBCjASAFTQRAIAQgAhDSASEDIAQgAhBzIAMgBRBzIAMgBRANDAELIAQgBxBzCyAEDQILIAEQACICRQ0AIAIgACABIAQQywFBeEF8IAQQxAEbaiICIAEgAkkbENEBIAAQBAwCC0EADAELIAQQxAEaIAQQ1AELCw8AIABBAXQiAEEAIABrcgsSACAAIAEQaiAAIAEoAjg2AjgLEAAgABC1ASAAQYABahC1AQsQACAAEKkBIABBgAFqEKkBCxAAIAAQtgEgAEGAAWoQtgELDwAgAEGAAWoQNiAAELABCxAAIAAQuAEgAEGAAWoQuAELDwAgACgCACAAKAIEEKgBCw0AIAAQHiAAQUBrEB4LDwAgABDBASAAQUBrEMEBCw8AIAAQygEgAEFAaxDBAQsPACAAEIIBIABBQGsQggELgwMBA38CfwJAAkACQAJAIAFBCU8EQEEQQQgQowEgAUsNAQwCCyAAEAAhAwwCC0EQQQgQowEhAQtBgIB8QQhBCBCjAUEUQQgQowFqQRBBCBCjAWprQXdxQQNrIgRBAEEQQQgQowFBAnRrIgIgAiAESxsgAWsgAE0NACABQRAgAEEEakEQQQgQowFBBWsgAEsbQQgQowEiBGpBEEEIEKMBakEEaxAAIgJFDQAgAhDVASEAAkAgAUEBayIDIAJxRQRAIAAhAQwBCyACIANqQQAgAWtxENUBIQJBEEEIEKMBIQMgABDLASACQQAgASACIABrIANLG2oiASAAayICayEDIAAQxAFFBEAgASADEHMgACACEHMgACACEA0MAQsgACgCACEAIAEgAzYCBCABIAAgAmo2AgALIAEQxAENASABEMsBIgJBEEEIEKMBIARqTQ0BIAEgBBDSASEAIAEgBBBzIAAgAiAEayIEEHMgACAEEA0MAQsgAwwBCyABENQBIAEQxAEaCwuOBAEFfyAAKAIAIQAjAEEQayIEJAACQAJ/AkAgAUGAAU8EQCAEQQA2AgwgAUGAEE8NASAEIAFBP3FBgAFyOgANIAQgAUEGdkHAAXI6AAxBAgwCCyAAKAIIIgIgAEEEaigCAEYEQCMAQSBrIgMkAAJAAkAgAiACQQFqIgVLDQAgAEEEaigCACICQQF0IgYgBSAFIAZJGyIFQQggBUEISxshBQJAIAIEQCADQRhqQQE2AgAgAyACNgIUIAMgACgCADYCEAwBCyADQQA2AhALIAMgBSADQRBqECYgAygCAARAIANBCGooAgAiAEUNASADKAIEIAAQzwEACyADKAIEIQIgAEEEaiAFNgIAIAAgAjYCACADQSBqJAAMAQsQZQALIAAoAgghAgsgACACQQFqNgIIIAAoAgAgAmogAToAAAwCCyABQYCABE8EQCAEIAFBP3FBgAFyOgAPIAQgAUESdkHwAXI6AAwgBCABQQZ2QT9xQYABcjoADiAEIAFBDHZBP3FBgAFyOgANQQQMAQsgBCABQT9xQYABcjoADiAEIAFBDHZB4AFyOgAMIAQgAUEGdkE/cUGAAXI6AA1BAwshASABIABBBGooAgAgAEEIaiIDKAIAIgJrSwRAIAAgAiABECIgAygCACECCyAAKAIAIAJqIARBDGogARDRARogAyABIAJqNgIACyAEQRBqJABBAAsTACAAQZS3wAA2AgQgACABNgIACw0AIAAtAARBAnFBAXYL5QYCDH8CfiMAQbAcayIDJAACQAJAAkAgAhBXDQAgARCGAQ0AIANBCGoQZyADQcgBaiIFIAIQXQNAIARBOEcEQCAEIAVqIgYgBikDACACIARqKQMAhDcDACAEQQhqIQQMAQsLIAUQKiEHQQAhBCADQYACakE4ENABGiADQbgCakE4ENABGiADQfACaiIFEGcgA0GwBGoQZyADQfARaiIIEGcgA0GwE2oiCRBnIANB8BRqIgoQZyADQbAWaiILEGcgA0HwF2oiDBBnIANBsBlqIg0QZyADQfAaaiIGEGcgA0GwEGoQZyADQfAFaiIOIAhBwAEQ0QEaIANBsAdqIAlBwAEQ0QEaIANB8AhqIApBwAEQ0QEaIANBsApqIAtBwAEQ0QEaIANB8AtqIAxBwAEQ0QEaIANBsA1qIA1BwAEQ0QEaIANB8A5qIAZBwAEQ0QEaIAZB5wAQ0AEaIAUgARB4IAUQFCAOIAEQeAwBCyAAEGcMAQsDQCAEQcAKRwRAIANBsARqIgUgA0HwBWogBGoiBhB4IAZBwAFqIgYgBRB4IAYgA0HwAmoQCSAEQcABaiEEDAELCyADQbgCaiIEIAIQaiADKQO4AiEPIARBARCTASAEEEIgAykDuAIhECADQYACaiICIAQQaiACQQEQkwEgAhBCIAQgAiAPQgKBpxAwIANB8AJqIgQgASAQQgKBpxBuIAdBA2oiBkECdiIBQQFqIQIgA0GwBGogBBB4QQAhBAJAAkADQCADQbgCakEFEI8BIQUgAiAERgRAIAZBmANPDQIgA0HwGmogAmogBToAACADQQhqIANB8AVqIAVBGHRBGHUQHQwDCyAEQecARwRAIANB8BpqIARqIAVBEGsiBzoAACADQbgCaiIFIAdBGHRBGHUQlAEgBRBCIAVBBBAsIARBAWohBAwBCwtB5wBB5wBBuIHAABA7AAsgAkHnAEHIgcAAEDsACwNAIAFBf0cEQCADQfACaiIEIANB8AVqIANB8BpqIAFqLAAAEB0gAUEBayEBIANBCGoiAhAUIAIQFCACEBQgAhAUIAIgBBAJDAELCyMAQcABayIBJAAgARBnIAEgA0GwBGoQeCABEKQBIANBCGoiAiABEAkgAUHAAWokACAAIAJBwAEQ0QEaCyADQbAcaiQAC1ABAX8gAEE4ENABIQACQANAIAJBMEYNASAAQQgQKCACQTBHBEAgACAAKQMAIAEgAmoxAAB8NwMAIAJBAWohAgwBCwsgAkEwQaSbwAAQOwALCw0AIAAQNiAAIAEQmgELDAAgACABEGogABBUCw0AIAAQcSAAQQE2AjgLDAAgABBDIAAgARB3CwoAQQAgAGsgAHELCwAgAC0ABEEDcUULDAAgACABQQNyNgIECw0AIAAoAgAgACgCBGoLDgAgACgCABoDQAwACwALgQgCCX8CfiAANQIAIQsjAEEwayIGJABBJyEAAkAgC0KQzgBUBEAgCyEMDAELA0AgBkEJaiAAaiICQQRrIAsgC0KQzgCAIgxCkM4Afn2nIgNB//8DcUHkAG4iBEEBdEHouMAAai8AADsAACACQQJrIAMgBEHkAGxrQf//A3FBAXRB6LjAAGovAAA7AAAgAEEEayEAIAtC/8HXL1YgDCELDQALCyAMpyICQeMASwRAIABBAmsiACAGQQlqaiAMpyICIAJB//8DcUHkAG4iAkHkAGxrQf//A3FBAXRB6LjAAGovAAA7AAALAkAgAkEKTwRAIABBAmsiACAGQQlqaiACQQF0Qei4wABqLwAAOwAADAELIABBAWsiACAGQQlqaiACQTBqOgAACwJ/IAZBCWogAGohCEErQYCAxAAgASgCACIDQQFxIgIbIQQgAkEnIABrIglqIQJBlLjAAEEAIANBBHEbIQUCQAJAIAEoAghFBEBBASEAIAEgBCAFEFINAQwCCwJAAkACQAJAIAIgAUEMaigCACIDSQRAIAEtAABBCHENBEEAIQAgAyACayICIQNBASABLQAgIgcgB0EDRhtBA3FBAWsOAgECAwtBASEAIAEgBCAFEFINBAwFC0EAIQMgAiEADAELIAJBAXYhACACQQFqQQF2IQMLIABBAWohACABQRxqKAIAIQcgASgCBCECIAEoAhghCgJAA0AgAEEBayIARQ0BIAogAiAHKAIQEQQARQ0AC0EBDAQLQQEhACACQYCAxABGDQEgASAEIAUQUg0BIAEoAhggCCAJIAEoAhwoAgwRBQANASABKAIcIQQgASgCGCEBQQAhAAJ/A0AgAyAAIANGDQEaIABBAWohACABIAIgBCgCEBEEAEUNAAsgAEEBawsgA0khAAwBCyABKAIEIQcgAUEwNgIEIAEtACAhCkEBIQAgAUEBOgAgIAEgBCAFEFINAEEAIQAgAyACayICIQMCQAJAAkBBASABLQAgIgQgBEEDRhtBA3FBAWsOAgABAgtBACEDIAIhAAwBCyACQQF2IQAgAkEBakEBdiEDCyAAQQFqIQAgAUEcaigCACECIAEoAgQhBCABKAIYIQUCQANAIABBAWsiAEUNASAFIAQgAigCEBEEAEUNAAtBAQwDC0EBIQAgBEGAgMQARg0AIAEoAhggCCAJIAEoAhwoAgwRBQANACABKAIcIQAgASgCGCEFQQAhAgJAA0AgAiADRg0BIAJBAWohAiAFIAQgACgCEBEEAEUNAAtBASEAIAJBAWsgA0kNAQsgASAKOgAgIAEgBzYCBEEADAILIAAMAQsgASgCGCAIIAkgAUEcaigCACgCDBEFAAsgBkEwaiQACwsAIAAQNiAAELABCysCAX8BfkIBIQIDQCAAIAFqIAI3AwBCACECIAFBCGoiAUE4Rw0ACyAAEFQLCgAgACgCBEF4cQsKACAAKAIEQQFxCwoAIAAoAgxBAXELCgAgACgCDEEBdgsZACAAIAFByLvAACgCACIAQQIgABsRAAAAC58BAQN/AkAgASICQQ9NBEAgACEBDAELIABBACAAa0EDcSIEaiEDIAQEQCAAIQEDQCABQQA6AAAgAUEBaiIBIANJDQALCyADIAIgBGsiAkF8cSIEaiEBIARBAEoEQANAIANBADYCACADQQRqIgMgAUkNAAsLIAJBA3EhAgsgAgRAIAEgAmohAgNAIAFBADoAACABQQFqIgEgAkkNAAsLIAALuAIBB38CQCACIgRBD00EQCAAIQIMAQsgAEEAIABrQQNxIgNqIQUgAwRAIAAhAiABIQYDQCACIAYtAAA6AAAgBkEBaiEGIAJBAWoiAiAFSQ0ACwsgBSAEIANrIghBfHEiB2ohAgJAIAEgA2oiA0EDcQRAIAdBAEwNASADQQN0IgRBGHEhCSADQXxxIgZBBGohAUEAIARrQRhxIQQgBigCACEGA0AgBSAGIAl2IAEoAgAiBiAEdHI2AgAgAUEEaiEBIAVBBGoiBSACSQ0ACwwBCyAHQQBMDQAgAyEBA0AgBSABKAIANgIAIAFBBGohASAFQQRqIgUgAkkNAAsLIAhBA3EhBCADIAdqIQELIAQEQCACIARqIQMDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADSQ0ACwsgAAsHACAAIAFqCwcAIAAgAWsLBwAgAEEIagsHACAAQQhrCwQAQQALDQBC0oGc3sHF/O+ofwsNAEKL5OeV8riP17h/Cw0AQu7u59vMr5Ho5gALAwABCzABAn8DQCADIAJHBEAgACADaiIEIAQpAwAgASADaikDAHw3AwAgA0EIaiEDDAELCwswAQJ/A0AgAyACRwRAIAAgA2oiBCAEKQMAIAEgA2opAwB9NwMAIANBCGohAwwBCwsLC/k5BwBBgIDAAAsBBABBuIDAAAupAXNyYy9ibHMxMjM4MS9lY3AucnMAAAAAAKuq//////4B7v//VKz//wLqQWIPaw8qAcOc/UoUzhMCS3dk16xLQwLt6caSpvlfAqMeEaABAAAAOAAQABMAAADOAQAAFgAAADgAEAATAAAA0gEAABEAAAA4ABAAEwAAANQBAAAaAAAAOAAQABMAAAB0BAAAEQAAADgAEAATAAAAeQQAAA0AAAABAAEAAAABAjQAQZCCwAAL2SUdTFgtCCj0ANdfPjho49sAickaiP2ugQGiY6OauQ9OAZjqsIJJbckCgE5az1A67gCKaUQBAAAAAOArF47pSMwBdKk6W4xWyACiVe817/wUAOeCwgE9ycMDwRYgO+4+dQC6xGIADCBaANEIKS4BAAAAuCHovWIQxQDf/hWXO0ilAYsIMfwD1L0BuxH8JzRS0gMd8BLaG9ejASo9zjbdL9sCyGJ0HwAAAAAp0qKLLrrIAepHTpMt4MYCJIy2xiS88QMCj/DeIIv4AZ3XMT3u7YEDiKVHL5yDiQNIwghuAAAAAHv7BRY/32cCMnsXCuPH3QJpb4YUOwA2AytUW/7hmXcDzH36DVtW0gECO7ac+IFzAgfaIQMBAAAAngw5vmcQJANf3skAt8tCAjH6t7FLr0sBjJ1lcjHoAALLLt0ijxNdAdQNgwvx6fMC4fixaQEAAAAX45eEaphxAVul062lfKUA+uQdXYySbAEWi9JVfZ6zAXU7xA2ZvmMBzSzkHvHjaQIfz9OAAAAAAI7I8OMYVssA52sdPTI+8gGbM1MnD+9iAAuaxjZtnawC5W01U34R0QAhDh26+PZqAHDngXsBAAAAhO05oSXy1wG3sktBMEqUANqosoacjyECI0CGMz48mQCGFbG/UuaKA7DJjVpKE/kDU2Xt1gAAAACDKWVvxsETAXNGz7lyS8MBCAr5aH4JuQJOe27mSWX3AbE827VKp/cDBkh0wP/EXANQMgxjAQAAANmViKzpTBUBFPGdB8wbigKFicH6glm2Arsh/OxfSWgBmduZVI4R5AMsrZDZEH1mAKMml+kAAAAAYWibHWSIswHxZBzEOJe4ATM1CDMbnygDzMaX/DaqlQHk9dcSVOUHA3SCgdNtG/MDZnGOdwEAAACw3J6snZ8XAPinXIJKjw8DWMkljsYeUALjoZUPZqXMASQDzhuaCtEBMRJEBzueXQLbBUDVAAAAALuDy7Px7jQAutUwxrypPAKDtIYeDcczApfVXxCqvWwB5xd8HKhHIQKsLmLBy+pQAj7tlHIBAAAAt0lGc2IWrAKrW4u5fLUwAGGFLE7bbLUDicl/AVyLIgI+MGuFFZjZAQdEAi7QzKADsfIFGgEAAAAK3exo0YRjAQtAGd7SktMBMVnBMY+XMwF9291A31u6A7SC9oBmpbMCj1vbEbVKegKrE/yVAAAAAEHWoXk67HYDEdyQ7qqkmQA4UIOY82faAEDQrdmExXUAjX/gzKPHrwHPgqSX4FNpA2rPDqEAAAAAXlrMvZvZ9wHEtHhEJ1JuAfqAxSKY3xwCW2agoilvCANjf26ZAc90AGz9LIwsKlkDqcJ6SgEAAAA6SuhuSXQlADsbeMPj1OwAp87p7SoGcwC4OCWGTr1mAlcPVyFnWeADGIPPQ4ZNWgDPqix3AAAAAKUEY5+i+S0AcMSjCPGSNABA94KJS/LOAw4pNLVyOqcDNVc56cYGBQPfQ05V7pk5AY5fNecAAAAAHqIyNVs5nQNUB17NB+qmAL2pbTA7g04ArTXuioGEZgHH3/99oOdDA1fHmwIqRYoAIBaOOgEAAADYLMaNk+gNAwRxPbsPSbUBlwT91ii8igIyU0WVxVr8ACQIW1TrQHwD+6sOsr+4YgEaWCU0AAAAABk+uFy6OcIAP7c/JZ8l9ABqzeqsEQvgAJnyRzPGab0BQYlvH5nyvwGK+U2gl8joAeUvlrIAAAAA/zsryG4nyAF5ugksGyGqAj1x9YvEiCUAmwQwAMIzKAPoQXA2NuWYAkQcLdIQZ9UC3qVhJQEAAAAcG9JA+vk8ASZ+D41voDUCVSvGivwXhgBWcuoibY0uAe/VAW/600sDi7kshmvGPwNI1aiMAAAAAAS2yGm+VrQAwR0HsL+fQAFmKxvwWqlPAbde5WhZEj4CHRjLtS7fQgPOQqmT88BDAunka14BAAAASyJ1VHEeawLh7Wte2SZBALpGzqeW0/UArGajlaFfBwI9Z178o8RIA31WqEDEM5EDRZYSXAAAAAAzAZjb9dPZAhCZyghHK+QDbMxZBsTTMgKZTwBWMDUgADt7ddwV43sCKwC/3KayRwNKOVokAAAAAPgelwvwBEwBg3yEZGRwFAJs8DNGe4AOAZwAO8Ka0KgAsad6RD/1BABYQlV05uQGAMHKgrEAAAAAjk0H0KTIBwKzgTXRBn1zAp0kQ/YR+ecDr7kYCcOr4gJZNVLM7dL+A1AwRq63vc0DCKlGiwEAAAAywRHQGnETADq/7o8zl84DGwNhnjgW5ANgRP8kvbItA8svzZP7Qx0D40J/g2803wB55BOXAQAAADAcc8rrqq8DypuuU3cV3AOzuUNNHu3nAWEa+NtrRZ4CDCrEI0qhrQN5r45Iba9hAKGnu+EAAAAAh6Xbe1cONwDY6IHhcYCUAZ3mqwzyoeYCLXqwCXeeWQC9Oo+7oU0eAognI/oSmmUDiwHEnwAAAAAp+3AYo0xeAWhN+rc/VJEBL2RCyCZs2gAO9H9g947/AgUKF3TGpiwBr0mm9xuuzgBTjXyYAAAAAPLW6V+F+GEBslfQg5GwHgJ6dPM01sQTAMVILROGrygDuFvnPGt5JwD0XbIs7wbrA7y5sEoAAAAA8KUzNrE6sgGmHKBWssnYAwPiRFWt08MBQdn13ra+UgPQp3SgpvC4AUd4hIja0hgApPwDZgEAAADb/ujy7Nq2ARAqEGQCN/4B7sKtURMi/QMM5uFCOY/vAzZVGcQpFaIC+NMr18Q/+APeP8CMAAAAAMv05bB3XDUCKXuHsaeuFgDknc9RMsA+ApIncOStO+QCpyrUV2d02AJGHSZeCAcmAm43hh8AAAAA9uEtx0Di3wDuSAEsioVUAyZ92gAUueQDEg2Lc4xiWQPiUiWUSTtqADLhKL2Zm6UCuobHDAAAAACWxkEuWueXAPgv6otlxFkBbE3TerY+NAJBPvTgPJWwAekjEoNG+3YDtQ1EdQSWOwEQapk0AQAAADO7B5dxRZgCr/Dozqa7HgPQPD1UVsn2AkqtSKWhIjkCE60R+tyASQHCR2cJuJPoAoF82ZAAAAAAj0tjHTpHFQAR4CVNPFy9AMoFospWY80DO8lM4c6JlwEPxHHBGXgNAlcJyZoPcLcBgR364AAAAAD3Bu0mE9z6ATQgM8Vh70UBIOSAJJQn3wDSLQefpJxTAltWv/J2zVMBQ/ei2M6TywIOQGAmAAAAAMxFM1c4sZkCR7BC7vjYAQAwabjZAJrvAnP1mQh8K2YDRjNUlhRftABRTNjw+J8dAxSVa60AAAAAkhBW4im1hAKl+q7fGyZaAm9RE3nqjKgBPjBKCzm/KwL/lH9HDMVIAgdLYf3PQAcCdLbLrAAAAACoao+6nLT4AACBweDTp3ABGodcamNuswFkOaSYhu3mANBtnB2R0hoAKAQ8Um8BqQOeJS9NAAAAAFU/kbiL9G4AjddsSvWoFwJzvE996ueSASFM7R72hI8B9xYykIRK2QNlgaA6h5vCAdpcpWcBAAAASl1TVZ09IwPaIJLk7r34AyyFtDm/xFADFa+CZL0akwMM+/nETNfRA1P5hsZIGNsA045shgEAAADZLoEVWkHuABi5dwACbD0AkisTV2Mg/QDN+l8/feh7ATek5W7/prsCfjfvgPqpjwOL8D5qAQAAAFx3ahKZExoBT+7HYmkApwJfHQWgAMRbAk13veMzNOoD/exeS4LprADNoe7wy3amAgh8AGYBAAAArLf5qn9HxgKAOHPqd27jAJ9EpvXwtocBsxcHYkNVGQNSAbeCMXisArqZ7GfLtmEAl1KejQAAAAAdAKURIxQ5AnZ7u/QDd8UCIGqR7J38oAG7UMHupj18ApzRxtyNIvgCRDIDLPnQFwGVBw6+AAAAABZUX0SYbdIAauuloLA82QAnF/Rqcp5IAvZIOEzzdm8DxRXR0bTtiQPvSIN85ZRjAocofWsBAAAA8me/PbU4JQJH4lu+jTVfAWfKLs150l0C1jDE/LlGVQGFxHhXsY5uAZ+r6tuJNpABBjPfWAAAAAA9oEkuLBD2AkyNp9TYgQkBivcBPkVvNQCEknJWE8fcA0/IhbhIw0MAWy+DhgdI4ADCdS2WAQAAAMFjNrBTkkcBQBsIg70j2gB/oOdyvrUyAgy7my9g4pUDbRpg6erQ+gBQBIaULCanAsPEEmEBAAAAc3JjL2JsczEyMzgxL2JpZy5ycwBQDRAAEwAAAE4AAAAWAAAAUA0QABMAAADtAAAAGgAAAFANEAATAAAA7QAAAA0AAABQDRAAEwAAAO8AAAAJAAAAUA0QABMAAACmAQAAFwAAAFANEAATAAAALQIAABIAAABQDRAAEwAAAFIDAAAYAAAAUA0QABMAAABSAwAAIQAAAFANEAATAAAAXAMAACEAAABQDRAAEwAAAHUDAAAXAAAAUA0QABMAAAB+AwAAFwAAAFANEAATAAAAwQMAABgAAABQDRAAEwAAAM8DAAAYAAAAVHJpZWQgdG8gc2hyaW5rIHRvIGEgbGFyZ2VyIGNhcGFjaXR5NA4QACQAAAAvcnVzdGMvZmU1YjEzZDY4MWYyNWVlNjQ3NGJlMjlkNzQ4YzY1YWRjZDkxZjY5ZS9saWJyYXJ5L2FsbG9jL3NyYy9yYXdfdmVjLnJzYA4QAEwAAACpAQAACQAAAAAAAAAirijXmC+KQs1l7yORRDdxLztN7M/7wLW824mBpdu16Ti1SPNbwlY5GdAFtvER8VmbTxmvpII/khiBbdrVXhyrQgIDo5iqB9i+b3BFAVuDEoyy5E6+hTEk4rT/1cN9DFVviXvydF2+crGWFjv+sd6ANRLHJacG3JuUJmnPdPGbwdJK8Z7BaZvk4yVPOIZHvu+11YyLxp3BD2WcrHfMoQwkdQIrWW8s6S2D5KZuqoR0StT7Qb3cqbBctVMRg9qI+Xar32buUlE+mBAytC1txjGoPyH7mMgnA7DkDu++x39Zv8KPqD3zC+DGJacKk0eRp9VvggPgUWPKBnBuDgpnKSkU/C/SRoUKtycmySZcOCEbLu0qxFr8bSxN37OVnRMNOFPeY6+LVHMKZaiydzy7Cmp25q7tRy7JwoE7NYIUhSxykmQD8Uyh6L+iATBCvEtmGqiRl/jQcItLwjC+VAajUWzHGFLv1hnoktEQqWVVJAaZ1iogcVeFNQ70uNG7MnCgahDI0NK4FsGkGVOrQVEIbDcemeuO30x3SCeoSJvhtbywNGNaycWzDBw5y4pB40qq2E5z42N3T8qcW6O4stbzby5o/LLvXe6Cj3RgLxdDb2OleHKr8KEUeMiE7DlkGggCx4woHmMj+v++kOm9gt7rbFCkFXnGsvej+b4rU3Lj8nhxxpxhJurOPifKB8LAIce4htEe6+DN1n3a6njRbu5/T331um8Xcqpn8AammMiixX1jCq4N+b4EmD8RG0ccEzULcRuEfQQj9XfbKJMkx0B7q8oyvL7JFQq+njxMDRCcxGcdQ7ZCPsu+1MVMKn5l/Jwpf1ns+tY6q2/LXxdYR0qMGURsmC+KQpFEN3HP+8C1pdu16VvCVjnxEfFZpII/ktVeHKuYqgfYAVuDEr6FMSTDfQxVdF2+cv6x3oCnBtybdPGbwcFpm+SGR77vxp3BD8yhDCRvLOktqoR0StypsFzaiPl2UlE+mG3GMajIJwOwx39Zv/ML4MZHkafVUWPKBmcpKRSFCrcnOCEbLvxtLE0TDThTVHMKZbsKanYuycKBhSxykqHov6JLZhqocItLwqNRbMcZ6JLRJAaZ1oU1DvRwoGoQFsGkGQhsNx5Md0gntbywNLMMHDlKqthOT8qcW/NvLmjugo90b2OleBR4yIQIAseM+v++kOtsUKT3o/m+8nhxxnNyYy9ibHMxMjM4MS9ibHMucnMAAAAAAKuq//////4B7v//VKz//wLqQWIPaw8qAcOc/UoUzhMCS3dk16xLQwLt6caSpvlfAqMeEaABAAAAQBIQABMAAABBAAAAEwAAAEASEAATAAAAQQAAAA0AAABAEhAAEwAAAEMAAAAsAAAAQkxTX1NJR19CTFMxMjM4MUcxX1hNRDpTSEEtMjU2X1NTV1VfUk9fTlVMX3NyYy9ibHMxMjM4MS9mcDIucnMAAOsSEAATAAAAmwAAABIAAADrEhAAEwAAAJ8AAAASAAAAc3JjL2JsczEyMzgxL2VjcDIucnMgExAAFAAAAJMAAAAVAAAAIBMQABQAAACUAAAAFQAAACATEAAUAAAAlQAAABUAAAAgExAAFAAAAJYAAAAVAAAAIBMQABQAAACXAAAAFQAAACATEAAUAAAAmAAAABUAAAAgExAAFAAAAJkAAAAVAAAAIBMQABQAAACaAAAAFQAAACATEAAUAAAAGQEAABEAAAAgExAAFAAAACIBAAAWAAAAIBMQABQAAAAoAQAAGgAAAAAAAAAEAEGgqMAAC/kEIBMQABQAAABXAgAADQAAACATEAAUAAAAXAIAAAkAAAC4vSHByFaAAPX7bgGqyQADunAXPa5HtgBE0QrsAOlTA3rkxlEQxS0DSQGCSaTCIwAvK6okAAAAAH4rBF0FfawB+VUX5YREPAM0kwT1x70bAmnXatiCZEID0GtZZU8niADoNGsf2GecAAW2Aj4BAAAAASi4CIZUkwF4oijrDnOyAiPJEg0WlaYBCrWdTvcyqgKb/a0aNS7aAnFzMmOEW58Ad1JdzgAAAAC+eV/wXwepAmpoBzvXScMB87Oa6XK1KgHSmbyOnRb6ASg+y5mLwisArDSrDDPNqQMCSmxgAAAAAHNyYy9obWFjLnJzACAVEAALAAAAewAAABQAAAAgFRAACwAAAHsAAAANAAAAIBUQAAsAAAB/AAAAIAAAACAVEAALAAAAfwAAAA0AAAAgFRAACwAAAIIAAAANAAAAIBUQAAsAAAB3AAAAFAAAACAVEAALAAAAdwAAAA0AAAAAAAAAYXR0ZW1wdCB0byBkaXZpZGUgYnkgemVybwAAACAVEAALAAAARAEAAAUAAABIMkMtT1ZFUlNJWkUtRFNULQAAACAVEAALAAAAWwEAADYAAAAgFRAACwAAAHABAAAJAAAAIBUQAAsAAAByAQAABQAAACAVEAALAAAAdAEAAEAAAAAgFRAACwAAAHkBAAAUAAAAIBUQAAsAAAB/AQAADQAAACAVEAALAAAAgQEAAAkAAAAgFRAACwAAAIMBAAAzAAAAIBUQAAsAAACDAQAASwAAACAVEAALAAAAhQEAABQAAAAgFRAACwAAAIUBAAANAAAAAAABAAAAAQI0AEHIrcAAC5wBuF8jku11BwFjT+D5WE+pA2dPnKtLeD0Akew9ffXy9AMD1g8fDSwgAK1vjPCZwa4A8DtNkAEAAADzStxtEor3AIuwH1tTsFYDgvLFYx+X7AAysL/NHtseAkehVLifHyMCQHo6ogw4sQGz4sMPAAAAAP7//v///wECiwCAgtgE9gHhjWiJb76TAs52q989qB0Axmm6Uc523wPLWcYXAEHwrsAAC+EEAQAAAAAAAACCgAAAAAAAAIqAAAAAAACAAIAAgAAAAICLgAAAAAAAAAEAAIAAAAAAgYAAgAAAAIAJgAAAAAAAgIoAAAAAAAAAiAAAAAAAAAAJgACAAAAAAAoAAIAAAAAAi4AAgAAAAACLAAAAAAAAgImAAAAAAACAA4AAAAAAAIACgAAAAAAAgIAAAAAAAACACoAAAAAAAAAKAACAAAAAgIGAAIAAAACAgIAAAAAAAIABAACAAAAAAAiAAIAAAACAc3JjL3NoYTMucnMAMBgQAAsAAAC/AAAACQAAADAYEAALAAAA2QAAABAAAAAAAAAAYXR0ZW1wdCB0byBkaXZpZGUgYnkgemVybwAAADAYEAALAAAA3QAAABwAAAAwGBAACwAAAN8AAAAVAAAAMBgQAAsAAADpAAAAGAAAADAYEAALAAAA6wAAABEAAABzcmMvYmxzMTIzODEvZGJpZy5yc7wYEAAUAAAAXAAAAA4AAAC8GBAAFAAAAFwAAAAyAAAAvBgQABQAAABfAAAAOAAAALwYEAAUAAAAYgAAAAkAAAC8GBAAFAAAAG4AAAASAAAAvBgQABQAAABtAAAADQAAALwYEAAUAAAAcAAAAAkAAACrqv/////+Ae7//1Ss//8C6kFiD2sPKgHDnP1KFM4TAkt3ZNesS0MC7enGkqb5XwKjHhGgAQAAAK73vtWhOQYC6JPdYmRMJAHSLG5OtQktAtvlcDG2xBEBmWM2++htigO8nB/tzxZPACtqpp4BAAAAc3JjL2JsczEyMzgxL2ZwLnJzAACwGRAAEgAAAHoBAAANAEHgs8AAC8EHYXR0ZW1wdCB0byBkaXZpZGUgYnkgemVybwAAAAAAAABhdHRlbXB0IHRvIGRpdmlkZSB3aXRoIG92ZXJmbG93ALAZEAASAAAADAIAAA0AAACwGRAAEgAAABgCAAAmAAAAsBkQABIAAAAYAgAAIwAAALAZEAASAAAAHgIAABcAAACwGRAAEgAAAB4CAAAUAAAAqqr//////gHu//9UrP//AupBYg9rDyoBw5z9ShTOEwJLd2TXrEtDAu3pxpKm+V8Cox4RoAEAAAADAAAABAAAAAQAAAAEAAAABQAAAAYAAABjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlbWVtb3J5IGFsbG9jYXRpb24gb2YgIGJ5dGVzIGZhaWxlZAoAAOsaEAAVAAAAABsQAA4AAABsaWJyYXJ5L3N0ZC9zcmMvYWxsb2MucnMgGxAAGAAAAEkBAAAJAAAAbGlicmFyeS9zdGQvc3JjL3Bhbmlja2luZy5yc0gbEAAcAAAARgIAAB8AAABIGxAAHAAAAEcCAAAeAAAABwAAAAwAAAAEAAAACAAAAAMAAAAIAAAABAAAAAkAAAAKAAAAEAAAAAQAAAALAAAADAAAAAMAAAAIAAAABAAAAA0AAAAOAAAAbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc2NhcGFjaXR5IG92ZXJmbG93AAAA6BsQABEAAADMGxAAHAAAAAUCAAAFAAAAEAAAAAAAAAABAAAAEQAAAGluZGV4IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaXMgAAAkHBAAIAAAAEQcEAASAAAAMDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTkgb3V0IG9mIHJhbmdlIGZvciBzbGljZSBvZiBsZW5ndGggbGlicmFyeS9jb3JlL3NyYy9zbGljZS9pbmRleC5yc3JhbmdlIGVuZCBpbmRleCAAAABxHRAAEAAAADAdEAAiAAAAUh0QAB8AAABJAAAABQB7CXByb2R1Y2VycwIIbGFuZ3VhZ2UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdGMdMS42MS4wIChmZTViMTNkNjggMjAyMi0wNS0xOCkGd2FscnVzBjAuMTkuMAx3YXNtLWJpbmRnZW4SMC4yLjgxICgwNjJhYTVmNzAp`;
let wasm;
const wasmBytes = decode$2(wasmBytesBase64);
function bls_init() {
  let ret = wasm.bls_init();
  return ret;
}
let cachegetUint8Memory0 = null;
function getUint8Memory0() {
  if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {
    cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachegetUint8Memory0;
}
function passArray8ToWasm0(arg, malloc) {
  const ptr = malloc(arg.length * 1);
  getUint8Memory0().set(arg, ptr / 1);
  return [ptr, arg.length];
}
function bls_verify(sig, m2, w2) {
  const [ptr0, len0] = passArray8ToWasm0(sig, wasm.__wbindgen_malloc);
  const [ptr1, len1] = passArray8ToWasm0(m2, wasm.__wbindgen_malloc);
  const [ptr2, len2] = passArray8ToWasm0(w2, wasm.__wbindgen_malloc);
  const ret = wasm.bls_verify(ptr0, len0, ptr1, len1, ptr2, len2);
  return ret;
}
async function load(module2, imports) {
  if (typeof Response === "function" && module2 instanceof Response) {
    const bytes2 = await module2.arrayBuffer();
    return await WebAssembly.instantiate(bytes2, imports);
  } else {
    const instance = await WebAssembly.instantiate(module2, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module: module2 };
    } else {
      return instance;
    }
  }
}
async function init() {
  const imports = {};
  const { instance, module: module2 } = await load(wasmBytes, imports);
  wasm = instance.exports;
  init.__wbindgen_wasm_module = module2;
  return wasm;
}
let verify;
async function blsVerify(pk2, sig, msg) {
  if (!verify) {
    await init();
    if (bls_init() !== 0) {
      throw new Error("Cannot initialize BLS");
    }
    verify = (pk1, sig1, msg1) => {
      return bls_verify(sig1, msg1, pk1) === 0;
    };
  }
  return verify(pk2, sig, msg);
}
class CertificateVerificationError extends AgentError {
  constructor(reason) {
    super(`Invalid certificate: ${reason}`);
  }
}
function isBufferEqual(a, b2) {
  if (a.byteLength !== b2.byteLength) {
    return false;
  }
  const a8 = new Uint8Array(a);
  const b8 = new Uint8Array(b2);
  for (let i2 = 0; i2 < a8.length; i2++) {
    if (a8[i2] !== b8[i2]) {
      return false;
    }
  }
  return true;
}
class Certificate {
  constructor(certificate, _rootKey, _canisterId, _blsVerify) {
    this._rootKey = _rootKey;
    this._canisterId = _canisterId;
    this._blsVerify = _blsVerify;
    this.cert = decode(new Uint8Array(certificate));
  }
  static async create(options) {
    let blsVerify$12 = options.blsVerify;
    if (!blsVerify$12) {
      blsVerify$12 = blsVerify;
    }
    const cert = new Certificate(options.certificate, options.rootKey, options.canisterId, blsVerify$12);
    await cert.verify();
    return cert;
  }
  lookup(path) {
    return lookup_path(path, this.cert.tree);
  }
  async verify() {
    const rootHash = await reconstruct(this.cert.tree);
    const derKey = await this._checkDelegationAndGetKey(this.cert.delegation);
    const sig = this.cert.signature;
    const key = extractDER(derKey);
    const msg = concat(domain_sep("ic-state-root"), rootHash);
    let sigVer = false;
    try {
      sigVer = await this._blsVerify(new Uint8Array(key), new Uint8Array(sig), new Uint8Array(msg));
    } catch (err) {
      sigVer = false;
    }
    if (!sigVer) {
      throw new CertificateVerificationError("Signature verification failed");
    }
  }
  async _checkDelegationAndGetKey(d2) {
    if (!d2) {
      return this._rootKey;
    }
    const cert = await Certificate.create({
      certificate: d2.certificate,
      rootKey: this._rootKey,
      canisterId: this._canisterId
    });
    const rangeLookup = cert.lookup(["subnet", d2.subnet_id, "canister_ranges"]);
    if (!rangeLookup) {
      throw new CertificateVerificationError(`Could not find canister ranges for subnet 0x${toHex(d2.subnet_id)}`);
    }
    const ranges_arr = decode(rangeLookup);
    const ranges = ranges_arr.map((v2) => [
      Principal$3.fromUint8Array(v2[0]),
      Principal$3.fromUint8Array(v2[1])
    ]);
    const canisterInRange = ranges.some((r2) => r2[0].ltEq(this._canisterId) && r2[1].gtEq(this._canisterId));
    if (!canisterInRange) {
      throw new CertificateVerificationError(`Canister ${this._canisterId} not in range of delegations for subnet 0x${toHex(d2.subnet_id)}`);
    }
    const publicKeyLookup = cert.lookup(["subnet", d2.subnet_id, "public_key"]);
    if (!publicKeyLookup) {
      throw new Error(`Could not find subnet key for subnet 0x${toHex(d2.subnet_id)}`);
    }
    return publicKeyLookup;
  }
}
const DER_PREFIX = fromHex("308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100");
const KEY_LENGTH = 96;
function extractDER(buf) {
  const expectedLength = DER_PREFIX.byteLength + KEY_LENGTH;
  if (buf.byteLength !== expectedLength) {
    throw new TypeError(`BLS DER-encoded public key must be ${expectedLength} bytes long`);
  }
  const prefix2 = buf.slice(0, DER_PREFIX.byteLength);
  if (!isBufferEqual(prefix2, DER_PREFIX)) {
    throw new TypeError(`BLS DER-encoded public key is invalid. Expect the following prefix: ${DER_PREFIX}, but get ${prefix2}`);
  }
  return buf.slice(DER_PREFIX.byteLength);
}
async function reconstruct(t2) {
  switch (t2[0]) {
    case 0:
      return hash(domain_sep("ic-hashtree-empty"));
    case 4:
      return t2[1];
    case 3:
      return hash(concat(domain_sep("ic-hashtree-leaf"), t2[1]));
    case 2:
      return hash(concat(domain_sep("ic-hashtree-labeled"), t2[1], await reconstruct(t2[2])));
    case 1:
      return hash(concat(domain_sep("ic-hashtree-fork"), await reconstruct(t2[1]), await reconstruct(t2[2])));
    default:
      throw new Error("unreachable");
  }
}
function domain_sep(s) {
  const len2 = new Uint8Array([s.length]);
  const str = new TextEncoder().encode(s);
  return concat(len2, str);
}
function lookup_path(path, tree) {
  if (path.length === 0) {
    switch (tree[0]) {
      case 3: {
        return new Uint8Array(tree[1]).buffer;
      }
      default: {
        return void 0;
      }
    }
  }
  const label = typeof path[0] === "string" ? new TextEncoder().encode(path[0]) : path[0];
  const t2 = find_label(label, flatten_forks(tree));
  if (t2) {
    return lookup_path(path.slice(1), t2);
  }
}
function flatten_forks(t2) {
  switch (t2[0]) {
    case 0:
      return [];
    case 1:
      return flatten_forks(t2[1]).concat(flatten_forks(t2[2]));
    default:
      return [t2];
  }
}
function find_label(l2, trees) {
  if (trees.length === 0) {
    return void 0;
  }
  for (const t2 of trees) {
    if (t2[0] === 2) {
      const p2 = t2[1];
      if (isBufferEqual(l2, p2)) {
        return t2[2];
      }
    }
  }
}
const FIVE_MINUTES_IN_MSEC = 5 * 60 * 1e3;
function defaultStrategy() {
  return chain(conditionalDelay(once(), 1e3), backoff(1e3, 1.2), timeout$1(FIVE_MINUTES_IN_MSEC));
}
function once() {
  let first = true;
  return async () => {
    if (first) {
      first = false;
      return true;
    }
    return false;
  };
}
function conditionalDelay(condition, timeInMsec) {
  return async (canisterId, requestId, status) => {
    if (await condition(canisterId, requestId, status)) {
      return new Promise((resolve) => setTimeout(resolve, timeInMsec));
    }
  };
}
function timeout$1(timeInMsec) {
  const end = Date.now() + timeInMsec;
  return async (canisterId, requestId, status) => {
    if (Date.now() > end) {
      throw new Error(`Request timed out after ${timeInMsec} msec:
  Request ID: ${toHex(requestId)}
  Request status: ${status}
`);
    }
  };
}
function backoff(startingThrottleInMsec, backoffFactor) {
  let currentThrottling = startingThrottleInMsec;
  return () => new Promise((resolve) => setTimeout(() => {
    currentThrottling *= backoffFactor;
    resolve();
  }, currentThrottling));
}
function chain(...strategies) {
  return async (canisterId, requestId, status) => {
    for (const a of strategies) {
      await a(canisterId, requestId, status);
    }
  };
}
async function pollForResponse(agent, canisterId, requestId, strategy2, request2, blsVerify2) {
  var _a;
  const path = [new TextEncoder().encode("request_status"), requestId];
  const currentRequest = request2 !== null && request2 !== void 0 ? request2 : await ((_a = agent.createReadStateRequest) === null || _a === void 0 ? void 0 : _a.call(agent, { paths: [path] }));
  const state = await agent.readState(canisterId, { paths: [path] }, void 0, currentRequest);
  if (agent.rootKey == null)
    throw new Error("Agent root key not initialized before polling");
  const cert = await Certificate.create({
    certificate: state.certificate,
    rootKey: agent.rootKey,
    canisterId,
    blsVerify: blsVerify2
  });
  const maybeBuf = cert.lookup([...path, new TextEncoder().encode("status")]);
  let status;
  if (typeof maybeBuf === "undefined") {
    status = RequestStatusResponseStatus.Unknown;
  } else {
    status = new TextDecoder().decode(maybeBuf);
  }
  switch (status) {
    case RequestStatusResponseStatus.Replied: {
      return cert.lookup([...path, "reply"]);
    }
    case RequestStatusResponseStatus.Received:
    case RequestStatusResponseStatus.Unknown:
    case RequestStatusResponseStatus.Processing:
      await strategy2(canisterId, requestId, status);
      return pollForResponse(agent, canisterId, requestId, strategy2, currentRequest);
    case RequestStatusResponseStatus.Rejected: {
      const rejectCode = new Uint8Array(cert.lookup([...path, "reject_code"]))[0];
      const rejectMessage = new TextDecoder().decode(cert.lookup([...path, "reject_message"]));
      throw new Error(`Call was rejected:
  Request ID: ${toHex(requestId)}
  Reject code: ${rejectCode}
  Reject text: ${rejectMessage}
`);
    }
    case RequestStatusResponseStatus.Done:
      throw new Error(`Call was marked as done but we never saw the reply:
  Request ID: ${toHex(requestId)}
`);
  }
  throw new Error("unreachable");
}
class ActorCallError extends AgentError {
  constructor(canisterId, methodName, type, props) {
    super([
      `Call failed:`,
      `  Canister: ${canisterId.toText()}`,
      `  Method: ${methodName} (${type})`,
      ...Object.getOwnPropertyNames(props).map((n2) => `  "${n2}": ${JSON.stringify(props[n2])}`)
    ].join("\n"));
    this.canisterId = canisterId;
    this.methodName = methodName;
    this.type = type;
    this.props = props;
  }
}
class QueryCallRejectedError extends ActorCallError {
  constructor(canisterId, methodName, result) {
    var _a;
    super(canisterId, methodName, "query", {
      Status: result.status,
      Code: (_a = ReplicaRejectCode[result.reject_code]) !== null && _a !== void 0 ? _a : `Unknown Code "${result.reject_code}"`,
      Message: result.reject_message
    });
    this.result = result;
  }
}
class UpdateCallRejectedError extends ActorCallError {
  constructor(canisterId, methodName, requestId, response) {
    super(canisterId, methodName, "update", {
      "Request ID": toHex(requestId),
      "HTTP status code": response.status.toString(),
      "HTTP status text": response.statusText
    });
    this.requestId = requestId;
    this.response = response;
  }
}
var CanisterInstallMode;
(function(CanisterInstallMode2) {
  CanisterInstallMode2["Install"] = "install";
  CanisterInstallMode2["Reinstall"] = "reinstall";
  CanisterInstallMode2["Upgrade"] = "upgrade";
})(CanisterInstallMode || (CanisterInstallMode = {}));
const metadataSymbol = Symbol.for("ic-agent-metadata");
class Actor {
  constructor(metadata) {
    this[metadataSymbol] = Object.freeze(metadata);
  }
  static agentOf(actor) {
    return actor[metadataSymbol].config.agent;
  }
  static interfaceOf(actor) {
    return actor[metadataSymbol].service;
  }
  static canisterIdOf(actor) {
    return Principal$3.from(actor[metadataSymbol].config.canisterId);
  }
  static async install(fields, config) {
    const mode = fields.mode === void 0 ? CanisterInstallMode.Install : fields.mode;
    const arg = fields.arg ? [...new Uint8Array(fields.arg)] : [];
    const wasmModule = [...new Uint8Array(fields.module)];
    const canisterId = typeof config.canisterId === "string" ? Principal$3.fromText(config.canisterId) : config.canisterId;
    await getManagementCanister(config).install_code({
      mode: { [mode]: null },
      arg,
      wasm_module: wasmModule,
      canister_id: canisterId
    });
  }
  static async createCanister(config) {
    const { canister_id: canisterId } = await getManagementCanister(config || {}).provisional_create_canister_with_cycles({ amount: [], settings: [] });
    return canisterId;
  }
  static async createAndInstallCanister(interfaceFactory, fields, config) {
    const canisterId = await this.createCanister(config);
    await this.install(Object.assign({}, fields), Object.assign(Object.assign({}, config), { canisterId }));
    return this.createActor(interfaceFactory, Object.assign(Object.assign({}, config), { canisterId }));
  }
  static createActorClass(interfaceFactory) {
    const service = interfaceFactory({ IDL });
    class CanisterActor extends Actor {
      constructor(config) {
        const canisterId = typeof config.canisterId === "string" ? Principal$3.fromText(config.canisterId) : config.canisterId;
        super({
          config: Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), config), { canisterId }),
          service
        });
        for (const [methodName, func] of service._fields) {
          this[methodName] = _createActorMethod(this, methodName, func, config.blsVerify);
        }
      }
    }
    return CanisterActor;
  }
  static createActor(interfaceFactory, configuration) {
    return new (this.createActorClass(interfaceFactory))(configuration);
  }
}
function decodeReturnValue(types, msg) {
  const returnValues = decode$1(types, buffer$1.Buffer.from(msg));
  switch (returnValues.length) {
    case 0:
      return void 0;
    case 1:
      return returnValues[0];
    default:
      return returnValues;
  }
}
const DEFAULT_ACTOR_CONFIG = {
  pollingStrategyFactory: defaultStrategy
};
function _createActorMethod(actor, methodName, func, blsVerify2) {
  let caller;
  if (func.annotations.includes("query")) {
    caller = async (options, ...args) => {
      var _a, _b;
      options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).queryTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));
      const agent = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();
      const cid = Principal$3.from(options.canisterId || actor[metadataSymbol].config.canisterId);
      const arg = encode$1(func.argTypes, args);
      const result = await agent.query(cid, { methodName, arg });
      switch (result.status) {
        case "rejected":
          throw new QueryCallRejectedError(cid, methodName, result);
        case "replied":
          return decodeReturnValue(func.retTypes, result.reply.arg);
      }
    };
  } else {
    caller = async (options, ...args) => {
      var _a, _b;
      options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).callTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));
      const agent = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();
      const { canisterId, effectiveCanisterId, pollingStrategyFactory } = Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), actor[metadataSymbol].config), options);
      const cid = Principal$3.from(canisterId);
      const ecid = effectiveCanisterId !== void 0 ? Principal$3.from(effectiveCanisterId) : cid;
      const arg = encode$1(func.argTypes, args);
      const { requestId, response } = await agent.call(cid, {
        methodName,
        arg,
        effectiveCanisterId: ecid
      });
      if (!response.ok) {
        throw new UpdateCallRejectedError(cid, methodName, requestId, response);
      }
      const pollStrategy = pollingStrategyFactory();
      const responseBytes = await pollForResponse(agent, ecid, requestId, pollStrategy, blsVerify2);
      if (responseBytes !== void 0) {
        return decodeReturnValue(func.retTypes, responseBytes);
      } else if (func.retTypes.length === 0) {
        return void 0;
      } else {
        throw new Error(`Call was returned undefined, but type [${func.retTypes.join(",")}].`);
      }
    };
  }
  const handler = (...args) => caller({}, ...args);
  handler.withOptions = (options) => (...args) => caller(options, ...args);
  return handler;
}
const idlFactory = ({ IDL: IDL2 }) => {
  const Item = IDL2.Record({
    "token_id": IDL2.Int,
    "name": IDL2.Text,
    "canister_id": IDL2.Principal
  });
  const Trade2 = IDL2.Record({
    "id": IDL2.Text,
    "host_escrow": IDL2.Vec(Item),
    "host_data": IDL2.Vec(Item),
    "fulfilled": IDL2.Bool,
    "host": IDL2.Principal,
    "guest_data": IDL2.Vec(Item),
    "host_accept": IDL2.Bool,
    "guest_escrow": IDL2.Vec(Item),
    "guest": IDL2.Principal,
    "guest_accept": IDL2.Bool
  });
  return IDL2.Service({
    "accept": IDL2.Func([IDL2.Text], [Trade2], []),
    "add_item_to_escrow": IDL2.Func([IDL2.Text, Item], [Trade2], []),
    "add_item_to_trade": IDL2.Func([IDL2.Text, Item], [Trade2], []),
    "cancel": IDL2.Func([IDL2.Text], [Trade2], []),
    "create_trade": IDL2.Func([], [Trade2], []),
    "delete_trade": IDL2.Func([IDL2.Text], [Trade2], []),
    "get_all_trades": IDL2.Func([], [IDL2.Vec(Trade2)], ["query"]),
    "get_escrow_items": IDL2.Func([IDL2.Text], [IDL2.Vec(Item)], ["query"]),
    "get_escrow_items_self": IDL2.Func([IDL2.Text], [IDL2.Vec(Item)], ["query"]),
    "get_trade_by_id": IDL2.Func([IDL2.Text], [IDL2.Opt(Trade2)], ["query"]),
    "join_trade": IDL2.Func([IDL2.Text], [Trade2], []),
    "leave_trade": IDL2.Func([IDL2.Text], [Trade2], []),
    "remove_item_from_escrow": IDL2.Func([IDL2.Text, Item], [Trade2], []),
    "remove_item_from_trade": IDL2.Func([IDL2.Text, Item], [Trade2], []),
    "withdraw_from_escrow": IDL2.Func([IDL2.Text, Item], [Item], [])
  });
};
const canister_id$1 = "rrkah-fqaaa-aaaaa-aaaaq-cai";
const createActor = (canister_id2, options = {}) => {
  const agent = options.agent || new HttpAgent({ ...options.agentOptions });
  if (options.agent && options.agentOptions) {
    console.warn(
      "Detected both agent and agentOptions passed to createActor. Ignoring agentOptions and proceeding with the provided agent."
    );
  }
  agent.fetchRootKey().catch((err) => {
    console.warn(
      "Unable to fetch root key. Check to ensure that your local replica is running"
    );
    console.error(err);
  });
  return Actor.createActor(idlFactory, {
    agent,
    canisterId: canister_id2,
    ...options.actorOptions
  });
};
const trade_canister = createActor(canister_id$1, {
  agentOptions: {
    host: "http://127.0.0.1:4943"
  }
});
var stylis_min = { exports: {} };
(function(module2, exports2) {
  !function(e2) {
    module2.exports = e2(null);
  }(function e2(a) {
    var r2 = /^\0+/g, c2 = /[\0\r\f]/g, s = /: */g, t2 = /zoo|gra/, i2 = /([,: ])(transform)/g, f2 = /,+\s*(?![^(]*[)])/g, n2 = / +\s*(?![^(]*[)])/g, l2 = / *[\0] */g, o = /,\r+?/g, h2 = /([\t\r\n ])*\f?&/g, u2 = /:global\(((?:[^\(\)\[\]]*|\[.*\]|\([^\(\)]*\))*)\)/g, d2 = /\W+/g, b2 = /@(k\w+)\s*(\S*)\s*/, p2 = /::(place)/g, k2 = /:(read-only)/g, g2 = /\s+(?=[{\];=:>])/g, A2 = /([[}=:>])\s+/g, C2 = /(\{[^{]+?);(?=\})/g, w2 = /\s{2,}/g, v2 = /([^\(])(:+) */g, m2 = /[svh]\w+-[tblr]{2}/, x2 = /\(\s*(.*)\s*\)/g, $ = /([\s\S]*?);/g, y2 = /-self|flex-/g, O2 = /[^]*?(:[rp][el]a[\w-]+)[^]*/, j = /stretch|:\s*\w+\-(?:conte|avail)/, z2 = /([^-])(image-set\()/, N2 = "-webkit-", S2 = "-moz-", F2 = "-ms-", W2 = 59, q2 = 125, B2 = 123, D2 = 40, E2 = 41, G2 = 91, H2 = 93, I2 = 10, J2 = 13, K2 = 9, L2 = 64, M2 = 32, P2 = 38, Q2 = 45, R2 = 95, T2 = 42, U2 = 44, V2 = 58, X2 = 39, Y2 = 34, Z2 = 47, _2 = 62, ee2 = 43, ae2 = 126, re2 = 0, ce2 = 12, se2 = 11, te2 = 107, ie2 = 109, fe2 = 115, ne2 = 112, le2 = 111, oe2 = 105, he2 = 99, ue2 = 100, de2 = 112, be2 = 1, pe2 = 1, ke2 = 0, ge2 = 1, Ae2 = 1, Ce2 = 1, we2 = 0, ve2 = 0, me2 = 0, xe2 = [], $e2 = [], ye2 = 0, Oe2 = null, je2 = -2, ze2 = -1, Ne2 = 0, Se2 = 1, Fe2 = 2, We2 = 3, qe2 = 0, Be2 = 1, De2 = "", Ee2 = "", Ge2 = "";
    function He2(e3, a2, s2, t3, i3) {
      for (var f3, n3, o2 = 0, h3 = 0, u3 = 0, d3 = 0, g3 = 0, A3 = 0, C3 = 0, w3 = 0, m3 = 0, $2 = 0, y3 = 0, O3 = 0, j2 = 0, z3 = 0, R3 = 0, we3 = 0, $e3 = 0, Oe3 = 0, je3 = 0, ze3 = s2.length, Je3 = ze3 - 1, Re3 = "", Te3 = "", Ue2 = "", Ve2 = "", Xe2 = "", Ye2 = ""; R3 < ze3; ) {
        if (C3 = s2.charCodeAt(R3), R3 === Je3) {
          if (h3 + d3 + u3 + o2 !== 0) {
            if (0 !== h3)
              C3 = h3 === Z2 ? I2 : Z2;
            d3 = u3 = o2 = 0, ze3++, Je3++;
          }
        }
        if (h3 + d3 + u3 + o2 === 0) {
          if (R3 === Je3) {
            if (we3 > 0)
              Te3 = Te3.replace(c2, "");
            if (Te3.trim().length > 0) {
              switch (C3) {
                case M2:
                case K2:
                case W2:
                case J2:
                case I2:
                  break;
                default:
                  Te3 += s2.charAt(R3);
              }
              C3 = W2;
            }
          }
          if (1 === $e3)
            switch (C3) {
              case B2:
              case q2:
              case W2:
              case Y2:
              case X2:
              case D2:
              case E2:
              case U2:
                $e3 = 0;
              case K2:
              case J2:
              case I2:
              case M2:
                break;
              default:
                for ($e3 = 0, je3 = R3, g3 = C3, R3--, C3 = W2; je3 < ze3; )
                  switch (s2.charCodeAt(je3++)) {
                    case I2:
                    case J2:
                    case W2:
                      ++R3, C3 = g3, je3 = ze3;
                      break;
                    case V2:
                      if (we3 > 0)
                        ++R3, C3 = g3;
                    case B2:
                      je3 = ze3;
                  }
            }
          switch (C3) {
            case B2:
              for (g3 = (Te3 = Te3.trim()).charCodeAt(0), y3 = 1, je3 = ++R3; R3 < ze3; ) {
                switch (C3 = s2.charCodeAt(R3)) {
                  case B2:
                    y3++;
                    break;
                  case q2:
                    y3--;
                    break;
                  case Z2:
                    switch (A3 = s2.charCodeAt(R3 + 1)) {
                      case T2:
                      case Z2:
                        R3 = Qe2(A3, R3, Je3, s2);
                    }
                    break;
                  case G2:
                    C3++;
                  case D2:
                    C3++;
                  case Y2:
                  case X2:
                    for (; R3++ < Je3 && s2.charCodeAt(R3) !== C3; )
                      ;
                }
                if (0 === y3)
                  break;
                R3++;
              }
              if (Ue2 = s2.substring(je3, R3), g3 === re2)
                g3 = (Te3 = Te3.replace(r2, "").trim()).charCodeAt(0);
              switch (g3) {
                case L2:
                  if (we3 > 0)
                    Te3 = Te3.replace(c2, "");
                  switch (A3 = Te3.charCodeAt(1)) {
                    case ue2:
                    case ie2:
                    case fe2:
                    case Q2:
                      f3 = a2;
                      break;
                    default:
                      f3 = xe2;
                  }
                  if (je3 = (Ue2 = He2(a2, f3, Ue2, A3, i3 + 1)).length, me2 > 0 && 0 === je3)
                    je3 = Te3.length;
                  if (ye2 > 0) {
                    if (f3 = Ie2(xe2, Te3, Oe3), n3 = Pe2(We2, Ue2, f3, a2, pe2, be2, je3, A3, i3, t3), Te3 = f3.join(""), void 0 !== n3) {
                      if (0 === (je3 = (Ue2 = n3.trim()).length))
                        A3 = 0, Ue2 = "";
                    }
                  }
                  if (je3 > 0)
                    switch (A3) {
                      case fe2:
                        Te3 = Te3.replace(x2, Me2);
                      case ue2:
                      case ie2:
                      case Q2:
                        Ue2 = Te3 + "{" + Ue2 + "}";
                        break;
                      case te2:
                        if (Ue2 = (Te3 = Te3.replace(b2, "$1 $2" + (Be2 > 0 ? De2 : ""))) + "{" + Ue2 + "}", 1 === Ae2 || 2 === Ae2 && Le2("@" + Ue2, 3))
                          Ue2 = "@" + N2 + Ue2 + "@" + Ue2;
                        else
                          Ue2 = "@" + Ue2;
                        break;
                      default:
                        if (Ue2 = Te3 + Ue2, t3 === de2)
                          Ve2 += Ue2, Ue2 = "";
                    }
                  else
                    Ue2 = "";
                  break;
                default:
                  Ue2 = He2(a2, Ie2(a2, Te3, Oe3), Ue2, t3, i3 + 1);
              }
              Xe2 += Ue2, O3 = 0, $e3 = 0, z3 = 0, we3 = 0, Oe3 = 0, j2 = 0, Te3 = "", Ue2 = "", C3 = s2.charCodeAt(++R3);
              break;
            case q2:
            case W2:
              if ((je3 = (Te3 = (we3 > 0 ? Te3.replace(c2, "") : Te3).trim()).length) > 1) {
                if (0 === z3) {
                  if ((g3 = Te3.charCodeAt(0)) === Q2 || g3 > 96 && g3 < 123)
                    je3 = (Te3 = Te3.replace(" ", ":")).length;
                }
                if (ye2 > 0) {
                  if (void 0 !== (n3 = Pe2(Se2, Te3, a2, e3, pe2, be2, Ve2.length, t3, i3, t3))) {
                    if (0 === (je3 = (Te3 = n3.trim()).length))
                      Te3 = "\0\0";
                  }
                }
                switch (g3 = Te3.charCodeAt(0), A3 = Te3.charCodeAt(1), g3) {
                  case re2:
                    break;
                  case L2:
                    if (A3 === oe2 || A3 === he2) {
                      Ye2 += Te3 + s2.charAt(R3);
                      break;
                    }
                  default:
                    if (Te3.charCodeAt(je3 - 1) === V2)
                      break;
                    Ve2 += Ke2(Te3, g3, A3, Te3.charCodeAt(2));
                }
              }
              O3 = 0, $e3 = 0, z3 = 0, we3 = 0, Oe3 = 0, Te3 = "", C3 = s2.charCodeAt(++R3);
          }
        }
        switch (C3) {
          case J2:
          case I2:
            if (h3 + d3 + u3 + o2 + ve2 === 0)
              switch ($2) {
                case E2:
                case X2:
                case Y2:
                case L2:
                case ae2:
                case _2:
                case T2:
                case ee2:
                case Z2:
                case Q2:
                case V2:
                case U2:
                case W2:
                case B2:
                case q2:
                  break;
                default:
                  if (z3 > 0)
                    $e3 = 1;
              }
            if (h3 === Z2)
              h3 = 0;
            else if (ge2 + O3 === 0 && t3 !== te2 && Te3.length > 0)
              we3 = 1, Te3 += "\0";
            if (ye2 * qe2 > 0)
              Pe2(Ne2, Te3, a2, e3, pe2, be2, Ve2.length, t3, i3, t3);
            be2 = 1, pe2++;
            break;
          case W2:
          case q2:
            if (h3 + d3 + u3 + o2 === 0) {
              be2++;
              break;
            }
          default:
            switch (be2++, Re3 = s2.charAt(R3), C3) {
              case K2:
              case M2:
                if (d3 + o2 + h3 === 0)
                  switch (w3) {
                    case U2:
                    case V2:
                    case K2:
                    case M2:
                      Re3 = "";
                      break;
                    default:
                      if (C3 !== M2)
                        Re3 = " ";
                  }
                break;
              case re2:
                Re3 = "\\0";
                break;
              case ce2:
                Re3 = "\\f";
                break;
              case se2:
                Re3 = "\\v";
                break;
              case P2:
                if (d3 + h3 + o2 === 0 && ge2 > 0)
                  Oe3 = 1, we3 = 1, Re3 = "\f" + Re3;
                break;
              case 108:
                if (d3 + h3 + o2 + ke2 === 0 && z3 > 0)
                  switch (R3 - z3) {
                    case 2:
                      if (w3 === ne2 && s2.charCodeAt(R3 - 3) === V2)
                        ke2 = w3;
                    case 8:
                      if (m3 === le2)
                        ke2 = m3;
                  }
                break;
              case V2:
                if (d3 + h3 + o2 === 0)
                  z3 = R3;
                break;
              case U2:
                if (h3 + u3 + d3 + o2 === 0)
                  we3 = 1, Re3 += "\r";
                break;
              case Y2:
              case X2:
                if (0 === h3)
                  d3 = d3 === C3 ? 0 : 0 === d3 ? C3 : d3;
                break;
              case G2:
                if (d3 + h3 + u3 === 0)
                  o2++;
                break;
              case H2:
                if (d3 + h3 + u3 === 0)
                  o2--;
                break;
              case E2:
                if (d3 + h3 + o2 === 0)
                  u3--;
                break;
              case D2:
                if (d3 + h3 + o2 === 0) {
                  if (0 === O3)
                    switch (2 * w3 + 3 * m3) {
                      case 533:
                        break;
                      default:
                        y3 = 0, O3 = 1;
                    }
                  u3++;
                }
                break;
              case L2:
                if (h3 + u3 + d3 + o2 + z3 + j2 === 0)
                  j2 = 1;
                break;
              case T2:
              case Z2:
                if (d3 + o2 + u3 > 0)
                  break;
                switch (h3) {
                  case 0:
                    switch (2 * C3 + 3 * s2.charCodeAt(R3 + 1)) {
                      case 235:
                        h3 = Z2;
                        break;
                      case 220:
                        je3 = R3, h3 = T2;
                    }
                    break;
                  case T2:
                    if (C3 === Z2 && w3 === T2 && je3 + 2 !== R3) {
                      if (33 === s2.charCodeAt(je3 + 2))
                        Ve2 += s2.substring(je3, R3 + 1);
                      Re3 = "", h3 = 0;
                    }
                }
            }
            if (0 === h3) {
              if (ge2 + d3 + o2 + j2 === 0 && t3 !== te2 && C3 !== W2)
                switch (C3) {
                  case U2:
                  case ae2:
                  case _2:
                  case ee2:
                  case E2:
                  case D2:
                    if (0 === O3) {
                      switch (w3) {
                        case K2:
                        case M2:
                        case I2:
                        case J2:
                          Re3 += "\0";
                          break;
                        default:
                          Re3 = "\0" + Re3 + (C3 === U2 ? "" : "\0");
                      }
                      we3 = 1;
                    } else
                      switch (C3) {
                        case D2:
                          if (z3 + 7 === R3 && 108 === w3)
                            z3 = 0;
                          O3 = ++y3;
                          break;
                        case E2:
                          if (0 == (O3 = --y3))
                            we3 = 1, Re3 += "\0";
                      }
                    break;
                  case K2:
                  case M2:
                    switch (w3) {
                      case re2:
                      case B2:
                      case q2:
                      case W2:
                      case U2:
                      case ce2:
                      case K2:
                      case M2:
                      case I2:
                      case J2:
                        break;
                      default:
                        if (0 === O3)
                          we3 = 1, Re3 += "\0";
                    }
                }
              if (Te3 += Re3, C3 !== M2 && C3 !== K2)
                $2 = C3;
            }
        }
        m3 = w3, w3 = C3, R3++;
      }
      if (je3 = Ve2.length, me2 > 0) {
        if (0 === je3 && 0 === Xe2.length && 0 === a2[0].length == false) {
          if (t3 !== ie2 || 1 === a2.length && (ge2 > 0 ? Ee2 : Ge2) === a2[0])
            je3 = a2.join(",").length + 2;
        }
      }
      if (je3 > 0) {
        if (f3 = 0 === ge2 && t3 !== te2 ? function(e4) {
          for (var a3, r3, s3 = 0, t4 = e4.length, i4 = Array(t4); s3 < t4; ++s3) {
            for (var f4 = e4[s3].split(l2), n4 = "", o3 = 0, h4 = 0, u4 = 0, d4 = 0, b3 = f4.length; o3 < b3; ++o3) {
              if (0 === (h4 = (r3 = f4[o3]).length) && b3 > 1)
                continue;
              if (u4 = n4.charCodeAt(n4.length - 1), d4 = r3.charCodeAt(0), a3 = "", 0 !== o3)
                switch (u4) {
                  case T2:
                  case ae2:
                  case _2:
                  case ee2:
                  case M2:
                  case D2:
                    break;
                  default:
                    a3 = " ";
                }
              switch (d4) {
                case P2:
                  r3 = a3 + Ee2;
                case ae2:
                case _2:
                case ee2:
                case M2:
                case E2:
                case D2:
                  break;
                case G2:
                  r3 = a3 + r3 + Ee2;
                  break;
                case V2:
                  switch (2 * r3.charCodeAt(1) + 3 * r3.charCodeAt(2)) {
                    case 530:
                      if (Ce2 > 0) {
                        r3 = a3 + r3.substring(8, h4 - 1);
                        break;
                      }
                    default:
                      if (o3 < 1 || f4[o3 - 1].length < 1)
                        r3 = a3 + Ee2 + r3;
                  }
                  break;
                case U2:
                  a3 = "";
                default:
                  if (h4 > 1 && r3.indexOf(":") > 0)
                    r3 = a3 + r3.replace(v2, "$1" + Ee2 + "$2");
                  else
                    r3 = a3 + r3 + Ee2;
              }
              n4 += r3;
            }
            i4[s3] = n4.replace(c2, "").trim();
          }
          return i4;
        }(a2) : a2, ye2 > 0) {
          if (void 0 !== (n3 = Pe2(Fe2, Ve2, f3, e3, pe2, be2, je3, t3, i3, t3)) && 0 === (Ve2 = n3).length)
            return Ye2 + Ve2 + Xe2;
        }
        if (Ve2 = f3.join(",") + "{" + Ve2 + "}", Ae2 * ke2 != 0) {
          if (2 === Ae2 && !Le2(Ve2, 2))
            ke2 = 0;
          switch (ke2) {
            case le2:
              Ve2 = Ve2.replace(k2, ":" + S2 + "$1") + Ve2;
              break;
            case ne2:
              Ve2 = Ve2.replace(p2, "::" + N2 + "input-$1") + Ve2.replace(p2, "::" + S2 + "$1") + Ve2.replace(p2, ":" + F2 + "input-$1") + Ve2;
          }
          ke2 = 0;
        }
      }
      return Ye2 + Ve2 + Xe2;
    }
    function Ie2(e3, a2, r3) {
      var c3 = a2.trim().split(o), s2 = c3, t3 = c3.length, i3 = e3.length;
      switch (i3) {
        case 0:
        case 1:
          for (var f3 = 0, n3 = 0 === i3 ? "" : e3[0] + " "; f3 < t3; ++f3)
            s2[f3] = Je2(n3, s2[f3], r3, i3).trim();
          break;
        default:
          f3 = 0;
          var l3 = 0;
          for (s2 = []; f3 < t3; ++f3)
            for (var h3 = 0; h3 < i3; ++h3)
              s2[l3++] = Je2(e3[h3] + " ", c3[f3], r3, i3).trim();
      }
      return s2;
    }
    function Je2(e3, a2, r3, c3) {
      var s2 = a2, t3 = s2.charCodeAt(0);
      if (t3 < 33)
        t3 = (s2 = s2.trim()).charCodeAt(0);
      switch (t3) {
        case P2:
          switch (ge2 + c3) {
            case 0:
            case 1:
              if (0 === e3.trim().length)
                break;
            default:
              return s2.replace(h2, "$1" + e3.trim());
          }
          break;
        case V2:
          switch (s2.charCodeAt(1)) {
            case 103:
              if (Ce2 > 0 && ge2 > 0)
                return s2.replace(u2, "$1").replace(h2, "$1" + Ge2);
              break;
            default:
              return e3.trim() + s2.replace(h2, "$1" + e3.trim());
          }
        default:
          if (r3 * ge2 > 0 && s2.indexOf("\f") > 0)
            return s2.replace(h2, (e3.charCodeAt(0) === V2 ? "" : "$1") + e3.trim());
      }
      return e3 + s2;
    }
    function Ke2(e3, a2, r3, c3) {
      var l3, o2 = 0, h3 = e3 + ";", u3 = 2 * a2 + 3 * r3 + 4 * c3;
      if (944 === u3)
        return function(e4) {
          var a3 = e4.length, r4 = e4.indexOf(":", 9) + 1, c4 = e4.substring(0, r4).trim(), s2 = e4.substring(r4, a3 - 1).trim();
          switch (e4.charCodeAt(9) * Be2) {
            case 0:
              break;
            case Q2:
              if (110 !== e4.charCodeAt(10))
                break;
            default:
              for (var t3 = s2.split((s2 = "", f2)), i3 = 0, r4 = 0, a3 = t3.length; i3 < a3; r4 = 0, ++i3) {
                for (var l4 = t3[i3], o3 = l4.split(n2); l4 = o3[r4]; ) {
                  var h4 = l4.charCodeAt(0);
                  if (1 === Be2 && (h4 > L2 && h4 < 90 || h4 > 96 && h4 < 123 || h4 === R2 || h4 === Q2 && l4.charCodeAt(1) !== Q2))
                    switch (isNaN(parseFloat(l4)) + (-1 !== l4.indexOf("("))) {
                      case 1:
                        switch (l4) {
                          case "infinite":
                          case "alternate":
                          case "backwards":
                          case "running":
                          case "normal":
                          case "forwards":
                          case "both":
                          case "none":
                          case "linear":
                          case "ease":
                          case "ease-in":
                          case "ease-out":
                          case "ease-in-out":
                          case "paused":
                          case "reverse":
                          case "alternate-reverse":
                          case "inherit":
                          case "initial":
                          case "unset":
                          case "step-start":
                          case "step-end":
                            break;
                          default:
                            l4 += De2;
                        }
                    }
                  o3[r4++] = l4;
                }
                s2 += (0 === i3 ? "" : ",") + o3.join(" ");
              }
          }
          if (s2 = c4 + s2 + ";", 1 === Ae2 || 2 === Ae2 && Le2(s2, 1))
            return N2 + s2 + s2;
          return s2;
        }(h3);
      else if (0 === Ae2 || 2 === Ae2 && !Le2(h3, 1))
        return h3;
      switch (u3) {
        case 1015:
          return 97 === h3.charCodeAt(10) ? N2 + h3 + h3 : h3;
        case 951:
          return 116 === h3.charCodeAt(3) ? N2 + h3 + h3 : h3;
        case 963:
          return 110 === h3.charCodeAt(5) ? N2 + h3 + h3 : h3;
        case 1009:
          if (100 !== h3.charCodeAt(4))
            break;
        case 969:
        case 942:
          return N2 + h3 + h3;
        case 978:
          return N2 + h3 + S2 + h3 + h3;
        case 1019:
        case 983:
          return N2 + h3 + S2 + h3 + F2 + h3 + h3;
        case 883:
          if (h3.charCodeAt(8) === Q2)
            return N2 + h3 + h3;
          if (h3.indexOf("image-set(", 11) > 0)
            return h3.replace(z2, "$1" + N2 + "$2") + h3;
          return h3;
        case 932:
          if (h3.charCodeAt(4) === Q2)
            switch (h3.charCodeAt(5)) {
              case 103:
                return N2 + "box-" + h3.replace("-grow", "") + N2 + h3 + F2 + h3.replace("grow", "positive") + h3;
              case 115:
                return N2 + h3 + F2 + h3.replace("shrink", "negative") + h3;
              case 98:
                return N2 + h3 + F2 + h3.replace("basis", "preferred-size") + h3;
            }
          return N2 + h3 + F2 + h3 + h3;
        case 964:
          return N2 + h3 + F2 + "flex-" + h3 + h3;
        case 1023:
          if (99 !== h3.charCodeAt(8))
            break;
          return l3 = h3.substring(h3.indexOf(":", 15)).replace("flex-", "").replace("space-between", "justify"), N2 + "box-pack" + l3 + N2 + h3 + F2 + "flex-pack" + l3 + h3;
        case 1005:
          return t2.test(h3) ? h3.replace(s, ":" + N2) + h3.replace(s, ":" + S2) + h3 : h3;
        case 1e3:
          switch (o2 = (l3 = h3.substring(13).trim()).indexOf("-") + 1, l3.charCodeAt(0) + l3.charCodeAt(o2)) {
            case 226:
              l3 = h3.replace(m2, "tb");
              break;
            case 232:
              l3 = h3.replace(m2, "tb-rl");
              break;
            case 220:
              l3 = h3.replace(m2, "lr");
              break;
            default:
              return h3;
          }
          return N2 + h3 + F2 + l3 + h3;
        case 1017:
          if (-1 === h3.indexOf("sticky", 9))
            return h3;
        case 975:
          switch (o2 = (h3 = e3).length - 10, u3 = (l3 = (33 === h3.charCodeAt(o2) ? h3.substring(0, o2) : h3).substring(e3.indexOf(":", 7) + 1).trim()).charCodeAt(0) + (0 | l3.charCodeAt(7))) {
            case 203:
              if (l3.charCodeAt(8) < 111)
                break;
            case 115:
              h3 = h3.replace(l3, N2 + l3) + ";" + h3;
              break;
            case 207:
            case 102:
              h3 = h3.replace(l3, N2 + (u3 > 102 ? "inline-" : "") + "box") + ";" + h3.replace(l3, N2 + l3) + ";" + h3.replace(l3, F2 + l3 + "box") + ";" + h3;
          }
          return h3 + ";";
        case 938:
          if (h3.charCodeAt(5) === Q2)
            switch (h3.charCodeAt(6)) {
              case 105:
                return l3 = h3.replace("-items", ""), N2 + h3 + N2 + "box-" + l3 + F2 + "flex-" + l3 + h3;
              case 115:
                return N2 + h3 + F2 + "flex-item-" + h3.replace(y2, "") + h3;
              default:
                return N2 + h3 + F2 + "flex-line-pack" + h3.replace("align-content", "").replace(y2, "") + h3;
            }
          break;
        case 973:
        case 989:
          if (h3.charCodeAt(3) !== Q2 || 122 === h3.charCodeAt(4))
            break;
        case 931:
        case 953:
          if (true === j.test(e3))
            if (115 === (l3 = e3.substring(e3.indexOf(":") + 1)).charCodeAt(0))
              return Ke2(e3.replace("stretch", "fill-available"), a2, r3, c3).replace(":fill-available", ":stretch");
            else
              return h3.replace(l3, N2 + l3) + h3.replace(l3, S2 + l3.replace("fill-", "")) + h3;
          break;
        case 962:
          if (h3 = N2 + h3 + (102 === h3.charCodeAt(5) ? F2 + h3 : "") + h3, r3 + c3 === 211 && 105 === h3.charCodeAt(13) && h3.indexOf("transform", 10) > 0)
            return h3.substring(0, h3.indexOf(";", 27) + 1).replace(i2, "$1" + N2 + "$2") + h3;
      }
      return h3;
    }
    function Le2(e3, a2) {
      var r3 = e3.indexOf(1 === a2 ? ":" : "{"), c3 = e3.substring(0, 3 !== a2 ? r3 : 10), s2 = e3.substring(r3 + 1, e3.length - 1);
      return Oe2(2 !== a2 ? c3 : c3.replace(O2, "$1"), s2, a2);
    }
    function Me2(e3, a2) {
      var r3 = Ke2(a2, a2.charCodeAt(0), a2.charCodeAt(1), a2.charCodeAt(2));
      return r3 !== a2 + ";" ? r3.replace($, " or ($1)").substring(4) : "(" + a2 + ")";
    }
    function Pe2(e3, a2, r3, c3, s2, t3, i3, f3, n3, l3) {
      for (var o2, h3 = 0, u3 = a2; h3 < ye2; ++h3)
        switch (o2 = $e2[h3].call(Te2, e3, u3, r3, c3, s2, t3, i3, f3, n3, l3)) {
          case void 0:
          case false:
          case true:
          case null:
            break;
          default:
            u3 = o2;
        }
      if (u3 !== a2)
        return u3;
    }
    function Qe2(e3, a2, r3, c3) {
      for (var s2 = a2 + 1; s2 < r3; ++s2)
        switch (c3.charCodeAt(s2)) {
          case Z2:
            if (e3 === T2) {
              if (c3.charCodeAt(s2 - 1) === T2 && a2 + 2 !== s2)
                return s2 + 1;
            }
            break;
          case I2:
            if (e3 === Z2)
              return s2 + 1;
        }
      return s2;
    }
    function Re2(e3) {
      for (var a2 in e3) {
        var r3 = e3[a2];
        switch (a2) {
          case "keyframe":
            Be2 = 0 | r3;
            break;
          case "global":
            Ce2 = 0 | r3;
            break;
          case "cascade":
            ge2 = 0 | r3;
            break;
          case "compress":
            we2 = 0 | r3;
            break;
          case "semicolon":
            ve2 = 0 | r3;
            break;
          case "preserve":
            me2 = 0 | r3;
            break;
          case "prefix":
            if (Oe2 = null, !r3)
              Ae2 = 0;
            else if ("function" != typeof r3)
              Ae2 = 1;
            else
              Ae2 = 2, Oe2 = r3;
        }
      }
      return Re2;
    }
    function Te2(a2, r3) {
      if (void 0 !== this && this.constructor === Te2)
        return e2(a2);
      var s2 = a2, t3 = s2.charCodeAt(0);
      if (t3 < 33)
        t3 = (s2 = s2.trim()).charCodeAt(0);
      if (Be2 > 0)
        De2 = s2.replace(d2, t3 === G2 ? "" : "-");
      if (t3 = 1, 1 === ge2)
        Ge2 = s2;
      else
        Ee2 = s2;
      var i3, f3 = [Ge2];
      if (ye2 > 0) {
        if (void 0 !== (i3 = Pe2(ze2, r3, f3, f3, pe2, be2, 0, 0, 0, 0)) && "string" == typeof i3)
          r3 = i3;
      }
      var n3 = He2(xe2, f3, r3, 0, 0);
      if (ye2 > 0) {
        if (void 0 !== (i3 = Pe2(je2, n3, f3, f3, pe2, be2, n3.length, 0, 0, 0)) && "string" != typeof (n3 = i3))
          t3 = 0;
      }
      return De2 = "", Ge2 = "", Ee2 = "", ke2 = 0, pe2 = 1, be2 = 1, we2 * t3 == 0 ? n3 : n3.replace(c2, "").replace(g2, "").replace(A2, "$1").replace(C2, "$1").replace(w2, " ");
    }
    if (Te2.use = function e3(a2) {
      switch (a2) {
        case void 0:
        case null:
          ye2 = $e2.length = 0;
          break;
        default:
          if ("function" == typeof a2)
            $e2[ye2++] = a2;
          else if ("object" == typeof a2)
            for (var r3 = 0, c3 = a2.length; r3 < c3; ++r3)
              e3(a2[r3]);
          else
            qe2 = 0 | !!a2;
      }
      return e3;
    }, Te2.set = Re2, void 0 !== a)
      Re2(a);
    return Te2;
  });
})(stylis_min);
const Stylis = stylis_min.exports;
var stylisRuleSheet = { exports: {} };
(function(module2, exports2) {
  (function(factory) {
    module2["exports"] = factory();
  })(function() {
    return function(insertRule) {
      var delimiter2 = "/*|*/";
      var needle = delimiter2 + "}";
      function toSheet(block) {
        if (block)
          try {
            insertRule(block + "}");
          } catch (e2) {
          }
      }
      return function ruleSheet(context, content, selectors, parents, line2, column2, length2, ns, depth, at) {
        switch (context) {
          case 1:
            if (depth === 0 && content.charCodeAt(0) === 64)
              return insertRule(content + ";"), "";
            break;
          case 2:
            if (ns === 0)
              return content + delimiter2;
            break;
          case 3:
            switch (ns) {
              case 102:
              case 112:
                return insertRule(selectors[0] + content), "";
              default:
                return content + (at === 0 ? delimiter2 : "");
            }
          case -2:
            content.split(needle).forEach(toSheet);
        }
      };
    };
  });
})(stylisRuleSheet);
const _insertRulePlugin = stylisRuleSheet.exports;
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var reactIs = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b = "function" === typeof Symbol && Symbol.for, c = b ? Symbol.for("react.element") : 60103, d = b ? Symbol.for("react.portal") : 60106, e = b ? Symbol.for("react.fragment") : 60107, f = b ? Symbol.for("react.strict_mode") : 60108, g = b ? Symbol.for("react.profiler") : 60114, h = b ? Symbol.for("react.provider") : 60109, k = b ? Symbol.for("react.context") : 60110, l = b ? Symbol.for("react.async_mode") : 60111, m = b ? Symbol.for("react.concurrent_mode") : 60111, n = b ? Symbol.for("react.forward_ref") : 60112, p = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.suspense_list") : 60120, r = b ? Symbol.for("react.memo") : 60115, t = b ? Symbol.for("react.lazy") : 60116, v = b ? Symbol.for("react.block") : 60121, w = b ? Symbol.for("react.fundamental") : 60117, x = b ? Symbol.for("react.responder") : 60118, y = b ? Symbol.for("react.scope") : 60119;
function z(a) {
  if ("object" === typeof a && null !== a) {
    var u2 = a.$$typeof;
    switch (u2) {
      case c:
        switch (a = a.type, a) {
          case l:
          case m:
          case e:
          case g:
          case f:
          case p:
            return a;
          default:
            switch (a = a && a.$$typeof, a) {
              case k:
              case n:
              case t:
              case r:
              case h:
                return a;
              default:
                return u2;
            }
        }
      case d:
        return u2;
    }
  }
}
function A(a) {
  return z(a) === m;
}
reactIs_production_min.AsyncMode = l;
reactIs_production_min.ConcurrentMode = m;
reactIs_production_min.ContextConsumer = k;
reactIs_production_min.ContextProvider = h;
reactIs_production_min.Element = c;
reactIs_production_min.ForwardRef = n;
reactIs_production_min.Fragment = e;
reactIs_production_min.Lazy = t;
reactIs_production_min.Memo = r;
reactIs_production_min.Portal = d;
reactIs_production_min.Profiler = g;
reactIs_production_min.StrictMode = f;
reactIs_production_min.Suspense = p;
reactIs_production_min.isAsyncMode = function(a) {
  return A(a) || z(a) === l;
};
reactIs_production_min.isConcurrentMode = A;
reactIs_production_min.isContextConsumer = function(a) {
  return z(a) === k;
};
reactIs_production_min.isContextProvider = function(a) {
  return z(a) === h;
};
reactIs_production_min.isElement = function(a) {
  return "object" === typeof a && null !== a && a.$$typeof === c;
};
reactIs_production_min.isForwardRef = function(a) {
  return z(a) === n;
};
reactIs_production_min.isFragment = function(a) {
  return z(a) === e;
};
reactIs_production_min.isLazy = function(a) {
  return z(a) === t;
};
reactIs_production_min.isMemo = function(a) {
  return z(a) === r;
};
reactIs_production_min.isPortal = function(a) {
  return z(a) === d;
};
reactIs_production_min.isProfiler = function(a) {
  return z(a) === g;
};
reactIs_production_min.isStrictMode = function(a) {
  return z(a) === f;
};
reactIs_production_min.isSuspense = function(a) {
  return z(a) === p;
};
reactIs_production_min.isValidElementType = function(a) {
  return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
};
reactIs_production_min.typeOf = z;
(function(module2) {
  {
    module2.exports = reactIs_production_min;
  }
})(reactIs);
var safeIsNaN = Number.isNaN || function ponyfill(value2) {
  return typeof value2 === "number" && value2 !== value2;
};
function isEqual(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i2 = 0; i2 < newInputs.length; i2++) {
    if (!isEqual(newInputs[i2], lastInputs[i2])) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual2) {
  if (isEqual2 === void 0) {
    isEqual2 = areInputsEqual;
  }
  var lastThis;
  var lastArgs = [];
  var lastResult;
  var calledOnce = false;
  function memoized() {
    var newArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }
    if (calledOnce && lastThis === this && isEqual2(newArgs, lastArgs)) {
      return lastResult;
    }
    lastResult = resultFn.apply(this, newArgs);
    calledOnce = true;
    lastThis = this;
    lastArgs = newArgs;
    return lastResult;
  }
  return memoized;
}
function memoize(fn) {
  var cache = {};
  return function(arg) {
    if (cache[arg] === void 0)
      cache[arg] = fn(arg);
    return cache[arg];
  };
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var index = memoize(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
);
function getType(payload) {
  return Object.prototype.toString.call(payload).slice(8, -1);
}
function isPlainObject$1(payload) {
  if (getType(payload) !== "Object")
    return false;
  return payload.constructor === Object && Object.getPrototypeOf(payload) === Object.prototype;
}
function isArray(payload) {
  return getType(payload) === "Array";
}
function isSymbol(payload) {
  return getType(payload) === "Symbol";
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
function __spreadArrays() {
  for (var s = 0, i2 = 0, il2 = arguments.length; i2 < il2; i2++)
    s += arguments[i2].length;
  for (var r2 = Array(s), k2 = 0, i2 = 0; i2 < il2; i2++)
    for (var a = arguments[i2], j = 0, jl2 = a.length; j < jl2; j++, k2++)
      r2[k2] = a[j];
  return r2;
}
function assignProp(carry, key, newVal, originalObject) {
  var propType = originalObject.propertyIsEnumerable(key) ? "enumerable" : "nonenumerable";
  if (propType === "enumerable")
    carry[key] = newVal;
  if (propType === "nonenumerable") {
    Object.defineProperty(carry, key, {
      value: newVal,
      enumerable: false,
      writable: true,
      configurable: true
    });
  }
}
function mergeRecursively(origin, newComer, extensions) {
  if (!isPlainObject$1(newComer)) {
    if (extensions && isArray(extensions)) {
      extensions.forEach(function(extend2) {
        newComer = extend2(origin, newComer);
      });
    }
    return newComer;
  }
  var newObject = {};
  if (isPlainObject$1(origin)) {
    var props_1 = Object.getOwnPropertyNames(origin);
    var symbols_1 = Object.getOwnPropertySymbols(origin);
    newObject = __spreadArrays(props_1, symbols_1).reduce(function(carry, key) {
      var targetVal = origin[key];
      if (!isSymbol(key) && !Object.getOwnPropertyNames(newComer).includes(key) || isSymbol(key) && !Object.getOwnPropertySymbols(newComer).includes(key)) {
        assignProp(carry, key, targetVal, origin);
      }
      return carry;
    }, {});
  }
  var props = Object.getOwnPropertyNames(newComer);
  var symbols = Object.getOwnPropertySymbols(newComer);
  var result = __spreadArrays(props, symbols).reduce(function(carry, key) {
    var newVal = newComer[key];
    var targetVal = isPlainObject$1(origin) ? origin[key] : void 0;
    if (extensions && isArray(extensions)) {
      extensions.forEach(function(extend2) {
        newVal = extend2(targetVal, newVal);
      });
    }
    if (targetVal !== void 0 && isPlainObject$1(newVal)) {
      newVal = mergeRecursively(targetVal, newVal, extensions);
    }
    assignProp(carry, key, newVal, newComer);
    return carry;
  }, newObject);
  return result;
}
function merge(origin) {
  var newComers = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    newComers[_i - 1] = arguments[_i];
  }
  var extensions = null;
  var base = origin;
  if (isPlainObject$1(origin) && origin.extensions && Object.keys(origin).length === 1) {
    base = {};
    extensions = origin.extensions;
  }
  return newComers.reduce(function(result, newComer) {
    return mergeRecursively(result, newComer, extensions);
  }, base);
}
var interleave = function(strings, interpolations) {
  var result = [strings[0]];
  for (var i2 = 0, len2 = interpolations.length; i2 < len2; i2 += 1) {
    result.push(interpolations[i2], strings[i2 + 1]);
  }
  return result;
};
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
  return typeof obj;
} : function(obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var classCallCheck = function(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
var createClass = function() {
  function defineProperties(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
var _extends = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var inherits = function(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};
var objectWithoutProperties = function(obj, keys) {
  var target = {};
  for (var i2 in obj) {
    if (keys.indexOf(i2) >= 0)
      continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i2))
      continue;
    target[i2] = obj[i2];
  }
  return target;
};
var possibleConstructorReturn = function(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
};
var isPlainObject = function(x2) {
  return (typeof x2 === "undefined" ? "undefined" : _typeof(x2)) === "object" && x2.constructor === Object;
};
var EMPTY_ARRAY = Object.freeze([]);
var EMPTY_OBJECT = Object.freeze({});
function isFunction(test) {
  return typeof test === "function";
}
function getComponentName(target) {
  return target.displayName || target.name || "Component";
}
function isStatelessFunction(test) {
  return typeof test === "function" && !(test.prototype && test.prototype.isReactComponent);
}
function isStyledComponent(target) {
  return target && typeof target.styledComponentId === "string";
}
var SC_ATTR = typeof process !== "undefined" && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || "data-styled";
var SC_VERSION_ATTR = "data-styled-version";
var SC_STREAM_ATTR = "data-styled-streamed";
var IS_BROWSER = typeof window !== "undefined" && "HTMLElement" in window;
var DISABLE_SPEEDY = typeof SC_DISABLE_SPEEDY === "boolean" && SC_DISABLE_SPEEDY || typeof process !== "undefined" && (process.env.REACT_APP_SC_DISABLE_SPEEDY || process.env.SC_DISABLE_SPEEDY) || false;
var StyledComponentsError = function(_Error) {
  inherits(StyledComponentsError2, _Error);
  function StyledComponentsError2(code2) {
    classCallCheck(this, StyledComponentsError2);
    for (var _len = arguments.length, interpolations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      interpolations[_key - 1] = arguments[_key];
    }
    var _this;
    {
      var _this = possibleConstructorReturn(this, _Error.call(this, "An error occurred. See https://github.com/styled-components/styled-components/blob/master/packages/styled-components/src/utils/errors.md#" + code2 + " for more information." + (interpolations.length > 0 ? " Additional arguments: " + interpolations.join(", ") : "")));
    }
    return possibleConstructorReturn(_this);
  }
  return StyledComponentsError2;
}(Error);
var SC_COMPONENT_ID = /^[^\S\n]*?\/\* sc-component-id:\s*(\S+)\s+\*\//gm;
var extractComps = function(maybeCSS) {
  var css2 = "" + (maybeCSS || "");
  var existingComponents = [];
  css2.replace(SC_COMPONENT_ID, function(match2, componentId, matchIndex) {
    existingComponents.push({
      componentId,
      matchIndex
    });
    return match2;
  });
  return existingComponents.map(function(_ref, i2) {
    var componentId = _ref.componentId, matchIndex = _ref.matchIndex;
    var nextComp = existingComponents[i2 + 1];
    var cssFromDOM = nextComp ? css2.slice(matchIndex, nextComp.matchIndex) : css2.slice(matchIndex);
    return {
      componentId,
      cssFromDOM
    };
  });
};
var COMMENT_REGEX = /^\s*\/\/.*$/gm;
var stylisSplitter = new Stylis({
  global: false,
  cascade: true,
  keyframe: false,
  prefix: false,
  compress: false,
  semicolon: true
});
var stylis = new Stylis({
  global: false,
  cascade: true,
  keyframe: false,
  prefix: true,
  compress: false,
  semicolon: false
});
var parsingRules = [];
var returnRulesPlugin = function returnRulesPlugin2(context) {
  if (context === -2) {
    var parsedRules = parsingRules;
    parsingRules = [];
    return parsedRules;
  }
};
var parseRulesPlugin = _insertRulePlugin(function(rule) {
  parsingRules.push(rule);
});
var _componentId = void 0;
var _selector = void 0;
var _selectorRegexp = void 0;
var selfReferenceReplacer = function selfReferenceReplacer2(match2, offset, string2) {
  if (offset > 0 && string2.slice(0, offset).indexOf(_selector) !== -1 && string2.slice(offset - _selector.length, offset) !== _selector) {
    return "." + _componentId;
  }
  return match2;
};
var selfReferenceReplacementPlugin = function selfReferenceReplacementPlugin2(context, _2, selectors) {
  if (context === 2 && selectors.length && selectors[0].lastIndexOf(_selector) > 0) {
    selectors[0] = selectors[0].replace(_selectorRegexp, selfReferenceReplacer);
  }
};
stylis.use([selfReferenceReplacementPlugin, parseRulesPlugin, returnRulesPlugin]);
stylisSplitter.use([parseRulesPlugin, returnRulesPlugin]);
var splitByRules = function splitByRules2(css2) {
  return stylisSplitter("", css2);
};
function stringifyRules(rules, selector, prefix2) {
  var componentId = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "&";
  var flatCSS = rules.join("").replace(COMMENT_REGEX, "");
  var cssStr = selector && prefix2 ? prefix2 + " " + selector + " { " + flatCSS + " }" : flatCSS;
  _componentId = componentId;
  _selector = selector;
  _selectorRegexp = new RegExp("\\" + _selector + "\\b", "g");
  return stylis(prefix2 || !selector ? "" : selector, cssStr);
}
var getNonce = function() {
  return typeof __webpack_nonce__ !== "undefined" ? __webpack_nonce__ : null;
};
var addNameForId = function addNameForId2(names, id2, name) {
  if (name) {
    var namesForId = names[id2] || (names[id2] = /* @__PURE__ */ Object.create(null));
    namesForId[name] = true;
  }
};
var resetIdNames = function resetIdNames2(names, id2) {
  names[id2] = /* @__PURE__ */ Object.create(null);
};
var hasNameForId = function hasNameForId2(names) {
  return function(id2, name) {
    return names[id2] !== void 0 && names[id2][name];
  };
};
var stringifyNames = function stringifyNames2(names) {
  var str = "";
  for (var id2 in names) {
    str += Object.keys(names[id2]).join(" ") + " ";
  }
  return str.trim();
};
var cloneNames = function cloneNames2(names) {
  var clone2 = /* @__PURE__ */ Object.create(null);
  for (var id2 in names) {
    clone2[id2] = _extends({}, names[id2]);
  }
  return clone2;
};
var sheetForTag = function sheetForTag2(tag) {
  if (tag.sheet)
    return tag.sheet;
  var size = tag.ownerDocument.styleSheets.length;
  for (var i2 = 0; i2 < size; i2 += 1) {
    var sheet = tag.ownerDocument.styleSheets[i2];
    if (sheet.ownerNode === tag)
      return sheet;
  }
  throw new StyledComponentsError(10);
};
var safeInsertRule = function safeInsertRule2(sheet, cssRule, index2) {
  if (!cssRule)
    return false;
  var maxIndex = sheet.cssRules.length;
  try {
    sheet.insertRule(cssRule, index2 <= maxIndex ? index2 : maxIndex);
  } catch (err) {
    return false;
  }
  return true;
};
var deleteRules = function deleteRules2(sheet, removalIndex, size) {
  var lowerBound = removalIndex - size;
  for (var i2 = removalIndex; i2 > lowerBound; i2 -= 1) {
    sheet.deleteRule(i2);
  }
};
var makeTextMarker = function makeTextMarker2(id2) {
  return "\n/* sc-component-id: " + id2 + " */\n";
};
var addUpUntilIndex = function addUpUntilIndex2(sizes, index2) {
  var totalUpToIndex = 0;
  for (var i2 = 0; i2 <= index2; i2 += 1) {
    totalUpToIndex += sizes[i2];
  }
  return totalUpToIndex;
};
var makeStyleTag = function makeStyleTag2(target, tagEl, insertBefore) {
  var targetDocument = document;
  if (target)
    targetDocument = target.ownerDocument;
  else if (tagEl)
    targetDocument = tagEl.ownerDocument;
  var el2 = targetDocument.createElement("style");
  el2.setAttribute(SC_ATTR, "");
  el2.setAttribute(SC_VERSION_ATTR, "4.4.1");
  var nonce = getNonce();
  if (nonce) {
    el2.setAttribute("nonce", nonce);
  }
  el2.appendChild(targetDocument.createTextNode(""));
  if (target && !tagEl) {
    target.appendChild(el2);
  } else {
    if (!tagEl || !target || !tagEl.parentNode) {
      throw new StyledComponentsError(6);
    }
    tagEl.parentNode.insertBefore(el2, insertBefore ? tagEl : tagEl.nextSibling);
  }
  return el2;
};
var wrapAsHtmlTag = function wrapAsHtmlTag2(css2, names) {
  return function(additionalAttrs) {
    var nonce = getNonce();
    var attrs = [nonce && 'nonce="' + nonce + '"', SC_ATTR + '="' + stringifyNames(names) + '"', SC_VERSION_ATTR + '="4.4.1"', additionalAttrs];
    var htmlAttr = attrs.filter(Boolean).join(" ");
    return "<style " + htmlAttr + ">" + css2() + "</style>";
  };
};
var wrapAsElement = function wrapAsElement2(css2, names) {
  return function() {
    var _props;
    var props = (_props = {}, _props[SC_ATTR] = stringifyNames(names), _props[SC_VERSION_ATTR] = "4.4.1", _props);
    var nonce = getNonce();
    if (nonce) {
      props.nonce = nonce;
    }
    return /* @__PURE__ */ jsx("style", {
      ...props,
      dangerouslySetInnerHTML: {
        __html: css2()
      }
    });
  };
};
var getIdsFromMarkersFactory = function getIdsFromMarkersFactory2(markers) {
  return function() {
    return Object.keys(markers);
  };
};
var makeSpeedyTag = function makeSpeedyTag2(el2, getImportRuleTag) {
  var names = /* @__PURE__ */ Object.create(null);
  var markers = /* @__PURE__ */ Object.create(null);
  var sizes = [];
  var extractImport = getImportRuleTag !== void 0;
  var usedImportRuleTag = false;
  var insertMarker = function insertMarker2(id2) {
    var prev2 = markers[id2];
    if (prev2 !== void 0) {
      return prev2;
    }
    markers[id2] = sizes.length;
    sizes.push(0);
    resetIdNames(names, id2);
    return markers[id2];
  };
  var insertRules = function insertRules2(id2, cssRules, name) {
    var marker = insertMarker(id2);
    var sheet = sheetForTag(el2);
    var insertIndex = addUpUntilIndex(sizes, marker);
    var injectedRules = 0;
    var importRules = [];
    var cssRulesSize = cssRules.length;
    for (var i2 = 0; i2 < cssRulesSize; i2 += 1) {
      var cssRule = cssRules[i2];
      var mayHaveImport = extractImport;
      if (mayHaveImport && cssRule.indexOf("@import") !== -1) {
        importRules.push(cssRule);
      } else if (safeInsertRule(sheet, cssRule, insertIndex + injectedRules)) {
        mayHaveImport = false;
        injectedRules += 1;
      }
    }
    if (extractImport && importRules.length > 0) {
      usedImportRuleTag = true;
      getImportRuleTag().insertRules(id2 + "-import", importRules);
    }
    sizes[marker] += injectedRules;
    addNameForId(names, id2, name);
  };
  var removeRules = function removeRules2(id2) {
    var marker = markers[id2];
    if (marker === void 0)
      return;
    if (el2.isConnected === false)
      return;
    var size = sizes[marker];
    var sheet = sheetForTag(el2);
    var removalIndex = addUpUntilIndex(sizes, marker) - 1;
    deleteRules(sheet, removalIndex, size);
    sizes[marker] = 0;
    resetIdNames(names, id2);
    if (extractImport && usedImportRuleTag) {
      getImportRuleTag().removeRules(id2 + "-import");
    }
  };
  var css2 = function css3() {
    var _sheetForTag = sheetForTag(el2), cssRules = _sheetForTag.cssRules;
    var str = "";
    for (var id2 in markers) {
      str += makeTextMarker(id2);
      var marker = markers[id2];
      var end = addUpUntilIndex(sizes, marker);
      var size = sizes[marker];
      for (var i2 = end - size; i2 < end; i2 += 1) {
        var rule = cssRules[i2];
        if (rule !== void 0) {
          str += rule.cssText;
        }
      }
    }
    return str;
  };
  return {
    clone: function clone2() {
      throw new StyledComponentsError(5);
    },
    css: css2,
    getIds: getIdsFromMarkersFactory(markers),
    hasNameForId: hasNameForId(names),
    insertMarker,
    insertRules,
    removeRules,
    sealed: false,
    styleTag: el2,
    toElement: wrapAsElement(css2, names),
    toHTML: wrapAsHtmlTag(css2, names)
  };
};
var makeTextNode = function makeTextNode2(targetDocument, id2) {
  return targetDocument.createTextNode(makeTextMarker(id2));
};
var makeBrowserTag = function makeBrowserTag2(el2, getImportRuleTag) {
  var names = /* @__PURE__ */ Object.create(null);
  var markers = /* @__PURE__ */ Object.create(null);
  var extractImport = getImportRuleTag !== void 0;
  var usedImportRuleTag = false;
  var insertMarker = function insertMarker2(id2) {
    var prev2 = markers[id2];
    if (prev2 !== void 0) {
      return prev2;
    }
    markers[id2] = makeTextNode(el2.ownerDocument, id2);
    el2.appendChild(markers[id2]);
    names[id2] = /* @__PURE__ */ Object.create(null);
    return markers[id2];
  };
  var insertRules = function insertRules2(id2, cssRules, name) {
    var marker = insertMarker(id2);
    var importRules = [];
    var cssRulesSize = cssRules.length;
    for (var i2 = 0; i2 < cssRulesSize; i2 += 1) {
      var rule = cssRules[i2];
      var mayHaveImport = extractImport;
      if (mayHaveImport && rule.indexOf("@import") !== -1) {
        importRules.push(rule);
      } else {
        mayHaveImport = false;
        var separator = i2 === cssRulesSize - 1 ? "" : " ";
        marker.appendData("" + rule + separator);
      }
    }
    addNameForId(names, id2, name);
    if (extractImport && importRules.length > 0) {
      usedImportRuleTag = true;
      getImportRuleTag().insertRules(id2 + "-import", importRules);
    }
  };
  var removeRules = function removeRules2(id2) {
    var marker = markers[id2];
    if (marker === void 0)
      return;
    var newMarker = makeTextNode(el2.ownerDocument, id2);
    el2.replaceChild(newMarker, marker);
    markers[id2] = newMarker;
    resetIdNames(names, id2);
    if (extractImport && usedImportRuleTag) {
      getImportRuleTag().removeRules(id2 + "-import");
    }
  };
  var css2 = function css3() {
    var str = "";
    for (var id2 in markers) {
      str += markers[id2].data;
    }
    return str;
  };
  return {
    clone: function clone2() {
      throw new StyledComponentsError(5);
    },
    css: css2,
    getIds: getIdsFromMarkersFactory(markers),
    hasNameForId: hasNameForId(names),
    insertMarker,
    insertRules,
    removeRules,
    sealed: false,
    styleTag: el2,
    toElement: wrapAsElement(css2, names),
    toHTML: wrapAsHtmlTag(css2, names)
  };
};
var makeServerTag = function makeServerTag2(namesArg, markersArg) {
  var names = namesArg === void 0 ? /* @__PURE__ */ Object.create(null) : namesArg;
  var markers = markersArg === void 0 ? /* @__PURE__ */ Object.create(null) : markersArg;
  var insertMarker = function insertMarker2(id2) {
    var prev2 = markers[id2];
    if (prev2 !== void 0) {
      return prev2;
    }
    return markers[id2] = [""];
  };
  var insertRules = function insertRules2(id2, cssRules, name) {
    var marker = insertMarker(id2);
    marker[0] += cssRules.join(" ");
    addNameForId(names, id2, name);
  };
  var removeRules = function removeRules2(id2) {
    var marker = markers[id2];
    if (marker === void 0)
      return;
    marker[0] = "";
    resetIdNames(names, id2);
  };
  var css2 = function css3() {
    var str = "";
    for (var id2 in markers) {
      var cssForId = markers[id2][0];
      if (cssForId) {
        str += makeTextMarker(id2) + cssForId;
      }
    }
    return str;
  };
  var clone2 = function clone3() {
    var namesClone = cloneNames(names);
    var markersClone = /* @__PURE__ */ Object.create(null);
    for (var id2 in markers) {
      markersClone[id2] = [markers[id2][0]];
    }
    return makeServerTag2(namesClone, markersClone);
  };
  var tag = {
    clone: clone2,
    css: css2,
    getIds: getIdsFromMarkersFactory(markers),
    hasNameForId: hasNameForId(names),
    insertMarker,
    insertRules,
    removeRules,
    sealed: false,
    styleTag: null,
    toElement: wrapAsElement(css2, names),
    toHTML: wrapAsHtmlTag(css2, names)
  };
  return tag;
};
var makeTag = function makeTag2(target, tagEl, forceServer, insertBefore, getImportRuleTag) {
  if (IS_BROWSER && !forceServer) {
    var el2 = makeStyleTag(target, tagEl, insertBefore);
    if (DISABLE_SPEEDY) {
      return makeBrowserTag(el2, getImportRuleTag);
    } else {
      return makeSpeedyTag(el2, getImportRuleTag);
    }
  }
  return makeServerTag();
};
var rehydrate = function rehydrate2(tag, els, extracted) {
  for (var i2 = 0, len2 = extracted.length; i2 < len2; i2 += 1) {
    var _extracted$i = extracted[i2], componentId = _extracted$i.componentId, cssFromDOM = _extracted$i.cssFromDOM;
    var cssRules = splitByRules(cssFromDOM);
    tag.insertRules(componentId, cssRules);
  }
  for (var _i = 0, _len = els.length; _i < _len; _i += 1) {
    var el2 = els[_i];
    if (el2.parentNode) {
      el2.parentNode.removeChild(el2);
    }
  }
};
var SPLIT_REGEX = /\s+/;
var MAX_SIZE = void 0;
if (IS_BROWSER) {
  MAX_SIZE = DISABLE_SPEEDY ? 40 : 1e3;
} else {
  MAX_SIZE = -1;
}
var sheetRunningId = 0;
var master = void 0;
var StyleSheet = function() {
  function StyleSheet2() {
    var _this = this;
    var target = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : IS_BROWSER ? document.head : null;
    var forceServer = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    classCallCheck(this, StyleSheet2);
    this.getImportRuleTag = function() {
      var importRuleTag = _this.importRuleTag;
      if (importRuleTag !== void 0) {
        return importRuleTag;
      }
      var firstTag = _this.tags[0];
      var insertBefore = true;
      return _this.importRuleTag = makeTag(_this.target, firstTag ? firstTag.styleTag : null, _this.forceServer, insertBefore);
    };
    sheetRunningId += 1;
    this.id = sheetRunningId;
    this.forceServer = forceServer;
    this.target = forceServer ? null : target;
    this.tagMap = {};
    this.deferred = {};
    this.rehydratedNames = {};
    this.ignoreRehydratedNames = {};
    this.tags = [];
    this.capacity = 1;
    this.clones = [];
  }
  StyleSheet2.prototype.rehydrate = function rehydrate$$1() {
    if (!IS_BROWSER || this.forceServer)
      return this;
    var els = [];
    var extracted = [];
    var isStreamed = false;
    var nodes = document.querySelectorAll("style[" + SC_ATTR + "][" + SC_VERSION_ATTR + '="4.4.1"]');
    var nodesSize = nodes.length;
    if (!nodesSize)
      return this;
    for (var i2 = 0; i2 < nodesSize; i2 += 1) {
      var el2 = nodes[i2];
      if (!isStreamed)
        isStreamed = !!el2.getAttribute(SC_STREAM_ATTR);
      var elNames = (el2.getAttribute(SC_ATTR) || "").trim().split(SPLIT_REGEX);
      var elNamesSize = elNames.length;
      for (var j = 0, name; j < elNamesSize; j += 1) {
        name = elNames[j];
        this.rehydratedNames[name] = true;
      }
      extracted.push.apply(extracted, extractComps(el2.textContent));
      els.push(el2);
    }
    var extractedSize = extracted.length;
    if (!extractedSize)
      return this;
    var tag = this.makeTag(null);
    rehydrate(tag, els, extracted);
    this.capacity = Math.max(1, MAX_SIZE - extractedSize);
    this.tags.push(tag);
    for (var _j = 0; _j < extractedSize; _j += 1) {
      this.tagMap[extracted[_j].componentId] = tag;
    }
    return this;
  };
  StyleSheet2.reset = function reset() {
    var forceServer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    master = new StyleSheet2(void 0, forceServer).rehydrate();
  };
  StyleSheet2.prototype.clone = function clone2() {
    var sheet = new StyleSheet2(this.target, this.forceServer);
    this.clones.push(sheet);
    sheet.tags = this.tags.map(function(tag) {
      var ids = tag.getIds();
      var newTag = tag.clone();
      for (var i2 = 0; i2 < ids.length; i2 += 1) {
        sheet.tagMap[ids[i2]] = newTag;
      }
      return newTag;
    });
    sheet.rehydratedNames = _extends({}, this.rehydratedNames);
    sheet.deferred = _extends({}, this.deferred);
    return sheet;
  };
  StyleSheet2.prototype.sealAllTags = function sealAllTags() {
    this.capacity = 1;
    this.tags.forEach(function(tag) {
      tag.sealed = true;
    });
  };
  StyleSheet2.prototype.makeTag = function makeTag$$1(tag) {
    var lastEl = tag ? tag.styleTag : null;
    var insertBefore = false;
    return makeTag(this.target, lastEl, this.forceServer, insertBefore, this.getImportRuleTag);
  };
  StyleSheet2.prototype.getTagForId = function getTagForId(id2) {
    var prev2 = this.tagMap[id2];
    if (prev2 !== void 0 && !prev2.sealed) {
      return prev2;
    }
    var tag = this.tags[this.tags.length - 1];
    this.capacity -= 1;
    if (this.capacity === 0) {
      this.capacity = MAX_SIZE;
      tag = this.makeTag(tag);
      this.tags.push(tag);
    }
    return this.tagMap[id2] = tag;
  };
  StyleSheet2.prototype.hasId = function hasId(id2) {
    return this.tagMap[id2] !== void 0;
  };
  StyleSheet2.prototype.hasNameForId = function hasNameForId3(id2, name) {
    if (this.ignoreRehydratedNames[id2] === void 0 && this.rehydratedNames[name]) {
      return true;
    }
    var tag = this.tagMap[id2];
    return tag !== void 0 && tag.hasNameForId(id2, name);
  };
  StyleSheet2.prototype.deferredInject = function deferredInject(id2, cssRules) {
    if (this.tagMap[id2] !== void 0)
      return;
    var clones = this.clones;
    for (var i2 = 0; i2 < clones.length; i2 += 1) {
      clones[i2].deferredInject(id2, cssRules);
    }
    this.getTagForId(id2).insertMarker(id2);
    this.deferred[id2] = cssRules;
  };
  StyleSheet2.prototype.inject = function inject(id2, cssRules, name) {
    var clones = this.clones;
    for (var i2 = 0; i2 < clones.length; i2 += 1) {
      clones[i2].inject(id2, cssRules, name);
    }
    var tag = this.getTagForId(id2);
    if (this.deferred[id2] !== void 0) {
      var rules = this.deferred[id2].concat(cssRules);
      tag.insertRules(id2, rules, name);
      this.deferred[id2] = void 0;
    } else {
      tag.insertRules(id2, cssRules, name);
    }
  };
  StyleSheet2.prototype.remove = function remove(id2) {
    var tag = this.tagMap[id2];
    if (tag === void 0)
      return;
    var clones = this.clones;
    for (var i2 = 0; i2 < clones.length; i2 += 1) {
      clones[i2].remove(id2);
    }
    tag.removeRules(id2);
    this.ignoreRehydratedNames[id2] = true;
    this.deferred[id2] = void 0;
  };
  StyleSheet2.prototype.toHTML = function toHTML() {
    return this.tags.map(function(tag) {
      return tag.toHTML();
    }).join("");
  };
  StyleSheet2.prototype.toReactElements = function toReactElements() {
    var id2 = this.id;
    return this.tags.map(function(tag, i2) {
      var key = "sc-" + id2 + "-" + i2;
      return react.exports.cloneElement(tag.toElement(), {
        key
      });
    });
  };
  createClass(StyleSheet2, null, [{
    key: "master",
    get: function get$$1() {
      return master || (master = new StyleSheet2().rehydrate());
    }
  }, {
    key: "instance",
    get: function get$$1() {
      return StyleSheet2.master;
    }
  }]);
  return StyleSheet2;
}();
var Keyframes = function() {
  function Keyframes2(name, rules) {
    var _this = this;
    classCallCheck(this, Keyframes2);
    this.inject = function(styleSheet) {
      if (!styleSheet.hasNameForId(_this.id, _this.name)) {
        styleSheet.inject(_this.id, _this.rules, _this.name);
      }
    };
    this.toString = function() {
      throw new StyledComponentsError(12, String(_this.name));
    };
    this.name = name;
    this.rules = rules;
    this.id = "sc-keyframes-" + name;
  }
  Keyframes2.prototype.getName = function getName() {
    return this.name;
  };
  return Keyframes2;
}();
var uppercasePattern = /([A-Z])/g;
var msPattern = /^ms-/;
function hyphenateStyleName(string2) {
  return string2.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
}
function addUnitIfNeeded(name, value2) {
  if (value2 == null || typeof value2 === "boolean" || value2 === "") {
    return "";
  }
  if (typeof value2 === "number" && value2 !== 0 && !(name in unitlessKeys)) {
    return value2 + "px";
  }
  return String(value2).trim();
}
var isFalsish = function isFalsish2(chunk) {
  return chunk === void 0 || chunk === null || chunk === false || chunk === "";
};
var objToCssArray = function objToCssArray2(obj, prevKey) {
  var rules = [];
  var keys = Object.keys(obj);
  keys.forEach(function(key) {
    if (!isFalsish(obj[key])) {
      if (isPlainObject(obj[key])) {
        rules.push.apply(rules, objToCssArray2(obj[key], key));
        return rules;
      } else if (isFunction(obj[key])) {
        rules.push(hyphenateStyleName(key) + ":", obj[key], ";");
        return rules;
      }
      rules.push(hyphenateStyleName(key) + ": " + addUnitIfNeeded(key, obj[key]) + ";");
    }
    return rules;
  });
  return prevKey ? [prevKey + " {"].concat(rules, ["}"]) : rules;
};
function flatten(chunk, executionContext, styleSheet) {
  if (Array.isArray(chunk)) {
    var ruleSet = [];
    for (var i2 = 0, len2 = chunk.length, result; i2 < len2; i2 += 1) {
      result = flatten(chunk[i2], executionContext, styleSheet);
      if (result === null)
        continue;
      else if (Array.isArray(result))
        ruleSet.push.apply(ruleSet, result);
      else
        ruleSet.push(result);
    }
    return ruleSet;
  }
  if (isFalsish(chunk)) {
    return null;
  }
  if (isStyledComponent(chunk)) {
    return "." + chunk.styledComponentId;
  }
  if (isFunction(chunk)) {
    if (isStatelessFunction(chunk) && executionContext) {
      var _result = chunk(executionContext);
      return flatten(_result, executionContext, styleSheet);
    } else
      return chunk;
  }
  if (chunk instanceof Keyframes) {
    if (styleSheet) {
      chunk.inject(styleSheet);
      return chunk.getName();
    } else
      return chunk;
  }
  return isPlainObject(chunk) ? objToCssArray(chunk) : chunk.toString();
}
function css(styles) {
  for (var _len = arguments.length, interpolations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    interpolations[_key - 1] = arguments[_key];
  }
  if (isFunction(styles) || isPlainObject(styles)) {
    return flatten(interleave(EMPTY_ARRAY, [styles].concat(interpolations)));
  }
  return flatten(interleave(styles, interpolations));
}
function constructWithOptions(componentConstructor, tag) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : EMPTY_OBJECT;
  if (!reactIs.exports.isValidElementType(tag)) {
    throw new StyledComponentsError(1, String(tag));
  }
  var templateFunction = function templateFunction2() {
    return componentConstructor(tag, options, css.apply(void 0, arguments));
  };
  templateFunction.withConfig = function(config) {
    return constructWithOptions(componentConstructor, tag, _extends({}, options, config));
  };
  templateFunction.attrs = function(attrs) {
    return constructWithOptions(componentConstructor, tag, _extends({}, options, {
      attrs: Array.prototype.concat(options.attrs, attrs).filter(Boolean)
    }));
  };
  return templateFunction;
}
function murmurhash(c2) {
  for (var e2 = c2.length | 0, a = e2 | 0, d2 = 0, b2; e2 >= 4; ) {
    b2 = c2.charCodeAt(d2) & 255 | (c2.charCodeAt(++d2) & 255) << 8 | (c2.charCodeAt(++d2) & 255) << 16 | (c2.charCodeAt(++d2) & 255) << 24, b2 = 1540483477 * (b2 & 65535) + ((1540483477 * (b2 >>> 16) & 65535) << 16), b2 ^= b2 >>> 24, b2 = 1540483477 * (b2 & 65535) + ((1540483477 * (b2 >>> 16) & 65535) << 16), a = 1540483477 * (a & 65535) + ((1540483477 * (a >>> 16) & 65535) << 16) ^ b2, e2 -= 4, ++d2;
  }
  switch (e2) {
    case 3:
      a ^= (c2.charCodeAt(d2 + 2) & 255) << 16;
    case 2:
      a ^= (c2.charCodeAt(d2 + 1) & 255) << 8;
    case 1:
      a ^= c2.charCodeAt(d2) & 255, a = 1540483477 * (a & 65535) + ((1540483477 * (a >>> 16) & 65535) << 16);
  }
  a ^= a >>> 13;
  a = 1540483477 * (a & 65535) + ((1540483477 * (a >>> 16) & 65535) << 16);
  return (a ^ a >>> 15) >>> 0;
}
var charsLength = 52;
var getAlphabeticChar = function getAlphabeticChar2(code2) {
  return String.fromCharCode(code2 + (code2 > 25 ? 39 : 97));
};
function generateAlphabeticName(code2) {
  var name = "";
  var x2 = void 0;
  for (x2 = code2; x2 > charsLength; x2 = Math.floor(x2 / charsLength)) {
    name = getAlphabeticChar(x2 % charsLength) + name;
  }
  return getAlphabeticChar(x2 % charsLength) + name;
}
function hasFunctionObjectKey(obj) {
  for (var key in obj) {
    if (isFunction(obj[key])) {
      return true;
    }
  }
  return false;
}
function isStaticRules(rules, attrs) {
  for (var i2 = 0; i2 < rules.length; i2 += 1) {
    var rule = rules[i2];
    if (Array.isArray(rule) && !isStaticRules(rule, attrs)) {
      return false;
    } else if (isFunction(rule) && !isStyledComponent(rule)) {
      return false;
    }
  }
  if (attrs.some(function(x2) {
    return isFunction(x2) || hasFunctionObjectKey(x2);
  }))
    return false;
  return true;
}
var hasher = function hasher2(str) {
  return generateAlphabeticName(murmurhash(str));
};
var ComponentStyle = function() {
  function ComponentStyle2(rules, attrs, componentId) {
    classCallCheck(this, ComponentStyle2);
    this.rules = rules;
    this.isStatic = isStaticRules(rules, attrs);
    this.componentId = componentId;
    if (!StyleSheet.master.hasId(componentId)) {
      StyleSheet.master.deferredInject(componentId, []);
    }
  }
  ComponentStyle2.prototype.generateAndInjectStyles = function generateAndInjectStyles(executionContext, styleSheet) {
    var isStatic = this.isStatic, componentId = this.componentId, lastClassName = this.lastClassName;
    if (IS_BROWSER && isStatic && typeof lastClassName === "string" && styleSheet.hasNameForId(componentId, lastClassName)) {
      return lastClassName;
    }
    var flatCSS = flatten(this.rules, executionContext, styleSheet);
    var name = hasher(this.componentId + flatCSS.join(""));
    if (!styleSheet.hasNameForId(componentId, name)) {
      styleSheet.inject(this.componentId, stringifyRules(flatCSS, "." + name, void 0, componentId), name);
    }
    this.lastClassName = name;
    return name;
  };
  ComponentStyle2.generateName = function generateName(str) {
    return hasher(str);
  };
  return ComponentStyle2;
}();
var determineTheme = function(props, fallbackTheme) {
  var defaultProps2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : EMPTY_OBJECT;
  var isDefaultTheme = defaultProps2 ? props.theme === defaultProps2.theme : false;
  var theme = props.theme && !isDefaultTheme ? props.theme : fallbackTheme || defaultProps2.theme;
  return theme;
};
var escapeRegex = /[[\].#*$><+~=|^:(),"'`-]+/g;
var dashesAtEnds = /(^-|-$)/g;
function escape$1(str) {
  return str.replace(escapeRegex, "-").replace(dashesAtEnds, "");
}
function isTag(target) {
  return typeof target === "string" && true;
}
function generateDisplayName(target) {
  return isTag(target) ? "styled." + target : "Styled(" + getComponentName(target) + ")";
}
var _TYPE_STATICS;
var REACT_STATICS = {
  childContextTypes: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDerivedStateFromProps: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var TYPE_STATICS = (_TYPE_STATICS = {}, _TYPE_STATICS[reactIs.exports.ForwardRef] = {
  $$typeof: true,
  render: true
}, _TYPE_STATICS);
var defineProperty$1 = Object.defineProperty, getOwnPropertyNames = Object.getOwnPropertyNames, _Object$getOwnPropert = Object.getOwnPropertySymbols, getOwnPropertySymbols = _Object$getOwnPropert === void 0 ? function() {
  return [];
} : _Object$getOwnPropert, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, getPrototypeOf = Object.getPrototypeOf, objectPrototype = Object.prototype;
var arrayPrototype = Array.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== "string") {
    var inheritedComponent = getPrototypeOf(sourceComponent);
    if (inheritedComponent && inheritedComponent !== objectPrototype) {
      hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
    }
    var keys = arrayPrototype.concat(
      getOwnPropertyNames(sourceComponent),
      getOwnPropertySymbols(sourceComponent)
    );
    var targetStatics = TYPE_STATICS[targetComponent.$$typeof] || REACT_STATICS;
    var sourceStatics = TYPE_STATICS[sourceComponent.$$typeof] || REACT_STATICS;
    var i2 = keys.length;
    var descriptor = void 0;
    var key = void 0;
    while (i2--) {
      key = keys[i2];
      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        descriptor = getOwnPropertyDescriptor(sourceComponent, key);
        if (descriptor) {
          try {
            defineProperty$1(targetComponent, key, descriptor);
          } catch (e2) {
          }
        }
      }
    }
    return targetComponent;
  }
  return targetComponent;
}
function isDerivedReactComponent(fn) {
  return !!(fn && fn.prototype && fn.prototype.isReactComponent);
}
var ThemeContext = react.exports.createContext();
var ThemeConsumer = ThemeContext.Consumer;
(function(_Component) {
  inherits(ThemeProvider, _Component);
  function ThemeProvider(props) {
    classCallCheck(this, ThemeProvider);
    var _this = possibleConstructorReturn(this, _Component.call(this, props));
    _this.getContext = memoizeOne(_this.getContext.bind(_this));
    _this.renderInner = _this.renderInner.bind(_this);
    return _this;
  }
  ThemeProvider.prototype.render = function render() {
    if (!this.props.children)
      return null;
    return /* @__PURE__ */ jsx(ThemeContext.Consumer, {
      children: this.renderInner
    });
  };
  ThemeProvider.prototype.renderInner = function renderInner(outerTheme) {
    var context = this.getContext(this.props.theme, outerTheme);
    return /* @__PURE__ */ jsx(ThemeContext.Provider, {
      value: context,
      children: this.props.children
    });
  };
  ThemeProvider.prototype.getTheme = function getTheme(theme, outerTheme) {
    if (isFunction(theme)) {
      var mergedTheme = theme(outerTheme);
      return mergedTheme;
    }
    if (theme === null || Array.isArray(theme) || (typeof theme === "undefined" ? "undefined" : _typeof(theme)) !== "object") {
      throw new StyledComponentsError(8);
    }
    return _extends({}, outerTheme, theme);
  };
  ThemeProvider.prototype.getContext = function getContext(theme, outerTheme) {
    return this.getTheme(theme, outerTheme);
  };
  return ThemeProvider;
})(react.exports.Component);
var StyleSheetContext = react.exports.createContext();
var StyleSheetConsumer = StyleSheetContext.Consumer;
(function(_Component) {
  inherits(StyleSheetManager, _Component);
  function StyleSheetManager(props) {
    classCallCheck(this, StyleSheetManager);
    var _this = possibleConstructorReturn(this, _Component.call(this, props));
    _this.getContext = memoizeOne(_this.getContext);
    return _this;
  }
  StyleSheetManager.prototype.getContext = function getContext(sheet, target) {
    if (sheet) {
      return sheet;
    } else if (target) {
      return new StyleSheet(target);
    } else {
      throw new StyledComponentsError(4);
    }
  };
  StyleSheetManager.prototype.render = function render() {
    var _props = this.props, children = _props.children, sheet = _props.sheet, target = _props.target;
    return /* @__PURE__ */ jsx(StyleSheetContext.Provider, {
      value: this.getContext(sheet, target),
      children
    });
  };
  return StyleSheetManager;
})(react.exports.Component);
var identifiers = {};
function generateId(_ComponentStyle, _displayName, parentComponentId) {
  var displayName = typeof _displayName !== "string" ? "sc" : escape$1(_displayName);
  var nr = (identifiers[displayName] || 0) + 1;
  identifiers[displayName] = nr;
  var componentId = displayName + "-" + _ComponentStyle.generateName(displayName + nr);
  return parentComponentId ? parentComponentId + "-" + componentId : componentId;
}
var StyledComponent = function(_Component) {
  inherits(StyledComponent2, _Component);
  function StyledComponent2() {
    classCallCheck(this, StyledComponent2);
    var _this = possibleConstructorReturn(this, _Component.call(this));
    _this.attrs = {};
    _this.renderOuter = _this.renderOuter.bind(_this);
    _this.renderInner = _this.renderInner.bind(_this);
    return _this;
  }
  StyledComponent2.prototype.render = function render() {
    return /* @__PURE__ */ jsx(StyleSheetConsumer, {
      children: this.renderOuter
    });
  };
  StyledComponent2.prototype.renderOuter = function renderOuter() {
    var styleSheet = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : StyleSheet.master;
    this.styleSheet = styleSheet;
    if (this.props.forwardedComponent.componentStyle.isStatic)
      return this.renderInner();
    return /* @__PURE__ */ jsx(ThemeConsumer, {
      children: this.renderInner
    });
  };
  StyledComponent2.prototype.renderInner = function renderInner(theme) {
    var _props$forwardedCompo = this.props.forwardedComponent, componentStyle = _props$forwardedCompo.componentStyle, defaultProps2 = _props$forwardedCompo.defaultProps;
    _props$forwardedCompo.displayName;
    var foldedComponentIds = _props$forwardedCompo.foldedComponentIds, styledComponentId = _props$forwardedCompo.styledComponentId, target = _props$forwardedCompo.target;
    var generatedClassName = void 0;
    if (componentStyle.isStatic) {
      generatedClassName = this.generateAndInjectStyles(EMPTY_OBJECT, this.props);
    } else {
      generatedClassName = this.generateAndInjectStyles(determineTheme(this.props, theme, defaultProps2) || EMPTY_OBJECT, this.props);
    }
    var elementToBeCreated = this.props.as || this.attrs.as || target;
    var isTargetTag = isTag(elementToBeCreated);
    var propsForElement = {};
    var computedProps = _extends({}, this.props, this.attrs);
    var key = void 0;
    for (key in computedProps) {
      if (key === "forwardedComponent" || key === "as") {
        continue;
      } else if (key === "forwardedRef")
        propsForElement.ref = computedProps[key];
      else if (key === "forwardedAs")
        propsForElement.as = computedProps[key];
      else if (!isTargetTag || index(key)) {
        propsForElement[key] = computedProps[key];
      }
    }
    if (this.props.style && this.attrs.style) {
      propsForElement.style = _extends({}, this.attrs.style, this.props.style);
    }
    propsForElement.className = Array.prototype.concat(foldedComponentIds, styledComponentId, generatedClassName !== styledComponentId ? generatedClassName : null, this.props.className, this.attrs.className).filter(Boolean).join(" ");
    return react.exports.createElement(elementToBeCreated, propsForElement);
  };
  StyledComponent2.prototype.buildExecutionContext = function buildExecutionContext(theme, props, attrs) {
    var _this2 = this;
    var context = _extends({}, props, {
      theme
    });
    if (!attrs.length)
      return context;
    this.attrs = {};
    attrs.forEach(function(attrDef) {
      var resolvedAttrDef = attrDef;
      var attrDefWasFn = false;
      var attr = void 0;
      var key = void 0;
      if (isFunction(resolvedAttrDef)) {
        resolvedAttrDef = resolvedAttrDef(context);
        attrDefWasFn = true;
      }
      for (key in resolvedAttrDef) {
        attr = resolvedAttrDef[key];
        if (!attrDefWasFn) {
          if (isFunction(attr) && !isDerivedReactComponent(attr) && !isStyledComponent(attr)) {
            attr = attr(context);
          }
        }
        _this2.attrs[key] = attr;
        context[key] = attr;
      }
    });
    return context;
  };
  StyledComponent2.prototype.generateAndInjectStyles = function generateAndInjectStyles(theme, props) {
    var _props$forwardedCompo2 = props.forwardedComponent, attrs = _props$forwardedCompo2.attrs, componentStyle = _props$forwardedCompo2.componentStyle;
    _props$forwardedCompo2.warnTooManyClasses;
    if (componentStyle.isStatic && !attrs.length) {
      return componentStyle.generateAndInjectStyles(EMPTY_OBJECT, this.styleSheet);
    }
    var className = componentStyle.generateAndInjectStyles(this.buildExecutionContext(theme, props, attrs), this.styleSheet);
    return className;
  };
  return StyledComponent2;
}(react.exports.Component);
function createStyledComponent(target, options, rules) {
  var isTargetStyledComp = isStyledComponent(target);
  var isClass = !isTag(target);
  var _options$displayName = options.displayName, displayName = _options$displayName === void 0 ? generateDisplayName(target) : _options$displayName, _options$componentId = options.componentId, componentId = _options$componentId === void 0 ? generateId(ComponentStyle, options.displayName, options.parentComponentId) : _options$componentId, _options$ParentCompon = options.ParentComponent, ParentComponent = _options$ParentCompon === void 0 ? StyledComponent : _options$ParentCompon, _options$attrs = options.attrs, attrs = _options$attrs === void 0 ? EMPTY_ARRAY : _options$attrs;
  var styledComponentId = options.displayName && options.componentId ? escape$1(options.displayName) + "-" + options.componentId : options.componentId || componentId;
  var finalAttrs = isTargetStyledComp && target.attrs ? Array.prototype.concat(target.attrs, attrs).filter(Boolean) : attrs;
  var componentStyle = new ComponentStyle(isTargetStyledComp ? target.componentStyle.rules.concat(rules) : rules, finalAttrs, styledComponentId);
  var WrappedStyledComponent = void 0;
  var forwardRef = function forwardRef2(props, ref) {
    return /* @__PURE__ */ jsx(ParentComponent, {
      ...props,
      forwardedComponent: WrappedStyledComponent,
      forwardedRef: ref
    });
  };
  forwardRef.displayName = displayName;
  WrappedStyledComponent = React.forwardRef(forwardRef);
  WrappedStyledComponent.displayName = displayName;
  WrappedStyledComponent.attrs = finalAttrs;
  WrappedStyledComponent.componentStyle = componentStyle;
  WrappedStyledComponent.foldedComponentIds = isTargetStyledComp ? Array.prototype.concat(target.foldedComponentIds, target.styledComponentId) : EMPTY_ARRAY;
  WrappedStyledComponent.styledComponentId = styledComponentId;
  WrappedStyledComponent.target = isTargetStyledComp ? target.target : target;
  WrappedStyledComponent.withComponent = function withComponent(tag) {
    var previousComponentId = options.componentId, optionsToCopy = objectWithoutProperties(options, ["componentId"]);
    var newComponentId = previousComponentId && previousComponentId + "-" + (isTag(tag) ? tag : escape$1(getComponentName(tag)));
    var newOptions = _extends({}, optionsToCopy, {
      attrs: finalAttrs,
      componentId: newComponentId,
      ParentComponent
    });
    return createStyledComponent(tag, newOptions, rules);
  };
  Object.defineProperty(WrappedStyledComponent, "defaultProps", {
    get: function get$$1() {
      return this._foldedDefaultProps;
    },
    set: function set$$1(obj) {
      this._foldedDefaultProps = isTargetStyledComp ? merge(target.defaultProps, obj) : obj;
    }
  });
  WrappedStyledComponent.toString = function() {
    return "." + WrappedStyledComponent.styledComponentId;
  };
  if (isClass) {
    hoistNonReactStatics(WrappedStyledComponent, target, {
      attrs: true,
      componentStyle: true,
      displayName: true,
      foldedComponentIds: true,
      styledComponentId: true,
      target: true,
      withComponent: true
    });
  }
  return WrappedStyledComponent;
}
var domElements = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "marker",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
var styled = function styled2(tag) {
  return constructWithOptions(createStyledComponent, tag);
};
domElements.forEach(function(domElement) {
  styled[domElement] = styled(domElement);
});
if (IS_BROWSER) {
  window.scCGSHMRCache = {};
}
const styled$1 = styled;
const StyledFrame = styled$1.div`
  align-self: flex-end;
  display: flex;
  background-image: url("frame/left-top-corner.png"),
    url("frame/right-top-corner.png"), url("frame/left-bottom-corner.png"),
    url("frame/right-bottom-corner.png"), url("frame/top-horizontal-bar.png"),
    url("frame/bottom-horizontal-bar.png"), url("frame/left-vertical-bar.png"),
    url("frame/right-vertical-bar.png"), url("frame/bg2.jpg");
  background-position: left top, right top, left 1px bottom, right 1px bottom,
    left 1px, left 1px bottom, left 1px bottom, right 1px top, center top;
  background-repeat: no-repeat, no-repeat, no-repeat, no-repeat, repeat-x,
    repeat-x, repeat-y, repeat-y, no-repeat;
  background-color: #1d2123;
  position: relative;
  padding: 8px;
`;
StyledFrame.displayName = "StyledFrame";
const Frame = ({
  className,
  children
}) => /* @__PURE__ */ jsx(StyledFrame, {
  className,
  children: /* @__PURE__ */ jsx("div", {
    className: "w-full h-full p-3 rounded shadow-inner bg-[url('/frame/bg.jpg')] bg-center bg-cover",
    children
  })
});
const StyledBagBox = styled$1.div`
  ${(props) => {
  const {
    canDrop,
    isOver
  } = props;
  return css`
      position: relative;
      border: ${canDrop ? `1px solid ${isOver ? "green" : "gold"}` : "1px solid #0c1e20"};
      position: relative;
      width: 6em;
      display: flex;
      height: 6em;
      align-items: center;
      justify-content: center;
      background-image: radial-gradient(#0c1e20 0%, #101010 66%);
      border-radius: 2px;
      box-shadow: 0px 0px 0px 2px #2f3639;
    `;
}}
`;
StyledBagBox.displayName = "StyledBagBox";
const RemoteBox = ({
  className,
  children
}) => {
  return /* @__PURE__ */ jsx(StyledBagBox, {
    className,
    isOver: false,
    canDrop: false,
    children
  });
};
const RemoteBox$1 = React.memo(RemoteBox);
const BagBox = ({
  className,
  children,
  isOver,
  canDrop
}) => {
  return /* @__PURE__ */ jsx(StyledBagBox, {
    className,
    isOver,
    canDrop,
    children
  });
};
const BagBox$1 = React.memo(BagBox);
var classnames$1 = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(module2) {
  (function() {
    var hasOwn = {}.hasOwnProperty;
    function classNames() {
      var classes = [];
      for (var i2 = 0; i2 < arguments.length; i2++) {
        var arg = arguments[i2];
        if (!arg)
          continue;
        var argType = typeof arg;
        if (argType === "string" || argType === "number") {
          classes.push(arg);
        } else if (Array.isArray(arg)) {
          if (arg.length) {
            var inner = classNames.apply(null, arg);
            if (inner) {
              classes.push(inner);
            }
          }
        } else if (argType === "object") {
          if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
            classes.push(arg.toString());
            continue;
          }
          for (var key in arg) {
            if (hasOwn.call(arg, key) && arg[key]) {
              classes.push(key);
            }
          }
        }
      }
      return classes.join(" ");
    }
    if (module2.exports) {
      classNames.default = classNames;
      module2.exports = classNames;
    } else {
      window.classNames = classNames;
    }
  })();
})(classnames$1);
const classnames = classnames$1.exports;
var react3dViewer = { exports: {} };
/*!
 *  react-3d-viewer v1.0.12
 *  By https://github.com/dwqdaiwenqi 
 *  Github: https://github.com/dwqdaiwenqi/react-3d-viewer
 *  MIT Licensed.
 */
(function(module2, exports2) {
  !function(e2, t2) {
    module2.exports = t2();
  }(window, function() {
    return function(e2) {
      var t2 = {};
      function n2(r2) {
        if (t2[r2])
          return t2[r2].exports;
        var i2 = t2[r2] = { i: r2, l: false, exports: {} };
        return e2[r2].call(i2.exports, i2, i2.exports, n2), i2.l = true, i2.exports;
      }
      return n2.m = e2, n2.c = t2, n2.d = function(e3, t3, r2) {
        n2.o(e3, t3) || Object.defineProperty(e3, t3, { enumerable: true, get: r2 });
      }, n2.r = function(e3) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
      }, n2.t = function(e3, t3) {
        if (1 & t3 && (e3 = n2(e3)), 8 & t3)
          return e3;
        if (4 & t3 && "object" == typeof e3 && e3 && e3.__esModule)
          return e3;
        var r2 = /* @__PURE__ */ Object.create(null);
        if (n2.r(r2), Object.defineProperty(r2, "default", { enumerable: true, value: e3 }), 2 & t3 && "string" != typeof e3)
          for (var i2 in e3)
            n2.d(r2, i2, function(t4) {
              return e3[t4];
            }.bind(null, i2));
        return r2;
      }, n2.n = function(e3) {
        var t3 = e3 && e3.__esModule ? function() {
          return e3.default;
        } : function() {
          return e3;
        };
        return n2.d(t3, "a", t3), t3;
      }, n2.o = function(e3, t3) {
        return Object.prototype.hasOwnProperty.call(e3, t3);
      }, n2.p = "", n2(n2.s = 13);
    }([function(e2, t2, n2) {
      function r2() {
      }
      n2.r(t2), n2.d(t2, "WebGLRenderTargetCube", function() {
        return Yt;
      }), n2.d(t2, "WebGLRenderTarget", function() {
        return qt;
      }), n2.d(t2, "WebGLRenderer", function() {
        return oi2;
      }), n2.d(t2, "ShaderLib", function() {
        return on;
      }), n2.d(t2, "UniformsLib", function() {
        return an;
      }), n2.d(t2, "UniformsUtils", function() {
        return tn;
      }), n2.d(t2, "ShaderChunk", function() {
        return en;
      }), n2.d(t2, "FogExp2", function() {
        return si2;
      }), n2.d(t2, "Fog", function() {
        return ci2;
      }), n2.d(t2, "Scene", function() {
        return ui2;
      }), n2.d(t2, "Sprite", function() {
        return pi2;
      }), n2.d(t2, "LOD", function() {
        return fi2;
      }), n2.d(t2, "SkinnedMesh", function() {
        return vi2;
      }), n2.d(t2, "Skeleton", function() {
        return mi2;
      }), n2.d(t2, "Bone", function() {
        return gi2;
      }), n2.d(t2, "Mesh", function() {
        return kn;
      }), n2.d(t2, "LineSegments", function() {
        return bi2;
      }), n2.d(t2, "LineLoop", function() {
        return wi2;
      }), n2.d(t2, "Line", function() {
        return xi2;
      }), n2.d(t2, "Points", function() {
        return Mi2;
      }), n2.d(t2, "Group", function() {
        return ni2;
      }), n2.d(t2, "VideoTexture", function() {
        return Ei2;
      }), n2.d(t2, "DataTexture", function() {
        return Zt;
      }), n2.d(t2, "CompressedTexture", function() {
        return Ti2;
      }), n2.d(t2, "CubeTexture", function() {
        return Vn;
      }), n2.d(t2, "CanvasTexture", function() {
        return Si2;
      }), n2.d(t2, "DepthTexture", function() {
        return Ai2;
      }), n2.d(t2, "Texture", function() {
        return Wt;
      }), n2.d(t2, "CompressedTextureLoader", function() {
        return no;
      }), n2.d(t2, "DataTextureLoader", function() {
        return ro;
      }), n2.d(t2, "CubeTextureLoader", function() {
        return ao;
      }), n2.d(t2, "TextureLoader", function() {
        return oo;
      }), n2.d(t2, "ObjectLoader", function() {
        return cs;
      }), n2.d(t2, "MaterialLoader", function() {
        return ns;
      }), n2.d(t2, "BufferGeometryLoader", function() {
        return rs;
      }), n2.d(t2, "DefaultLoadingManager", function() {
        return $a;
      }), n2.d(t2, "LoadingManager", function() {
        return Qa2;
      }), n2.d(t2, "JSONLoader", function() {
        return ss;
      }), n2.d(t2, "ImageLoader", function() {
        return io;
      }), n2.d(t2, "ImageBitmapLoader", function() {
        return ps;
      }), n2.d(t2, "FontLoader", function() {
        return vs;
      }), n2.d(t2, "FileLoader", function() {
        return to;
      }), n2.d(t2, "Loader", function() {
        return as;
      }), n2.d(t2, "LoaderUtils", function() {
        return os;
      }), n2.d(t2, "Cache", function() {
        return Ka2;
      }), n2.d(t2, "AudioLoader", function() {
        return xs;
      }), n2.d(t2, "SpotLightShadow", function() {
        return Io;
      }), n2.d(t2, "SpotLight", function() {
        return Do;
      }), n2.d(t2, "PointLight", function() {
        return Uo;
      }), n2.d(t2, "RectAreaLight", function() {
        return zo;
      }), n2.d(t2, "HemisphereLight", function() {
        return Oo;
      }), n2.d(t2, "DirectionalLightShadow", function() {
        return Bo;
      }), n2.d(t2, "DirectionalLight", function() {
        return Fo;
      }), n2.d(t2, "AmbientLight", function() {
        return Go;
      }), n2.d(t2, "LightShadow", function() {
        return No;
      }), n2.d(t2, "Light", function() {
        return Po;
      }), n2.d(t2, "StereoCamera", function() {
        return bs;
      }), n2.d(t2, "PerspectiveCamera", function() {
        return ri2;
      }), n2.d(t2, "OrthographicCamera", function() {
        return fn;
      }), n2.d(t2, "CubeCamera", function() {
        return ws;
      }), n2.d(t2, "ArrayCamera", function() {
        return ii2;
      }), n2.d(t2, "Camera", function() {
        return pn;
      }), n2.d(t2, "AudioListener", function() {
        return _s;
      }), n2.d(t2, "PositionalAudio", function() {
        return Es;
      }), n2.d(t2, "AudioContext", function() {
        return ys;
      }), n2.d(t2, "AudioAnalyser", function() {
        return Ts;
      }), n2.d(t2, "Audio", function() {
        return Ms;
      }), n2.d(t2, "VectorKeyframeTrack", function() {
        return $o;
      }), n2.d(t2, "StringKeyframeTrack", function() {
        return Qo;
      }), n2.d(t2, "QuaternionKeyframeTrack", function() {
        return Ko;
      }), n2.d(t2, "NumberKeyframeTrack", function() {
        return Zo;
      }), n2.d(t2, "ColorKeyframeTrack", function() {
        return Yo;
      }), n2.d(t2, "BooleanKeyframeTrack", function() {
        return qo;
      }), n2.d(t2, "PropertyMixer", function() {
        return Ss;
      }), n2.d(t2, "PropertyBinding", function() {
        return Cs;
      }), n2.d(t2, "KeyframeTrack", function() {
        return Xo;
      }), n2.d(t2, "AnimationUtils", function() {
        return Ho;
      }), n2.d(t2, "AnimationObjectGroup", function() {
        return Ps;
      }), n2.d(t2, "AnimationMixer", function() {
        return Ns;
      }), n2.d(t2, "AnimationClip", function() {
        return es;
      }), n2.d(t2, "Uniform", function() {
        return Is;
      }), n2.d(t2, "InstancedBufferGeometry", function() {
        return Ds;
      }), n2.d(t2, "BufferGeometry", function() {
        return Pn;
      }), n2.d(t2, "Geometry", function() {
        return vn;
      }), n2.d(t2, "InterleavedBufferAttribute", function() {
        return hi2;
      }), n2.d(t2, "InstancedInterleavedBuffer", function() {
        return Us;
      }), n2.d(t2, "InterleavedBuffer", function() {
        return li2;
      }), n2.d(t2, "InstancedBufferAttribute", function() {
        return Bs;
      }), n2.d(t2, "Face3", function() {
        return mn;
      }), n2.d(t2, "Object3D", function() {
        return dn;
      }), n2.d(t2, "Raycaster", function() {
        return Fs;
      }), n2.d(t2, "Layers", function() {
        return ln;
      }), n2.d(t2, "EventDispatcher", function() {
        return r2;
      }), n2.d(t2, "Clock", function() {
        return Hs;
      }), n2.d(t2, "QuaternionLinearInterpolant", function() {
        return Jo;
      }), n2.d(t2, "LinearInterpolant", function() {
        return Vo;
      }), n2.d(t2, "DiscreteInterpolant", function() {
        return Wo;
      }), n2.d(t2, "CubicInterpolant", function() {
        return jo;
      }), n2.d(t2, "Interpolant", function() {
        return ko;
      }), n2.d(t2, "Triangle", function() {
        return Hn;
      }), n2.d(t2, "Math", function() {
        return Bt;
      }), n2.d(t2, "Spherical", function() {
        return ks;
      }), n2.d(t2, "Cylindrical", function() {
        return js;
      }), n2.d(t2, "Plane", function() {
        return Qt;
      }), n2.d(t2, "Frustum", function() {
        return $t;
      }), n2.d(t2, "Sphere", function() {
        return Kt;
      }), n2.d(t2, "Ray", function() {
        return zn;
      }), n2.d(t2, "Matrix4", function() {
        return Gt;
      }), n2.d(t2, "Matrix3", function() {
        return kt;
      }), n2.d(t2, "Box3", function() {
        return Jt;
      }), n2.d(t2, "Box2", function() {
        return Vs;
      }), n2.d(t2, "Line3", function() {
        return Ws;
      }), n2.d(t2, "Euler", function() {
        return un;
      }), n2.d(t2, "Vector4", function() {
        return Xt;
      }), n2.d(t2, "Vector3", function() {
        return Ht;
      }), n2.d(t2, "Vector2", function() {
        return Ft;
      }), n2.d(t2, "Quaternion", function() {
        return zt;
      }), n2.d(t2, "Color", function() {
        return rn;
      }), n2.d(t2, "ImmediateRenderObject", function() {
        return Xs;
      }), n2.d(t2, "VertexNormalsHelper", function() {
        return qs;
      }), n2.d(t2, "SpotLightHelper", function() {
        return Ys;
      }), n2.d(t2, "SkeletonHelper", function() {
        return Zs;
      }), n2.d(t2, "PointLightHelper", function() {
        return Js;
      }), n2.d(t2, "RectAreaLightHelper", function() {
        return Ks;
      }), n2.d(t2, "HemisphereLightHelper", function() {
        return Qs;
      }), n2.d(t2, "GridHelper", function() {
        return $s;
      }), n2.d(t2, "PolarGridHelper", function() {
        return ec2;
      }), n2.d(t2, "FaceNormalsHelper", function() {
        return tc2;
      }), n2.d(t2, "DirectionalLightHelper", function() {
        return nc2;
      }), n2.d(t2, "CameraHelper", function() {
        return rc2;
      }), n2.d(t2, "BoxHelper", function() {
        return ic2;
      }), n2.d(t2, "Box3Helper", function() {
        return ac2;
      }), n2.d(t2, "PlaneHelper", function() {
        return oc2;
      }), n2.d(t2, "ArrowHelper", function() {
        return sc2;
      }), n2.d(t2, "AxesHelper", function() {
        return cc2;
      }), n2.d(t2, "Shape", function() {
        return Co;
      }), n2.d(t2, "Path", function() {
        return Ro;
      }), n2.d(t2, "ShapePath", function() {
        return fs;
      }), n2.d(t2, "Font", function() {
        return ms;
      }), n2.d(t2, "CurvePath", function() {
        return Lo;
      }), n2.d(t2, "Curve", function() {
        return so;
      }), n2.d(t2, "ImageUtils", function() {
        return jt;
      }), n2.d(t2, "ShapeUtils", function() {
        return ma2;
      }), n2.d(t2, "WebGLUtils", function() {
        return ti2;
      }), n2.d(t2, "WireframeGeometry", function() {
        return Li2;
      }), n2.d(t2, "ParametricGeometry", function() {
        return Ri2;
      }), n2.d(t2, "ParametricBufferGeometry", function() {
        return Ci2;
      }), n2.d(t2, "TetrahedronGeometry", function() {
        return Ni2;
      }), n2.d(t2, "TetrahedronBufferGeometry", function() {
        return Ii2;
      }), n2.d(t2, "OctahedronGeometry", function() {
        return Di2;
      }), n2.d(t2, "OctahedronBufferGeometry", function() {
        return Ui2;
      }), n2.d(t2, "IcosahedronGeometry", function() {
        return Bi2;
      }), n2.d(t2, "IcosahedronBufferGeometry", function() {
        return Fi2;
      }), n2.d(t2, "DodecahedronGeometry", function() {
        return Gi2;
      }), n2.d(t2, "DodecahedronBufferGeometry", function() {
        return zi2;
      }), n2.d(t2, "PolyhedronGeometry", function() {
        return Pi2;
      }), n2.d(t2, "PolyhedronBufferGeometry", function() {
        return Oi2;
      }), n2.d(t2, "TubeGeometry", function() {
        return Hi2;
      }), n2.d(t2, "TubeBufferGeometry", function() {
        return ki2;
      }), n2.d(t2, "TorusKnotGeometry", function() {
        return ji2;
      }), n2.d(t2, "TorusKnotBufferGeometry", function() {
        return Vi2;
      }), n2.d(t2, "TorusGeometry", function() {
        return Wi2;
      }), n2.d(t2, "TorusBufferGeometry", function() {
        return Xi2;
      }), n2.d(t2, "TextGeometry", function() {
        return _a;
      }), n2.d(t2, "TextBufferGeometry", function() {
        return Ma2;
      }), n2.d(t2, "SphereGeometry", function() {
        return Ea2;
      }), n2.d(t2, "SphereBufferGeometry", function() {
        return Ta2;
      }), n2.d(t2, "RingGeometry", function() {
        return Sa2;
      }), n2.d(t2, "RingBufferGeometry", function() {
        return Aa2;
      }), n2.d(t2, "PlaneGeometry", function() {
        return In;
      }), n2.d(t2, "PlaneBufferGeometry", function() {
        return Dn;
      }), n2.d(t2, "LatheGeometry", function() {
        return La2;
      }), n2.d(t2, "LatheBufferGeometry", function() {
        return Ra2;
      }), n2.d(t2, "ShapeGeometry", function() {
        return Ca2;
      }), n2.d(t2, "ShapeBufferGeometry", function() {
        return Pa2;
      }), n2.d(t2, "ExtrudeGeometry", function() {
        return ya2;
      }), n2.d(t2, "ExtrudeBufferGeometry", function() {
        return xa;
      }), n2.d(t2, "EdgesGeometry", function() {
        return Na2;
      }), n2.d(t2, "ConeGeometry", function() {
        return Ua2;
      }), n2.d(t2, "ConeBufferGeometry", function() {
        return Ba2;
      }), n2.d(t2, "CylinderGeometry", function() {
        return Ia2;
      }), n2.d(t2, "CylinderBufferGeometry", function() {
        return Da2;
      }), n2.d(t2, "CircleGeometry", function() {
        return Fa2;
      }), n2.d(t2, "CircleBufferGeometry", function() {
        return Ga2;
      }), n2.d(t2, "BoxGeometry", function() {
        return On;
      }), n2.d(t2, "BoxBufferGeometry", function() {
        return Nn;
      }), n2.d(t2, "ShadowMaterial", function() {
        return Ha2;
      }), n2.d(t2, "SpriteMaterial", function() {
        return di2;
      }), n2.d(t2, "RawShaderMaterial", function() {
        return ka2;
      }), n2.d(t2, "ShaderMaterial", function() {
        return Gn;
      }), n2.d(t2, "PointsMaterial", function() {
        return _i;
      }), n2.d(t2, "MeshPhysicalMaterial", function() {
        return Va2;
      }), n2.d(t2, "MeshStandardMaterial", function() {
        return ja2;
      }), n2.d(t2, "MeshPhongMaterial", function() {
        return Wa2;
      }), n2.d(t2, "MeshToonMaterial", function() {
        return Xa2;
      }), n2.d(t2, "MeshNormalMaterial", function() {
        return qa2;
      }), n2.d(t2, "MeshLambertMaterial", function() {
        return Ya2;
      }), n2.d(t2, "MeshDepthMaterial", function() {
        return Kr;
      }), n2.d(t2, "MeshDistanceMaterial", function() {
        return Qr;
      }), n2.d(t2, "MeshBasicMaterial", function() {
        return Fn;
      }), n2.d(t2, "LineDashedMaterial", function() {
        return Za2;
      }), n2.d(t2, "LineBasicMaterial", function() {
        return yi2;
      }), n2.d(t2, "Material", function() {
        return Bn;
      }), n2.d(t2, "Float64BufferAttribute", function() {
        return An;
      }), n2.d(t2, "Float32BufferAttribute", function() {
        return Sn;
      }), n2.d(t2, "Uint32BufferAttribute", function() {
        return Tn;
      }), n2.d(t2, "Int32BufferAttribute", function() {
        return En;
      }), n2.d(t2, "Uint16BufferAttribute", function() {
        return Mn;
      }), n2.d(t2, "Int16BufferAttribute", function() {
        return _n;
      }), n2.d(t2, "Uint8ClampedBufferAttribute", function() {
        return wn;
      }), n2.d(t2, "Uint8BufferAttribute", function() {
        return bn;
      }), n2.d(t2, "Int8BufferAttribute", function() {
        return xn;
      }), n2.d(t2, "BufferAttribute", function() {
        return yn;
      }), n2.d(t2, "ArcCurve", function() {
        return uo;
      }), n2.d(t2, "CatmullRomCurve3", function() {
        return go;
      }), n2.d(t2, "CubicBezierCurve", function() {
        return bo;
      }), n2.d(t2, "CubicBezierCurve3", function() {
        return wo;
      }), n2.d(t2, "EllipseCurve", function() {
        return co;
      }), n2.d(t2, "LineCurve", function() {
        return _o;
      }), n2.d(t2, "LineCurve3", function() {
        return Mo;
      }), n2.d(t2, "QuadraticBezierCurve", function() {
        return Eo;
      }), n2.d(t2, "QuadraticBezierCurve3", function() {
        return To;
      }), n2.d(t2, "SplineCurve", function() {
        return So;
      }), n2.d(t2, "REVISION", function() {
        return i2;
      }), n2.d(t2, "MOUSE", function() {
        return a;
      }), n2.d(t2, "CullFaceNone", function() {
        return o;
      }), n2.d(t2, "CullFaceBack", function() {
        return s;
      }), n2.d(t2, "CullFaceFront", function() {
        return c2;
      }), n2.d(t2, "CullFaceFrontBack", function() {
        return u2;
      }), n2.d(t2, "FrontFaceDirectionCW", function() {
        return l2;
      }), n2.d(t2, "FrontFaceDirectionCCW", function() {
        return h2;
      }), n2.d(t2, "BasicShadowMap", function() {
        return d2;
      }), n2.d(t2, "PCFShadowMap", function() {
        return p2;
      }), n2.d(t2, "PCFSoftShadowMap", function() {
        return f2;
      }), n2.d(t2, "FrontSide", function() {
        return m2;
      }), n2.d(t2, "BackSide", function() {
        return g2;
      }), n2.d(t2, "DoubleSide", function() {
        return v2;
      }), n2.d(t2, "FlatShading", function() {
        return y2;
      }), n2.d(t2, "SmoothShading", function() {
        return x2;
      }), n2.d(t2, "NoColors", function() {
        return b2;
      }), n2.d(t2, "FaceColors", function() {
        return w2;
      }), n2.d(t2, "VertexColors", function() {
        return _2;
      }), n2.d(t2, "NoBlending", function() {
        return M2;
      }), n2.d(t2, "NormalBlending", function() {
        return E2;
      }), n2.d(t2, "AdditiveBlending", function() {
        return T2;
      }), n2.d(t2, "SubtractiveBlending", function() {
        return S2;
      }), n2.d(t2, "MultiplyBlending", function() {
        return A2;
      }), n2.d(t2, "CustomBlending", function() {
        return L2;
      }), n2.d(t2, "AddEquation", function() {
        return R2;
      }), n2.d(t2, "SubtractEquation", function() {
        return C2;
      }), n2.d(t2, "ReverseSubtractEquation", function() {
        return P2;
      }), n2.d(t2, "MinEquation", function() {
        return O2;
      }), n2.d(t2, "MaxEquation", function() {
        return N2;
      }), n2.d(t2, "ZeroFactor", function() {
        return I2;
      }), n2.d(t2, "OneFactor", function() {
        return D2;
      }), n2.d(t2, "SrcColorFactor", function() {
        return U2;
      }), n2.d(t2, "OneMinusSrcColorFactor", function() {
        return B2;
      }), n2.d(t2, "SrcAlphaFactor", function() {
        return F2;
      }), n2.d(t2, "OneMinusSrcAlphaFactor", function() {
        return G2;
      }), n2.d(t2, "DstAlphaFactor", function() {
        return z2;
      }), n2.d(t2, "OneMinusDstAlphaFactor", function() {
        return H2;
      }), n2.d(t2, "DstColorFactor", function() {
        return k2;
      }), n2.d(t2, "OneMinusDstColorFactor", function() {
        return j;
      }), n2.d(t2, "SrcAlphaSaturateFactor", function() {
        return V2;
      }), n2.d(t2, "NeverDepth", function() {
        return W2;
      }), n2.d(t2, "AlwaysDepth", function() {
        return X2;
      }), n2.d(t2, "LessDepth", function() {
        return q2;
      }), n2.d(t2, "LessEqualDepth", function() {
        return Y2;
      }), n2.d(t2, "EqualDepth", function() {
        return Z2;
      }), n2.d(t2, "GreaterEqualDepth", function() {
        return J2;
      }), n2.d(t2, "GreaterDepth", function() {
        return K2;
      }), n2.d(t2, "NotEqualDepth", function() {
        return Q2;
      }), n2.d(t2, "MultiplyOperation", function() {
        return $;
      }), n2.d(t2, "MixOperation", function() {
        return ee2;
      }), n2.d(t2, "AddOperation", function() {
        return te2;
      }), n2.d(t2, "NoToneMapping", function() {
        return ne2;
      }), n2.d(t2, "LinearToneMapping", function() {
        return re2;
      }), n2.d(t2, "ReinhardToneMapping", function() {
        return ie2;
      }), n2.d(t2, "Uncharted2ToneMapping", function() {
        return ae2;
      }), n2.d(t2, "CineonToneMapping", function() {
        return oe2;
      }), n2.d(t2, "UVMapping", function() {
        return se2;
      }), n2.d(t2, "CubeReflectionMapping", function() {
        return ce2;
      }), n2.d(t2, "CubeRefractionMapping", function() {
        return ue2;
      }), n2.d(t2, "EquirectangularReflectionMapping", function() {
        return le2;
      }), n2.d(t2, "EquirectangularRefractionMapping", function() {
        return he2;
      }), n2.d(t2, "SphericalReflectionMapping", function() {
        return de2;
      }), n2.d(t2, "CubeUVReflectionMapping", function() {
        return pe2;
      }), n2.d(t2, "CubeUVRefractionMapping", function() {
        return fe2;
      }), n2.d(t2, "RepeatWrapping", function() {
        return me2;
      }), n2.d(t2, "ClampToEdgeWrapping", function() {
        return ge2;
      }), n2.d(t2, "MirroredRepeatWrapping", function() {
        return ve2;
      }), n2.d(t2, "NearestFilter", function() {
        return ye2;
      }), n2.d(t2, "NearestMipMapNearestFilter", function() {
        return xe2;
      }), n2.d(t2, "NearestMipMapLinearFilter", function() {
        return be2;
      }), n2.d(t2, "LinearFilter", function() {
        return we2;
      }), n2.d(t2, "LinearMipMapNearestFilter", function() {
        return _e;
      }), n2.d(t2, "LinearMipMapLinearFilter", function() {
        return Me2;
      }), n2.d(t2, "UnsignedByteType", function() {
        return Ee2;
      }), n2.d(t2, "ByteType", function() {
        return Te2;
      }), n2.d(t2, "ShortType", function() {
        return Se2;
      }), n2.d(t2, "UnsignedShortType", function() {
        return Ae2;
      }), n2.d(t2, "IntType", function() {
        return Le2;
      }), n2.d(t2, "UnsignedIntType", function() {
        return Re2;
      }), n2.d(t2, "FloatType", function() {
        return Ce2;
      }), n2.d(t2, "HalfFloatType", function() {
        return Pe2;
      }), n2.d(t2, "UnsignedShort4444Type", function() {
        return Oe2;
      }), n2.d(t2, "UnsignedShort5551Type", function() {
        return Ne2;
      }), n2.d(t2, "UnsignedShort565Type", function() {
        return Ie2;
      }), n2.d(t2, "UnsignedInt248Type", function() {
        return De2;
      }), n2.d(t2, "AlphaFormat", function() {
        return Ue2;
      }), n2.d(t2, "RGBFormat", function() {
        return Be2;
      }), n2.d(t2, "RGBAFormat", function() {
        return Fe2;
      }), n2.d(t2, "LuminanceFormat", function() {
        return Ge2;
      }), n2.d(t2, "LuminanceAlphaFormat", function() {
        return ze2;
      }), n2.d(t2, "RGBEFormat", function() {
        return He2;
      }), n2.d(t2, "DepthFormat", function() {
        return ke2;
      }), n2.d(t2, "DepthStencilFormat", function() {
        return je2;
      }), n2.d(t2, "RGB_S3TC_DXT1_Format", function() {
        return Ve2;
      }), n2.d(t2, "RGBA_S3TC_DXT1_Format", function() {
        return We2;
      }), n2.d(t2, "RGBA_S3TC_DXT3_Format", function() {
        return Xe2;
      }), n2.d(t2, "RGBA_S3TC_DXT5_Format", function() {
        return qe2;
      }), n2.d(t2, "RGB_PVRTC_4BPPV1_Format", function() {
        return Ye2;
      }), n2.d(t2, "RGB_PVRTC_2BPPV1_Format", function() {
        return Ze2;
      }), n2.d(t2, "RGBA_PVRTC_4BPPV1_Format", function() {
        return Je2;
      }), n2.d(t2, "RGBA_PVRTC_2BPPV1_Format", function() {
        return Ke2;
      }), n2.d(t2, "RGB_ETC1_Format", function() {
        return Qe2;
      }), n2.d(t2, "RGBA_ASTC_4x4_Format", function() {
        return $e2;
      }), n2.d(t2, "RGBA_ASTC_5x4_Format", function() {
        return et;
      }), n2.d(t2, "RGBA_ASTC_5x5_Format", function() {
        return tt;
      }), n2.d(t2, "RGBA_ASTC_6x5_Format", function() {
        return nt;
      }), n2.d(t2, "RGBA_ASTC_6x6_Format", function() {
        return rt;
      }), n2.d(t2, "RGBA_ASTC_8x5_Format", function() {
        return it;
      }), n2.d(t2, "RGBA_ASTC_8x6_Format", function() {
        return at;
      }), n2.d(t2, "RGBA_ASTC_8x8_Format", function() {
        return ot;
      }), n2.d(t2, "RGBA_ASTC_10x5_Format", function() {
        return st;
      }), n2.d(t2, "RGBA_ASTC_10x6_Format", function() {
        return ct;
      }), n2.d(t2, "RGBA_ASTC_10x8_Format", function() {
        return ut;
      }), n2.d(t2, "RGBA_ASTC_10x10_Format", function() {
        return lt;
      }), n2.d(t2, "RGBA_ASTC_12x10_Format", function() {
        return ht;
      }), n2.d(t2, "RGBA_ASTC_12x12_Format", function() {
        return dt;
      }), n2.d(t2, "LoopOnce", function() {
        return pt;
      }), n2.d(t2, "LoopRepeat", function() {
        return ft;
      }), n2.d(t2, "LoopPingPong", function() {
        return mt;
      }), n2.d(t2, "InterpolateDiscrete", function() {
        return gt;
      }), n2.d(t2, "InterpolateLinear", function() {
        return vt;
      }), n2.d(t2, "InterpolateSmooth", function() {
        return yt;
      }), n2.d(t2, "ZeroCurvatureEnding", function() {
        return xt;
      }), n2.d(t2, "ZeroSlopeEnding", function() {
        return bt;
      }), n2.d(t2, "WrapAroundEnding", function() {
        return wt;
      }), n2.d(t2, "TrianglesDrawMode", function() {
        return _t5;
      }), n2.d(t2, "TriangleStripDrawMode", function() {
        return Mt;
      }), n2.d(t2, "TriangleFanDrawMode", function() {
        return Et;
      }), n2.d(t2, "LinearEncoding", function() {
        return Tt;
      }), n2.d(t2, "sRGBEncoding", function() {
        return St;
      }), n2.d(t2, "GammaEncoding", function() {
        return At;
      }), n2.d(t2, "RGBEEncoding", function() {
        return Lt;
      }), n2.d(t2, "LogLuvEncoding", function() {
        return Rt;
      }), n2.d(t2, "RGBM7Encoding", function() {
        return Ct;
      }), n2.d(t2, "RGBM16Encoding", function() {
        return Pt;
      }), n2.d(t2, "RGBDEncoding", function() {
        return Ot;
      }), n2.d(t2, "BasicDepthPacking", function() {
        return Nt;
      }), n2.d(t2, "RGBADepthPacking", function() {
        return It;
      }), n2.d(t2, "TangentSpaceNormalMap", function() {
        return Dt;
      }), n2.d(t2, "ObjectSpaceNormalMap", function() {
        return Ut;
      }), n2.d(t2, "CubeGeometry", function() {
        return On;
      }), n2.d(t2, "Face4", function() {
        return uc2;
      }), n2.d(t2, "LineStrip", function() {
        return lc2;
      }), n2.d(t2, "LinePieces", function() {
        return hc2;
      }), n2.d(t2, "MeshFaceMaterial", function() {
        return dc2;
      }), n2.d(t2, "MultiMaterial", function() {
        return pc2;
      }), n2.d(t2, "PointCloud", function() {
        return fc2;
      }), n2.d(t2, "Particle", function() {
        return mc2;
      }), n2.d(t2, "ParticleSystem", function() {
        return gc2;
      }), n2.d(t2, "PointCloudMaterial", function() {
        return vc2;
      }), n2.d(t2, "ParticleBasicMaterial", function() {
        return yc2;
      }), n2.d(t2, "ParticleSystemMaterial", function() {
        return xc2;
      }), n2.d(t2, "Vertex", function() {
        return bc2;
      }), n2.d(t2, "DynamicBufferAttribute", function() {
        return wc2;
      }), n2.d(t2, "Int8Attribute", function() {
        return _c;
      }), n2.d(t2, "Uint8Attribute", function() {
        return Mc2;
      }), n2.d(t2, "Uint8ClampedAttribute", function() {
        return Ec2;
      }), n2.d(t2, "Int16Attribute", function() {
        return Tc2;
      }), n2.d(t2, "Uint16Attribute", function() {
        return Sc2;
      }), n2.d(t2, "Int32Attribute", function() {
        return Ac2;
      }), n2.d(t2, "Uint32Attribute", function() {
        return Lc2;
      }), n2.d(t2, "Float32Attribute", function() {
        return Rc2;
      }), n2.d(t2, "Float64Attribute", function() {
        return Cc2;
      }), n2.d(t2, "ClosedSplineCurve3", function() {
        return Pc2;
      }), n2.d(t2, "SplineCurve3", function() {
        return Oc2;
      }), n2.d(t2, "Spline", function() {
        return Nc2;
      }), n2.d(t2, "AxisHelper", function() {
        return Ic2;
      }), n2.d(t2, "BoundingBoxHelper", function() {
        return Dc2;
      }), n2.d(t2, "EdgesHelper", function() {
        return Uc2;
      }), n2.d(t2, "WireframeHelper", function() {
        return Bc2;
      }), n2.d(t2, "XHRLoader", function() {
        return Fc2;
      }), n2.d(t2, "BinaryTextureLoader", function() {
        return Gc2;
      }), n2.d(t2, "GeometryUtils", function() {
        return zc2;
      }), n2.d(t2, "Projector", function() {
        return Hc2;
      }), n2.d(t2, "CanvasRenderer", function() {
        return kc2;
      }), n2.d(t2, "SceneUtils", function() {
        return jc2;
      }), n2.d(t2, "LensFlare", function() {
        return Vc2;
      }), void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(e3) {
        return "number" == typeof e3 && isFinite(e3) && Math.floor(e3) === e3;
      }), void 0 === Math.sign && (Math.sign = function(e3) {
        return e3 < 0 ? -1 : e3 > 0 ? 1 : +e3;
      }), "name" in Function.prototype == false && Object.defineProperty(Function.prototype, "name", { get: function() {
        return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
      } }), void 0 === Object.assign && (Object.assign = function(e3) {
        if (void 0 === e3 || null === e3)
          throw new TypeError("Cannot convert undefined or null to object");
        for (var t3 = Object(e3), n3 = 1; n3 < arguments.length; n3++) {
          var r3 = arguments[n3];
          if (void 0 !== r3 && null !== r3)
            for (var i3 in r3)
              Object.prototype.hasOwnProperty.call(r3, i3) && (t3[i3] = r3[i3]);
        }
        return t3;
      }), Object.assign(r2.prototype, { addEventListener: function(e3, t3) {
        void 0 === this._listeners && (this._listeners = {});
        var n3 = this._listeners;
        void 0 === n3[e3] && (n3[e3] = []), -1 === n3[e3].indexOf(t3) && n3[e3].push(t3);
      }, hasEventListener: function(e3, t3) {
        if (void 0 === this._listeners)
          return false;
        var n3 = this._listeners;
        return void 0 !== n3[e3] && -1 !== n3[e3].indexOf(t3);
      }, removeEventListener: function(e3, t3) {
        if (void 0 !== this._listeners) {
          var n3 = this._listeners[e3];
          if (void 0 !== n3) {
            var r3 = n3.indexOf(t3);
            -1 !== r3 && n3.splice(r3, 1);
          }
        }
      }, dispatchEvent: function(e3) {
        if (void 0 !== this._listeners) {
          var t3 = this._listeners[e3.type];
          if (void 0 !== t3) {
            e3.target = this;
            for (var n3 = t3.slice(0), r3 = 0, i3 = n3.length; r3 < i3; r3++)
              n3[r3].call(this, e3);
          }
        }
      } });
      var i2 = "95", a = { LEFT: 0, MIDDLE: 1, RIGHT: 2 }, o = 0, s = 1, c2 = 2, u2 = 3, l2 = 0, h2 = 1, d2 = 0, p2 = 1, f2 = 2, m2 = 0, g2 = 1, v2 = 2, y2 = 1, x2 = 2, b2 = 0, w2 = 1, _2 = 2, M2 = 0, E2 = 1, T2 = 2, S2 = 3, A2 = 4, L2 = 5, R2 = 100, C2 = 101, P2 = 102, O2 = 103, N2 = 104, I2 = 200, D2 = 201, U2 = 202, B2 = 203, F2 = 204, G2 = 205, z2 = 206, H2 = 207, k2 = 208, j = 209, V2 = 210, W2 = 0, X2 = 1, q2 = 2, Y2 = 3, Z2 = 4, J2 = 5, K2 = 6, Q2 = 7, $ = 0, ee2 = 1, te2 = 2, ne2 = 0, re2 = 1, ie2 = 2, ae2 = 3, oe2 = 4, se2 = 300, ce2 = 301, ue2 = 302, le2 = 303, he2 = 304, de2 = 305, pe2 = 306, fe2 = 307, me2 = 1e3, ge2 = 1001, ve2 = 1002, ye2 = 1003, xe2 = 1004, be2 = 1005, we2 = 1006, _e = 1007, Me2 = 1008, Ee2 = 1009, Te2 = 1010, Se2 = 1011, Ae2 = 1012, Le2 = 1013, Re2 = 1014, Ce2 = 1015, Pe2 = 1016, Oe2 = 1017, Ne2 = 1018, Ie2 = 1019, De2 = 1020, Ue2 = 1021, Be2 = 1022, Fe2 = 1023, Ge2 = 1024, ze2 = 1025, He2 = Fe2, ke2 = 1026, je2 = 1027, Ve2 = 33776, We2 = 33777, Xe2 = 33778, qe2 = 33779, Ye2 = 35840, Ze2 = 35841, Je2 = 35842, Ke2 = 35843, Qe2 = 36196, $e2 = 37808, et = 37809, tt = 37810, nt = 37811, rt = 37812, it = 37813, at = 37814, ot = 37815, st = 37816, ct = 37817, ut = 37818, lt = 37819, ht = 37820, dt = 37821, pt = 2200, ft = 2201, mt = 2202, gt = 2300, vt = 2301, yt = 2302, xt = 2400, bt = 2401, wt = 2402, _t5 = 0, Mt = 1, Et = 2, Tt = 3e3, St = 3001, At = 3007, Lt = 3002, Rt = 3003, Ct = 3004, Pt = 3005, Ot = 3006, Nt = 3200, It = 3201, Dt = 0, Ut = 1, Bt = { DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: function() {
        for (var e3 = [], t3 = 0; t3 < 256; t3++)
          e3[t3] = (t3 < 16 ? "0" : "") + t3.toString(16);
        return function() {
          var t4 = 4294967295 * Math.random() | 0, n3 = 4294967295 * Math.random() | 0, r3 = 4294967295 * Math.random() | 0, i3 = 4294967295 * Math.random() | 0;
          return (e3[255 & t4] + e3[t4 >> 8 & 255] + e3[t4 >> 16 & 255] + e3[t4 >> 24 & 255] + "-" + e3[255 & n3] + e3[n3 >> 8 & 255] + "-" + e3[n3 >> 16 & 15 | 64] + e3[n3 >> 24 & 255] + "-" + e3[63 & r3 | 128] + e3[r3 >> 8 & 255] + "-" + e3[r3 >> 16 & 255] + e3[r3 >> 24 & 255] + e3[255 & i3] + e3[i3 >> 8 & 255] + e3[i3 >> 16 & 255] + e3[i3 >> 24 & 255]).toUpperCase();
        };
      }(), clamp: function(e3, t3, n3) {
        return Math.max(t3, Math.min(n3, e3));
      }, euclideanModulo: function(e3, t3) {
        return (e3 % t3 + t3) % t3;
      }, mapLinear: function(e3, t3, n3, r3, i3) {
        return r3 + (e3 - t3) * (i3 - r3) / (n3 - t3);
      }, lerp: function(e3, t3, n3) {
        return (1 - n3) * e3 + n3 * t3;
      }, smoothstep: function(e3, t3, n3) {
        return e3 <= t3 ? 0 : e3 >= n3 ? 1 : (e3 = (e3 - t3) / (n3 - t3)) * e3 * (3 - 2 * e3);
      }, smootherstep: function(e3, t3, n3) {
        return e3 <= t3 ? 0 : e3 >= n3 ? 1 : (e3 = (e3 - t3) / (n3 - t3)) * e3 * e3 * (e3 * (6 * e3 - 15) + 10);
      }, randInt: function(e3, t3) {
        return e3 + Math.floor(Math.random() * (t3 - e3 + 1));
      }, randFloat: function(e3, t3) {
        return e3 + Math.random() * (t3 - e3);
      }, randFloatSpread: function(e3) {
        return e3 * (0.5 - Math.random());
      }, degToRad: function(e3) {
        return e3 * Bt.DEG2RAD;
      }, radToDeg: function(e3) {
        return e3 * Bt.RAD2DEG;
      }, isPowerOfTwo: function(e3) {
        return 0 == (e3 & e3 - 1) && 0 !== e3;
      }, ceilPowerOfTwo: function(e3) {
        return Math.pow(2, Math.ceil(Math.log(e3) / Math.LN2));
      }, floorPowerOfTwo: function(e3) {
        return Math.pow(2, Math.floor(Math.log(e3) / Math.LN2));
      } };
      function Ft(e3, t3) {
        this.x = e3 || 0, this.y = t3 || 0;
      }
      function Gt() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
      }
      function zt(e3, t3, n3, r3) {
        this._x = e3 || 0, this._y = t3 || 0, this._z = n3 || 0, this._w = void 0 !== r3 ? r3 : 1;
      }
      function Ht(e3, t3, n3) {
        this.x = e3 || 0, this.y = t3 || 0, this.z = n3 || 0;
      }
      function kt() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
      }
      Object.defineProperties(Ft.prototype, { width: { get: function() {
        return this.x;
      }, set: function(e3) {
        this.x = e3;
      } }, height: { get: function() {
        return this.y;
      }, set: function(e3) {
        this.y = e3;
      } } }), Object.assign(Ft.prototype, { isVector2: true, set: function(e3, t3) {
        return this.x = e3, this.y = t3, this;
      }, setScalar: function(e3) {
        return this.x = e3, this.y = e3, this;
      }, setX: function(e3) {
        return this.x = e3, this;
      }, setY: function(e3) {
        return this.y = e3, this;
      }, setComponent: function(e3, t3) {
        switch (e3) {
          case 0:
            this.x = t3;
            break;
          case 1:
            this.y = t3;
            break;
          default:
            throw new Error("index is out of range: " + e3);
        }
        return this;
      }, getComponent: function(e3) {
        switch (e3) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error("index is out of range: " + e3);
        }
      }, clone: function() {
        return new this.constructor(this.x, this.y);
      }, copy: function(e3) {
        return this.x = e3.x, this.y = e3.y, this;
      }, add: function(e3, t3) {
        return void 0 !== t3 ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e3, t3)) : (this.x += e3.x, this.y += e3.y, this);
      }, addScalar: function(e3) {
        return this.x += e3, this.y += e3, this;
      }, addVectors: function(e3, t3) {
        return this.x = e3.x + t3.x, this.y = e3.y + t3.y, this;
      }, addScaledVector: function(e3, t3) {
        return this.x += e3.x * t3, this.y += e3.y * t3, this;
      }, sub: function(e3, t3) {
        return void 0 !== t3 ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e3, t3)) : (this.x -= e3.x, this.y -= e3.y, this);
      }, subScalar: function(e3) {
        return this.x -= e3, this.y -= e3, this;
      }, subVectors: function(e3, t3) {
        return this.x = e3.x - t3.x, this.y = e3.y - t3.y, this;
      }, multiply: function(e3) {
        return this.x *= e3.x, this.y *= e3.y, this;
      }, multiplyScalar: function(e3) {
        return this.x *= e3, this.y *= e3, this;
      }, divide: function(e3) {
        return this.x /= e3.x, this.y /= e3.y, this;
      }, divideScalar: function(e3) {
        return this.multiplyScalar(1 / e3);
      }, applyMatrix3: function(e3) {
        var t3 = this.x, n3 = this.y, r3 = e3.elements;
        return this.x = r3[0] * t3 + r3[3] * n3 + r3[6], this.y = r3[1] * t3 + r3[4] * n3 + r3[7], this;
      }, min: function(e3) {
        return this.x = Math.min(this.x, e3.x), this.y = Math.min(this.y, e3.y), this;
      }, max: function(e3) {
        return this.x = Math.max(this.x, e3.x), this.y = Math.max(this.y, e3.y), this;
      }, clamp: function(e3, t3) {
        return this.x = Math.max(e3.x, Math.min(t3.x, this.x)), this.y = Math.max(e3.y, Math.min(t3.y, this.y)), this;
      }, clampScalar: function() {
        var e3 = new Ft(), t3 = new Ft();
        return function(n3, r3) {
          return e3.set(n3, n3), t3.set(r3, r3), this.clamp(e3, t3);
        };
      }(), clampLength: function(e3, t3) {
        var n3 = this.length();
        return this.divideScalar(n3 || 1).multiplyScalar(Math.max(e3, Math.min(t3, n3)));
      }, floor: function() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
      }, ceil: function() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
      }, round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      }, roundToZero: function() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
      }, negate: function() {
        return this.x = -this.x, this.y = -this.y, this;
      }, dot: function(e3) {
        return this.x * e3.x + this.y * e3.y;
      }, cross: function(e3) {
        return this.x * e3.y - this.y * e3.x;
      }, lengthSq: function() {
        return this.x * this.x + this.y * this.y;
      }, length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }, manhattanLength: function() {
        return Math.abs(this.x) + Math.abs(this.y);
      }, normalize: function() {
        return this.divideScalar(this.length() || 1);
      }, angle: function() {
        var e3 = Math.atan2(this.y, this.x);
        return e3 < 0 && (e3 += 2 * Math.PI), e3;
      }, distanceTo: function(e3) {
        return Math.sqrt(this.distanceToSquared(e3));
      }, distanceToSquared: function(e3) {
        var t3 = this.x - e3.x, n3 = this.y - e3.y;
        return t3 * t3 + n3 * n3;
      }, manhattanDistanceTo: function(e3) {
        return Math.abs(this.x - e3.x) + Math.abs(this.y - e3.y);
      }, setLength: function(e3) {
        return this.normalize().multiplyScalar(e3);
      }, lerp: function(e3, t3) {
        return this.x += (e3.x - this.x) * t3, this.y += (e3.y - this.y) * t3, this;
      }, lerpVectors: function(e3, t3, n3) {
        return this.subVectors(t3, e3).multiplyScalar(n3).add(e3);
      }, equals: function(e3) {
        return e3.x === this.x && e3.y === this.y;
      }, fromArray: function(e3, t3) {
        return void 0 === t3 && (t3 = 0), this.x = e3[t3], this.y = e3[t3 + 1], this;
      }, toArray: function(e3, t3) {
        return void 0 === e3 && (e3 = []), void 0 === t3 && (t3 = 0), e3[t3] = this.x, e3[t3 + 1] = this.y, e3;
      }, fromBufferAttribute: function(e3, t3, n3) {
        return void 0 !== n3 && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e3.getX(t3), this.y = e3.getY(t3), this;
      }, rotateAround: function(e3, t3) {
        var n3 = Math.cos(t3), r3 = Math.sin(t3), i3 = this.x - e3.x, a2 = this.y - e3.y;
        return this.x = i3 * n3 - a2 * r3 + e3.x, this.y = i3 * r3 + a2 * n3 + e3.y, this;
      } }), Object.assign(Gt.prototype, { isMatrix4: true, set: function(e3, t3, n3, r3, i3, a2, o2, s2, c3, u3, l3, h3, d3, p3, f3, m3) {
        var g3 = this.elements;
        return g3[0] = e3, g3[4] = t3, g3[8] = n3, g3[12] = r3, g3[1] = i3, g3[5] = a2, g3[9] = o2, g3[13] = s2, g3[2] = c3, g3[6] = u3, g3[10] = l3, g3[14] = h3, g3[3] = d3, g3[7] = p3, g3[11] = f3, g3[15] = m3, this;
      }, identity: function() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      }, clone: function() {
        return new Gt().fromArray(this.elements);
      }, copy: function(e3) {
        var t3 = this.elements, n3 = e3.elements;
        return t3[0] = n3[0], t3[1] = n3[1], t3[2] = n3[2], t3[3] = n3[3], t3[4] = n3[4], t3[5] = n3[5], t3[6] = n3[6], t3[7] = n3[7], t3[8] = n3[8], t3[9] = n3[9], t3[10] = n3[10], t3[11] = n3[11], t3[12] = n3[12], t3[13] = n3[13], t3[14] = n3[14], t3[15] = n3[15], this;
      }, copyPosition: function(e3) {
        var t3 = this.elements, n3 = e3.elements;
        return t3[12] = n3[12], t3[13] = n3[13], t3[14] = n3[14], this;
      }, extractBasis: function(e3, t3, n3) {
        return e3.setFromMatrixColumn(this, 0), t3.setFromMatrixColumn(this, 1), n3.setFromMatrixColumn(this, 2), this;
      }, makeBasis: function(e3, t3, n3) {
        return this.set(e3.x, t3.x, n3.x, 0, e3.y, t3.y, n3.y, 0, e3.z, t3.z, n3.z, 0, 0, 0, 0, 1), this;
      }, extractRotation: function() {
        var e3 = new Ht();
        return function(t3) {
          var n3 = this.elements, r3 = t3.elements, i3 = 1 / e3.setFromMatrixColumn(t3, 0).length(), a2 = 1 / e3.setFromMatrixColumn(t3, 1).length(), o2 = 1 / e3.setFromMatrixColumn(t3, 2).length();
          return n3[0] = r3[0] * i3, n3[1] = r3[1] * i3, n3[2] = r3[2] * i3, n3[3] = 0, n3[4] = r3[4] * a2, n3[5] = r3[5] * a2, n3[6] = r3[6] * a2, n3[7] = 0, n3[8] = r3[8] * o2, n3[9] = r3[9] * o2, n3[10] = r3[10] * o2, n3[11] = 0, n3[12] = 0, n3[13] = 0, n3[14] = 0, n3[15] = 1, this;
        };
      }(), makeRotationFromEuler: function(e3) {
        e3 && e3.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        var t3 = this.elements, n3 = e3.x, r3 = e3.y, i3 = e3.z, a2 = Math.cos(n3), o2 = Math.sin(n3), s2 = Math.cos(r3), c3 = Math.sin(r3), u3 = Math.cos(i3), l3 = Math.sin(i3);
        if ("XYZ" === e3.order) {
          var h3 = a2 * u3, d3 = a2 * l3, p3 = o2 * u3, f3 = o2 * l3;
          t3[0] = s2 * u3, t3[4] = -s2 * l3, t3[8] = c3, t3[1] = d3 + p3 * c3, t3[5] = h3 - f3 * c3, t3[9] = -o2 * s2, t3[2] = f3 - h3 * c3, t3[6] = p3 + d3 * c3, t3[10] = a2 * s2;
        } else if ("YXZ" === e3.order) {
          var m3 = s2 * u3, g3 = s2 * l3, v3 = c3 * u3, y3 = c3 * l3;
          t3[0] = m3 + y3 * o2, t3[4] = v3 * o2 - g3, t3[8] = a2 * c3, t3[1] = a2 * l3, t3[5] = a2 * u3, t3[9] = -o2, t3[2] = g3 * o2 - v3, t3[6] = y3 + m3 * o2, t3[10] = a2 * s2;
        } else if ("ZXY" === e3.order) {
          m3 = s2 * u3, g3 = s2 * l3, v3 = c3 * u3, y3 = c3 * l3;
          t3[0] = m3 - y3 * o2, t3[4] = -a2 * l3, t3[8] = v3 + g3 * o2, t3[1] = g3 + v3 * o2, t3[5] = a2 * u3, t3[9] = y3 - m3 * o2, t3[2] = -a2 * c3, t3[6] = o2, t3[10] = a2 * s2;
        } else if ("ZYX" === e3.order) {
          h3 = a2 * u3, d3 = a2 * l3, p3 = o2 * u3, f3 = o2 * l3;
          t3[0] = s2 * u3, t3[4] = p3 * c3 - d3, t3[8] = h3 * c3 + f3, t3[1] = s2 * l3, t3[5] = f3 * c3 + h3, t3[9] = d3 * c3 - p3, t3[2] = -c3, t3[6] = o2 * s2, t3[10] = a2 * s2;
        } else if ("YZX" === e3.order) {
          var x3 = a2 * s2, b3 = a2 * c3, w3 = o2 * s2, _3 = o2 * c3;
          t3[0] = s2 * u3, t3[4] = _3 - x3 * l3, t3[8] = w3 * l3 + b3, t3[1] = l3, t3[5] = a2 * u3, t3[9] = -o2 * u3, t3[2] = -c3 * u3, t3[6] = b3 * l3 + w3, t3[10] = x3 - _3 * l3;
        } else if ("XZY" === e3.order) {
          x3 = a2 * s2, b3 = a2 * c3, w3 = o2 * s2, _3 = o2 * c3;
          t3[0] = s2 * u3, t3[4] = -l3, t3[8] = c3 * u3, t3[1] = x3 * l3 + _3, t3[5] = a2 * u3, t3[9] = b3 * l3 - w3, t3[2] = w3 * l3 - b3, t3[6] = o2 * u3, t3[10] = _3 * l3 + x3;
        }
        return t3[3] = 0, t3[7] = 0, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, this;
      }, makeRotationFromQuaternion: function() {
        var e3 = new Ht(0, 0, 0), t3 = new Ht(1, 1, 1);
        return function(n3) {
          return this.compose(e3, n3, t3);
        };
      }(), lookAt: function() {
        var e3 = new Ht(), t3 = new Ht(), n3 = new Ht();
        return function(r3, i3, a2) {
          var o2 = this.elements;
          return n3.subVectors(r3, i3), 0 === n3.lengthSq() && (n3.z = 1), n3.normalize(), e3.crossVectors(a2, n3), 0 === e3.lengthSq() && (1 === Math.abs(a2.z) ? n3.x += 1e-4 : n3.z += 1e-4, n3.normalize(), e3.crossVectors(a2, n3)), e3.normalize(), t3.crossVectors(n3, e3), o2[0] = e3.x, o2[4] = t3.x, o2[8] = n3.x, o2[1] = e3.y, o2[5] = t3.y, o2[9] = n3.y, o2[2] = e3.z, o2[6] = t3.z, o2[10] = n3.z, this;
        };
      }(), multiply: function(e3, t3) {
        return void 0 !== t3 ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e3, t3)) : this.multiplyMatrices(this, e3);
      }, premultiply: function(e3) {
        return this.multiplyMatrices(e3, this);
      }, multiplyMatrices: function(e3, t3) {
        var n3 = e3.elements, r3 = t3.elements, i3 = this.elements, a2 = n3[0], o2 = n3[4], s2 = n3[8], c3 = n3[12], u3 = n3[1], l3 = n3[5], h3 = n3[9], d3 = n3[13], p3 = n3[2], f3 = n3[6], m3 = n3[10], g3 = n3[14], v3 = n3[3], y3 = n3[7], x3 = n3[11], b3 = n3[15], w3 = r3[0], _3 = r3[4], M3 = r3[8], E3 = r3[12], T3 = r3[1], S3 = r3[5], A3 = r3[9], L3 = r3[13], R3 = r3[2], C3 = r3[6], P3 = r3[10], O3 = r3[14], N3 = r3[3], I3 = r3[7], D3 = r3[11], U3 = r3[15];
        return i3[0] = a2 * w3 + o2 * T3 + s2 * R3 + c3 * N3, i3[4] = a2 * _3 + o2 * S3 + s2 * C3 + c3 * I3, i3[8] = a2 * M3 + o2 * A3 + s2 * P3 + c3 * D3, i3[12] = a2 * E3 + o2 * L3 + s2 * O3 + c3 * U3, i3[1] = u3 * w3 + l3 * T3 + h3 * R3 + d3 * N3, i3[5] = u3 * _3 + l3 * S3 + h3 * C3 + d3 * I3, i3[9] = u3 * M3 + l3 * A3 + h3 * P3 + d3 * D3, i3[13] = u3 * E3 + l3 * L3 + h3 * O3 + d3 * U3, i3[2] = p3 * w3 + f3 * T3 + m3 * R3 + g3 * N3, i3[6] = p3 * _3 + f3 * S3 + m3 * C3 + g3 * I3, i3[10] = p3 * M3 + f3 * A3 + m3 * P3 + g3 * D3, i3[14] = p3 * E3 + f3 * L3 + m3 * O3 + g3 * U3, i3[3] = v3 * w3 + y3 * T3 + x3 * R3 + b3 * N3, i3[7] = v3 * _3 + y3 * S3 + x3 * C3 + b3 * I3, i3[11] = v3 * M3 + y3 * A3 + x3 * P3 + b3 * D3, i3[15] = v3 * E3 + y3 * L3 + x3 * O3 + b3 * U3, this;
      }, multiplyScalar: function(e3) {
        var t3 = this.elements;
        return t3[0] *= e3, t3[4] *= e3, t3[8] *= e3, t3[12] *= e3, t3[1] *= e3, t3[5] *= e3, t3[9] *= e3, t3[13] *= e3, t3[2] *= e3, t3[6] *= e3, t3[10] *= e3, t3[14] *= e3, t3[3] *= e3, t3[7] *= e3, t3[11] *= e3, t3[15] *= e3, this;
      }, applyToBufferAttribute: function() {
        var e3 = new Ht();
        return function(t3) {
          for (var n3 = 0, r3 = t3.count; n3 < r3; n3++)
            e3.x = t3.getX(n3), e3.y = t3.getY(n3), e3.z = t3.getZ(n3), e3.applyMatrix4(this), t3.setXYZ(n3, e3.x, e3.y, e3.z);
          return t3;
        };
      }(), determinant: function() {
        var e3 = this.elements, t3 = e3[0], n3 = e3[4], r3 = e3[8], i3 = e3[12], a2 = e3[1], o2 = e3[5], s2 = e3[9], c3 = e3[13], u3 = e3[2], l3 = e3[6], h3 = e3[10], d3 = e3[14];
        return e3[3] * (+i3 * s2 * l3 - r3 * c3 * l3 - i3 * o2 * h3 + n3 * c3 * h3 + r3 * o2 * d3 - n3 * s2 * d3) + e3[7] * (+t3 * s2 * d3 - t3 * c3 * h3 + i3 * a2 * h3 - r3 * a2 * d3 + r3 * c3 * u3 - i3 * s2 * u3) + e3[11] * (+t3 * c3 * l3 - t3 * o2 * d3 - i3 * a2 * l3 + n3 * a2 * d3 + i3 * o2 * u3 - n3 * c3 * u3) + e3[15] * (-r3 * o2 * u3 - t3 * s2 * l3 + t3 * o2 * h3 + r3 * a2 * l3 - n3 * a2 * h3 + n3 * s2 * u3);
      }, transpose: function() {
        var e3, t3 = this.elements;
        return e3 = t3[1], t3[1] = t3[4], t3[4] = e3, e3 = t3[2], t3[2] = t3[8], t3[8] = e3, e3 = t3[6], t3[6] = t3[9], t3[9] = e3, e3 = t3[3], t3[3] = t3[12], t3[12] = e3, e3 = t3[7], t3[7] = t3[13], t3[13] = e3, e3 = t3[11], t3[11] = t3[14], t3[14] = e3, this;
      }, setPosition: function(e3) {
        var t3 = this.elements;
        return t3[12] = e3.x, t3[13] = e3.y, t3[14] = e3.z, this;
      }, getInverse: function(e3, t3) {
        var n3 = this.elements, r3 = e3.elements, i3 = r3[0], a2 = r3[1], o2 = r3[2], s2 = r3[3], c3 = r3[4], u3 = r3[5], l3 = r3[6], h3 = r3[7], d3 = r3[8], p3 = r3[9], f3 = r3[10], m3 = r3[11], g3 = r3[12], v3 = r3[13], y3 = r3[14], x3 = r3[15], b3 = p3 * y3 * h3 - v3 * f3 * h3 + v3 * l3 * m3 - u3 * y3 * m3 - p3 * l3 * x3 + u3 * f3 * x3, w3 = g3 * f3 * h3 - d3 * y3 * h3 - g3 * l3 * m3 + c3 * y3 * m3 + d3 * l3 * x3 - c3 * f3 * x3, _3 = d3 * v3 * h3 - g3 * p3 * h3 + g3 * u3 * m3 - c3 * v3 * m3 - d3 * u3 * x3 + c3 * p3 * x3, M3 = g3 * p3 * l3 - d3 * v3 * l3 - g3 * u3 * f3 + c3 * v3 * f3 + d3 * u3 * y3 - c3 * p3 * y3, E3 = i3 * b3 + a2 * w3 + o2 * _3 + s2 * M3;
        if (0 === E3) {
          var T3 = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
          if (true === t3)
            throw new Error(T3);
          return console.warn(T3), this.identity();
        }
        var S3 = 1 / E3;
        return n3[0] = b3 * S3, n3[1] = (v3 * f3 * s2 - p3 * y3 * s2 - v3 * o2 * m3 + a2 * y3 * m3 + p3 * o2 * x3 - a2 * f3 * x3) * S3, n3[2] = (u3 * y3 * s2 - v3 * l3 * s2 + v3 * o2 * h3 - a2 * y3 * h3 - u3 * o2 * x3 + a2 * l3 * x3) * S3, n3[3] = (p3 * l3 * s2 - u3 * f3 * s2 - p3 * o2 * h3 + a2 * f3 * h3 + u3 * o2 * m3 - a2 * l3 * m3) * S3, n3[4] = w3 * S3, n3[5] = (d3 * y3 * s2 - g3 * f3 * s2 + g3 * o2 * m3 - i3 * y3 * m3 - d3 * o2 * x3 + i3 * f3 * x3) * S3, n3[6] = (g3 * l3 * s2 - c3 * y3 * s2 - g3 * o2 * h3 + i3 * y3 * h3 + c3 * o2 * x3 - i3 * l3 * x3) * S3, n3[7] = (c3 * f3 * s2 - d3 * l3 * s2 + d3 * o2 * h3 - i3 * f3 * h3 - c3 * o2 * m3 + i3 * l3 * m3) * S3, n3[8] = _3 * S3, n3[9] = (g3 * p3 * s2 - d3 * v3 * s2 - g3 * a2 * m3 + i3 * v3 * m3 + d3 * a2 * x3 - i3 * p3 * x3) * S3, n3[10] = (c3 * v3 * s2 - g3 * u3 * s2 + g3 * a2 * h3 - i3 * v3 * h3 - c3 * a2 * x3 + i3 * u3 * x3) * S3, n3[11] = (d3 * u3 * s2 - c3 * p3 * s2 - d3 * a2 * h3 + i3 * p3 * h3 + c3 * a2 * m3 - i3 * u3 * m3) * S3, n3[12] = M3 * S3, n3[13] = (d3 * v3 * o2 - g3 * p3 * o2 + g3 * a2 * f3 - i3 * v3 * f3 - d3 * a2 * y3 + i3 * p3 * y3) * S3, n3[14] = (g3 * u3 * o2 - c3 * v3 * o2 - g3 * a2 * l3 + i3 * v3 * l3 + c3 * a2 * y3 - i3 * u3 * y3) * S3, n3[15] = (c3 * p3 * o2 - d3 * u3 * o2 + d3 * a2 * l3 - i3 * p3 * l3 - c3 * a2 * f3 + i3 * u3 * f3) * S3, this;
      }, scale: function(e3) {
        var t3 = this.elements, n3 = e3.x, r3 = e3.y, i3 = e3.z;
        return t3[0] *= n3, t3[4] *= r3, t3[8] *= i3, t3[1] *= n3, t3[5] *= r3, t3[9] *= i3, t3[2] *= n3, t3[6] *= r3, t3[10] *= i3, t3[3] *= n3, t3[7] *= r3, t3[11] *= i3, this;
      }, getMaxScaleOnAxis: function() {
        var e3 = this.elements, t3 = e3[0] * e3[0] + e3[1] * e3[1] + e3[2] * e3[2], n3 = e3[4] * e3[4] + e3[5] * e3[5] + e3[6] * e3[6], r3 = e3[8] * e3[8] + e3[9] * e3[9] + e3[10] * e3[10];
        return Math.sqrt(Math.max(t3, n3, r3));
      }, makeTranslation: function(e3, t3, n3) {
        return this.set(1, 0, 0, e3, 0, 1, 0, t3, 0, 0, 1, n3, 0, 0, 0, 1), this;
      }, makeRotationX: function(e3) {
        var t3 = Math.cos(e3), n3 = Math.sin(e3);
        return this.set(1, 0, 0, 0, 0, t3, -n3, 0, 0, n3, t3, 0, 0, 0, 0, 1), this;
      }, makeRotationY: function(e3) {
        var t3 = Math.cos(e3), n3 = Math.sin(e3);
        return this.set(t3, 0, n3, 0, 0, 1, 0, 0, -n3, 0, t3, 0, 0, 0, 0, 1), this;
      }, makeRotationZ: function(e3) {
        var t3 = Math.cos(e3), n3 = Math.sin(e3);
        return this.set(t3, -n3, 0, 0, n3, t3, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      }, makeRotationAxis: function(e3, t3) {
        var n3 = Math.cos(t3), r3 = Math.sin(t3), i3 = 1 - n3, a2 = e3.x, o2 = e3.y, s2 = e3.z, c3 = i3 * a2, u3 = i3 * o2;
        return this.set(c3 * a2 + n3, c3 * o2 - r3 * s2, c3 * s2 + r3 * o2, 0, c3 * o2 + r3 * s2, u3 * o2 + n3, u3 * s2 - r3 * a2, 0, c3 * s2 - r3 * o2, u3 * s2 + r3 * a2, i3 * s2 * s2 + n3, 0, 0, 0, 0, 1), this;
      }, makeScale: function(e3, t3, n3) {
        return this.set(e3, 0, 0, 0, 0, t3, 0, 0, 0, 0, n3, 0, 0, 0, 0, 1), this;
      }, makeShear: function(e3, t3, n3) {
        return this.set(1, t3, n3, 0, e3, 1, n3, 0, e3, t3, 1, 0, 0, 0, 0, 1), this;
      }, compose: function(e3, t3, n3) {
        var r3 = this.elements, i3 = t3._x, a2 = t3._y, o2 = t3._z, s2 = t3._w, c3 = i3 + i3, u3 = a2 + a2, l3 = o2 + o2, h3 = i3 * c3, d3 = i3 * u3, p3 = i3 * l3, f3 = a2 * u3, m3 = a2 * l3, g3 = o2 * l3, v3 = s2 * c3, y3 = s2 * u3, x3 = s2 * l3, b3 = n3.x, w3 = n3.y, _3 = n3.z;
        return r3[0] = (1 - (f3 + g3)) * b3, r3[1] = (d3 + x3) * b3, r3[2] = (p3 - y3) * b3, r3[3] = 0, r3[4] = (d3 - x3) * w3, r3[5] = (1 - (h3 + g3)) * w3, r3[6] = (m3 + v3) * w3, r3[7] = 0, r3[8] = (p3 + y3) * _3, r3[9] = (m3 - v3) * _3, r3[10] = (1 - (h3 + f3)) * _3, r3[11] = 0, r3[12] = e3.x, r3[13] = e3.y, r3[14] = e3.z, r3[15] = 1, this;
      }, decompose: function() {
        var e3 = new Ht(), t3 = new Gt();
        return function(n3, r3, i3) {
          var a2 = this.elements, o2 = e3.set(a2[0], a2[1], a2[2]).length(), s2 = e3.set(a2[4], a2[5], a2[6]).length(), c3 = e3.set(a2[8], a2[9], a2[10]).length();
          this.determinant() < 0 && (o2 = -o2), n3.x = a2[12], n3.y = a2[13], n3.z = a2[14], t3.copy(this);
          var u3 = 1 / o2, l3 = 1 / s2, h3 = 1 / c3;
          return t3.elements[0] *= u3, t3.elements[1] *= u3, t3.elements[2] *= u3, t3.elements[4] *= l3, t3.elements[5] *= l3, t3.elements[6] *= l3, t3.elements[8] *= h3, t3.elements[9] *= h3, t3.elements[10] *= h3, r3.setFromRotationMatrix(t3), i3.x = o2, i3.y = s2, i3.z = c3, this;
        };
      }(), makePerspective: function(e3, t3, n3, r3, i3, a2) {
        void 0 === a2 && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
        var o2 = this.elements, s2 = 2 * i3 / (t3 - e3), c3 = 2 * i3 / (n3 - r3), u3 = (t3 + e3) / (t3 - e3), l3 = (n3 + r3) / (n3 - r3), h3 = -(a2 + i3) / (a2 - i3), d3 = -2 * a2 * i3 / (a2 - i3);
        return o2[0] = s2, o2[4] = 0, o2[8] = u3, o2[12] = 0, o2[1] = 0, o2[5] = c3, o2[9] = l3, o2[13] = 0, o2[2] = 0, o2[6] = 0, o2[10] = h3, o2[14] = d3, o2[3] = 0, o2[7] = 0, o2[11] = -1, o2[15] = 0, this;
      }, makeOrthographic: function(e3, t3, n3, r3, i3, a2) {
        var o2 = this.elements, s2 = 1 / (t3 - e3), c3 = 1 / (n3 - r3), u3 = 1 / (a2 - i3), l3 = (t3 + e3) * s2, h3 = (n3 + r3) * c3, d3 = (a2 + i3) * u3;
        return o2[0] = 2 * s2, o2[4] = 0, o2[8] = 0, o2[12] = -l3, o2[1] = 0, o2[5] = 2 * c3, o2[9] = 0, o2[13] = -h3, o2[2] = 0, o2[6] = 0, o2[10] = -2 * u3, o2[14] = -d3, o2[3] = 0, o2[7] = 0, o2[11] = 0, o2[15] = 1, this;
      }, equals: function(e3) {
        for (var t3 = this.elements, n3 = e3.elements, r3 = 0; r3 < 16; r3++)
          if (t3[r3] !== n3[r3])
            return false;
        return true;
      }, fromArray: function(e3, t3) {
        void 0 === t3 && (t3 = 0);
        for (var n3 = 0; n3 < 16; n3++)
          this.elements[n3] = e3[n3 + t3];
        return this;
      }, toArray: function(e3, t3) {
        void 0 === e3 && (e3 = []), void 0 === t3 && (t3 = 0);
        var n3 = this.elements;
        return e3[t3] = n3[0], e3[t3 + 1] = n3[1], e3[t3 + 2] = n3[2], e3[t3 + 3] = n3[3], e3[t3 + 4] = n3[4], e3[t3 + 5] = n3[5], e3[t3 + 6] = n3[6], e3[t3 + 7] = n3[7], e3[t3 + 8] = n3[8], e3[t3 + 9] = n3[9], e3[t3 + 10] = n3[10], e3[t3 + 11] = n3[11], e3[t3 + 12] = n3[12], e3[t3 + 13] = n3[13], e3[t3 + 14] = n3[14], e3[t3 + 15] = n3[15], e3;
      } }), Object.assign(zt, { slerp: function(e3, t3, n3, r3) {
        return n3.copy(e3).slerp(t3, r3);
      }, slerpFlat: function(e3, t3, n3, r3, i3, a2, o2) {
        var s2 = n3[r3 + 0], c3 = n3[r3 + 1], u3 = n3[r3 + 2], l3 = n3[r3 + 3], h3 = i3[a2 + 0], d3 = i3[a2 + 1], p3 = i3[a2 + 2], f3 = i3[a2 + 3];
        if (l3 !== f3 || s2 !== h3 || c3 !== d3 || u3 !== p3) {
          var m3 = 1 - o2, g3 = s2 * h3 + c3 * d3 + u3 * p3 + l3 * f3, v3 = g3 >= 0 ? 1 : -1, y3 = 1 - g3 * g3;
          if (y3 > Number.EPSILON) {
            var x3 = Math.sqrt(y3), b3 = Math.atan2(x3, g3 * v3);
            m3 = Math.sin(m3 * b3) / x3, o2 = Math.sin(o2 * b3) / x3;
          }
          var w3 = o2 * v3;
          if (s2 = s2 * m3 + h3 * w3, c3 = c3 * m3 + d3 * w3, u3 = u3 * m3 + p3 * w3, l3 = l3 * m3 + f3 * w3, m3 === 1 - o2) {
            var _3 = 1 / Math.sqrt(s2 * s2 + c3 * c3 + u3 * u3 + l3 * l3);
            s2 *= _3, c3 *= _3, u3 *= _3, l3 *= _3;
          }
        }
        e3[t3] = s2, e3[t3 + 1] = c3, e3[t3 + 2] = u3, e3[t3 + 3] = l3;
      } }), Object.defineProperties(zt.prototype, { x: { get: function() {
        return this._x;
      }, set: function(e3) {
        this._x = e3, this.onChangeCallback();
      } }, y: { get: function() {
        return this._y;
      }, set: function(e3) {
        this._y = e3, this.onChangeCallback();
      } }, z: { get: function() {
        return this._z;
      }, set: function(e3) {
        this._z = e3, this.onChangeCallback();
      } }, w: { get: function() {
        return this._w;
      }, set: function(e3) {
        this._w = e3, this.onChangeCallback();
      } } }), Object.assign(zt.prototype, { set: function(e3, t3, n3, r3) {
        return this._x = e3, this._y = t3, this._z = n3, this._w = r3, this.onChangeCallback(), this;
      }, clone: function() {
        return new this.constructor(this._x, this._y, this._z, this._w);
      }, copy: function(e3) {
        return this._x = e3.x, this._y = e3.y, this._z = e3.z, this._w = e3.w, this.onChangeCallback(), this;
      }, setFromEuler: function(e3, t3) {
        if (!e3 || !e3.isEuler)
          throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
        var n3 = e3._x, r3 = e3._y, i3 = e3._z, a2 = e3.order, o2 = Math.cos, s2 = Math.sin, c3 = o2(n3 / 2), u3 = o2(r3 / 2), l3 = o2(i3 / 2), h3 = s2(n3 / 2), d3 = s2(r3 / 2), p3 = s2(i3 / 2);
        return "XYZ" === a2 ? (this._x = h3 * u3 * l3 + c3 * d3 * p3, this._y = c3 * d3 * l3 - h3 * u3 * p3, this._z = c3 * u3 * p3 + h3 * d3 * l3, this._w = c3 * u3 * l3 - h3 * d3 * p3) : "YXZ" === a2 ? (this._x = h3 * u3 * l3 + c3 * d3 * p3, this._y = c3 * d3 * l3 - h3 * u3 * p3, this._z = c3 * u3 * p3 - h3 * d3 * l3, this._w = c3 * u3 * l3 + h3 * d3 * p3) : "ZXY" === a2 ? (this._x = h3 * u3 * l3 - c3 * d3 * p3, this._y = c3 * d3 * l3 + h3 * u3 * p3, this._z = c3 * u3 * p3 + h3 * d3 * l3, this._w = c3 * u3 * l3 - h3 * d3 * p3) : "ZYX" === a2 ? (this._x = h3 * u3 * l3 - c3 * d3 * p3, this._y = c3 * d3 * l3 + h3 * u3 * p3, this._z = c3 * u3 * p3 - h3 * d3 * l3, this._w = c3 * u3 * l3 + h3 * d3 * p3) : "YZX" === a2 ? (this._x = h3 * u3 * l3 + c3 * d3 * p3, this._y = c3 * d3 * l3 + h3 * u3 * p3, this._z = c3 * u3 * p3 - h3 * d3 * l3, this._w = c3 * u3 * l3 - h3 * d3 * p3) : "XZY" === a2 && (this._x = h3 * u3 * l3 - c3 * d3 * p3, this._y = c3 * d3 * l3 - h3 * u3 * p3, this._z = c3 * u3 * p3 + h3 * d3 * l3, this._w = c3 * u3 * l3 + h3 * d3 * p3), false !== t3 && this.onChangeCallback(), this;
      }, setFromAxisAngle: function(e3, t3) {
        var n3 = t3 / 2, r3 = Math.sin(n3);
        return this._x = e3.x * r3, this._y = e3.y * r3, this._z = e3.z * r3, this._w = Math.cos(n3), this.onChangeCallback(), this;
      }, setFromRotationMatrix: function(e3) {
        var t3, n3 = e3.elements, r3 = n3[0], i3 = n3[4], a2 = n3[8], o2 = n3[1], s2 = n3[5], c3 = n3[9], u3 = n3[2], l3 = n3[6], h3 = n3[10], d3 = r3 + s2 + h3;
        return d3 > 0 ? (t3 = 0.5 / Math.sqrt(d3 + 1), this._w = 0.25 / t3, this._x = (l3 - c3) * t3, this._y = (a2 - u3) * t3, this._z = (o2 - i3) * t3) : r3 > s2 && r3 > h3 ? (t3 = 2 * Math.sqrt(1 + r3 - s2 - h3), this._w = (l3 - c3) / t3, this._x = 0.25 * t3, this._y = (i3 + o2) / t3, this._z = (a2 + u3) / t3) : s2 > h3 ? (t3 = 2 * Math.sqrt(1 + s2 - r3 - h3), this._w = (a2 - u3) / t3, this._x = (i3 + o2) / t3, this._y = 0.25 * t3, this._z = (c3 + l3) / t3) : (t3 = 2 * Math.sqrt(1 + h3 - r3 - s2), this._w = (o2 - i3) / t3, this._x = (a2 + u3) / t3, this._y = (c3 + l3) / t3, this._z = 0.25 * t3), this.onChangeCallback(), this;
      }, setFromUnitVectors: function() {
        var e3, t3 = new Ht();
        return function(n3, r3) {
          return void 0 === t3 && (t3 = new Ht()), (e3 = n3.dot(r3) + 1) < 1e-6 ? (e3 = 0, Math.abs(n3.x) > Math.abs(n3.z) ? t3.set(-n3.y, n3.x, 0) : t3.set(0, -n3.z, n3.y)) : t3.crossVectors(n3, r3), this._x = t3.x, this._y = t3.y, this._z = t3.z, this._w = e3, this.normalize();
        };
      }(), angleTo: function(e3) {
        return 2 * Math.acos(Math.abs(Bt.clamp(this.dot(e3), -1, 1)));
      }, rotateTowards: function(e3, t3) {
        var n3 = this.angleTo(e3);
        if (0 === n3)
          return this;
        var r3 = Math.min(1, t3 / n3);
        return this.slerp(e3, r3), this;
      }, inverse: function() {
        return this.conjugate();
      }, conjugate: function() {
        return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this;
      }, dot: function(e3) {
        return this._x * e3._x + this._y * e3._y + this._z * e3._z + this._w * e3._w;
      }, lengthSq: function() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
      }, length: function() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
      }, normalize: function() {
        var e3 = this.length();
        return 0 === e3 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e3 = 1 / e3, this._x = this._x * e3, this._y = this._y * e3, this._z = this._z * e3, this._w = this._w * e3), this.onChangeCallback(), this;
      }, multiply: function(e3, t3) {
        return void 0 !== t3 ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e3, t3)) : this.multiplyQuaternions(this, e3);
      }, premultiply: function(e3) {
        return this.multiplyQuaternions(e3, this);
      }, multiplyQuaternions: function(e3, t3) {
        var n3 = e3._x, r3 = e3._y, i3 = e3._z, a2 = e3._w, o2 = t3._x, s2 = t3._y, c3 = t3._z, u3 = t3._w;
        return this._x = n3 * u3 + a2 * o2 + r3 * c3 - i3 * s2, this._y = r3 * u3 + a2 * s2 + i3 * o2 - n3 * c3, this._z = i3 * u3 + a2 * c3 + n3 * s2 - r3 * o2, this._w = a2 * u3 - n3 * o2 - r3 * s2 - i3 * c3, this.onChangeCallback(), this;
      }, slerp: function(e3, t3) {
        if (0 === t3)
          return this;
        if (1 === t3)
          return this.copy(e3);
        var n3 = this._x, r3 = this._y, i3 = this._z, a2 = this._w, o2 = a2 * e3._w + n3 * e3._x + r3 * e3._y + i3 * e3._z;
        if (o2 < 0 ? (this._w = -e3._w, this._x = -e3._x, this._y = -e3._y, this._z = -e3._z, o2 = -o2) : this.copy(e3), o2 >= 1)
          return this._w = a2, this._x = n3, this._y = r3, this._z = i3, this;
        var s2 = 1 - o2 * o2;
        if (s2 <= Number.EPSILON) {
          var c3 = 1 - t3;
          return this._w = c3 * a2 + t3 * this._w, this._x = c3 * n3 + t3 * this._x, this._y = c3 * r3 + t3 * this._y, this._z = c3 * i3 + t3 * this._z, this.normalize();
        }
        var u3 = Math.sqrt(s2), l3 = Math.atan2(u3, o2), h3 = Math.sin((1 - t3) * l3) / u3, d3 = Math.sin(t3 * l3) / u3;
        return this._w = a2 * h3 + this._w * d3, this._x = n3 * h3 + this._x * d3, this._y = r3 * h3 + this._y * d3, this._z = i3 * h3 + this._z * d3, this.onChangeCallback(), this;
      }, equals: function(e3) {
        return e3._x === this._x && e3._y === this._y && e3._z === this._z && e3._w === this._w;
      }, fromArray: function(e3, t3) {
        return void 0 === t3 && (t3 = 0), this._x = e3[t3], this._y = e3[t3 + 1], this._z = e3[t3 + 2], this._w = e3[t3 + 3], this.onChangeCallback(), this;
      }, toArray: function(e3, t3) {
        return void 0 === e3 && (e3 = []), void 0 === t3 && (t3 = 0), e3[t3] = this._x, e3[t3 + 1] = this._y, e3[t3 + 2] = this._z, e3[t3 + 3] = this._w, e3;
      }, onChange: function(e3) {
        return this.onChangeCallback = e3, this;
      }, onChangeCallback: function() {
      } }), Object.assign(Ht.prototype, { isVector3: true, set: function(e3, t3, n3) {
        return this.x = e3, this.y = t3, this.z = n3, this;
      }, setScalar: function(e3) {
        return this.x = e3, this.y = e3, this.z = e3, this;
      }, setX: function(e3) {
        return this.x = e3, this;
      }, setY: function(e3) {
        return this.y = e3, this;
      }, setZ: function(e3) {
        return this.z = e3, this;
      }, setComponent: function(e3, t3) {
        switch (e3) {
          case 0:
            this.x = t3;
            break;
          case 1:
            this.y = t3;
            break;
          case 2:
            this.z = t3;
            break;
          default:
            throw new Error("index is out of range: " + e3);
        }
        return this;
      }, getComponent: function(e3) {
        switch (e3) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            throw new Error("index is out of range: " + e3);
        }
      }, clone: function() {
        return new this.constructor(this.x, this.y, this.z);
      }, copy: function(e3) {
        return this.x = e3.x, this.y = e3.y, this.z = e3.z, this;
      }, add: function(e3, t3) {
        return void 0 !== t3 ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e3, t3)) : (this.x += e3.x, this.y += e3.y, this.z += e3.z, this);
      }, addScalar: function(e3) {
        return this.x += e3, this.y += e3, this.z += e3, this;
      }, addVectors: function(e3, t3) {
        return this.x = e3.x + t3.x, this.y = e3.y + t3.y, this.z = e3.z + t3.z, this;
      }, addScaledVector: function(e3, t3) {
        return this.x += e3.x * t3, this.y += e3.y * t3, this.z += e3.z * t3, this;
      }, sub: function(e3, t3) {
        return void 0 !== t3 ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e3, t3)) : (this.x -= e3.x, this.y -= e3.y, this.z -= e3.z, this);
      }, subScalar: function(e3) {
        return this.x -= e3, this.y -= e3, this.z -= e3, this;
      }, subVectors: function(e3, t3) {
        return this.x = e3.x - t3.x, this.y = e3.y - t3.y, this.z = e3.z - t3.z, this;
      }, multiply: function(e3, t3) {
        return void 0 !== t3 ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e3, t3)) : (this.x *= e3.x, this.y *= e3.y, this.z *= e3.z, this);
      }, multiplyScalar: function(e3) {
        return this.x *= e3, this.y *= e3, this.z *= e3, this;
      }, multiplyVectors: function(e3, t3) {
        return this.x = e3.x * t3.x, this.y = e3.y * t3.y, this.z = e3.z * t3.z, this;
      }, applyEuler: function() {
        var e3 = new zt();
        return function(t3) {
          return t3 && t3.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(e3.setFromEuler(t3));
        };
      }(), applyAxisAngle: function() {
        var e3 = new zt();
        return function(t3, n3) {
          return this.applyQuaternion(e3.setFromAxisAngle(t3, n3));
        };
      }(), applyMatrix3: function(e3) {
        var t3 = this.x, n3 = this.y, r3 = this.z, i3 = e3.elements;
        return this.x = i3[0] * t3 + i3[3] * n3 + i3[6] * r3, this.y = i3[1] * t3 + i3[4] * n3 + i3[7] * r3, this.z = i3[2] * t3 + i3[5] * n3 + i3[8] * r3, this;
      }, applyMatrix4: function(e3) {
        var t3 = this.x, n3 = this.y, r3 = this.z, i3 = e3.elements, a2 = 1 / (i3[3] * t3 + i3[7] * n3 + i3[11] * r3 + i3[15]);
        return this.x = (i3[0] * t3 + i3[4] * n3 + i3[8] * r3 + i3[12]) * a2, this.y = (i3[1] * t3 + i3[5] * n3 + i3[9] * r3 + i3[13]) * a2, this.z = (i3[2] * t3 + i3[6] * n3 + i3[10] * r3 + i3[14]) * a2, this;
      }, applyQuaternion: function(e3) {
        var t3 = this.x, n3 = this.y, r3 = this.z, i3 = e3.x, a2 = e3.y, o2 = e3.z, s2 = e3.w, c3 = s2 * t3 + a2 * r3 - o2 * n3, u3 = s2 * n3 + o2 * t3 - i3 * r3, l3 = s2 * r3 + i3 * n3 - a2 * t3, h3 = -i3 * t3 - a2 * n3 - o2 * r3;
        return this.x = c3 * s2 + h3 * -i3 + u3 * -o2 - l3 * -a2, this.y = u3 * s2 + h3 * -a2 + l3 * -i3 - c3 * -o2, this.z = l3 * s2 + h3 * -o2 + c3 * -a2 - u3 * -i3, this;
      }, project: function() {
        var e3 = new Gt();
        return function(t3) {
          return e3.multiplyMatrices(t3.projectionMatrix, e3.getInverse(t3.matrixWorld)), this.applyMatrix4(e3);
        };
      }(), unproject: function() {
        var e3 = new Gt();
        return function(t3) {
          return e3.multiplyMatrices(t3.matrixWorld, e3.getInverse(t3.projectionMatrix)), this.applyMatrix4(e3);
        };
      }(), transformDirection: function(e3) {
        var t3 = this.x, n3 = this.y, r3 = this.z, i3 = e3.elements;
        return this.x = i3[0] * t3 + i3[4] * n3 + i3[8] * r3, this.y = i3[1] * t3 + i3[5] * n3 + i3[9] * r3, this.z = i3[2] * t3 + i3[6] * n3 + i3[10] * r3, this.normalize();
      }, divide: function(e3) {
        return this.x /= e3.x, this.y /= e3.y, this.z /= e3.z, this;
      }, divideScalar: function(e3) {
        return this.multiplyScalar(1 / e3);
      }, min: function(e3) {
        return this.x = Math.min(this.x, e3.x), this.y = Math.min(this.y, e3.y), this.z = Math.min(this.z, e3.z), this;
      }, max: function(e3) {
        return this.x = Math.max(this.x, e3.x), this.y = Math.max(this.y, e3.y), this.z = Math.max(this.z, e3.z), this;
      }, clamp: function(e3, t3) {
        return this.x = Math.max(e3.x, Math.min(t3.x, this.x)), this.y = Math.max(e3.y, Math.min(t3.y, this.y)), this.z = Math.max(e3.z, Math.min(t3.z, this.z)), this;
      }, clampScalar: function() {
        var e3 = new Ht(), t3 = new Ht();
        return function(n3, r3) {
          return e3.set(n3, n3, n3), t3.set(r3, r3, r3), this.clamp(e3, t3);
        };
      }(), clampLength: function(e3, t3) {
        var n3 = this.length();
        return this.divideScalar(n3 || 1).multiplyScalar(Math.max(e3, Math.min(t3, n3)));
      }, floor: function() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
      }, ceil: function() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
      }, round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
      }, roundToZero: function() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
      }, negate: function() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
      }, dot: function(e3) {
        return this.x * e3.x + this.y * e3.y + this.z * e3.z;
      }, lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      }, length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      }, manhattanLength: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      }, normalize: function() {
        return this.divideScalar(this.length() || 1);
      }, setLength: function(e3) {
        return this.normalize().multiplyScalar(e3);
      }, lerp: function(e3, t3) {
        return this.x += (e3.x - this.x) * t3, this.y += (e3.y - this.y) * t3, this.z += (e3.z - this.z) * t3, this;
      }, lerpVectors: function(e3, t3, n3) {
        return this.subVectors(t3, e3).multiplyScalar(n3).add(e3);
      }, cross: function(e3, t3) {
        return void 0 !== t3 ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e3, t3)) : this.crossVectors(this, e3);
      }, crossVectors: function(e3, t3) {
        var n3 = e3.x, r3 = e3.y, i3 = e3.z, a2 = t3.x, o2 = t3.y, s2 = t3.z;
        return this.x = r3 * s2 - i3 * o2, this.y = i3 * a2 - n3 * s2, this.z = n3 * o2 - r3 * a2, this;
      }, projectOnVector: function(e3) {
        var t3 = e3.dot(this) / e3.lengthSq();
        return this.copy(e3).multiplyScalar(t3);
      }, projectOnPlane: function() {
        var e3 = new Ht();
        return function(t3) {
          return e3.copy(this).projectOnVector(t3), this.sub(e3);
        };
      }(), reflect: function() {
        var e3 = new Ht();
        return function(t3) {
          return this.sub(e3.copy(t3).multiplyScalar(2 * this.dot(t3)));
        };
      }(), angleTo: function(e3) {
        var t3 = this.dot(e3) / Math.sqrt(this.lengthSq() * e3.lengthSq());
        return Math.acos(Bt.clamp(t3, -1, 1));
      }, distanceTo: function(e3) {
        return Math.sqrt(this.distanceToSquared(e3));
      }, distanceToSquared: function(e3) {
        var t3 = this.x - e3.x, n3 = this.y - e3.y, r3 = this.z - e3.z;
        return t3 * t3 + n3 * n3 + r3 * r3;
      }, manhattanDistanceTo: function(e3) {
        return Math.abs(this.x - e3.x) + Math.abs(this.y - e3.y) + Math.abs(this.z - e3.z);
      }, setFromSpherical: function(e3) {
        var t3 = Math.sin(e3.phi) * e3.radius;
        return this.x = t3 * Math.sin(e3.theta), this.y = Math.cos(e3.phi) * e3.radius, this.z = t3 * Math.cos(e3.theta), this;
      }, setFromCylindrical: function(e3) {
        return this.x = e3.radius * Math.sin(e3.theta), this.y = e3.y, this.z = e3.radius * Math.cos(e3.theta), this;
      }, setFromMatrixPosition: function(e3) {
        var t3 = e3.elements;
        return this.x = t3[12], this.y = t3[13], this.z = t3[14], this;
      }, setFromMatrixScale: function(e3) {
        var t3 = this.setFromMatrixColumn(e3, 0).length(), n3 = this.setFromMatrixColumn(e3, 1).length(), r3 = this.setFromMatrixColumn(e3, 2).length();
        return this.x = t3, this.y = n3, this.z = r3, this;
      }, setFromMatrixColumn: function(e3, t3) {
        return this.fromArray(e3.elements, 4 * t3);
      }, equals: function(e3) {
        return e3.x === this.x && e3.y === this.y && e3.z === this.z;
      }, fromArray: function(e3, t3) {
        return void 0 === t3 && (t3 = 0), this.x = e3[t3], this.y = e3[t3 + 1], this.z = e3[t3 + 2], this;
      }, toArray: function(e3, t3) {
        return void 0 === e3 && (e3 = []), void 0 === t3 && (t3 = 0), e3[t3] = this.x, e3[t3 + 1] = this.y, e3[t3 + 2] = this.z, e3;
      }, fromBufferAttribute: function(e3, t3, n3) {
        return void 0 !== n3 && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e3.getX(t3), this.y = e3.getY(t3), this.z = e3.getZ(t3), this;
      } }), Object.assign(kt.prototype, { isMatrix3: true, set: function(e3, t3, n3, r3, i3, a2, o2, s2, c3) {
        var u3 = this.elements;
        return u3[0] = e3, u3[1] = r3, u3[2] = o2, u3[3] = t3, u3[4] = i3, u3[5] = s2, u3[6] = n3, u3[7] = a2, u3[8] = c3, this;
      }, identity: function() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
      }, clone: function() {
        return new this.constructor().fromArray(this.elements);
      }, copy: function(e3) {
        var t3 = this.elements, n3 = e3.elements;
        return t3[0] = n3[0], t3[1] = n3[1], t3[2] = n3[2], t3[3] = n3[3], t3[4] = n3[4], t3[5] = n3[5], t3[6] = n3[6], t3[7] = n3[7], t3[8] = n3[8], this;
      }, setFromMatrix4: function(e3) {
        var t3 = e3.elements;
        return this.set(t3[0], t3[4], t3[8], t3[1], t3[5], t3[9], t3[2], t3[6], t3[10]), this;
      }, applyToBufferAttribute: function() {
        var e3 = new Ht();
        return function(t3) {
          for (var n3 = 0, r3 = t3.count; n3 < r3; n3++)
            e3.x = t3.getX(n3), e3.y = t3.getY(n3), e3.z = t3.getZ(n3), e3.applyMatrix3(this), t3.setXYZ(n3, e3.x, e3.y, e3.z);
          return t3;
        };
      }(), multiply: function(e3) {
        return this.multiplyMatrices(this, e3);
      }, premultiply: function(e3) {
        return this.multiplyMatrices(e3, this);
      }, multiplyMatrices: function(e3, t3) {
        var n3 = e3.elements, r3 = t3.elements, i3 = this.elements, a2 = n3[0], o2 = n3[3], s2 = n3[6], c3 = n3[1], u3 = n3[4], l3 = n3[7], h3 = n3[2], d3 = n3[5], p3 = n3[8], f3 = r3[0], m3 = r3[3], g3 = r3[6], v3 = r3[1], y3 = r3[4], x3 = r3[7], b3 = r3[2], w3 = r3[5], _3 = r3[8];
        return i3[0] = a2 * f3 + o2 * v3 + s2 * b3, i3[3] = a2 * m3 + o2 * y3 + s2 * w3, i3[6] = a2 * g3 + o2 * x3 + s2 * _3, i3[1] = c3 * f3 + u3 * v3 + l3 * b3, i3[4] = c3 * m3 + u3 * y3 + l3 * w3, i3[7] = c3 * g3 + u3 * x3 + l3 * _3, i3[2] = h3 * f3 + d3 * v3 + p3 * b3, i3[5] = h3 * m3 + d3 * y3 + p3 * w3, i3[8] = h3 * g3 + d3 * x3 + p3 * _3, this;
      }, multiplyScalar: function(e3) {
        var t3 = this.elements;
        return t3[0] *= e3, t3[3] *= e3, t3[6] *= e3, t3[1] *= e3, t3[4] *= e3, t3[7] *= e3, t3[2] *= e3, t3[5] *= e3, t3[8] *= e3, this;
      }, determinant: function() {
        var e3 = this.elements, t3 = e3[0], n3 = e3[1], r3 = e3[2], i3 = e3[3], a2 = e3[4], o2 = e3[5], s2 = e3[6], c3 = e3[7], u3 = e3[8];
        return t3 * a2 * u3 - t3 * o2 * c3 - n3 * i3 * u3 + n3 * o2 * s2 + r3 * i3 * c3 - r3 * a2 * s2;
      }, getInverse: function(e3, t3) {
        e3 && e3.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
        var n3 = e3.elements, r3 = this.elements, i3 = n3[0], a2 = n3[1], o2 = n3[2], s2 = n3[3], c3 = n3[4], u3 = n3[5], l3 = n3[6], h3 = n3[7], d3 = n3[8], p3 = d3 * c3 - u3 * h3, f3 = u3 * l3 - d3 * s2, m3 = h3 * s2 - c3 * l3, g3 = i3 * p3 + a2 * f3 + o2 * m3;
        if (0 === g3) {
          var v3 = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
          if (true === t3)
            throw new Error(v3);
          return console.warn(v3), this.identity();
        }
        var y3 = 1 / g3;
        return r3[0] = p3 * y3, r3[1] = (o2 * h3 - d3 * a2) * y3, r3[2] = (u3 * a2 - o2 * c3) * y3, r3[3] = f3 * y3, r3[4] = (d3 * i3 - o2 * l3) * y3, r3[5] = (o2 * s2 - u3 * i3) * y3, r3[6] = m3 * y3, r3[7] = (a2 * l3 - h3 * i3) * y3, r3[8] = (c3 * i3 - a2 * s2) * y3, this;
      }, transpose: function() {
        var e3, t3 = this.elements;
        return e3 = t3[1], t3[1] = t3[3], t3[3] = e3, e3 = t3[2], t3[2] = t3[6], t3[6] = e3, e3 = t3[5], t3[5] = t3[7], t3[7] = e3, this;
      }, getNormalMatrix: function(e3) {
        return this.setFromMatrix4(e3).getInverse(this).transpose();
      }, transposeIntoArray: function(e3) {
        var t3 = this.elements;
        return e3[0] = t3[0], e3[1] = t3[3], e3[2] = t3[6], e3[3] = t3[1], e3[4] = t3[4], e3[5] = t3[7], e3[6] = t3[2], e3[7] = t3[5], e3[8] = t3[8], this;
      }, setUvTransform: function(e3, t3, n3, r3, i3, a2, o2) {
        var s2 = Math.cos(i3), c3 = Math.sin(i3);
        this.set(n3 * s2, n3 * c3, -n3 * (s2 * a2 + c3 * o2) + a2 + e3, -r3 * c3, r3 * s2, -r3 * (-c3 * a2 + s2 * o2) + o2 + t3, 0, 0, 1);
      }, scale: function(e3, t3) {
        var n3 = this.elements;
        return n3[0] *= e3, n3[3] *= e3, n3[6] *= e3, n3[1] *= t3, n3[4] *= t3, n3[7] *= t3, this;
      }, rotate: function(e3) {
        var t3 = Math.cos(e3), n3 = Math.sin(e3), r3 = this.elements, i3 = r3[0], a2 = r3[3], o2 = r3[6], s2 = r3[1], c3 = r3[4], u3 = r3[7];
        return r3[0] = t3 * i3 + n3 * s2, r3[3] = t3 * a2 + n3 * c3, r3[6] = t3 * o2 + n3 * u3, r3[1] = -n3 * i3 + t3 * s2, r3[4] = -n3 * a2 + t3 * c3, r3[7] = -n3 * o2 + t3 * u3, this;
      }, translate: function(e3, t3) {
        var n3 = this.elements;
        return n3[0] += e3 * n3[2], n3[3] += e3 * n3[5], n3[6] += e3 * n3[8], n3[1] += t3 * n3[2], n3[4] += t3 * n3[5], n3[7] += t3 * n3[8], this;
      }, equals: function(e3) {
        for (var t3 = this.elements, n3 = e3.elements, r3 = 0; r3 < 9; r3++)
          if (t3[r3] !== n3[r3])
            return false;
        return true;
      }, fromArray: function(e3, t3) {
        void 0 === t3 && (t3 = 0);
        for (var n3 = 0; n3 < 9; n3++)
          this.elements[n3] = e3[n3 + t3];
        return this;
      }, toArray: function(e3, t3) {
        void 0 === e3 && (e3 = []), void 0 === t3 && (t3 = 0);
        var n3 = this.elements;
        return e3[t3] = n3[0], e3[t3 + 1] = n3[1], e3[t3 + 2] = n3[2], e3[t3 + 3] = n3[3], e3[t3 + 4] = n3[4], e3[t3 + 5] = n3[5], e3[t3 + 6] = n3[6], e3[t3 + 7] = n3[7], e3[t3 + 8] = n3[8], e3;
      } });
      var jt = { getDataURL: function(e3) {
        var t3;
        if (e3 instanceof HTMLCanvasElement)
          t3 = e3;
        else {
          "undefined" != typeof OffscreenCanvas ? t3 = new OffscreenCanvas(e3.width, e3.height) : ((t3 = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")).width = e3.width, t3.height = e3.height);
          var n3 = t3.getContext("2d");
          e3 instanceof ImageData ? n3.putImageData(e3, 0, 0) : n3.drawImage(e3, 0, 0, e3.width, e3.height);
        }
        return t3.width > 2048 || t3.height > 2048 ? t3.toDataURL("image/jpeg", 0.6) : t3.toDataURL("image/png");
      } }, Vt = 0;
      function Wt(e3, t3, n3, r3, i3, a2, o2, s2, c3, u3) {
        Object.defineProperty(this, "id", { value: Vt++ }), this.uuid = Bt.generateUUID(), this.name = "", this.image = void 0 !== e3 ? e3 : Wt.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== t3 ? t3 : Wt.DEFAULT_MAPPING, this.wrapS = void 0 !== n3 ? n3 : ge2, this.wrapT = void 0 !== r3 ? r3 : ge2, this.magFilter = void 0 !== i3 ? i3 : we2, this.minFilter = void 0 !== a2 ? a2 : Me2, this.anisotropy = void 0 !== c3 ? c3 : 1, this.format = void 0 !== o2 ? o2 : Fe2, this.type = void 0 !== s2 ? s2 : Ee2, this.offset = new Ft(0, 0), this.repeat = new Ft(1, 1), this.center = new Ft(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new kt(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.encoding = void 0 !== u3 ? u3 : Tt, this.version = 0, this.onUpdate = null;
      }
      function Xt(e3, t3, n3, r3) {
        this.x = e3 || 0, this.y = t3 || 0, this.z = n3 || 0, this.w = void 0 !== r3 ? r3 : 1;
      }
      function qt(e3, t3, n3) {
        this.width = e3, this.height = t3, this.scissor = new Xt(0, 0, e3, t3), this.scissorTest = false, this.viewport = new Xt(0, 0, e3, t3), void 0 === (n3 = n3 || {}).minFilter && (n3.minFilter = we2), this.texture = new Wt(void 0, void 0, n3.wrapS, n3.wrapT, n3.magFilter, n3.minFilter, n3.format, n3.type, n3.anisotropy, n3.encoding), this.texture.generateMipmaps = void 0 === n3.generateMipmaps || n3.generateMipmaps, this.depthBuffer = void 0 === n3.depthBuffer || n3.depthBuffer, this.stencilBuffer = void 0 === n3.stencilBuffer || n3.stencilBuffer, this.depthTexture = void 0 !== n3.depthTexture ? n3.depthTexture : null;
      }
      function Yt(e3, t3, n3) {
        qt.call(this, e3, t3, n3), this.activeCubeFace = 0, this.activeMipMapLevel = 0;
      }
      function Zt(e3, t3, n3, r3, i3, a2, o2, s2, c3, u3, l3, h3) {
        Wt.call(this, null, a2, o2, s2, c3, u3, r3, i3, l3, h3), this.image = { data: e3, width: t3, height: n3 }, this.magFilter = void 0 !== c3 ? c3 : ye2, this.minFilter = void 0 !== u3 ? u3 : ye2, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
      }
      function Jt(e3, t3) {
        this.min = void 0 !== e3 ? e3 : new Ht(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== t3 ? t3 : new Ht(-1 / 0, -1 / 0, -1 / 0);
      }
      function Kt(e3, t3) {
        this.center = void 0 !== e3 ? e3 : new Ht(), this.radius = void 0 !== t3 ? t3 : 0;
      }
      function Qt(e3, t3) {
        this.normal = void 0 !== e3 ? e3 : new Ht(1, 0, 0), this.constant = void 0 !== t3 ? t3 : 0;
      }
      function $t(e3, t3, n3, r3, i3, a2) {
        this.planes = [void 0 !== e3 ? e3 : new Qt(), void 0 !== t3 ? t3 : new Qt(), void 0 !== n3 ? n3 : new Qt(), void 0 !== r3 ? r3 : new Qt(), void 0 !== i3 ? i3 : new Qt(), void 0 !== a2 ? a2 : new Qt()];
      }
      Wt.DEFAULT_IMAGE = void 0, Wt.DEFAULT_MAPPING = se2, Wt.prototype = Object.assign(Object.create(r2.prototype), { constructor: Wt, isTexture: true, updateMatrix: function() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
      }, clone: function() {
        return new this.constructor().copy(this);
      }, copy: function(e3) {
        return this.name = e3.name, this.image = e3.image, this.mipmaps = e3.mipmaps.slice(0), this.mapping = e3.mapping, this.wrapS = e3.wrapS, this.wrapT = e3.wrapT, this.magFilter = e3.magFilter, this.minFilter = e3.minFilter, this.anisotropy = e3.anisotropy, this.format = e3.format, this.type = e3.type, this.offset.copy(e3.offset), this.repeat.copy(e3.repeat), this.center.copy(e3.center), this.rotation = e3.rotation, this.matrixAutoUpdate = e3.matrixAutoUpdate, this.matrix.copy(e3.matrix), this.generateMipmaps = e3.generateMipmaps, this.premultiplyAlpha = e3.premultiplyAlpha, this.flipY = e3.flipY, this.unpackAlignment = e3.unpackAlignment, this.encoding = e3.encoding, this;
      }, toJSON: function(e3) {
        var t3 = void 0 === e3 || "string" == typeof e3;
        if (!t3 && void 0 !== e3.textures[this.uuid])
          return e3.textures[this.uuid];
        var n3 = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY };
        if (void 0 !== this.image) {
          var r3 = this.image;
          if (void 0 === r3.uuid && (r3.uuid = Bt.generateUUID()), !t3 && void 0 === e3.images[r3.uuid]) {
            var i3;
            if (Array.isArray(r3)) {
              i3 = [];
              for (var a2 = 0, o2 = r3.length; a2 < o2; a2++)
                i3.push(jt.getDataURL(r3[a2]));
            } else
              i3 = jt.getDataURL(r3);
            e3.images[r3.uuid] = { uuid: r3.uuid, url: i3 };
          }
          n3.image = r3.uuid;
        }
        return t3 || (e3.textures[this.uuid] = n3), n3;
      }, dispose: function() {
        this.dispatchEvent({ type: "dispose" });
      }, transformUv: function(e3) {
        if (this.mapping === se2) {
          if (e3.applyMatrix3(this.matrix), e3.x < 0 || e3.x > 1)
            switch (this.wrapS) {
              case me2:
                e3.x = e3.x - Math.floor(e3.x);
                break;
              case ge2:
                e3.x = e3.x < 0 ? 0 : 1;
                break;
              case ve2:
                1 === Math.abs(Math.floor(e3.x) % 2) ? e3.x = Math.ceil(e3.x) - e3.x : e3.x = e3.x - Math.floor(e3.x);
            }
          if (e3.y < 0 || e3.y > 1)
            switch (this.wrapT) {
              case me2:
                e3.y = e3.y - Math.floor(e3.y);
                break;
              case ge2:
                e3.y = e3.y < 0 ? 0 : 1;
                break;
              case ve2:
                1 === Math.abs(Math.floor(e3.y) % 2) ? e3.y = Math.ceil(e3.y) - e3.y : e3.y = e3.y - Math.floor(e3.y);
            }
          this.flipY && (e3.y = 1 - e3.y);
        }
      } }), Object.defineProperty(Wt.prototype, "needsUpdate", { set: function(e3) {
        true === e3 && this.version++;
      } }), Object.assign(Xt.prototype, { isVector4: true, set: function(e3, t3, n3, r3) {
        return this.x = e3, this.y = t3, this.z = n3, this.w = r3, this;
      }, setScalar: function(e3) {
        return this.x = e3, this.y = e3, this.z = e3, this.w = e3, this;
      }, setX: function(e3) {
        return this.x = e3, this;
      }, setY: function(e3) {
        return this.y = e3, this;
      }, setZ: function(e3) {
        return this.z = e3, this;
      }, setW: function(e3) {
        return this.w = e3, this;
      }, setComponent: function(e3, t3) {
        switch (e3) {
          case 0:
            this.x = t3;
            break;
          case 1:
            this.y = t3;
            break;
          case 2:
            this.z = t3;
            break;
          case 3:
            this.w = t3;
            break;
          default:
            throw new Error("index is out of range: " + e3);
        }
        return this;
      }, getComponent: function(e3) {
        switch (e3) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          case 3:
            return this.w;
          default:
            throw new Error("index is out of range: " + e3);
        }
      }, clone: function() {
        return new this.constructor(this.x, this.y, this.z, this.w);
      }, copy: function(e3) {
        return this.x = e3.x, this.y = e3.y, this.z = e3.z, this.w = void 0 !== e3.w ? e3.w : 1, this;
      }, add: function(e3, t3) {
        return void 0 !== t3 ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e3, t3)) : (this.x += e3.x, this.y += e3.y, this.z += e3.z, this.w += e3.w, this);
      }, addScalar: function(e3) {
        return this.x += e3, this.y += e3, this.z += e3, this.w += e3, this;
      }, addVectors: function(e3, t3) {
        return this.x = e3.x + t3.x, this.y = e3.y + t3.y, this.z = e3.z + t3.z, this.w = e3.w + t3.w, this;
      }, addScaledVector: function(e3, t3) {
        return this.x += e3.x * t3, this.y += e3.y * t3, this.z += e3.z * t3, this.w += e3.w * t3, this;
      }, sub: function(e3, t3) {
        return void 0 !== t3 ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e3, t3)) : (this.x -= e3.x, this.y -= e3.y, this.z -= e3.z, this.w -= e3.w, this);
      }, subScalar: function(e3) {
        return this.x -= e3, this.y -= e3, this.z -= e3, this.w -= e3, this;
      }, subVectors: function(e3, t3) {
        return this.x = e3.x - t3.x, this.y = e3.y - t3.y, this.z = e3.z - t3.z, this.w = e3.w - t3.w, this;
      }, multiplyScalar: function(e3) {
        return this.x *= e3, this.y *= e3, this.z *= e3, this.w *= e3, this;
      }, applyMatrix4: function(e3) {
        var t3 = this.x, n3 = this.y, r3 = this.z, i3 = this.w, a2 = e3.elements;
        return this.x = a2[0] * t3 + a2[4] * n3 + a2[8] * r3 + a2[12] * i3, this.y = a2[1] * t3 + a2[5] * n3 + a2[9] * r3 + a2[13] * i3, this.z = a2[2] * t3 + a2[6] * n3 + a2[10] * r3 + a2[14] * i3, this.w = a2[3] * t3 + a2[7] * n3 + a2[11] * r3 + a2[15] * i3, this;
      }, divideScalar: function(e3) {
        return this.multiplyScalar(1 / e3);
      }, setAxisAngleFromQuaternion: function(e3) {
        this.w = 2 * Math.acos(e3.w);
        var t3 = Math.sqrt(1 - e3.w * e3.w);
        return t3 < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e3.x / t3, this.y = e3.y / t3, this.z = e3.z / t3), this;
      }, setAxisAngleFromRotationMatrix: function(e3) {
        var t3, n3, r3, i3, a2 = e3.elements, o2 = a2[0], s2 = a2[4], c3 = a2[8], u3 = a2[1], l3 = a2[5], h3 = a2[9], d3 = a2[2], p3 = a2[6], f3 = a2[10];
        if (Math.abs(s2 - u3) < 0.01 && Math.abs(c3 - d3) < 0.01 && Math.abs(h3 - p3) < 0.01) {
          if (Math.abs(s2 + u3) < 0.1 && Math.abs(c3 + d3) < 0.1 && Math.abs(h3 + p3) < 0.1 && Math.abs(o2 + l3 + f3 - 3) < 0.1)
            return this.set(1, 0, 0, 0), this;
          t3 = Math.PI;
          var m3 = (o2 + 1) / 2, g3 = (l3 + 1) / 2, v3 = (f3 + 1) / 2, y3 = (s2 + u3) / 4, x3 = (c3 + d3) / 4, b3 = (h3 + p3) / 4;
          return m3 > g3 && m3 > v3 ? m3 < 0.01 ? (n3 = 0, r3 = 0.707106781, i3 = 0.707106781) : (r3 = y3 / (n3 = Math.sqrt(m3)), i3 = x3 / n3) : g3 > v3 ? g3 < 0.01 ? (n3 = 0.707106781, r3 = 0, i3 = 0.707106781) : (n3 = y3 / (r3 = Math.sqrt(g3)), i3 = b3 / r3) : v3 < 0.01 ? (n3 = 0.707106781, r3 = 0.707106781, i3 = 0) : (n3 = x3 / (i3 = Math.sqrt(v3)), r3 = b3 / i3), this.set(n3, r3, i3, t3), this;
        }
        var w3 = Math.sqrt((p3 - h3) * (p3 - h3) + (c3 - d3) * (c3 - d3) + (u3 - s2) * (u3 - s2));
        return Math.abs(w3) < 1e-3 && (w3 = 1), this.x = (p3 - h3) / w3, this.y = (c3 - d3) / w3, this.z = (u3 - s2) / w3, this.w = Math.acos((o2 + l3 + f3 - 1) / 2), this;
      }, min: function(e3) {
        return this.x = Math.min(this.x, e3.x), this.y = Math.min(this.y, e3.y), this.z = Math.min(this.z, e3.z), this.w = Math.min(this.w, e3.w), this;
      }, max: function(e3) {
        return this.x = Math.max(this.x, e3.x), this.y = Math.max(this.y, e3.y), this.z = Math.max(this.z, e3.z), this.w = Math.max(this.w, e3.w), this;
      }, clamp: function(e3, t3) {
        return this.x = Math.max(e3.x, Math.min(t3.x, this.x)), this.y = Math.max(e3.y, Math.min(t3.y, this.y)), this.z = Math.max(e3.z, Math.min(t3.z, this.z)), this.w = Math.max(e3.w, Math.min(t3.w, this.w)), this;
      }, clampScalar: function() {
        var e3, t3;
        return function(n3, r3) {
          return void 0 === e3 && (e3 = new Xt(), t3 = new Xt()), e3.set(n3, n3, n3, n3), t3.set(r3, r3, r3, r3), this.clamp(e3, t3);
        };
      }(), clampLength: function(e3, t3) {
        var n3 = this.length();
        return this.divideScalar(n3 || 1).multiplyScalar(Math.max(e3, Math.min(t3, n3)));
      }, floor: function() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
      }, ceil: function() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
      }, round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
      }, roundToZero: function() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
      }, negate: function() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
      }, dot: function(e3) {
        return this.x * e3.x + this.y * e3.y + this.z * e3.z + this.w * e3.w;
      }, lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
      }, length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
      }, manhattanLength: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
      }, normalize: function() {
        return this.divideScalar(this.length() || 1);
      }, setLength: function(e3) {
        return this.normalize().multiplyScalar(e3);
      }, lerp: function(e3, t3) {
        return this.x += (e3.x - this.x) * t3, this.y += (e3.y - this.y) * t3, this.z += (e3.z - this.z) * t3, this.w += (e3.w - this.w) * t3, this;
      }, lerpVectors: function(e3, t3, n3) {
        return this.subVectors(t3, e3).multiplyScalar(n3).add(e3);
      }, equals: function(e3) {
        return e3.x === this.x && e3.y === this.y && e3.z === this.z && e3.w === this.w;
      }, fromArray: function(e3, t3) {
        return void 0 === t3 && (t3 = 0), this.x = e3[t3], this.y = e3[t3 + 1], this.z = e3[t3 + 2], this.w = e3[t3 + 3], this;
      }, toArray: function(e3, t3) {
        return void 0 === e3 && (e3 = []), void 0 === t3 && (t3 = 0), e3[t3] = this.x, e3[t3 + 1] = this.y, e3[t3 + 2] = this.z, e3[t3 + 3] = this.w, e3;
      }, fromBufferAttribute: function(e3, t3, n3) {
        return void 0 !== n3 && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e3.getX(t3), this.y = e3.getY(t3), this.z = e3.getZ(t3), this.w = e3.getW(t3), this;
      } }), qt.prototype = Object.assign(Object.create(r2.prototype), { constructor: qt, isWebGLRenderTarget: true, setSize: function(e3, t3) {
        this.width === e3 && this.height === t3 || (this.width = e3, this.height = t3, this.dispose()), this.viewport.set(0, 0, e3, t3), this.scissor.set(0, 0, e3, t3);
      }, clone: function() {
        return new this.constructor().copy(this);
      }, copy: function(e3) {
        return this.width = e3.width, this.height = e3.height, this.viewport.copy(e3.viewport), this.texture = e3.texture.clone(), this.depthBuffer = e3.depthBuffer, this.stencilBuffer = e3.stencilBuffer, this.depthTexture = e3.depthTexture, this;
      }, dispose: function() {
        this.dispatchEvent({ type: "dispose" });
      } }), Yt.prototype = Object.create(qt.prototype), Yt.prototype.constructor = Yt, Yt.prototype.isWebGLRenderTargetCube = true, Zt.prototype = Object.create(Wt.prototype), Zt.prototype.constructor = Zt, Zt.prototype.isDataTexture = true, Object.assign(Jt.prototype, { isBox3: true, set: function(e3, t3) {
        return this.min.copy(e3), this.max.copy(t3), this;
      }, setFromArray: function(e3) {
        for (var t3 = 1 / 0, n3 = 1 / 0, r3 = 1 / 0, i3 = -1 / 0, a2 = -1 / 0, o2 = -1 / 0, s2 = 0, c3 = e3.length; s2 < c3; s2 += 3) {
          var u3 = e3[s2], l3 = e3[s2 + 1], h3 = e3[s2 + 2];
          u3 < t3 && (t3 = u3), l3 < n3 && (n3 = l3), h3 < r3 && (r3 = h3), u3 > i3 && (i3 = u3), l3 > a2 && (a2 = l3), h3 > o2 && (o2 = h3);
        }
        return this.min.set(t3, n3, r3), this.max.set(i3, a2, o2), this;
      }, setFromBufferAttribute: function(e3) {
        for (var t3 = 1 / 0, n3 = 1 / 0, r3 = 1 / 0, i3 = -1 / 0, a2 = -1 / 0, o2 = -1 / 0, s2 = 0, c3 = e3.count; s2 < c3; s2++) {
          var u3 = e3.getX(s2), l3 = e3.getY(s2), h3 = e3.getZ(s2);
          u3 < t3 && (t3 = u3), l3 < n3 && (n3 = l3), h3 < r3 && (r3 = h3), u3 > i3 && (i3 = u3), l3 > a2 && (a2 = l3), h3 > o2 && (o2 = h3);
        }
        return this.min.set(t3, n3, r3), this.max.set(i3, a2, o2), this;
      }, setFromPoints: function(e3) {
        this.makeEmpty();
        for (var t3 = 0, n3 = e3.length; t3 < n3; t3++)
          this.expandByPoint(e3[t3]);
        return this;
      }, setFromCenterAndSize: function() {
        var e3 = new Ht();
        return function(t3, n3) {
          var r3 = e3.copy(n3).multiplyScalar(0.5);
          return this.min.copy(t3).sub(r3), this.max.copy(t3).add(r3), this;
        };
      }(), setFromObject: function(e3) {
        return this.makeEmpty(), this.expandByObject(e3);
      }, clone: function() {
        return new this.constructor().copy(this);
      }, copy: function(e3) {
        return this.min.copy(e3.min), this.max.copy(e3.max), this;
      }, makeEmpty: function() {
        return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
      }, isEmpty: function() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
      }, getCenter: function(e3) {
        return void 0 === e3 && (console.warn("THREE.Box3: .getCenter() target is now required"), e3 = new Ht()), this.isEmpty() ? e3.set(0, 0, 0) : e3.addVectors(this.min, this.max).multiplyScalar(0.5);
      }, getSize: function(e3) {
        return void 0 === e3 && (console.warn("THREE.Box3: .getSize() target is now required"), e3 = new Ht()), this.isEmpty() ? e3.set(0, 0, 0) : e3.subVectors(this.max, this.min);
      }, expandByPoint: function(e3) {
        return this.min.min(e3), this.max.max(e3), this;
      }, expandByVector: function(e3) {
        return this.min.sub(e3), this.max.add(e3), this;
      }, expandByScalar: function(e3) {
        return this.min.addScalar(-e3), this.max.addScalar(e3), this;
      }, expandByObject: function() {
        var e3, t3, n3, r3 = new Ht();
        function i3(i4) {
          var a2 = i4.geometry;
          if (void 0 !== a2) {
            if (a2.isGeometry) {
              var o2 = a2.vertices;
              for (t3 = 0, n3 = o2.length; t3 < n3; t3++)
                r3.copy(o2[t3]), r3.applyMatrix4(i4.matrixWorld), e3.expandByPoint(r3);
            } else if (a2.isBufferGeometry) {
              var s2 = a2.attributes.position;
              if (void 0 !== s2)
                for (t3 = 0, n3 = s2.count; t3 < n3; t3++)
                  r3.fromBufferAttribute(s2, t3).applyMatrix4(i4.matrixWorld), e3.expandByPoint(r3);
            }
          }
        }
        return function(t4) {
          return e3 = this, t4.updateMatrixWorld(true), t4.traverse(i3), this;
        };
      }(), containsPoint: function(e3) {
        return !(e3.x < this.min.x || e3.x > this.max.x || e3.y < this.min.y || e3.y > this.max.y || e3.z < this.min.z || e3.z > this.max.z);
      }, containsBox: function(e3) {
        return this.min.x <= e3.min.x && e3.max.x <= this.max.x && this.min.y <= e3.min.y && e3.max.y <= this.max.y && this.min.z <= e3.min.z && e3.max.z <= this.max.z;
      }, getParameter: function(e3, t3) {
        return void 0 === t3 && (console.warn("THREE.Box3: .getParameter() target is now required"), t3 = new Ht()), t3.set((e3.x - this.min.x) / (this.max.x - this.min.x), (e3.y - this.min.y) / (this.max.y - this.min.y), (e3.z - this.min.z) / (this.max.z - this.min.z));
      }, intersectsBox: function(e3) {
        return !(e3.max.x < this.min.x || e3.min.x > this.max.x || e3.max.y < this.min.y || e3.min.y > this.max.y || e3.max.z < this.min.z || e3.min.z > this.max.z);
      }, intersectsSphere: function() {
        var e3 = new Ht();
        return function(t3) {
          return this.clampPoint(t3.center, e3), e3.distanceToSquared(t3.center) <= t3.radius * t3.radius;
        };
      }(), intersectsPlane: function(e3) {
        var t3, n3;
        return e3.normal.x > 0 ? (t3 = e3.normal.x * this.min.x, n3 = e3.normal.x * this.max.x) : (t3 = e3.normal.x * this.max.x, n3 = e3.normal.x * this.min.x), e3.normal.y > 0 ? (t3 += e3.normal.y * this.min.y, n3 += e3.normal.y * this.max.y) : (t3 += e3.normal.y * this.max.y, n3 += e3.normal.y * this.min.y), e3.normal.z > 0 ? (t3 += e3.normal.z * this.min.z, n3 += e3.normal.z * this.max.z) : (t3 += e3.normal.z * this.max.z, n3 += e3.normal.z * this.min.z), t3 <= e3.constant && n3 >= e3.constant;
      }, intersectsTriangle: function() {
        var e3 = new Ht(), t3 = new Ht(), n3 = new Ht(), r3 = new Ht(), i3 = new Ht(), a2 = new Ht(), o2 = new Ht(), s2 = new Ht(), c3 = new Ht(), u3 = new Ht();
        function l3(r4) {
          var i4, a3;
          for (i4 = 0, a3 = r4.length - 3; i4 <= a3; i4 += 3) {
            o2.fromArray(r4, i4);
            var s3 = c3.x * Math.abs(o2.x) + c3.y * Math.abs(o2.y) + c3.z * Math.abs(o2.z), u4 = e3.dot(o2), l4 = t3.dot(o2), h3 = n3.dot(o2);
            if (Math.max(-Math.max(u4, l4, h3), Math.min(u4, l4, h3)) > s3)
              return false;
          }
          return true;
        }
        return function(o3) {
          if (this.isEmpty())
            return false;
          this.getCenter(s2), c3.subVectors(this.max, s2), e3.subVectors(o3.a, s2), t3.subVectors(o3.b, s2), n3.subVectors(o3.c, s2), r3.subVectors(t3, e3), i3.subVectors(n3, t3), a2.subVectors(e3, n3);
          var h3 = [0, -r3.z, r3.y, 0, -i3.z, i3.y, 0, -a2.z, a2.y, r3.z, 0, -r3.x, i3.z, 0, -i3.x, a2.z, 0, -a2.x, -r3.y, r3.x, 0, -i3.y, i3.x, 0, -a2.y, a2.x, 0];
          return !!l3(h3) && (!!l3(h3 = [1, 0, 0, 0, 1, 0, 0, 0, 1]) && (u3.crossVectors(r3, i3), l3(h3 = [u3.x, u3.y, u3.z])));
        };
      }(), clampPoint: function(e3, t3) {
        return void 0 === t3 && (console.warn("THREE.Box3: .clampPoint() target is now required"), t3 = new Ht()), t3.copy(e3).clamp(this.min, this.max);
      }, distanceToPoint: function() {
        var e3 = new Ht();
        return function(t3) {
          return e3.copy(t3).clamp(this.min, this.max).sub(t3).length();
        };
      }(), getBoundingSphere: function() {
        var e3 = new Ht();
        return function(t3) {
          return void 0 === t3 && (console.warn("THREE.Box3: .getBoundingSphere() target is now required"), t3 = new Kt()), this.getCenter(t3.center), t3.radius = 0.5 * this.getSize(e3).length(), t3;
        };
      }(), intersect: function(e3) {
        return this.min.max(e3.min), this.max.min(e3.max), this.isEmpty() && this.makeEmpty(), this;
      }, union: function(e3) {
        return this.min.min(e3.min), this.max.max(e3.max), this;
      }, applyMatrix4: function(e3) {
        if (this.isEmpty())
          return this;
        var t3 = e3.elements, n3 = t3[0] * this.min.x, r3 = t3[1] * this.min.x, i3 = t3[2] * this.min.x, a2 = t3[0] * this.max.x, o2 = t3[1] * this.max.x, s2 = t3[2] * this.max.x, c3 = t3[4] * this.min.y, u3 = t3[5] * this.min.y, l3 = t3[6] * this.min.y, h3 = t3[4] * this.max.y, d3 = t3[5] * this.max.y, p3 = t3[6] * this.max.y, f3 = t3[8] * this.min.z, m3 = t3[9] * this.min.z, g3 = t3[10] * this.min.z, v3 = t3[8] * this.max.z, y3 = t3[9] * this.max.z, x3 = t3[10] * this.max.z;
        return this.min.x = Math.min(n3, a2) + Math.min(c3, h3) + Math.min(f3, v3) + t3[12], this.min.y = Math.min(r3, o2) + Math.min(u3, d3) + Math.min(m3, y3) + t3[13], this.min.z = Math.min(i3, s2) + Math.min(l3, p3) + Math.min(g3, x3) + t3[14], this.max.x = Math.max(n3, a2) + Math.max(c3, h3) + Math.max(f3, v3) + t3[12], this.max.y = Math.max(r3, o2) + Math.max(u3, d3) + Math.max(m3, y3) + t3[13], this.max.z = Math.max(i3, s2) + Math.max(l3, p3) + Math.max(g3, x3) + t3[14], this;
      }, translate: function(e3) {
        return this.min.add(e3), this.max.add(e3), this;
      }, equals: function(e3) {
        return e3.min.equals(this.min) && e3.max.equals(this.max);
      } }), Object.assign(Kt.prototype, { set: function(e3, t3) {
        return this.center.copy(e3), this.radius = t3, this;
      }, setFromPoints: function() {
        var e3 = new Jt();
        return function(t3, n3) {
          var r3 = this.center;
          void 0 !== n3 ? r3.copy(n3) : e3.setFromPoints(t3).getCenter(r3);
          for (var i3 = 0, a2 = 0, o2 = t3.length; a2 < o2; a2++)
            i3 = Math.max(i3, r3.distanceToSquared(t3[a2]));
          return this.radius = Math.sqrt(i3), this;
        };
      }(), clone: function() {
        return new this.constructor().copy(this);
      }, copy: function(e3) {
        return this.center.copy(e3.center), this.radius = e3.radius, this;
      }, empty: function() {
        return this.radius <= 0;
      }, containsPoint: function(e3) {
        return e3.distanceToSquared(this.center) <= this.radius * this.radius;
      }, distanceToPoint: function(e3) {
        return e3.distanceTo(this.center) - this.radius;
      }, intersectsSphere: function(e3) {
        var t3 = this.radius + e3.radius;
        return e3.center.distanceToSquared(this.center) <= t3 * t3;
      }, intersectsBox: function(e3) {
        return e3.intersectsSphere(this);
      }, intersectsPlane: function(e3) {
        return Math.abs(e3.distanceToPoint(this.center)) <= this.radius;
      }, clampPoint: function(e3, t3) {
        var n3 = this.center.distanceToSquared(e3);
        return void 0 === t3 && (console.warn("THREE.Sphere: .clampPoint() target is now required"), t3 = new Ht()), t3.copy(e3), n3 > this.radius * this.radius && (t3.sub(this.center).normalize(), t3.multiplyScalar(this.radius).add(this.center)), t3;
      }, getBoundingBox: function(e3) {
        return void 0 === e3 && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), e3 = new Jt()), e3.set(this.center, this.center), e3.expandByScalar(this.radius), e3;
      }, applyMatrix4: function(e3) {
        return this.center.applyMatrix4(e3), this.radius = this.radius * e3.getMaxScaleOnAxis(), this;
      }, translate: function(e3) {
        return this.center.add(e3), this;
      }, equals: function(e3) {
        return e3.center.equals(this.center) && e3.radius === this.radius;
      } }), Object.assign(Qt.prototype, { set: function(e3, t3) {
        return this.normal.copy(e3), this.constant = t3, this;
      }, setComponents: function(e3, t3, n3, r3) {
        return this.normal.set(e3, t3, n3), this.constant = r3, this;
      }, setFromNormalAndCoplanarPoint: function(e3, t3) {
        return this.normal.copy(e3), this.constant = -t3.dot(this.normal), this;
      }, setFromCoplanarPoints: function() {
        var e3 = new Ht(), t3 = new Ht();
        return function(n3, r3, i3) {
          var a2 = e3.subVectors(i3, r3).cross(t3.subVectors(n3, r3)).normalize();
          return this.setFromNormalAndCoplanarPoint(a2, n3), this;
        };
      }(), clone: function() {
        return new this.constructor().copy(this);
      }, copy: function(e3) {
        return this.normal.copy(e3.normal), this.constant = e3.constant, this;
      }, normalize: function() {
        var e3 = 1 / this.normal.length();
        return this.normal.multiplyScalar(e3), this.constant *= e3, this;
      }, negate: function() {
        return this.constant *= -1, this.normal.negate(), this;
      }, distanceToPoint: function(e3) {
        return this.normal.dot(e3) + this.constant;
      }, distanceToSphere: function(e3) {
        return this.distanceToPoint(e3.center) - e3.radius;
      }, projectPoint: function(e3, t3) {
        return void 0 === t3 && (console.warn("THREE.Plane: .projectPoint() target is now required"), t3 = new Ht()), t3.copy(this.normal).multiplyScalar(-this.distanceToPoint(e3)).add(e3);
      }, intersectLine: function() {
        var e3 = new Ht();
        return function(t3, n3) {
          void 0 === n3 && (console.warn("THREE.Plane: .intersectLine() target is now required"), n3 = new Ht());
          var r3 = t3.delta(e3), i3 = this.normal.dot(r3);
          if (0 === i3)
            return 0 === this.distanceToPoint(t3.start) ? n3.copy(t3.start) : void 0;
          var a2 = -(t3.start.dot(this.normal) + this.constant) / i3;
          return a2 < 0 || a2 > 1 ? void 0 : n3.copy(r3).multiplyScalar(a2).add(t3.start);
        };
      }(), intersectsLine: function(e3) {
        var t3 = this.distanceToPoint(e3.start), n3 = this.distanceToPoint(e3.end);
        return t3 < 0 && n3 > 0 || n3 < 0 && t3 > 0;
      }, intersectsBox: function(e3) {
        return e3.intersectsPlane(this);
      }, intersectsSphere: function(e3) {
        return e3.intersectsPlane(this);
      }, coplanarPoint: function(e3) {
        return void 0 === e3 && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), e3 = new Ht()), e3.copy(this.normal).multiplyScalar(-this.constant);
      }, applyMatrix4: function() {
        var e3 = new Ht(), t3 = new kt();
        return function(n3, r3) {
          var i3 = r3 || t3.getNormalMatrix(n3), a2 = this.coplanarPoint(e3).applyMatrix4(n3), o2 = this.normal.applyMatrix3(i3).normalize();
          return this.constant = -a2.dot(o2), this;
        };
      }(), translate: function(e3) {
        return this.constant -= e3.dot(this.normal), this;
      }, equals: function(e3) {
        return e3.normal.equals(this.normal) && e3.constant === this.constant;
      } }), Object.assign($t.prototype, { set: function(e3, t3, n3, r3, i3, a2) {
        var o2 = this.planes;
        return o2[0].copy(e3), o2[1].copy(t3), o2[2].copy(n3), o2[3].copy(r3), o2[4].copy(i3), o2[5].copy(a2), this;
      }, clone: function() {
        return new this.constructor().copy(this);
      }, copy: function(e3) {
        for (var t3 = this.planes, n3 = 0; n3 < 6; n3++)
          t3[n3].copy(e3.planes[n3]);
        return this;
      }, setFromMatrix: function(e3) {
        var t3 = this.planes, n3 = e3.elements, r3 = n3[0], i3 = n3[1], a2 = n3[2], o2 = n3[3], s2 = n3[4], c3 = n3[5], u3 = n3[6], l3 = n3[7], h3 = n3[8], d3 = n3[9], p3 = n3[10], f3 = n3[11], m3 = n3[12], g3 = n3[13], v3 = n3[14], y3 = n3[15];
        return t3[0].setComponents(o2 - r3, l3 - s2, f3 - h3, y3 - m3).normalize(), t3[1].setComponents(o2 + r3, l3 + s2, f3 + h3, y3 + m3).normalize(), t3[2].setComponents(o2 + i3, l3 + c3, f3 + d3, y3 + g3).normalize(), t3[3].setComponents(o2 - i3, l3 - c3, f3 - d3, y3 - g3).normalize(), t3[4].setComponents(o2 - a2, l3 - u3, f3 - p3, y3 - v3).normalize(), t3[5].setComponents(o2 + a2, l3 + u3, f3 + p3, y3 + v3).normalize(), this;
      }, intersectsObject: function() {
        var e3 = new Kt();
        return function(t3) {
          var n3 = t3.geometry;
          return null === n3.boundingSphere && n3.computeBoundingSphere(), e3.copy(n3.boundingSphere).applyMatrix4(t3.matrixWorld), this.intersectsSphere(e3);
        };
      }(), intersectsSprite: function() {
        var e3 = new Kt();
        return function(t3) {
          return e3.center.set(0, 0, 0), e3.radius = 0.7071067811865476, e3.applyMatrix4(t3.matrixWorld), this.intersectsSphere(e3);
        };
      }(), intersectsSphere: function(e3) {
        for (var t3 = this.planes, n3 = e3.center, r3 = -e3.radius, i3 = 0; i3 < 6; i3++) {
          if (t3[i3].distanceToPoint(n3) < r3)
            return false;
        }
        return true;
      }, intersectsBox: function() {
        var e3 = new Ht();
        return function(t3) {
          for (var n3 = this.planes, r3 = 0; r3 < 6; r3++) {
            var i3 = n3[r3];
            if (e3.x = i3.normal.x > 0 ? t3.max.x : t3.min.x, e3.y = i3.normal.y > 0 ? t3.max.y : t3.min.y, e3.z = i3.normal.z > 0 ? t3.max.z : t3.min.z, i3.distanceToPoint(e3) < 0)
              return false;
          }
          return true;
        };
      }(), containsPoint: function(e3) {
        for (var t3 = this.planes, n3 = 0; n3 < 6; n3++)
          if (t3[n3].distanceToPoint(e3) < 0)
            return false;
        return true;
      } });
      var en = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif\n", alphatest_fragment: "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n", aomap_fragment: "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif\n", aomap_pars_fragment: "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif", begin_vertex: "\nvec3 transformed = vec3( position );\n", beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n", bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	if( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		float maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		return distanceFalloff * maxDistanceCutoffFactor;\n#else\n		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n	}\n	return 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE  = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS  = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n	return specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 );\n		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif\n", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		if ( clipped ) discard;\n	#endif\n#endif\n", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n	#if ! defined( PHYSICAL ) && ! defined( PHONG )\n		varying vec3 vViewPosition;\n	#endif\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n	varying vec3 vViewPosition;\n#endif\n", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n	vViewPosition = - mvPosition.xyz;\n#endif\n", color_fragment: "#ifdef USE_COLOR\n	diffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif\n", color_pars_vertex: "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif", color_vertex: "#ifdef USE_COLOR\n	vColor.xyz = color.xyz;\n#endif", common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\n", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n	vec3 absDirection = abs(direction);\n	int face = -1;\n	if( absDirection.x > absDirection.z ) {\n		if(absDirection.x > absDirection.y )\n			face = direction.x > 0.0 ? 0 : 3;\n		else\n			face = direction.y > 0.0 ? 1 : 4;\n	}\n	else {\n		if(absDirection.z > absDirection.y )\n			face = direction.z > 0.0 ? 2 : 5;\n		else\n			face = direction.y > 0.0 ? 1 : 4;\n	}\n	return face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n	float scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n	float dxRoughness = dFdx(roughness);\n	float dyRoughness = dFdy(roughness);\n	vec3 dx = dFdx( vec * scale * dxRoughness );\n	vec3 dy = dFdy( vec * scale * dyRoughness );\n	float d = max( dot( dx, dx ), dot( dy, dy ) );\n	d = clamp(d, 1.0, cubeUV_rangeClamp);\n	float mipLevel = 0.5 * log2(d);\n	return vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n	mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n	float a = 16.0 * cubeUV_rcpTextureSize;\n	vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n	vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n	float powScale = exp2_packed.x * exp2_packed.y;\n	float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n	float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n	bool bRes = mipLevel == 0.0;\n	scale =  bRes && (scale < a) ? a : scale;\n	vec3 r;\n	vec2 offset;\n	int face = getFaceFromDirection(direction);\n	float rcpPowScale = 1.0 / powScale;\n	if( face == 0) {\n		r = vec3(direction.x, -direction.z, direction.y);\n		offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n	}\n	else if( face == 1) {\n		r = vec3(direction.y, direction.x, direction.z);\n		offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n	}\n	else if( face == 2) {\n		r = vec3(direction.z, direction.x, direction.y);\n		offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n	}\n	else if( face == 3) {\n		r = vec3(direction.x, direction.z, direction.y);\n		offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n	}\n	else if( face == 4) {\n		r = vec3(direction.y, direction.x, -direction.z);\n		offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n	}\n	else {\n		r = vec3(direction.z, -direction.x, direction.y);\n		offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n	}\n	r = normalize(r);\n	float texelOffset = 0.5 * cubeUV_rcpTextureSize;\n	vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n	vec2 base = offset + vec2( texelOffset );\n	return base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n	float roughnessVal = roughness* cubeUV_maxLods3;\n	float r1 = floor(roughnessVal);\n	float r2 = r1 + 1.0;\n	float t = fract(roughnessVal);\n	vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n	float s = mipInfo.y;\n	float level0 = mipInfo.x;\n	float level1 = level0 + 1.0;\n	level1 = level1 > 5.0 ? 5.0 : level1;\n	level0 += min( floor( s + 0.5 ), 5.0 );\n	vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n	vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n	vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n	vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n	vec4 result = mix(color10, color20, t);\n	return vec4(result.rgb, 1.0);\n}\n#endif\n", defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif\n", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif\n", encodings_fragment: "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.x, max( value.g, value.b ) );\n	float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M            = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.x, max( value.g, value.b ) );\n	float D      = max( maxRange / maxRGB, 1.0 );\n	D            = min( floor( D ) / 255.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n	vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n	Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract(Le);\n	vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n	return vec4( max(vRGB, 0.0), 1.0 );\n}\n", envmap_fragment: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		reflectVec = normalize( reflectVec );\n		sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n		sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		reflectVec = normalize( reflectVec );\n		vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	envColor = envMapTexelToLinear( envColor );\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif\n", envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n	uniform float reflectivity;\n	uniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n	#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n		varying vec3 vWorldPosition;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif\n", envmap_pars_vertex: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif\n", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			vec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n		#else\n			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			vec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n		#elif defined( ENVMAP_TYPE_EQUIREC )\n			vec2 sampleUV;\n			sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n			sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_SPHERE )\n			vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif\n", envmap_vertex: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif\n", fog_vertex: "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n", fog_fragment: "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n", fog_pars_fragment: "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float fogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif\n", gradientmap_pars_fragment: "#ifdef TOON\n	uniform sampler2D gradientMap;\n	vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n		float dotNL = dot( normal, lightDirection );\n		vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n		#ifdef USE_GRADIENTMAP\n			return texture2D( gradientMap, coord ).rgb;\n		#else\n			return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n		#endif\n	}\n#endif\n", lightmap_fragment: "#ifdef USE_LIGHTMAP\n	reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n#endif\n", lights_pars_begin: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n		float shadowCameraNear;\n		float shadowCameraFar;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n		directLight.visible = ( directLight.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( angleCos > spotLight.coneCos ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif\n", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n", lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3	diffuseColor;\n	vec3	specularColor;\n	float	specularShininess;\n	float	specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	#ifdef TOON\n		vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	#else\n		float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n		vec3 irradiance = dotNL * directLight.color;\n	#endif\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)\n", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n	material.clearCoat = saturate( clearCoat );	material.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n", lights_physical_pars_fragment: "struct PhysicalMaterial {\n	vec3	diffuseColor;\n	float	specularRoughness;\n	vec3	specularColor;\n	#ifndef STANDARD\n		float clearCoat;\n		float clearCoatRoughness;\n	#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.specularRoughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos - halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifndef STANDARD\n		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n	#else\n		float clearCoatDHR = 0.0;\n	#endif\n	reflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n	reflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	#ifndef STANDARD\n		reflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n	#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	#ifndef STANDARD\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		float dotNL = dotNV;\n		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n	#else\n		float clearCoatDHR = 0.0;\n	#endif\n	reflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n	#ifndef STANDARD\n		reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n	#endif\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearCoatRadiance = vec3( 0.0 );\n#endif\n", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n		irradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n	#ifndef STANDARD\n		clearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n	#endif\n#endif\n", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#ifdef USE_LOGDEPTHBUF\n	uniform float logDepthBufFC;\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#endif\n#endif\n", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#endif\n	uniform float logDepthBufFC;\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n	#else\n		gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n		gl_Position.z *= gl_Position.w;\n	#endif\n#endif\n", map_fragment: "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif\n", map_pars_fragment: "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n", map_particle_fragment: "#ifdef USE_MAP\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n", map_particle_pars_fragment: "#ifdef USE_MAP\n	uniform mat3 uvTransform;\n	uniform sampler2D map;\n#endif\n", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif\n", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n	#ifndef USE_MORPHNORMALS\n	uniform float morphTargetInfluences[ 8 ];\n	#else\n	uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n	#endif\n#endif\n", normal_fragment_begin: "#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#endif\n#endif\n", normal_fragment_maps: "#ifdef USE_NORMALMAP\n	#ifdef OBJECTSPACE_NORMALMAP\n		normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		#ifdef FLIP_SIDED\n			normal = - normal;\n		#endif\n		#ifdef DOUBLE_SIDED\n			normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		#endif\n		normal = normalize( normalMatrix * normal );\n	#else\n		normal = perturbNormal2Arb( -vViewPosition, normal );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n	#ifdef OBJECTSPACE_NORMALMAP\n		uniform mat3 normalMatrix;\n	#else\n		vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n			vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n			vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n			vec2 st0 = dFdx( vUv.st );\n			vec2 st1 = dFdy( vUv.st );\n			float scale = sign( st1.t * st0.s - st0.t * st1.s );\n			vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n			vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n			vec3 N = normalize( surf_norm );\n			mat3 tsn = mat3( S, T, N );\n			vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n			mapN.xy *= normalScale;\n			mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n			return normalize( tsn * mapN );\n		}\n	#endif\n#endif\n", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif\n", project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n", dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n", dithering_pars_fragment: "#if defined( DITHERING )\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif\n", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif\n", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n		const vec2 offset = vec2( 0.0, 1.0 );\n		vec2 texelSize = vec2( 1.0 ) / size;\n		vec2 centroidUV = floor( uv * size + 0.5 ) / size;\n		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n		vec2 f = fract( uv * size + 0.5 );\n		float a = mix( lb, lt, f.y );\n		float b = mix( rb, rt, f.y );\n		float c = mix( a, b, f.x );\n		return c;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			shadow = (\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif\n", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n#endif\n", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n#endif\n", shadowmask_pars_fragment: "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	DirectionalLight directionalLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	SpotLight spotLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		shadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	PointLight pointLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		shadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#endif\n	#endif\n	return shadow;\n}\n", skinbase_vertex: "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif\n", skinning_vertex: "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n", skinnormal_vertex: "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n", tonemapping_pars_fragment: "#ifndef saturate\n	#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n", uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n#endif", uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif\n", uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = uv2;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n	vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n", cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n	gl_FragColor.a *= opacity;\n}\n", cube_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n	vWorldPosition = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}\n", depth_frag: "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n	#endif\n}\n", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}\n", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}\n", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldPosition );\n	vec2 sampleUV;\n	sampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n}\n", equirect_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n	vWorldPosition = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}\n", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	vLineDistance = scale * lineDistance;\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}\n", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}\n", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}\n", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}\n", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}\n", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}\n", meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n	uniform float clearCoat;\n	uniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}\n", meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}\n", normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n", normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}\n", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#ifdef USE_SIZEATTENUATION\n		gl_PointSize = size * ( scale / - mvPosition.z );\n	#else\n		gl_PointSize = size;\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}\n", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <fog_fragment>\n}\n", shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}\n", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	vec4 mvPosition;\n	mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}\n" }, tn = { merge: function(e3) {
        for (var t3 = {}, n3 = 0; n3 < e3.length; n3++) {
          var r3 = this.clone(e3[n3]);
          for (var i3 in r3)
            t3[i3] = r3[i3];
        }
        return t3;
      }, clone: function(e3) {
        var t3 = {};
        for (var n3 in e3)
          for (var r3 in t3[n3] = {}, e3[n3]) {
            var i3 = e3[n3][r3];
            i3 && (i3.isColor || i3.isMatrix3 || i3.isMatrix4 || i3.isVector2 || i3.isVector3 || i3.isVector4 || i3.isTexture) ? t3[n3][r3] = i3.clone() : Array.isArray(i3) ? t3[n3][r3] = i3.slice() : t3[n3][r3] = i3;
          }
        return t3;
      } }, nn = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 };
      function rn(e3, t3, n3) {
        return void 0 === t3 && void 0 === n3 ? this.set(e3) : this.setRGB(e3, t3, n3);
      }
      Object.assign(rn.prototype, { isColor: true, r: 1, g: 1, b: 1, set: function(e3) {
        return e3 && e3.isColor ? this.copy(e3) : "number" == typeof e3 ? this.setHex(e3) : "string" == typeof e3 && this.setStyle(e3), this;
      }, setScalar: function(e3) {
        return this.r = e3, this.g = e3, this.b = e3, this;
      }, setHex: function(e3) {
        return e3 = Math.floor(e3), this.r = (e3 >> 16 & 255) / 255, this.g = (e3 >> 8 & 255) / 255, this.b = (255 & e3) / 255, this;
      }, setRGB: function(e3, t3, n3) {
        return this.r = e3, this.g = t3, this.b = n3, this;
      }, setHSL: function() {
        function e3(e4, t3, n3) {
          return n3 < 0 && (n3 += 1), n3 > 1 && (n3 -= 1), n3 < 1 / 6 ? e4 + 6 * (t3 - e4) * n3 : n3 < 0.5 ? t3 : n3 < 2 / 3 ? e4 + 6 * (t3 - e4) * (2 / 3 - n3) : e4;
        }
        return function(t3, n3, r3) {
          if (t3 = Bt.euclideanModulo(t3, 1), n3 = Bt.clamp(n3, 0, 1), r3 = Bt.clamp(r3, 0, 1), 0 === n3)
            this.r = this.g = this.b = r3;
          else {
            var i3 = r3 <= 0.5 ? r3 * (1 + n3) : r3 + n3 - r3 * n3, a2 = 2 * r3 - i3;
            this.r = e3(a2, i3, t3 + 1 / 3), this.g = e3(a2, i3, t3), this.b = e3(a2, i3, t3 - 1 / 3);
          }
          return this;
        };
      }(), setStyle: function(e3) {
        function t3(t4) {
          void 0 !== t4 && parseFloat(t4) < 1 && console.warn("THREE.Color: Alpha component of " + e3 + " will be ignored.");
        }
        var n3;
        if (n3 = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e3)) {
          var r3, i3 = n3[1], a2 = n3[2];
          switch (i3) {
            case "rgb":
            case "rgba":
              if (r3 = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a2))
                return this.r = Math.min(255, parseInt(r3[1], 10)) / 255, this.g = Math.min(255, parseInt(r3[2], 10)) / 255, this.b = Math.min(255, parseInt(r3[3], 10)) / 255, t3(r3[5]), this;
              if (r3 = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a2))
                return this.r = Math.min(100, parseInt(r3[1], 10)) / 100, this.g = Math.min(100, parseInt(r3[2], 10)) / 100, this.b = Math.min(100, parseInt(r3[3], 10)) / 100, t3(r3[5]), this;
              break;
            case "hsl":
            case "hsla":
              if (r3 = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a2)) {
                var o2 = parseFloat(r3[1]) / 360, s2 = parseInt(r3[2], 10) / 100, c3 = parseInt(r3[3], 10) / 100;
                return t3(r3[5]), this.setHSL(o2, s2, c3);
              }
          }
        } else if (n3 = /^\#([A-Fa-f0-9]+)$/.exec(e3)) {
          var u3, l3 = (u3 = n3[1]).length;
          if (3 === l3)
            return this.r = parseInt(u3.charAt(0) + u3.charAt(0), 16) / 255, this.g = parseInt(u3.charAt(1) + u3.charAt(1), 16) / 255, this.b = parseInt(u3.charAt(2) + u3.charAt(2), 16) / 255, this;
          if (6 === l3)
            return this.r = parseInt(u3.charAt(0) + u3.charAt(1), 16) / 255, this.g = parseInt(u3.charAt(2) + u3.charAt(3), 16) / 255, this.b = parseInt(u3.charAt(4) + u3.charAt(5), 16) / 255, this;
        }
        e3 && e3.length > 0 && (void 0 !== (u3 = nn[e3]) ? this.setHex(u3) : console.warn("THREE.Color: Unknown color " + e3));
        return this;
      }, clone: function() {
        return new this.constructor(this.r, this.g, this.b);
      }, copy: function(e3) {
        return this.r = e3.r, this.g = e3.g, this.b = e3.b, this;
      }, copyGammaToLinear: function(e3, t3) {
        return void 0 === t3 && (t3 = 2), this.r = Math.pow(e3.r, t3), this.g = Math.pow(e3.g, t3), this.b = Math.pow(e3.b, t3), this;
      }, copyLinearToGamma: function(e3, t3) {
        void 0 === t3 && (t3 = 2);
        var n3 = t3 > 0 ? 1 / t3 : 1;
        return this.r = Math.pow(e3.r, n3), this.g = Math.pow(e3.g, n3), this.b = Math.pow(e3.b, n3), this;
      }, convertGammaToLinear: function(e3) {
        return this.copyGammaToLinear(this, e3), this;
      }, convertLinearToGamma: function(e3) {
        return this.copyLinearToGamma(this, e3), this;
      }, copySRGBToLinear: function() {
        function e3(e4) {
          return e4 < 0.04045 ? 0.0773993808 * e4 : Math.pow(0.9478672986 * e4 + 0.0521327014, 2.4);
        }
        return function(t3) {
          return this.r = e3(t3.r), this.g = e3(t3.g), this.b = e3(t3.b), this;
        };
      }(), copyLinearToSRGB: function() {
        function e3(e4) {
          return e4 < 31308e-7 ? 12.92 * e4 : 1.055 * Math.pow(e4, 0.41666) - 0.055;
        }
        return function(t3) {
          return this.r = e3(t3.r), this.g = e3(t3.g), this.b = e3(t3.b), this;
        };
      }(), convertSRGBToLinear: function() {
        return this.copySRGBToLinear(this), this;
      }, convertLinearToSRGB: function() {
        return this.copyLinearToSRGB(this), this;
      }, getHex: function() {
        return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
      }, getHexString: function() {
        return ("000000" + this.getHex().toString(16)).slice(-6);
      }, getHSL: function(e3) {
        void 0 === e3 && (console.warn("THREE.Color: .getHSL() target is now required"), e3 = { h: 0, s: 0, l: 0 });
        var t3, n3, r3 = this.r, i3 = this.g, a2 = this.b, o2 = Math.max(r3, i3, a2), s2 = Math.min(r3, i3, a2), c3 = (s2 + o2) / 2;
        if (s2 === o2)
          t3 = 0, n3 = 0;
        else {
          var u3 = o2 - s2;
          switch (n3 = c3 <= 0.5 ? u3 / (o2 + s2) : u3 / (2 - o2 - s2), o2) {
            case r3:
              t3 = (i3 - a2) / u3 + (i3 < a2 ? 6 : 0);
              break;
            case i3:
              t3 = (a2 - r3) / u3 + 2;
              break;
            case a2:
              t3 = (r3 - i3) / u3 + 4;
          }
          t3 /= 6;
        }
        return e3.h = t3, e3.s = n3, e3.l = c3, e3;
      }, getStyle: function() {
        return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
      }, offsetHSL: function() {
        var e3 = {};
        return function(t3, n3, r3) {
          return this.getHSL(e3), e3.h += t3, e3.s += n3, e3.l += r3, this.setHSL(e3.h, e3.s, e3.l), this;
        };
      }(), add: function(e3) {
        return this.r += e3.r, this.g += e3.g, this.b += e3.b, this;
      }, addColors: function(e3, t3) {
        return this.r = e3.r + t3.r, this.g = e3.g + t3.g, this.b = e3.b + t3.b, this;
      }, addScalar: function(e3) {
        return this.r += e3, this.g += e3, this.b += e3, this;
      }, sub: function(e3) {
        return this.r = Math.max(0, this.r - e3.r), this.g = Math.max(0, this.g - e3.g), this.b = Math.max(0, this.b - e3.b), this;
      }, multiply: function(e3) {
        return this.r *= e3.r, this.g *= e3.g, this.b *= e3.b, this;
      }, multiplyScalar: function(e3) {
        return this.r *= e3, this.g *= e3, this.b *= e3, this;
      }, lerp: function(e3, t3) {
        return this.r += (e3.r - this.r) * t3, this.g += (e3.g - this.g) * t3, this.b += (e3.b - this.b) * t3, this;
      }, equals: function(e3) {
        return e3.r === this.r && e3.g === this.g && e3.b === this.b;
      }, fromArray: function(e3, t3) {
        return void 0 === t3 && (t3 = 0), this.r = e3[t3], this.g = e3[t3 + 1], this.b = e3[t3 + 2], this;
      }, toArray: function(e3, t3) {
        return void 0 === e3 && (e3 = []), void 0 === t3 && (t3 = 0), e3[t3] = this.r, e3[t3 + 1] = this.g, e3[t3 + 2] = this.b, e3;
      }, toJSON: function() {
        return this.getHex();
      } });
      var an = { common: { diffuse: { value: new rn(15658734) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new kt() }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: 0.98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new Ft(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new rn(16777215) } }, lights: { ambientLightColor: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } } }, points: { diffuse: { value: new rn(15658734) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, uvTransform: { value: new kt() } }, sprite: { diffuse: { value: new rn(15658734) }, opacity: { value: 1 }, center: { value: new Ft(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, uvTransform: { value: new kt() } } }, on = { basic: { uniforms: tn.merge([an.common, an.specularmap, an.envmap, an.aomap, an.lightmap, an.fog]), vertexShader: en.meshbasic_vert, fragmentShader: en.meshbasic_frag }, lambert: { uniforms: tn.merge([an.common, an.specularmap, an.envmap, an.aomap, an.lightmap, an.emissivemap, an.fog, an.lights, { emissive: { value: new rn(0) } }]), vertexShader: en.meshlambert_vert, fragmentShader: en.meshlambert_frag }, phong: { uniforms: tn.merge([an.common, an.specularmap, an.envmap, an.aomap, an.lightmap, an.emissivemap, an.bumpmap, an.normalmap, an.displacementmap, an.gradientmap, an.fog, an.lights, { emissive: { value: new rn(0) }, specular: { value: new rn(1118481) }, shininess: { value: 30 } }]), vertexShader: en.meshphong_vert, fragmentShader: en.meshphong_frag }, standard: { uniforms: tn.merge([an.common, an.envmap, an.aomap, an.lightmap, an.emissivemap, an.bumpmap, an.normalmap, an.displacementmap, an.roughnessmap, an.metalnessmap, an.fog, an.lights, { emissive: { value: new rn(0) }, roughness: { value: 0.5 }, metalness: { value: 0.5 }, envMapIntensity: { value: 1 } }]), vertexShader: en.meshphysical_vert, fragmentShader: en.meshphysical_frag }, points: { uniforms: tn.merge([an.points, an.fog]), vertexShader: en.points_vert, fragmentShader: en.points_frag }, dashed: { uniforms: tn.merge([an.common, an.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: en.linedashed_vert, fragmentShader: en.linedashed_frag }, depth: { uniforms: tn.merge([an.common, an.displacementmap]), vertexShader: en.depth_vert, fragmentShader: en.depth_frag }, normal: { uniforms: tn.merge([an.common, an.bumpmap, an.normalmap, an.displacementmap, { opacity: { value: 1 } }]), vertexShader: en.normal_vert, fragmentShader: en.normal_frag }, sprite: { uniforms: tn.merge([an.sprite, an.fog]), vertexShader: en.sprite_vert, fragmentShader: en.sprite_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: en.cube_vert, fragmentShader: en.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: en.equirect_vert, fragmentShader: en.equirect_frag }, distanceRGBA: { uniforms: tn.merge([an.common, an.displacementmap, { referencePosition: { value: new Ht() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: en.distanceRGBA_vert, fragmentShader: en.distanceRGBA_frag }, shadow: { uniforms: tn.merge([an.lights, an.fog, { color: { value: new rn(0) }, opacity: { value: 1 } }]), vertexShader: en.shadow_vert, fragmentShader: en.shadow_frag } };
      function sn() {
        var e3 = null, t3 = false, n3 = null;
        function r3(i3, a2) {
          false !== t3 && (n3(i3, a2), e3.requestAnimationFrame(r3));
        }
        return { start: function() {
          true !== t3 && null !== n3 && (e3.requestAnimationFrame(r3), t3 = true);
        }, stop: function() {
          t3 = false;
        }, setAnimationLoop: function(e4) {
          n3 = e4;
        }, setContext: function(t4) {
          e3 = t4;
        } };
      }
      function cn(e3) {
        var t3 = /* @__PURE__ */ new WeakMap();
        return { get: function(e4) {
          return e4.isInterleavedBufferAttribute && (e4 = e4.data), t3.get(e4);
        }, remove: function(n3) {
          n3.isInterleavedBufferAttribute && (n3 = n3.data);
          var r3 = t3.get(n3);
          r3 && (e3.deleteBuffer(r3.buffer), t3.delete(n3));
        }, update: function(n3, r3) {
          n3.isInterleavedBufferAttribute && (n3 = n3.data);
          var i3 = t3.get(n3);
          void 0 === i3 ? t3.set(n3, function(t4, n4) {
            var r4 = t4.array, i4 = t4.dynamic ? e3.DYNAMIC_DRAW : e3.STATIC_DRAW, a2 = e3.createBuffer();
            e3.bindBuffer(n4, a2), e3.bufferData(n4, r4, i4), t4.onUploadCallback();
            var o2 = e3.FLOAT;
            return r4 instanceof Float32Array ? o2 = e3.FLOAT : r4 instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r4 instanceof Uint16Array ? o2 = e3.UNSIGNED_SHORT : r4 instanceof Int16Array ? o2 = e3.SHORT : r4 instanceof Uint32Array ? o2 = e3.UNSIGNED_INT : r4 instanceof Int32Array ? o2 = e3.INT : r4 instanceof Int8Array ? o2 = e3.BYTE : r4 instanceof Uint8Array && (o2 = e3.UNSIGNED_BYTE), { buffer: a2, type: o2, bytesPerElement: r4.BYTES_PER_ELEMENT, version: t4.version };
          }(n3, r3)) : i3.version < n3.version && (function(t4, n4, r4) {
            var i4 = n4.array, a2 = n4.updateRange;
            e3.bindBuffer(r4, t4), false === n4.dynamic ? e3.bufferData(r4, i4, e3.STATIC_DRAW) : -1 === a2.count ? e3.bufferSubData(r4, 0, i4) : 0 === a2.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (e3.bufferSubData(r4, a2.offset * i4.BYTES_PER_ELEMENT, i4.subarray(a2.offset, a2.offset + a2.count)), a2.count = -1);
          }(i3.buffer, n3, r3), i3.version = n3.version);
        } };
      }
      function un(e3, t3, n3, r3) {
        this._x = e3 || 0, this._y = t3 || 0, this._z = n3 || 0, this._order = r3 || un.DefaultOrder;
      }
      function ln() {
        this.mask = 1;
      }
      on.physical = { uniforms: tn.merge([on.standard.uniforms, { clearCoat: { value: 0 }, clearCoatRoughness: { value: 0 } }]), vertexShader: en.meshphysical_vert, fragmentShader: en.meshphysical_frag }, un.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], un.DefaultOrder = "XYZ", Object.defineProperties(un.prototype, { x: { get: function() {
        return this._x;
      }, set: function(e3) {
        this._x = e3, this.onChangeCallback();
      } }, y: { get: function() {
        return this._y;
      }, set: function(e3) {
        this._y = e3, this.onChangeCallback();
      } }, z: { get: function() {
        return this._z;
      }, set: function(e3) {
        this._z = e3, this.onChangeCallback();
      } }, order: { get: function() {
        return this._order;
      }, set: function(e3) {
        this._order = e3, this.onChangeCallback();
      } } }), Object.assign(un.prototype, { isEuler: true, set: function(e3, t3, n3, r3) {
        return this._x = e3, this._y = t3, this._z = n3, this._order = r3 || this._order, this.onChangeCallback(), this;
      }, clone: function() {
        return new this.constructor(this._x, this._y, this._z, this._order);
      }, copy: function(e3) {
        return this._x = e3._x, this._y = e3._y, this._z = e3._z, this._order = e3._order, this.onChangeCallback(), this;
      }, setFromRotationMatrix: function(e3, t3, n3) {
        var r3 = Bt.clamp, i3 = e3.elements, a2 = i3[0], o2 = i3[4], s2 = i3[8], c3 = i3[1], u3 = i3[5], l3 = i3[9], h3 = i3[2], d3 = i3[6], p3 = i3[10];
        return "XYZ" === (t3 = t3 || this._order) ? (this._y = Math.asin(r3(s2, -1, 1)), Math.abs(s2) < 0.99999 ? (this._x = Math.atan2(-l3, p3), this._z = Math.atan2(-o2, a2)) : (this._x = Math.atan2(d3, u3), this._z = 0)) : "YXZ" === t3 ? (this._x = Math.asin(-r3(l3, -1, 1)), Math.abs(l3) < 0.99999 ? (this._y = Math.atan2(s2, p3), this._z = Math.atan2(c3, u3)) : (this._y = Math.atan2(-h3, a2), this._z = 0)) : "ZXY" === t3 ? (this._x = Math.asin(r3(d3, -1, 1)), Math.abs(d3) < 0.99999 ? (this._y = Math.atan2(-h3, p3), this._z = Math.atan2(-o2, u3)) : (this._y = 0, this._z = Math.atan2(c3, a2))) : "ZYX" === t3 ? (this._y = Math.asin(-r3(h3, -1, 1)), Math.abs(h3) < 0.99999 ? (this._x = Math.atan2(d3, p3), this._z = Math.atan2(c3, a2)) : (this._x = 0, this._z = Math.atan2(-o2, u3))) : "YZX" === t3 ? (this._z = Math.asin(r3(c3, -1, 1)), Math.abs(c3) < 0.99999 ? (this._x = Math.atan2(-l3, u3), this._y = Math.atan2(-h3, a2)) : (this._x = 0, this._y = Math.atan2(s2, p3))) : "XZY" === t3 ? (this._z = Math.asin(-r3(o2, -1, 1)), Math.abs(o2) < 0.99999 ? (this._x = Math.atan2(d3, u3), this._y = Math.atan2(s2, a2)) : (this._x = Math.atan2(-l3, p3), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t3), this._order = t3, false !== n3 && this.onChangeCallback(), this;
      }, setFromQuaternion: function() {
        var e3 = new Gt();
        return function(t3, n3, r3) {
          return e3.makeRotationFromQuaternion(t3), this.setFromRotationMatrix(e3, n3, r3);
        };
      }(), setFromVector3: function(e3, t3) {
        return this.set(e3.x, e3.y, e3.z, t3 || this._order);
      }, reorder: function() {
        var e3 = new zt();
        return function(t3) {
          return e3.setFromEuler(this), this.setFromQuaternion(e3, t3);
        };
      }(), equals: function(e3) {
        return e3._x === this._x && e3._y === this._y && e3._z === this._z && e3._order === this._order;
      }, fromArray: function(e3) {
        return this._x = e3[0], this._y = e3[1], this._z = e3[2], void 0 !== e3[3] && (this._order = e3[3]), this.onChangeCallback(), this;
      }, toArray: function(e3, t3) {
        return void 0 === e3 && (e3 = []), void 0 === t3 && (t3 = 0), e3[t3] = this._x, e3[t3 + 1] = this._y, e3[t3 + 2] = this._z, e3[t3 + 3] = this._order, e3;
      }, toVector3: function(e3) {
        return e3 ? e3.set(this._x, this._y, this._z) : new Ht(this._x, this._y, this._z);
      }, onChange: function(e3) {
        return this.onChangeCallback = e3, this;
      }, onChangeCallback: function() {
      } }), Object.assign(ln.prototype, { set: function(e3) {
        this.mask = 1 << e3 | 0;
      }, enable: function(e3) {
        this.mask |= 1 << e3 | 0;
      }, toggle: function(e3) {
        this.mask ^= 1 << e3 | 0;
      }, disable: function(e3) {
        this.mask &= ~(1 << e3 | 0);
      }, test: function(e3) {
        return 0 != (this.mask & e3.mask);
      } });
      var hn = 0;
      function dn() {
        Object.defineProperty(this, "id", { value: hn++ }), this.uuid = Bt.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = dn.DefaultUp.clone();
        var e3 = new Ht(), t3 = new un(), n3 = new zt(), r3 = new Ht(1, 1, 1);
        t3.onChange(function() {
          n3.setFromEuler(t3, false);
        }), n3.onChange(function() {
          t3.setFromQuaternion(n3, void 0, false);
        }), Object.defineProperties(this, { position: { enumerable: true, value: e3 }, rotation: { enumerable: true, value: t3 }, quaternion: { enumerable: true, value: n3 }, scale: { enumerable: true, value: r3 }, modelViewMatrix: { value: new Gt() }, normalMatrix: { value: new kt() } }), this.matrix = new Gt(), this.matrixWorld = new Gt(), this.matrixAutoUpdate = dn.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = false, this.layers = new ln(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.userData = {};
      }
      function pn() {
        dn.call(this), this.type = "Camera", this.matrixWorldInverse = new Gt(), this.projectionMatrix = new Gt();
      }
      function fn(e3, t3, n3, r3, i3, a2) {
        pn.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e3, this.right = t3, this.top = n3, this.bottom = r3, this.near = void 0 !== i3 ? i3 : 0.1, this.far = void 0 !== a2 ? a2 : 2e3, this.updateProjectionMatrix();
      }
      function mn(e3, t3, n3, r3, i3, a2) {
        this.a = e3, this.b = t3, this.c = n3, this.normal = r3 && r3.isVector3 ? r3 : new Ht(), this.vertexNormals = Array.isArray(r3) ? r3 : [], this.color = i3 && i3.isColor ? i3 : new rn(), this.vertexColors = Array.isArray(i3) ? i3 : [], this.materialIndex = void 0 !== a2 ? a2 : 0;
      }
      dn.DefaultUp = new Ht(0, 1, 0), dn.DefaultMatrixAutoUpdate = true, dn.prototype = Object.assign(Object.create(r2.prototype), { constructor: dn, isObject3D: true, onBeforeRender: function() {
      }, onAfterRender: function() {
      }, applyMatrix: function(e3) {
        this.matrix.multiplyMatrices(e3, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale);
      }, applyQuaternion: function(e3) {
        return this.quaternion.premultiply(e3), this;
      }, setRotationFromAxisAngle: function(e3, t3) {
        this.quaternion.setFromAxisAngle(e3, t3);
      }, setRotationFromEuler: function(e3) {
        this.quaternion.setFromEuler(e3, true);
      }, setRotationFromMatrix: function(e3) {
        this.quaternion.setFromRotationMatrix(e3);
      }, setRotationFromQuaternion: function(e3) {
        this.quaternion.copy(e3);
      }, rotateOnAxis: function() {
        var e3 = new zt();
        return function(t3, n3) {
          return e3.setFromAxisAngle(t3, n3), this.quaternion.multiply(e3), this;
        };
      }(), rotateOnWorldAxis: function() {
        var e3 = new zt();
        return function(t3, n3) {
          return e3.setFromAxisAngle(t3, n3), this.quaternion.premultiply(e3), this;
        };
      }(), rotateX: function() {
        var e3 = new Ht(1, 0, 0);
        return function(t3) {
          return this.rotateOnAxis(e3, t3);
        };
      }(), rotateY: function() {
        var e3 = new Ht(0, 1, 0);
        return function(t3) {
          return this.rotateOnAxis(e3, t3);
        };
      }(), rotateZ: function() {
        var e3 = new Ht(0, 0, 1);
        return function(t3) {
          return this.rotateOnAxis(e3, t3);
        };
      }(), translateOnAxis: function() {
        var e3 = new Ht();
        return function(t3, n3) {
          return e3.copy(t3).applyQuaternion(this.quaternion), this.position.add(e3.multiplyScalar(n3)), this;
        };
      }(), translateX: function() {
        var e3 = new Ht(1, 0, 0);
        return function(t3) {
          return this.translateOnAxis(e3, t3);
        };
      }(), translateY: function() {
        var e3 = new Ht(0, 1, 0);
        return function(t3) {
          return this.translateOnAxis(e3, t3);
        };
      }(), translateZ: function() {
        var e3 = new Ht(0, 0, 1);
        return function(t3) {
          return this.translateOnAxis(e3, t3);
        };
      }(), localToWorld: function(e3) {
        return e3.applyMatrix4(this.matrixWorld);
      }, worldToLocal: function() {
        var e3 = new Gt();
        return function(t3) {
          return t3.applyMatrix4(e3.getInverse(this.matrixWorld));
        };
      }(), lookAt: function() {
        var e3 = new Gt(), t3 = new Ht();
        return function(n3, r3, i3) {
          n3.isVector3 ? t3.copy(n3) : t3.set(n3, r3, i3), this.isCamera ? e3.lookAt(this.position, t3, this.up) : e3.lookAt(t3, this.position, this.up), this.quaternion.setFromRotationMatrix(e3);
        };
      }(), add: function(e3) {
        if (arguments.length > 1) {
          for (var t3 = 0; t3 < arguments.length; t3++)
            this.add(arguments[t3]);
          return this;
        }
        return e3 === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e3), this) : (e3 && e3.isObject3D ? (null !== e3.parent && e3.parent.remove(e3), e3.parent = this, e3.dispatchEvent({ type: "added" }), this.children.push(e3)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e3), this);
      }, remove: function(e3) {
        if (arguments.length > 1) {
          for (var t3 = 0; t3 < arguments.length; t3++)
            this.remove(arguments[t3]);
          return this;
        }
        var n3 = this.children.indexOf(e3);
        return -1 !== n3 && (e3.parent = null, e3.dispatchEvent({ type: "removed" }), this.children.splice(n3, 1)), this;
      }, getObjectById: function(e3) {
        return this.getObjectByProperty("id", e3);
      }, getObjectByName: function(e3) {
        return this.getObjectByProperty("name", e3);
      }, getObjectByProperty: function(e3, t3) {
        if (this[e3] === t3)
          return this;
        for (var n3 = 0, r3 = this.children.length; n3 < r3; n3++) {
          var i3 = this.children[n3].getObjectByProperty(e3, t3);
          if (void 0 !== i3)
            return i3;
        }
      }, getWorldPosition: function(e3) {
        return void 0 === e3 && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), e3 = new Ht()), this.updateMatrixWorld(true), e3.setFromMatrixPosition(this.matrixWorld);
      }, getWorldQuaternion: function() {
        var e3 = new Ht(), t3 = new Ht();
        return function(n3) {
          return void 0 === n3 && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), n3 = new zt()), this.updateMatrixWorld(true), this.matrixWorld.decompose(e3, n3, t3), n3;
        };
      }(), getWorldScale: function() {
        var e3 = new Ht(), t3 = new zt();
        return function(n3) {
          return void 0 === n3 && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), n3 = new Ht()), this.updateMatrixWorld(true), this.matrixWorld.decompose(e3, t3, n3), n3;
        };
      }(), getWorldDirection: function() {
        var e3 = new zt();
        return function(t3) {
          return void 0 === t3 && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t3 = new Ht()), this.getWorldQuaternion(e3), t3.set(0, 0, 1).applyQuaternion(e3);
        };
      }(), raycast: function() {
      }, traverse: function(e3) {
        e3(this);
        for (var t3 = this.children, n3 = 0, r3 = t3.length; n3 < r3; n3++)
          t3[n3].traverse(e3);
      }, traverseVisible: function(e3) {
        if (false !== this.visible) {
          e3(this);
          for (var t3 = this.children, n3 = 0, r3 = t3.length; n3 < r3; n3++)
            t3[n3].traverseVisible(e3);
        }
      }, traverseAncestors: function(e3) {
        var t3 = this.parent;
        null !== t3 && (e3(t3), t3.traverseAncestors(e3));
      }, updateMatrix: function() {
        this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
      }, updateMatrixWorld: function(e3) {
        this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e3) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = false, e3 = true);
        for (var t3 = this.children, n3 = 0, r3 = t3.length; n3 < r3; n3++)
          t3[n3].updateMatrixWorld(e3);
      }, toJSON: function(e3) {
        var t3 = void 0 === e3 || "string" == typeof e3, n3 = {};
        t3 && (e3 = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {} }, n3.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" });
        var r3 = {};
        function i3(t4, n4) {
          return void 0 === t4[n4.uuid] && (t4[n4.uuid] = n4.toJSON(e3)), n4.uuid;
        }
        if (r3.uuid = this.uuid, r3.type = this.type, "" !== this.name && (r3.name = this.name), true === this.castShadow && (r3.castShadow = true), true === this.receiveShadow && (r3.receiveShadow = true), false === this.visible && (r3.visible = false), false === this.frustumCulled && (r3.frustumCulled = false), 0 !== this.renderOrder && (r3.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (r3.userData = this.userData), r3.layers = this.layers.mask, r3.matrix = this.matrix.toArray(), false === this.matrixAutoUpdate && (r3.matrixAutoUpdate = false), this.isMesh || this.isLine || this.isPoints) {
          r3.geometry = i3(e3.geometries, this.geometry);
          var a2 = this.geometry.parameters;
          if (void 0 !== a2 && void 0 !== a2.shapes) {
            var o2 = a2.shapes;
            if (Array.isArray(o2))
              for (var s2 = 0, c3 = o2.length; s2 < c3; s2++) {
                var u3 = o2[s2];
                i3(e3.shapes, u3);
              }
            else
              i3(e3.shapes, o2);
          }
        }
        if (void 0 !== this.material)
          if (Array.isArray(this.material)) {
            var l3 = [];
            for (s2 = 0, c3 = this.material.length; s2 < c3; s2++)
              l3.push(i3(e3.materials, this.material[s2]));
            r3.material = l3;
          } else
            r3.material = i3(e3.materials, this.material);
        if (this.children.length > 0) {
          r3.children = [];
          for (s2 = 0; s2 < this.children.length; s2++)
            r3.children.push(this.children[s2].toJSON(e3).object);
        }
        if (t3) {
          var h3 = m3(e3.geometries), d3 = m3(e3.materials), p3 = m3(e3.textures), f3 = m3(e3.images);
          o2 = m3(e3.shapes);
          h3.length > 0 && (n3.geometries = h3), d3.length > 0 && (n3.materials = d3), p3.length > 0 && (n3.textures = p3), f3.length > 0 && (n3.images = f3), o2.length > 0 && (n3.shapes = o2);
        }
        return n3.object = r3, n3;
        function m3(e4) {
          var t4 = [];
          for (var n4 in e4) {
            var r4 = e4[n4];
            delete r4.metadata, t4.push(r4);
          }
          return t4;
        }
      }, clone: function(e3) {
        return new this.constructor().copy(this, e3);
      }, copy: function(e3, t3) {
        if (void 0 === t3 && (t3 = true), this.name = e3.name, this.up.copy(e3.up), this.position.copy(e3.position), this.quaternion.copy(e3.quaternion), this.scale.copy(e3.scale), this.matrix.copy(e3.matrix), this.matrixWorld.copy(e3.matrixWorld), this.matrixAutoUpdate = e3.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e3.matrixWorldNeedsUpdate, this.layers.mask = e3.layers.mask, this.visible = e3.visible, this.castShadow = e3.castShadow, this.receiveShadow = e3.receiveShadow, this.frustumCulled = e3.frustumCulled, this.renderOrder = e3.renderOrder, this.userData = JSON.parse(JSON.stringify(e3.userData)), true === t3)
          for (var n3 = 0; n3 < e3.children.length; n3++) {
            var r3 = e3.children[n3];
            this.add(r3.clone());
          }
        return this;
      } }), pn.prototype = Object.assign(Object.create(dn.prototype), { constructor: pn, isCamera: true, copy: function(e3, t3) {
        return dn.prototype.copy.call(this, e3, t3), this.matrixWorldInverse.copy(e3.matrixWorldInverse), this.projectionMatrix.copy(e3.projectionMatrix), this;
      }, getWorldDirection: function() {
        var e3 = new zt();
        return function(t3) {
          return void 0 === t3 && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t3 = new Ht()), this.getWorldQuaternion(e3), t3.set(0, 0, -1).applyQuaternion(e3);
        };
      }(), updateMatrixWorld: function(e3) {
        dn.prototype.updateMatrixWorld.call(this, e3), this.matrixWorldInverse.getInverse(this.matrixWorld);
      }, clone: function() {
        return new this.constructor().copy(this);
      } }), fn.prototype = Object.assign(Object.create(pn.prototype), { constructor: fn, isOrthographicCamera: true, copy: function(e3, t3) {
        return pn.prototype.copy.call(this, e3, t3), this.left = e3.left, this.right = e3.right, this.top = e3.top, this.bottom = e3.bottom, this.near = e3.near, this.far = e3.far, this.zoom = e3.zoom, this.view = null === e3.view ? null : Object.assign({}, e3.view), this;
      }, setViewOffset: function(e3, t3, n3, r3, i3, a2) {
        null === this.view && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = e3, this.view.fullHeight = t3, this.view.offsetX = n3, this.view.offsetY = r3, this.view.width = i3, this.view.height = a2, this.updateProjectionMatrix();
      }, clearViewOffset: function() {
        null !== this.view && (this.view.enabled = false), this.updateProjectionMatrix();
      }, updateProjectionMatrix: function() {
        var e3 = (this.right - this.left) / (2 * this.zoom), t3 = (this.top - this.bottom) / (2 * this.zoom), n3 = (this.right + this.left) / 2, r3 = (this.top + this.bottom) / 2, i3 = n3 - e3, a2 = n3 + e3, o2 = r3 + t3, s2 = r3 - t3;
        if (null !== this.view && this.view.enabled) {
          var c3 = this.zoom / (this.view.width / this.view.fullWidth), u3 = this.zoom / (this.view.height / this.view.fullHeight), l3 = (this.right - this.left) / this.view.width, h3 = (this.top - this.bottom) / this.view.height;
          a2 = (i3 += l3 * (this.view.offsetX / c3)) + l3 * (this.view.width / c3), s2 = (o2 -= h3 * (this.view.offsetY / u3)) - h3 * (this.view.height / u3);
        }
        this.projectionMatrix.makeOrthographic(i3, a2, o2, s2, this.near, this.far);
      }, toJSON: function(e3) {
        var t3 = dn.prototype.toJSON.call(this, e3);
        return t3.object.zoom = this.zoom, t3.object.left = this.left, t3.object.right = this.right, t3.object.top = this.top, t3.object.bottom = this.bottom, t3.object.near = this.near, t3.object.far = this.far, null !== this.view && (t3.object.view = Object.assign({}, this.view)), t3;
      } }), Object.assign(mn.prototype, { clone: function() {
        return new this.constructor().copy(this);
      }, copy: function(e3) {
        this.a = e3.a, this.b = e3.b, this.c = e3.c, this.normal.copy(e3.normal), this.color.copy(e3.color), this.materialIndex = e3.materialIndex;
        for (var t3 = 0, n3 = e3.vertexNormals.length; t3 < n3; t3++)
          this.vertexNormals[t3] = e3.vertexNormals[t3].clone();
        for (t3 = 0, n3 = e3.vertexColors.length; t3 < n3; t3++)
          this.vertexColors[t3] = e3.vertexColors[t3].clone();
        return this;
      } });
      var gn = 0;
      function vn() {
        Object.defineProperty(this, "id", { value: gn += 2 }), this.uuid = Bt.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = false, this.verticesNeedUpdate = false, this.uvsNeedUpdate = false, this.normalsNeedUpdate = false, this.colorsNeedUpdate = false, this.lineDistancesNeedUpdate = false, this.groupsNeedUpdate = false;
      }
      function yn(e3, t3, n3) {
        if (Array.isArray(e3))
          throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "", this.array = e3, this.itemSize = t3, this.count = void 0 !== e3 ? e3.length / t3 : 0, this.normalized = true === n3, this.dynamic = false, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
      }
      function xn(e3, t3, n3) {
        yn.call(this, new Int8Array(e3), t3, n3);
      }
      function bn(e3, t3, n3) {
        yn.call(this, new Uint8Array(e3), t3, n3);
      }
      function wn(e3, t3, n3) {
        yn.call(this, new Uint8ClampedArray(e3), t3, n3);
      }
      function _n(e3, t3, n3) {
        yn.call(this, new Int16Array(e3), t3, n3);
      }
      function Mn(e3, t3, n3) {
        yn.call(this, new Uint16Array(e3), t3, n3);
      }
      function En(e3, t3, n3) {
        yn.call(this, new Int32Array(e3), t3, n3);
      }
      function Tn(e3, t3, n3) {
        yn.call(this, new Uint32Array(e3), t3, n3);
      }
      function Sn(e3, t3, n3) {
        yn.call(this, new Float32Array(e3), t3, n3);
      }
      function An(e3, t3, n3) {
        yn.call(this, new Float64Array(e3), t3, n3);
      }
      function Ln() {
        this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = false, this.normalsNeedUpdate = false, this.colorsNeedUpdate = false, this.uvsNeedUpdate = false, this.groupsNeedUpdate = false;
      }
      function Rn(e3) {
        if (0 === e3.length)
          return -1 / 0;
        for (var t3 = e3[0], n3 = 1, r3 = e3.length; n3 < r3; ++n3)
          e3[n3] > t3 && (t3 = e3[n3]);
        return t3;
      }
      vn.prototype = Object.assign(Object.create(r2.prototype), { constructor: vn, isGeometry: true, applyMatrix: function(e3) {
        for (var t3 = new kt().getNormalMatrix(e3), n3 = 0, r3 = this.vertices.length; n3 < r3; n3++) {
          this.vertices[n3].applyMatrix4(e3);
        }
        for (n3 = 0, r3 = this.faces.length; n3 < r3; n3++) {
          var i3 = this.faces[n3];
          i3.normal.applyMatrix3(t3).normalize();
          for (var a2 = 0, o2 = i3.vertexNormals.length; a2 < o2; a2++)
            i3.vertexNormals[a2].applyMatrix3(t3).normalize();
        }
        return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = true, this.normalsNeedUpdate = true, this;
      }, rotateX: function() {
        var e3 = new Gt();
        return function(t3) {
          return e3.makeRotationX(t3), this.applyMatrix(e3), this;
        };
      }(), rotateY: function() {
        var e3 = new Gt();
        return function(t3) {
          return e3.makeRotationY(t3), this.applyMatrix(e3), this;
        };
      }(), rotateZ: function() {
        var e3 = new Gt();
        return function(t3) {
          return e3.makeRotationZ(t3), this.applyMatrix(e3), this;
        };
      }(), translate: function() {
        var e3 = new Gt();
        return function(t3, n3, r3) {
          return e3.makeTranslation(t3, n3, r3), this.applyMatrix(e3), this;
        };
      }(), scale: function() {
        var e3 = new Gt();
        return function(t3, n3, r3) {
          return e3.makeScale(t3, n3, r3), this.applyMatrix(e3), this;
        };
      }(), lookAt: function() {
        var e3 = new dn();
        return function(t3) {
          e3.lookAt(t3), e3.updateMatrix(), this.applyMatrix(e3.matrix);
        };
      }(), fromBufferGeometry: function(e3) {
        var t3 = this, n3 = null !== e3.index ? e3.index.array : void 0, r3 = e3.attributes, i3 = r3.position.array, a2 = void 0 !== r3.normal ? r3.normal.array : void 0, o2 = void 0 !== r3.color ? r3.color.array : void 0, s2 = void 0 !== r3.uv ? r3.uv.array : void 0, c3 = void 0 !== r3.uv2 ? r3.uv2.array : void 0;
        void 0 !== c3 && (this.faceVertexUvs[1] = []);
        for (var u3 = [], l3 = [], h3 = [], d3 = 0, p3 = 0; d3 < i3.length; d3 += 3, p3 += 2)
          t3.vertices.push(new Ht(i3[d3], i3[d3 + 1], i3[d3 + 2])), void 0 !== a2 && u3.push(new Ht(a2[d3], a2[d3 + 1], a2[d3 + 2])), void 0 !== o2 && t3.colors.push(new rn(o2[d3], o2[d3 + 1], o2[d3 + 2])), void 0 !== s2 && l3.push(new Ft(s2[p3], s2[p3 + 1])), void 0 !== c3 && h3.push(new Ft(c3[p3], c3[p3 + 1]));
        function f3(e4, n4, r4, i4) {
          var d4 = new mn(e4, n4, r4, void 0 !== a2 ? [u3[e4].clone(), u3[n4].clone(), u3[r4].clone()] : [], void 0 !== o2 ? [t3.colors[e4].clone(), t3.colors[n4].clone(), t3.colors[r4].clone()] : [], i4);
          t3.faces.push(d4), void 0 !== s2 && t3.faceVertexUvs[0].push([l3[e4].clone(), l3[n4].clone(), l3[r4].clone()]), void 0 !== c3 && t3.faceVertexUvs[1].push([h3[e4].clone(), h3[n4].clone(), h3[r4].clone()]);
        }
        var m3 = e3.groups;
        if (m3.length > 0)
          for (d3 = 0; d3 < m3.length; d3++)
            for (var g3 = m3[d3], v3 = g3.start, y3 = (p3 = v3, v3 + g3.count); p3 < y3; p3 += 3)
              void 0 !== n3 ? f3(n3[p3], n3[p3 + 1], n3[p3 + 2], g3.materialIndex) : f3(p3, p3 + 1, p3 + 2, g3.materialIndex);
        else if (void 0 !== n3)
          for (d3 = 0; d3 < n3.length; d3 += 3)
            f3(n3[d3], n3[d3 + 1], n3[d3 + 2]);
        else
          for (d3 = 0; d3 < i3.length / 3; d3 += 3)
            f3(d3, d3 + 1, d3 + 2);
        return this.computeFaceNormals(), null !== e3.boundingBox && (this.boundingBox = e3.boundingBox.clone()), null !== e3.boundingSphere && (this.boundingSphere = e3.boundingSphere.clone()), this;
      }, center: function() {
        var e3 = new Ht();
        return function() {
          return this.computeBoundingBox(), this.boundingBox.getCenter(e3).negate(), this.translate(e3.x, e3.y, e3.z), this;
        };
      }(), normalize: function() {
        this.computeBoundingSphere();
        var e3 = this.boundingSphere.center, t3 = this.boundingSphere.radius, n3 = 0 === t3 ? 1 : 1 / t3, r3 = new Gt();
        return r3.set(n3, 0, 0, -n3 * e3.x, 0, n3, 0, -n3 * e3.y, 0, 0, n3, -n3 * e3.z, 0, 0, 0, 1), this.applyMatrix(r3), this;
      }, computeFaceNormals: function() {
        for (var e3 = new Ht(), t3 = new Ht(), n3 = 0, r3 = this.faces.length; n3 < r3; n3++) {
          var i3 = this.faces[n3], a2 = this.vertices[i3.a], o2 = this.vertices[i3.b], s2 = this.vertices[i3.c];
          e3.subVectors(s2, o2), t3.subVectors(a2, o2), e3.cross(t3), e3.normalize(), i3.normal.copy(e3);
        }
      }, computeVertexNormals: function(e3) {
        var t3, n3, r3, i3, a2, o2;
        for (void 0 === e3 && (e3 = true), o2 = new Array(this.vertices.length), t3 = 0, n3 = this.vertices.length; t3 < n3; t3++)
          o2[t3] = new Ht();
        if (e3) {
          var s2, c3, u3, l3 = new Ht(), h3 = new Ht();
          for (r3 = 0, i3 = this.faces.length; r3 < i3; r3++)
            a2 = this.faces[r3], s2 = this.vertices[a2.a], c3 = this.vertices[a2.b], u3 = this.vertices[a2.c], l3.subVectors(u3, c3), h3.subVectors(s2, c3), l3.cross(h3), o2[a2.a].add(l3), o2[a2.b].add(l3), o2[a2.c].add(l3);
        } else
          for (this.computeFaceNormals(), r3 = 0, i3 = this.faces.length; r3 < i3; r3++)
            o2[(a2 = this.faces[r3]).a].add(a2.normal), o2[a2.b].add(a2.normal), o2[a2.c].add(a2.normal);
        for (t3 = 0, n3 = this.vertices.length; t3 < n3; t3++)
          o2[t3].normalize();
        for (r3 = 0, i3 = this.faces.length; r3 < i3; r3++) {
          var d3 = (a2 = this.faces[r3]).vertexNormals;
          3 === d3.length ? (d3[0].copy(o2[a2.a]), d3[1].copy(o2[a2.b]), d3[2].copy(o2[a2.c])) : (d3[0] = o2[a2.a].clone(), d3[1] = o2[a2.b].clone(), d3[2] = o2[a2.c].clone());
        }
        this.faces.length > 0 && (this.normalsNeedUpdate = true);
      }, computeFlatVertexNormals: function() {
        var e3, t3, n3;
        for (this.computeFaceNormals(), e3 = 0, t3 = this.faces.length; e3 < t3; e3++) {
          var r3 = (n3 = this.faces[e3]).vertexNormals;
          3 === r3.length ? (r3[0].copy(n3.normal), r3[1].copy(n3.normal), r3[2].copy(n3.normal)) : (r3[0] = n3.normal.clone(), r3[1] = n3.normal.clone(), r3[2] = n3.normal.clone());
        }
        this.faces.length > 0 && (this.normalsNeedUpdate = true);
      }, computeMorphNormals: function() {
        var e3, t3, n3, r3, i3;
        for (n3 = 0, r3 = this.faces.length; n3 < r3; n3++)
          for ((i3 = this.faces[n3]).__originalFaceNormal ? i3.__originalFaceNormal.copy(i3.normal) : i3.__originalFaceNormal = i3.normal.clone(), i3.__originalVertexNormals || (i3.__originalVertexNormals = []), e3 = 0, t3 = i3.vertexNormals.length; e3 < t3; e3++)
            i3.__originalVertexNormals[e3] ? i3.__originalVertexNormals[e3].copy(i3.vertexNormals[e3]) : i3.__originalVertexNormals[e3] = i3.vertexNormals[e3].clone();
        var a2 = new vn();
        for (a2.faces = this.faces, e3 = 0, t3 = this.morphTargets.length; e3 < t3; e3++) {
          if (!this.morphNormals[e3]) {
            this.morphNormals[e3] = {}, this.morphNormals[e3].faceNormals = [], this.morphNormals[e3].vertexNormals = [];
            var o2 = this.morphNormals[e3].faceNormals, s2 = this.morphNormals[e3].vertexNormals;
            for (n3 = 0, r3 = this.faces.length; n3 < r3; n3++)
              c3 = new Ht(), u3 = { a: new Ht(), b: new Ht(), c: new Ht() }, o2.push(c3), s2.push(u3);
          }
          var c3, u3, l3 = this.morphNormals[e3];
          for (a2.vertices = this.morphTargets[e3].vertices, a2.computeFaceNormals(), a2.computeVertexNormals(), n3 = 0, r3 = this.faces.length; n3 < r3; n3++)
            i3 = this.faces[n3], c3 = l3.faceNormals[n3], u3 = l3.vertexNormals[n3], c3.copy(i3.normal), u3.a.copy(i3.vertexNormals[0]), u3.b.copy(i3.vertexNormals[1]), u3.c.copy(i3.vertexNormals[2]);
        }
        for (n3 = 0, r3 = this.faces.length; n3 < r3; n3++)
          (i3 = this.faces[n3]).normal = i3.__originalFaceNormal, i3.vertexNormals = i3.__originalVertexNormals;
      }, computeBoundingBox: function() {
        null === this.boundingBox && (this.boundingBox = new Jt()), this.boundingBox.setFromPoints(this.vertices);
      }, computeBoundingSphere: function() {
        null === this.boundingSphere && (this.boundingSphere = new Kt()), this.boundingSphere.setFromPoints(this.vertices);
      }, merge: function(e3, t3, n3) {
        if (e3 && e3.isGeometry) {
          var r3, i3 = this.vertices.length, a2 = this.vertices, o2 = e3.vertices, s2 = this.faces, c3 = e3.faces, u3 = this.faceVertexUvs[0], l3 = e3.faceVertexUvs[0], h3 = this.colors, d3 = e3.colors;
          void 0 === n3 && (n3 = 0), void 0 !== t3 && (r3 = new kt().getNormalMatrix(t3));
          for (var p3 = 0, f3 = o2.length; p3 < f3; p3++) {
            var m3 = o2[p3].clone();
            void 0 !== t3 && m3.applyMatrix4(t3), a2.push(m3);
          }
          for (p3 = 0, f3 = d3.length; p3 < f3; p3++)
            h3.push(d3[p3].clone());
          for (p3 = 0, f3 = c3.length; p3 < f3; p3++) {
            var g3, v3, y3, x3 = c3[p3], b3 = x3.vertexNormals, w3 = x3.vertexColors;
            (g3 = new mn(x3.a + i3, x3.b + i3, x3.c + i3)).normal.copy(x3.normal), void 0 !== r3 && g3.normal.applyMatrix3(r3).normalize();
            for (var _3 = 0, M3 = b3.length; _3 < M3; _3++)
              v3 = b3[_3].clone(), void 0 !== r3 && v3.applyMatrix3(r3).normalize(), g3.vertexNormals.push(v3);
            g3.color.copy(x3.color);
            for (_3 = 0, M3 = w3.length; _3 < M3; _3++)
              y3 = w3[_3], g3.vertexColors.push(y3.clone());
            g3.materialIndex = x3.materialIndex + n3, s2.push(g3);
          }
          for (p3 = 0, f3 = l3.length; p3 < f3; p3++) {
            var E3 = l3[p3], T3 = [];
            if (void 0 !== E3) {
              for (_3 = 0, M3 = E3.length; _3 < M3; _3++)
                T3.push(E3[_3].clone());
              u3.push(T3);
            }
          }
        } else
          console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e3);
      }, mergeMesh: function(e3) {
        e3 && e3.isMesh ? (e3.matrixAutoUpdate && e3.updateMatrix(), this.merge(e3.geometry, e3.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e3);
      }, mergeVertices: function() {
        var e3, t3, n3, r3, i3, a2, o2, s2, c3 = {}, u3 = [], l3 = [], h3 = Math.pow(10, 4);
        for (n3 = 0, r3 = this.vertices.length; n3 < r3; n3++)
          e3 = this.vertices[n3], void 0 === c3[t3 = Math.round(e3.x * h3) + "_" + Math.round(e3.y * h3) + "_" + Math.round(e3.z * h3)] ? (c3[t3] = n3, u3.push(this.vertices[n3]), l3[n3] = u3.length - 1) : l3[n3] = l3[c3[t3]];
        var d3 = [];
        for (n3 = 0, r3 = this.faces.length; n3 < r3; n3++) {
          (i3 = this.faces[n3]).a = l3[i3.a], i3.b = l3[i3.b], i3.c = l3[i3.c], a2 = [i3.a, i3.b, i3.c];
          for (var p3 = 0; p3 < 3; p3++)
            if (a2[p3] === a2[(p3 + 1) % 3]) {
              d3.push(n3);
              break;
            }
        }
        for (n3 = d3.length - 1; n3 >= 0; n3--) {
          var f3 = d3[n3];
          for (this.faces.splice(f3, 1), o2 = 0, s2 = this.faceVertexUvs.length; o2 < s2; o2++)
            this.faceVertexUvs[o2].splice(f3, 1);
        }
        var m3 = this.vertices.length - u3.length;
        return this.vertices = u3, m3;
      }, setFromPoints: function(e3) {
        this.vertices = [];
        for (var t3 = 0, n3 = e3.length; t3 < n3; t3++) {
          var r3 = e3[t3];
          this.vertices.push(new Ht(r3.x, r3.y, r3.z || 0));
        }
        return this;
      }, sortFacesByMaterialIndex: function() {
        for (var e3 = this.faces, t3 = e3.length, n3 = 0; n3 < t3; n3++)
          e3[n3]._id = n3;
        e3.sort(function(e4, t4) {
          return e4.materialIndex - t4.materialIndex;
        });
        var r3, i3, a2 = this.faceVertexUvs[0], o2 = this.faceVertexUvs[1];
        a2 && a2.length === t3 && (r3 = []), o2 && o2.length === t3 && (i3 = []);
        for (n3 = 0; n3 < t3; n3++) {
          var s2 = e3[n3]._id;
          r3 && r3.push(a2[s2]), i3 && i3.push(o2[s2]);
        }
        r3 && (this.faceVertexUvs[0] = r3), i3 && (this.faceVertexUvs[1] = i3);
      }, toJSON: function() {
        var e3 = { metadata: { version: 4.5, type: "Geometry", generator: "Geometry.toJSON" } };
        if (e3.uuid = this.uuid, e3.type = this.type, "" !== this.name && (e3.name = this.name), void 0 !== this.parameters) {
          var t3 = this.parameters;
          for (var n3 in t3)
            void 0 !== t3[n3] && (e3[n3] = t3[n3]);
          return e3;
        }
        for (var r3 = [], i3 = 0; i3 < this.vertices.length; i3++) {
          var a2 = this.vertices[i3];
          r3.push(a2.x, a2.y, a2.z);
        }
        var o2 = [], s2 = [], c3 = {}, u3 = [], l3 = {}, h3 = [], d3 = {};
        for (i3 = 0; i3 < this.faces.length; i3++) {
          var p3 = this.faces[i3], f3 = void 0 !== this.faceVertexUvs[0][i3], m3 = p3.normal.length() > 0, g3 = p3.vertexNormals.length > 0, v3 = 1 !== p3.color.r || 1 !== p3.color.g || 1 !== p3.color.b, y3 = p3.vertexColors.length > 0, x3 = 0;
          if (x3 = M3(x3 = M3(x3 = M3(x3 = M3(x3 = M3(x3 = M3(x3 = M3(x3 = M3(x3, 0, 0), 1, true), 2, false), 3, f3), 4, m3), 5, g3), 6, v3), 7, y3), o2.push(x3), o2.push(p3.a, p3.b, p3.c), o2.push(p3.materialIndex), f3) {
            var b3 = this.faceVertexUvs[0][i3];
            o2.push(S3(b3[0]), S3(b3[1]), S3(b3[2]));
          }
          if (m3 && o2.push(E3(p3.normal)), g3) {
            var w3 = p3.vertexNormals;
            o2.push(E3(w3[0]), E3(w3[1]), E3(w3[2]));
          }
          if (v3 && o2.push(T3(p3.color)), y3) {
            var _3 = p3.vertexColors;
            o2.push(T3(_3[0]), T3(_3[1]), T3(_3[2]));
          }
        }
        function M3(e4, t4, n4) {
          return n4 ? e4 | 1 << t4 : e4 & ~(1 << t4);
        }
        function E3(e4) {
          var t4 = e4.x.toString() + e4.y.toString() + e4.z.toString();
          return void 0 !== c3[t4] ? c3[t4] : (c3[t4] = s2.length / 3, s2.push(e4.x, e4.y, e4.z), c3[t4]);
        }
        function T3(e4) {
          var t4 = e4.r.toString() + e4.g.toString() + e4.b.toString();
          return void 0 !== l3[t4] ? l3[t4] : (l3[t4] = u3.length, u3.push(e4.getHex()), l3[t4]);
        }
        function S3(e4) {
          var t4 = e4.x.toString() + e4.y.toString();
          return void 0 !== d3[t4] ? d3[t4] : (d3[t4] = h3.length / 2, h3.push(e4.x, e4.y), d3[t4]);
        }
        return e3.data = {}, e3.data.vertices = r3, e3.data.normals = s2, u3.length > 0 && (e3.data.colors = u3), h3.length > 0 && (e3.data.uvs = [h3]), e3.data.faces = o2, e3;
      }, clone: function() {
        return new vn().copy(this);
      }, copy: function(e3) {
        var t3, n3, r3, i3, a2, o2;
        this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = e3.name;
        var s2 = e3.vertices;
        for (t3 = 0, n3 = s2.length; t3 < n3; t3++)
          this.vertices.push(s2[t3].clone());
        var c3 = e3.colors;
        for (t3 = 0, n3 = c3.length; t3 < n3; t3++)
          this.colors.push(c3[t3].clone());
        var u3 = e3.faces;
        for (t3 = 0, n3 = u3.length; t3 < n3; t3++)
          this.faces.push(u3[t3].clone());
        for (t3 = 0, n3 = e3.faceVertexUvs.length; t3 < n3; t3++) {
          var l3 = e3.faceVertexUvs[t3];
          for (void 0 === this.faceVertexUvs[t3] && (this.faceVertexUvs[t3] = []), r3 = 0, i3 = l3.length; r3 < i3; r3++) {
            var h3 = l3[r3], d3 = [];
            for (a2 = 0, o2 = h3.length; a2 < o2; a2++) {
              var p3 = h3[a2];
              d3.push(p3.clone());
            }
            this.faceVertexUvs[t3].push(d3);
          }
        }
        var f3 = e3.morphTargets;
        for (t3 = 0, n3 = f3.length; t3 < n3; t3++) {
          var m3 = {};
          if (m3.name = f3[t3].name, void 0 !== f3[t3].vertices)
            for (m3.vertices = [], r3 = 0, i3 = f3[t3].vertices.length; r3 < i3; r3++)
              m3.vertices.push(f3[t3].vertices[r3].clone());
          if (void 0 !== f3[t3].normals)
            for (m3.normals = [], r3 = 0, i3 = f3[t3].normals.length; r3 < i3; r3++)
              m3.normals.push(f3[t3].normals[r3].clone());
          this.morphTargets.push(m3);
        }
        var g3 = e3.morphNormals;
        for (t3 = 0, n3 = g3.length; t3 < n3; t3++) {
          var v3 = {};
          if (void 0 !== g3[t3].vertexNormals)
            for (v3.vertexNormals = [], r3 = 0, i3 = g3[t3].vertexNormals.length; r3 < i3; r3++) {
              var y3 = g3[t3].vertexNormals[r3], x3 = {};
              x3.a = y3.a.clone(), x3.b = y3.b.clone(), x3.c = y3.c.clone(), v3.vertexNormals.push(x3);
            }
          if (void 0 !== g3[t3].faceNormals)
            for (v3.faceNormals = [], r3 = 0, i3 = g3[t3].faceNormals.length; r3 < i3; r3++)
              v3.faceNormals.push(g3[t3].faceNormals[r3].clone());
          this.morphNormals.push(v3);
        }
        var b3 = e3.skinWeights;
        for (t3 = 0, n3 = b3.length; t3 < n3; t3++)
          this.skinWeights.push(b3[t3].clone());
        var w3 = e3.skinIndices;
        for (t3 = 0, n3 = w3.length; t3 < n3; t3++)
          this.skinIndices.push(w3[t3].clone());
        var _3 = e3.lineDistances;
        for (t3 = 0, n3 = _3.length; t3 < n3; t3++)
          this.lineDistances.push(_3[t3]);
        var M3 = e3.boundingBox;
        null !== M3 && (this.boundingBox = M3.clone());
        var E3 = e3.boundingSphere;
        return null !== E3 && (this.boundingSphere = E3.clone()), this.elementsNeedUpdate = e3.elementsNeedUpdate, this.verticesNeedUpdate = e3.verticesNeedUpdate, this.uvsNeedUpdate = e3.uvsNeedUpdate, this.normalsNeedUpdate = e3.normalsNeedUpdate, this.colorsNeedUpdate = e3.colorsNeedUpdate, this.lineDistancesNeedUpdate = e3.lineDistancesNeedUpdate, this.groupsNeedUpdate = e3.groupsNeedUpdate, this;
      }, dispose: function() {
        this.dispatchEvent({ type: "dispose" });
      } }), Object.defineProperty(yn.prototype, "needsUpdate", { set: function(e3) {
        true === e3 && this.version++;
      } }), Object.assign(yn.prototype, { isBufferAttribute: true, onUploadCallback: function() {
      }, setArray: function(e3) {
        if (Array.isArray(e3))
          throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        return this.count = void 0 !== e3 ? e3.length / this.itemSize : 0, this.array = e3, this;
      }, setDynamic: function(e3) {
        return this.dynamic = e3, this;
      }, copy: function(e3) {
        return this.name = e3.name, this.array = new e3.array.constructor(e3.array), this.itemSize = e3.itemSize, this.count = e3.count, this.normalized = e3.normalized, this.dynamic = e3.dynamic, this;
      }, copyAt: function(e3, t3, n3) {
        e3 *= this.itemSize, n3 *= t3.itemSize;
        for (var r3 = 0, i3 = this.itemSize; r3 < i3; r3++)
          this.array[e3 + r3] = t3.array[n3 + r3];
        return this;
      }, copyArray: function(e3) {
        return this.array.set(e3), this;
      }, copyColorsArray: function(e3) {
        for (var t3 = this.array, n3 = 0, r3 = 0, i3 = e3.length; r3 < i3; r3++) {
          var a2 = e3[r3];
          void 0 === a2 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r3), a2 = new rn()), t3[n3++] = a2.r, t3[n3++] = a2.g, t3[n3++] = a2.b;
        }
        return this;
      }, copyVector2sArray: function(e3) {
        for (var t3 = this.array, n3 = 0, r3 = 0, i3 = e3.length; r3 < i3; r3++) {
          var a2 = e3[r3];
          void 0 === a2 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r3), a2 = new Ft()), t3[n3++] = a2.x, t3[n3++] = a2.y;
        }
        return this;
      }, copyVector3sArray: function(e3) {
        for (var t3 = this.array, n3 = 0, r3 = 0, i3 = e3.length; r3 < i3; r3++) {
          var a2 = e3[r3];
          void 0 === a2 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r3), a2 = new Ht()), t3[n3++] = a2.x, t3[n3++] = a2.y, t3[n3++] = a2.z;
        }
        return this;
      }, copyVector4sArray: function(e3) {
        for (var t3 = this.array, n3 = 0, r3 = 0, i3 = e3.length; r3 < i3; r3++) {
          var a2 = e3[r3];
          void 0 === a2 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r3), a2 = new Xt()), t3[n3++] = a2.x, t3[n3++] = a2.y, t3[n3++] = a2.z, t3[n3++] = a2.w;
        }
        return this;
      }, set: function(e3, t3) {
        return void 0 === t3 && (t3 = 0), this.array.set(e3, t3), this;
      }, getX: function(e3) {
        return this.array[e3 * this.itemSize];
      }, setX: function(e3, t3) {
        return this.array[e3 * this.itemSize] = t3, this;
      }, getY: function(e3) {
        return this.array[e3 * this.itemSize + 1];
      }, setY: function(e3, t3) {
        return this.array[e3 * this.itemSize + 1] = t3, this;
      }, getZ: function(e3) {
        return this.array[e3 * this.itemSize + 2];
      }, setZ: function(e3, t3) {
        return this.array[e3 * this.itemSize + 2] = t3, this;
      }, getW: function(e3) {
        return this.array[e3 * this.itemSize + 3];
      }, setW: function(e3, t3) {
        return this.array[e3 * this.itemSize + 3] = t3, this;
      }, setXY: function(e3, t3, n3) {
        return e3 *= this.itemSize, this.array[e3 + 0] = t3, this.array[e3 + 1] = n3, this;
      }, setXYZ: function(e3, t3, n3, r3) {
        return e3 *= this.itemSize, this.array[e3 + 0] = t3, this.array[e3 + 1] = n3, this.array[e3 + 2] = r3, this;
      }, setXYZW: function(e3, t3, n3, r3, i3) {
        return e3 *= this.itemSize, this.array[e3 + 0] = t3, this.array[e3 + 1] = n3, this.array[e3 + 2] = r3, this.array[e3 + 3] = i3, this;
      }, onUpload: function(e3) {
        return this.onUploadCallback = e3, this;
      }, clone: function() {
        return new this.constructor(this.array, this.itemSize).copy(this);
      } }), xn.prototype = Object.create(yn.prototype), xn.prototype.constructor = xn, bn.prototype = Object.create(yn.prototype), bn.prototype.constructor = bn, wn.prototype = Object.create(yn.prototype), wn.prototype.constructor = wn, _n.prototype = Object.create(yn.prototype), _n.prototype.constructor = _n, Mn.prototype = Object.create(yn.prototype), Mn.prototype.constructor = Mn, En.prototype = Object.create(yn.prototype), En.prototype.constructor = En, Tn.prototype = Object.create(yn.prototype), Tn.prototype.constructor = Tn, Sn.prototype = Object.create(yn.prototype), Sn.prototype.constructor = Sn, An.prototype = Object.create(yn.prototype), An.prototype.constructor = An, Object.assign(Ln.prototype, { computeGroups: function(e3) {
        for (var t3, n3 = [], r3 = void 0, i3 = e3.faces, a2 = 0; a2 < i3.length; a2++) {
          var o2 = i3[a2];
          o2.materialIndex !== r3 && (r3 = o2.materialIndex, void 0 !== t3 && (t3.count = 3 * a2 - t3.start, n3.push(t3)), t3 = { start: 3 * a2, materialIndex: r3 });
        }
        void 0 !== t3 && (t3.count = 3 * a2 - t3.start, n3.push(t3)), this.groups = n3;
      }, fromGeometry: function(e3) {
        var t3, n3 = e3.faces, r3 = e3.vertices, i3 = e3.faceVertexUvs, a2 = i3[0] && i3[0].length > 0, o2 = i3[1] && i3[1].length > 0, s2 = e3.morphTargets, c3 = s2.length;
        if (c3 > 0) {
          t3 = [];
          for (var u3 = 0; u3 < c3; u3++)
            t3[u3] = [];
          this.morphTargets.position = t3;
        }
        var l3, h3 = e3.morphNormals, d3 = h3.length;
        if (d3 > 0) {
          l3 = [];
          for (u3 = 0; u3 < d3; u3++)
            l3[u3] = [];
          this.morphTargets.normal = l3;
        }
        var p3 = e3.skinIndices, f3 = e3.skinWeights, m3 = p3.length === r3.length, g3 = f3.length === r3.length;
        r3.length > 0 && 0 === n3.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
        for (u3 = 0; u3 < n3.length; u3++) {
          var v3 = n3[u3];
          this.vertices.push(r3[v3.a], r3[v3.b], r3[v3.c]);
          var y3 = v3.vertexNormals;
          if (3 === y3.length)
            this.normals.push(y3[0], y3[1], y3[2]);
          else {
            var x3 = v3.normal;
            this.normals.push(x3, x3, x3);
          }
          var b3, w3 = v3.vertexColors;
          if (3 === w3.length)
            this.colors.push(w3[0], w3[1], w3[2]);
          else {
            var _3 = v3.color;
            this.colors.push(_3, _3, _3);
          }
          if (true === a2)
            void 0 !== (b3 = i3[0][u3]) ? this.uvs.push(b3[0], b3[1], b3[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", u3), this.uvs.push(new Ft(), new Ft(), new Ft()));
          if (true === o2)
            void 0 !== (b3 = i3[1][u3]) ? this.uvs2.push(b3[0], b3[1], b3[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", u3), this.uvs2.push(new Ft(), new Ft(), new Ft()));
          for (var M3 = 0; M3 < c3; M3++) {
            var E3 = s2[M3].vertices;
            t3[M3].push(E3[v3.a], E3[v3.b], E3[v3.c]);
          }
          for (M3 = 0; M3 < d3; M3++) {
            var T3 = h3[M3].vertexNormals[u3];
            l3[M3].push(T3.a, T3.b, T3.c);
          }
          m3 && this.skinIndices.push(p3[v3.a], p3[v3.b], p3[v3.c]), g3 && this.skinWeights.push(f3[v3.a], f3[v3.b], f3[v3.c]);
        }
        return this.computeGroups(e3), this.verticesNeedUpdate = e3.verticesNeedUpdate, this.normalsNeedUpdate = e3.normalsNeedUpdate, this.colorsNeedUpdate = e3.colorsNeedUpdate, this.uvsNeedUpdate = e3.uvsNeedUpdate, this.groupsNeedUpdate = e3.groupsNeedUpdate, this;
      } });
      var Cn = 1;
      function Pn() {
        Object.defineProperty(this, "id", { value: Cn += 2 }), this.uuid = Bt.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
      }
      function On(e3, t3, n3, r3, i3, a2) {
        vn.call(this), this.type = "BoxGeometry", this.parameters = { width: e3, height: t3, depth: n3, widthSegments: r3, heightSegments: i3, depthSegments: a2 }, this.fromBufferGeometry(new Nn(e3, t3, n3, r3, i3, a2)), this.mergeVertices();
      }
      function Nn(e3, t3, n3, r3, i3, a2) {
        Pn.call(this), this.type = "BoxBufferGeometry", this.parameters = { width: e3, height: t3, depth: n3, widthSegments: r3, heightSegments: i3, depthSegments: a2 };
        var o2 = this;
        e3 = e3 || 1, t3 = t3 || 1, n3 = n3 || 1, r3 = Math.floor(r3) || 1, i3 = Math.floor(i3) || 1;
        var s2 = [], c3 = [], u3 = [], l3 = [], h3 = 0, d3 = 0;
        function p3(e4, t4, n4, r4, i4, a3, p4, f3, m3, g3, v3) {
          var y3, x3, b3 = a3 / m3, w3 = p4 / g3, _3 = a3 / 2, M3 = p4 / 2, E3 = f3 / 2, T3 = m3 + 1, S3 = g3 + 1, A3 = 0, L3 = 0, R3 = new Ht();
          for (x3 = 0; x3 < S3; x3++) {
            var C3 = x3 * w3 - M3;
            for (y3 = 0; y3 < T3; y3++) {
              var P3 = y3 * b3 - _3;
              R3[e4] = P3 * r4, R3[t4] = C3 * i4, R3[n4] = E3, c3.push(R3.x, R3.y, R3.z), R3[e4] = 0, R3[t4] = 0, R3[n4] = f3 > 0 ? 1 : -1, u3.push(R3.x, R3.y, R3.z), l3.push(y3 / m3), l3.push(1 - x3 / g3), A3 += 1;
            }
          }
          for (x3 = 0; x3 < g3; x3++)
            for (y3 = 0; y3 < m3; y3++) {
              var O3 = h3 + y3 + T3 * x3, N3 = h3 + y3 + T3 * (x3 + 1), I3 = h3 + (y3 + 1) + T3 * (x3 + 1), D3 = h3 + (y3 + 1) + T3 * x3;
              s2.push(O3, N3, D3), s2.push(N3, I3, D3), L3 += 6;
            }
          o2.addGroup(d3, L3, v3), d3 += L3, h3 += A3;
        }
        p3("z", "y", "x", -1, -1, n3, t3, e3, a2 = Math.floor(a2) || 1, i3, 0), p3("z", "y", "x", 1, -1, n3, t3, -e3, a2, i3, 1), p3("x", "z", "y", 1, 1, e3, n3, t3, r3, a2, 2), p3("x", "z", "y", 1, -1, e3, n3, -t3, r3, a2, 3), p3("x", "y", "z", 1, -1, e3, t3, n3, r3, i3, 4), p3("x", "y", "z", -1, -1, e3, t3, -n3, r3, i3, 5), this.setIndex(s2), this.addAttribute("position", new Sn(c3, 3)), this.addAttribute("normal", new Sn(u3, 3)), this.addAttribute("uv", new Sn(l3, 2));
      }
      function In(e3, t3, n3, r3) {
        vn.call(this), this.type = "PlaneGeometry", this.parameters = { width: e3, height: t3, widthSegments: n3, heightSegments: r3 }, this.fromBufferGeometry(new Dn(e3, t3, n3, r3)), this.mergeVertices();
      }
      function Dn(e3, t3, n3, r3) {
        Pn.call(this), this.type = "PlaneBufferGeometry", this.parameters = { width: e3, height: t3, widthSegments: n3, heightSegments: r3 };
        var i3, a2, o2 = (e3 = e3 || 1) / 2, s2 = (t3 = t3 || 1) / 2, c3 = Math.floor(n3) || 1, u3 = Math.floor(r3) || 1, l3 = c3 + 1, h3 = u3 + 1, d3 = e3 / c3, p3 = t3 / u3, f3 = [], m3 = [], g3 = [], v3 = [];
        for (a2 = 0; a2 < h3; a2++) {
          var y3 = a2 * p3 - s2;
          for (i3 = 0; i3 < l3; i3++) {
            var x3 = i3 * d3 - o2;
            m3.push(x3, -y3, 0), g3.push(0, 0, 1), v3.push(i3 / c3), v3.push(1 - a2 / u3);
          }
        }
        for (a2 = 0; a2 < u3; a2++)
          for (i3 = 0; i3 < c3; i3++) {
            var b3 = i3 + l3 * a2, w3 = i3 + l3 * (a2 + 1), _3 = i3 + 1 + l3 * (a2 + 1), M3 = i3 + 1 + l3 * a2;
            f3.push(b3, w3, M3), f3.push(w3, _3, M3);
          }
        this.setIndex(f3), this.addAttribute("position", new Sn(m3, 3)), this.addAttribute("normal", new Sn(g3, 3)), this.addAttribute("uv", new Sn(v3, 2));
      }
      Pn.prototype = Object.assign(Object.create(r2.prototype), { constructor: Pn, isBufferGeometry: true, getIndex: function() {
        return this.index;
      }, setIndex: function(e3) {
        Array.isArray(e3) ? this.index = new (Rn(e3) > 65535 ? Tn : Mn)(e3, 1) : this.index = e3;
      }, addAttribute: function(e3, t3) {
        return t3 && t3.isBufferAttribute || t3 && t3.isInterleavedBufferAttribute ? "index" === e3 ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t3), this) : (this.attributes[e3] = t3, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(e3, new yn(arguments[1], arguments[2])));
      }, getAttribute: function(e3) {
        return this.attributes[e3];
      }, removeAttribute: function(e3) {
        return delete this.attributes[e3], this;
      }, addGroup: function(e3, t3, n3) {
        this.groups.push({ start: e3, count: t3, materialIndex: void 0 !== n3 ? n3 : 0 });
      }, clearGroups: function() {
        this.groups = [];
      }, setDrawRange: function(e3, t3) {
        this.drawRange.start = e3, this.drawRange.count = t3;
      }, applyMatrix: function(e3) {
        var t3 = this.attributes.position;
        void 0 !== t3 && (e3.applyToBufferAttribute(t3), t3.needsUpdate = true);
        var n3 = this.attributes.normal;
        void 0 !== n3 && (new kt().getNormalMatrix(e3).applyToBufferAttribute(n3), n3.needsUpdate = true);
        return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this;
      }, rotateX: function() {
        var e3 = new Gt();
        return function(t3) {
          return e3.makeRotationX(t3), this.applyMatrix(e3), this;
        };
      }(), rotateY: function() {
        var e3 = new Gt();
        return function(t3) {
          return e3.makeRotationY(t3), this.applyMatrix(e3), this;
        };
      }(), rotateZ: function() {
        var e3 = new Gt();
        return function(t3) {
          return e3.makeRotationZ(t3), this.applyMatrix(e3), this;
        };
      }(), translate: function() {
        var e3 = new Gt();
        return function(t3, n3, r3) {
          return e3.makeTranslation(t3, n3, r3), this.applyMatrix(e3), this;
        };
      }(), scale: function() {
        var e3 = new Gt();
        return function(t3, n3, r3) {
          return e3.makeScale(t3, n3, r3), this.applyMatrix(e3), this;
        };
      }(), lookAt: function() {
        var e3 = new dn();
        return function(t3) {
          e3.lookAt(t3), e3.updateMatrix(), this.applyMatrix(e3.matrix);
        };
      }(), center: function() {
        var e3 = new Ht();
        return function() {
          return this.computeBoundingBox(), this.boundingBox.getCenter(e3).negate(), this.translate(e3.x, e3.y, e3.z), this;
        };
      }(), setFromObject: function(e3) {
        var t3 = e3.geometry;
        if (e3.isPoints || e3.isLine) {
          var n3 = new Sn(3 * t3.vertices.length, 3), r3 = new Sn(3 * t3.colors.length, 3);
          if (this.addAttribute("position", n3.copyVector3sArray(t3.vertices)), this.addAttribute("color", r3.copyColorsArray(t3.colors)), t3.lineDistances && t3.lineDistances.length === t3.vertices.length) {
            var i3 = new Sn(t3.lineDistances.length, 1);
            this.addAttribute("lineDistance", i3.copyArray(t3.lineDistances));
          }
          null !== t3.boundingSphere && (this.boundingSphere = t3.boundingSphere.clone()), null !== t3.boundingBox && (this.boundingBox = t3.boundingBox.clone());
        } else
          e3.isMesh && t3 && t3.isGeometry && this.fromGeometry(t3);
        return this;
      }, setFromPoints: function(e3) {
        for (var t3 = [], n3 = 0, r3 = e3.length; n3 < r3; n3++) {
          var i3 = e3[n3];
          t3.push(i3.x, i3.y, i3.z || 0);
        }
        return this.addAttribute("position", new Sn(t3, 3)), this;
      }, updateFromObject: function(e3) {
        var t3, n3 = e3.geometry;
        if (e3.isMesh) {
          var r3 = n3.__directGeometry;
          if (true === n3.elementsNeedUpdate && (r3 = void 0, n3.elementsNeedUpdate = false), void 0 === r3)
            return this.fromGeometry(n3);
          r3.verticesNeedUpdate = n3.verticesNeedUpdate, r3.normalsNeedUpdate = n3.normalsNeedUpdate, r3.colorsNeedUpdate = n3.colorsNeedUpdate, r3.uvsNeedUpdate = n3.uvsNeedUpdate, r3.groupsNeedUpdate = n3.groupsNeedUpdate, n3.verticesNeedUpdate = false, n3.normalsNeedUpdate = false, n3.colorsNeedUpdate = false, n3.uvsNeedUpdate = false, n3.groupsNeedUpdate = false, n3 = r3;
        }
        return true === n3.verticesNeedUpdate && (void 0 !== (t3 = this.attributes.position) && (t3.copyVector3sArray(n3.vertices), t3.needsUpdate = true), n3.verticesNeedUpdate = false), true === n3.normalsNeedUpdate && (void 0 !== (t3 = this.attributes.normal) && (t3.copyVector3sArray(n3.normals), t3.needsUpdate = true), n3.normalsNeedUpdate = false), true === n3.colorsNeedUpdate && (void 0 !== (t3 = this.attributes.color) && (t3.copyColorsArray(n3.colors), t3.needsUpdate = true), n3.colorsNeedUpdate = false), n3.uvsNeedUpdate && (void 0 !== (t3 = this.attributes.uv) && (t3.copyVector2sArray(n3.uvs), t3.needsUpdate = true), n3.uvsNeedUpdate = false), n3.lineDistancesNeedUpdate && (void 0 !== (t3 = this.attributes.lineDistance) && (t3.copyArray(n3.lineDistances), t3.needsUpdate = true), n3.lineDistancesNeedUpdate = false), n3.groupsNeedUpdate && (n3.computeGroups(e3.geometry), this.groups = n3.groups, n3.groupsNeedUpdate = false), this;
      }, fromGeometry: function(e3) {
        return e3.__directGeometry = new Ln().fromGeometry(e3), this.fromDirectGeometry(e3.__directGeometry);
      }, fromDirectGeometry: function(e3) {
        var t3 = new Float32Array(3 * e3.vertices.length);
        if (this.addAttribute("position", new yn(t3, 3).copyVector3sArray(e3.vertices)), e3.normals.length > 0) {
          var n3 = new Float32Array(3 * e3.normals.length);
          this.addAttribute("normal", new yn(n3, 3).copyVector3sArray(e3.normals));
        }
        if (e3.colors.length > 0) {
          var r3 = new Float32Array(3 * e3.colors.length);
          this.addAttribute("color", new yn(r3, 3).copyColorsArray(e3.colors));
        }
        if (e3.uvs.length > 0) {
          var i3 = new Float32Array(2 * e3.uvs.length);
          this.addAttribute("uv", new yn(i3, 2).copyVector2sArray(e3.uvs));
        }
        if (e3.uvs2.length > 0) {
          var a2 = new Float32Array(2 * e3.uvs2.length);
          this.addAttribute("uv2", new yn(a2, 2).copyVector2sArray(e3.uvs2));
        }
        for (var o2 in this.groups = e3.groups, e3.morphTargets) {
          for (var s2 = [], c3 = e3.morphTargets[o2], u3 = 0, l3 = c3.length; u3 < l3; u3++) {
            var h3 = c3[u3], d3 = new Sn(3 * h3.length, 3);
            s2.push(d3.copyVector3sArray(h3));
          }
          this.morphAttributes[o2] = s2;
        }
        if (e3.skinIndices.length > 0) {
          var p3 = new Sn(4 * e3.skinIndices.length, 4);
          this.addAttribute("skinIndex", p3.copyVector4sArray(e3.skinIndices));
        }
        if (e3.skinWeights.length > 0) {
          var f3 = new Sn(4 * e3.skinWeights.length, 4);
          this.addAttribute("skinWeight", f3.copyVector4sArray(e3.skinWeights));
        }
        return null !== e3.boundingSphere && (this.boundingSphere = e3.boundingSphere.clone()), null !== e3.boundingBox && (this.boundingBox = e3.boundingBox.clone()), this;
      }, computeBoundingBox: function() {
        null === this.boundingBox && (this.boundingBox = new Jt());
        var e3 = this.attributes.position;
        void 0 !== e3 ? this.boundingBox.setFromBufferAttribute(e3) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
      }, computeBoundingSphere: function() {
        var e3 = new Jt(), t3 = new Ht();
        return function() {
          null === this.boundingSphere && (this.boundingSphere = new Kt());
          var n3 = this.attributes.position;
          if (n3) {
            var r3 = this.boundingSphere.center;
            e3.setFromBufferAttribute(n3), e3.getCenter(r3);
            for (var i3 = 0, a2 = 0, o2 = n3.count; a2 < o2; a2++)
              t3.x = n3.getX(a2), t3.y = n3.getY(a2), t3.z = n3.getZ(a2), i3 = Math.max(i3, r3.distanceToSquared(t3));
            this.boundingSphere.radius = Math.sqrt(i3), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
          }
        };
      }(), computeFaceNormals: function() {
      }, computeVertexNormals: function() {
        var e3 = this.index, t3 = this.attributes, n3 = this.groups;
        if (t3.position) {
          var r3 = t3.position.array;
          if (void 0 === t3.normal)
            this.addAttribute("normal", new yn(new Float32Array(r3.length), 3));
          else
            for (var i3 = t3.normal.array, a2 = 0, o2 = i3.length; a2 < o2; a2++)
              i3[a2] = 0;
          var s2, c3, u3, l3 = t3.normal.array, h3 = new Ht(), d3 = new Ht(), p3 = new Ht(), f3 = new Ht(), m3 = new Ht();
          if (e3) {
            var g3 = e3.array;
            0 === n3.length && this.addGroup(0, g3.length);
            for (var v3 = 0, y3 = n3.length; v3 < y3; ++v3) {
              var x3 = n3[v3], b3 = x3.start;
              for (a2 = b3, o2 = b3 + x3.count; a2 < o2; a2 += 3)
                s2 = 3 * g3[a2 + 0], c3 = 3 * g3[a2 + 1], u3 = 3 * g3[a2 + 2], h3.fromArray(r3, s2), d3.fromArray(r3, c3), p3.fromArray(r3, u3), f3.subVectors(p3, d3), m3.subVectors(h3, d3), f3.cross(m3), l3[s2] += f3.x, l3[s2 + 1] += f3.y, l3[s2 + 2] += f3.z, l3[c3] += f3.x, l3[c3 + 1] += f3.y, l3[c3 + 2] += f3.z, l3[u3] += f3.x, l3[u3 + 1] += f3.y, l3[u3 + 2] += f3.z;
            }
          } else
            for (a2 = 0, o2 = r3.length; a2 < o2; a2 += 9)
              h3.fromArray(r3, a2), d3.fromArray(r3, a2 + 3), p3.fromArray(r3, a2 + 6), f3.subVectors(p3, d3), m3.subVectors(h3, d3), f3.cross(m3), l3[a2] = f3.x, l3[a2 + 1] = f3.y, l3[a2 + 2] = f3.z, l3[a2 + 3] = f3.x, l3[a2 + 4] = f3.y, l3[a2 + 5] = f3.z, l3[a2 + 6] = f3.x, l3[a2 + 7] = f3.y, l3[a2 + 8] = f3.z;
          this.normalizeNormals(), t3.normal.needsUpdate = true;
        }
      }, merge: function(e3, t3) {
        if (e3 && e3.isBufferGeometry) {
          void 0 === t3 && (t3 = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
          var n3 = this.attributes;
          for (var r3 in n3)
            if (void 0 !== e3.attributes[r3])
              for (var i3 = n3[r3].array, a2 = e3.attributes[r3], o2 = a2.array, s2 = 0, c3 = a2.itemSize * t3; s2 < o2.length; s2++, c3++)
                i3[c3] = o2[s2];
          return this;
        }
        console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e3);
      }, normalizeNormals: function() {
        var e3 = new Ht();
        return function() {
          for (var t3 = this.attributes.normal, n3 = 0, r3 = t3.count; n3 < r3; n3++)
            e3.x = t3.getX(n3), e3.y = t3.getY(n3), e3.z = t3.getZ(n3), e3.normalize(), t3.setXYZ(n3, e3.x, e3.y, e3.z);
        };
      }(), toNonIndexed: function() {
        if (null === this.index)
          return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
        var e3 = new Pn(), t3 = this.index.array, n3 = this.attributes;
        for (var r3 in n3) {
          for (var i3 = n3[r3], a2 = i3.array, o2 = i3.itemSize, s2 = new a2.constructor(t3.length * o2), c3 = 0, u3 = 0, l3 = 0, h3 = t3.length; l3 < h3; l3++) {
            c3 = t3[l3] * o2;
            for (var d3 = 0; d3 < o2; d3++)
              s2[u3++] = a2[c3++];
          }
          e3.addAttribute(r3, new yn(s2, o2));
        }
        var p3 = this.groups;
        for (l3 = 0, h3 = p3.length; l3 < h3; l3++) {
          var f3 = p3[l3];
          e3.addGroup(f3.start, f3.count, f3.materialIndex);
        }
        return e3;
      }, toJSON: function() {
        var e3 = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
        if (e3.uuid = this.uuid, e3.type = this.type, "" !== this.name && (e3.name = this.name), Object.keys(this.userData).length > 0 && (e3.userData = this.userData), void 0 !== this.parameters) {
          var t3 = this.parameters;
          for (var n3 in t3)
            void 0 !== t3[n3] && (e3[n3] = t3[n3]);
          return e3;
        }
        e3.data = { attributes: {} };
        var r3 = this.index;
        if (null !== r3) {
          var i3 = Array.prototype.slice.call(r3.array);
          e3.data.index = { type: r3.array.constructor.name, array: i3 };
        }
        var a2 = this.attributes;
        for (var n3 in a2) {
          var o2 = a2[n3];
          i3 = Array.prototype.slice.call(o2.array);
          e3.data.attributes[n3] = { itemSize: o2.itemSize, type: o2.array.constructor.name, array: i3, normalized: o2.normalized };
        }
        var s2 = this.groups;
        s2.length > 0 && (e3.data.groups = JSON.parse(JSON.stringify(s2)));
        var c3 = this.boundingSphere;
        return null !== c3 && (e3.data.boundingSphere = { center: c3.center.toArray(), radius: c3.radius }), e3;
      }, clone: function() {
        return new Pn().copy(this);
      }, copy: function(e3) {
        var t3, n3, r3;
        this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = e3.name;
        var i3 = e3.index;
        null !== i3 && this.setIndex(i3.clone());
        var a2 = e3.attributes;
        for (t3 in a2) {
          var o2 = a2[t3];
          this.addAttribute(t3, o2.clone());
        }
        var s2 = e3.morphAttributes;
        for (t3 in s2) {
          var c3 = [], u3 = s2[t3];
          for (n3 = 0, r3 = u3.length; n3 < r3; n3++)
            c3.push(u3[n3].clone());
          this.morphAttributes[t3] = c3;
        }
        var l3 = e3.groups;
        for (n3 = 0, r3 = l3.length; n3 < r3; n3++) {
          var h3 = l3[n3];
          this.addGroup(h3.start, h3.count, h3.materialIndex);
        }
        var d3 = e3.boundingBox;
        null !== d3 && (this.boundingBox = d3.clone());
        var p3 = e3.boundingSphere;
        return null !== p3 && (this.boundingSphere = p3.clone()), this.drawRange.start = e3.drawRange.start, this.drawRange.count = e3.drawRange.count, this.userData = e3.userData, this;
      }, dispose: function() {
        this.dispatchEvent({ type: "dispose" });
      } }), On.prototype = Object.create(vn.prototype), On.prototype.constructor = On, Nn.prototype = Object.create(Pn.prototype), Nn.prototype.constructor = Nn, In.prototype = Object.create(vn.prototype), In.prototype.constructor = In, Dn.prototype = Object.create(Pn.prototype), Dn.prototype.constructor = Dn;
      var Un = 0;
      function Bn() {
        Object.defineProperty(this, "id", { value: Un++ }), this.uuid = Bt.generateUUID(), this.name = "", this.type = "Material", this.fog = true, this.lights = true, this.blending = E2, this.side = m2, this.flatShading = false, this.vertexColors = b2, this.opacity = 1, this.transparent = false, this.blendSrc = F2, this.blendDst = G2, this.blendEquation = R2, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = Y2, this.depthTest = true, this.depthWrite = true, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaTest = 0, this.premultipliedAlpha = false, this.overdraw = 0, this.visible = true, this.userData = {}, this.needsUpdate = true;
      }
      function Fn(e3) {
        Bn.call(this), this.type = "MeshBasicMaterial", this.color = new rn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = $, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = false, this.morphTargets = false, this.lights = false, this.setValues(e3);
      }
      function Gn(e3) {
        Bn.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.skinning = false, this.morphTargets = false, this.morphNormals = false, this.extensions = { derivatives: false, fragDepth: false, drawBuffers: false, shaderTextureLOD: false }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, void 0 !== e3 && (void 0 !== e3.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e3));
      }
      function zn(e3, t3) {
        this.origin = void 0 !== e3 ? e3 : new Ht(), this.direction = void 0 !== t3 ? t3 : new Ht();
      }
      function Hn(e3, t3, n3) {
        this.a = void 0 !== e3 ? e3 : new Ht(), this.b = void 0 !== t3 ? t3 : new Ht(), this.c = void 0 !== n3 ? n3 : new Ht();
      }
      function kn(e3, t3) {
        dn.call(this), this.type = "Mesh", this.geometry = void 0 !== e3 ? e3 : new Pn(), this.material = void 0 !== t3 ? t3 : new Fn({ color: 16777215 * Math.random() }), this.drawMode = _t5, this.updateMorphTargets();
      }
      function jn(e3, t3) {
        return Math.abs(t3[1]) - Math.abs(e3[1]);
      }
      function Vn(e3, t3, n3, r3, i3, a2, o2, s2, c3, u3) {
        e3 = void 0 !== e3 ? e3 : [], t3 = void 0 !== t3 ? t3 : ce2, Wt.call(this, e3, t3, n3, r3, i3, a2, o2, s2, c3, u3), this.flipY = false;
      }
      Bn.prototype = Object.assign(Object.create(r2.prototype), { constructor: Bn, isMaterial: true, onBeforeCompile: function() {
      }, setValues: function(e3) {
        if (void 0 !== e3)
          for (var t3 in e3) {
            var n3 = e3[t3];
            if (void 0 !== n3)
              if ("shading" !== t3) {
                var r3 = this[t3];
                void 0 !== r3 ? r3 && r3.isColor ? r3.set(n3) : r3 && r3.isVector3 && n3 && n3.isVector3 ? r3.copy(n3) : this[t3] = "overdraw" === t3 ? Number(n3) : n3 : console.warn("THREE." + this.type + ": '" + t3 + "' is not a property of this material.");
              } else
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = n3 === y2;
            else
              console.warn("THREE.Material: '" + t3 + "' parameter is undefined.");
          }
      }, toJSON: function(e3) {
        var t3 = void 0 === e3 || "string" == typeof e3;
        t3 && (e3 = { textures: {}, images: {} });
        var n3 = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } };
        function r3(e4) {
          var t4 = [];
          for (var n4 in e4) {
            var r4 = e4[n4];
            delete r4.metadata, t4.push(r4);
          }
          return t4;
        }
        if (n3.uuid = this.uuid, n3.type = this.type, "" !== this.name && (n3.name = this.name), this.color && this.color.isColor && (n3.color = this.color.getHex()), void 0 !== this.roughness && (n3.roughness = this.roughness), void 0 !== this.metalness && (n3.metalness = this.metalness), this.emissive && this.emissive.isColor && (n3.emissive = this.emissive.getHex()), 1 !== this.emissiveIntensity && (n3.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n3.specular = this.specular.getHex()), void 0 !== this.shininess && (n3.shininess = this.shininess), void 0 !== this.clearCoat && (n3.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (n3.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (n3.map = this.map.toJSON(e3).uuid), this.alphaMap && this.alphaMap.isTexture && (n3.alphaMap = this.alphaMap.toJSON(e3).uuid), this.lightMap && this.lightMap.isTexture && (n3.lightMap = this.lightMap.toJSON(e3).uuid), this.aoMap && this.aoMap.isTexture && (n3.aoMap = this.aoMap.toJSON(e3).uuid, n3.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n3.bumpMap = this.bumpMap.toJSON(e3).uuid, n3.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n3.normalMap = this.normalMap.toJSON(e3).uuid, n3.normalMapType = this.normalMapType, n3.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n3.displacementMap = this.displacementMap.toJSON(e3).uuid, n3.displacementScale = this.displacementScale, n3.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n3.roughnessMap = this.roughnessMap.toJSON(e3).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n3.metalnessMap = this.metalnessMap.toJSON(e3).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n3.emissiveMap = this.emissiveMap.toJSON(e3).uuid), this.specularMap && this.specularMap.isTexture && (n3.specularMap = this.specularMap.toJSON(e3).uuid), this.envMap && this.envMap.isTexture && (n3.envMap = this.envMap.toJSON(e3).uuid, n3.reflectivity = this.reflectivity), this.gradientMap && this.gradientMap.isTexture && (n3.gradientMap = this.gradientMap.toJSON(e3).uuid), void 0 !== this.size && (n3.size = this.size), void 0 !== this.sizeAttenuation && (n3.sizeAttenuation = this.sizeAttenuation), this.blending !== E2 && (n3.blending = this.blending), true === this.flatShading && (n3.flatShading = this.flatShading), this.side !== m2 && (n3.side = this.side), this.vertexColors !== b2 && (n3.vertexColors = this.vertexColors), this.opacity < 1 && (n3.opacity = this.opacity), true === this.transparent && (n3.transparent = this.transparent), n3.depthFunc = this.depthFunc, n3.depthTest = this.depthTest, n3.depthWrite = this.depthWrite, 0 !== this.rotation && (n3.rotation = this.rotation), 1 !== this.linewidth && (n3.linewidth = this.linewidth), void 0 !== this.dashSize && (n3.dashSize = this.dashSize), void 0 !== this.gapSize && (n3.gapSize = this.gapSize), void 0 !== this.scale && (n3.scale = this.scale), true === this.dithering && (n3.dithering = true), this.alphaTest > 0 && (n3.alphaTest = this.alphaTest), true === this.premultipliedAlpha && (n3.premultipliedAlpha = this.premultipliedAlpha), true === this.wireframe && (n3.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n3.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n3.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n3.wireframeLinejoin = this.wireframeLinejoin), true === this.morphTargets && (n3.morphTargets = true), true === this.skinning && (n3.skinning = true), false === this.visible && (n3.visible = false), "{}" !== JSON.stringify(this.userData) && (n3.userData = this.userData), t3) {
          var i3 = r3(e3.textures), a2 = r3(e3.images);
          i3.length > 0 && (n3.textures = i3), a2.length > 0 && (n3.images = a2);
        }
        return n3;
      }, clone: function() {
        return new this.constructor().copy(this);
      }, copy: function(e3) {
        this.name = e3.name, this.fog = e3.fog, this.lights = e3.lights, this.blending = e3.blending, this.side = e3.side, this.flatShading = e3.flatShading, this.vertexColors = e3.vertexColors, this.opacity = e3.opacity, this.transparent = e3.transparent, this.blendSrc = e3.blendSrc, this.blendDst = e3.blendDst, this.blendEquation = e3.blendEquation, this.blendSrcAlpha = e3.blendSrcAlpha, this.blendDstAlpha = e3.blendDstAlpha, this.blendEquationAlpha = e3.blendEquationAlpha, this.depthFunc = e3.depthFunc, this.depthTest = e3.depthTest, this.depthWrite = e3.depthWrite, this.colorWrite = e3.colorWrite, this.precision = e3.precision, this.polygonOffset = e3.polygonOffset, this.polygonOffsetFactor = e3.polygonOffsetFactor, this.polygonOffsetUnits = e3.polygonOffsetUnits, this.dithering = e3.dithering, this.alphaTest = e3.alphaTest, this.premultipliedAlpha = e3.premultipliedAlpha, this.overdraw = e3.overdraw, this.visible = e3.visible, this.userData = JSON.parse(JSON.stringify(e3.userData)), this.clipShadows = e3.clipShadows, this.clipIntersection = e3.clipIntersection;
        var t3 = e3.clippingPlanes, n3 = null;
        if (null !== t3) {
          var r3 = t3.length;
          n3 = new Array(r3);
          for (var i3 = 0; i3 !== r3; ++i3)
            n3[i3] = t3[i3].clone();
        }
        return this.clippingPlanes = n3, this.shadowSide = e3.shadowSide, this;
      }, dispose: function() {
        this.dispatchEvent({ type: "dispose" });
      } }), Fn.prototype = Object.create(Bn.prototype), Fn.prototype.constructor = Fn, Fn.prototype.isMeshBasicMaterial = true, Fn.prototype.copy = function(e3) {
        return Bn.prototype.copy.call(this, e3), this.color.copy(e3.color), this.map = e3.map, this.lightMap = e3.lightMap, this.lightMapIntensity = e3.lightMapIntensity, this.aoMap = e3.aoMap, this.aoMapIntensity = e3.aoMapIntensity, this.specularMap = e3.specularMap, this.alphaMap = e3.alphaMap, this.envMap = e3.envMap, this.combine = e3.combine, this.reflectivity = e3.reflectivity, this.refractionRatio = e3.refractionRatio, this.wireframe = e3.wireframe, this.wireframeLinewidth = e3.wireframeLinewidth, this.wireframeLinecap = e3.wireframeLinecap, this.wireframeLinejoin = e3.wireframeLinejoin, this.skinning = e3.skinning, this.morphTargets = e3.morphTargets, this;
      }, Gn.prototype = Object.create(Bn.prototype), Gn.prototype.constructor = Gn, Gn.prototype.isShaderMaterial = true, Gn.prototype.copy = function(e3) {
        return Bn.prototype.copy.call(this, e3), this.fragmentShader = e3.fragmentShader, this.vertexShader = e3.vertexShader, this.uniforms = tn.clone(e3.uniforms), this.defines = Object.assign({}, e3.defines), this.wireframe = e3.wireframe, this.wireframeLinewidth = e3.wireframeLinewidth, this.lights = e3.lights, this.clipping = e3.clipping, this.skinning = e3.skinning, this.morphTargets = e3.morphTargets, this.morphNormals = e3.morphNormals, this.extensions = e3.extensions, this;
      }, Gn.prototype.toJSON = function(e3) {
        var t3 = Bn.prototype.toJSON.call(this, e3);
        return t3.uniforms = this.uniforms, t3.vertexShader = this.vertexShader, t3.fragmentShader = this.fragmentShader, t3;
      }, Object.assign(zn.prototype, { set: function(e3, t3) {
        return this.origin.copy(e3), this.direction.copy(t3), this;
      }, clone: function() {
        return new this.constructor().copy(this);
      }, copy: function(e3) {
        return this.origin.copy(e3.origin), this.direction.copy(e3.direction), this;
      }, at: function(e3, t3) {
        return void 0 === t3 && (console.warn("THREE.Ray: .at() target is now required"), t3 = new Ht()), t3.copy(this.direction).multiplyScalar(e3).add(this.origin);
      }, lookAt: function(e3) {
        return this.direction.copy(e3).sub(this.origin).normalize(), this;
      }, recast: function() {
        var e3 = new Ht();
        return function(t3) {
          return this.origin.copy(this.at(t3, e3)), this;
        };
      }(), closestPointToPoint: function(e3, t3) {
        void 0 === t3 && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), t3 = new Ht()), t3.subVectors(e3, this.origin);
        var n3 = t3.dot(this.direction);
        return n3 < 0 ? t3.copy(this.origin) : t3.copy(this.direction).multiplyScalar(n3).add(this.origin);
      }, distanceToPoint: function(e3) {
        return Math.sqrt(this.distanceSqToPoint(e3));
      }, distanceSqToPoint: function() {
        var e3 = new Ht();
        return function(t3) {
          var n3 = e3.subVectors(t3, this.origin).dot(this.direction);
          return n3 < 0 ? this.origin.distanceToSquared(t3) : (e3.copy(this.direction).multiplyScalar(n3).add(this.origin), e3.distanceToSquared(t3));
        };
      }(), distanceSqToSegment: function() {
        var e3 = new Ht(), t3 = new Ht(), n3 = new Ht();
        return function(r3, i3, a2, o2) {
          e3.copy(r3).add(i3).multiplyScalar(0.5), t3.copy(i3).sub(r3).normalize(), n3.copy(this.origin).sub(e3);
          var s2, c3, u3, l3, h3 = 0.5 * r3.distanceTo(i3), d3 = -this.direction.dot(t3), p3 = n3.dot(this.direction), f3 = -n3.dot(t3), m3 = n3.lengthSq(), g3 = Math.abs(1 - d3 * d3);
          if (g3 > 0)
            if (c3 = d3 * p3 - f3, l3 = h3 * g3, (s2 = d3 * f3 - p3) >= 0)
              if (c3 >= -l3)
                if (c3 <= l3) {
                  var v3 = 1 / g3;
                  u3 = (s2 *= v3) * (s2 + d3 * (c3 *= v3) + 2 * p3) + c3 * (d3 * s2 + c3 + 2 * f3) + m3;
                } else
                  c3 = h3, u3 = -(s2 = Math.max(0, -(d3 * c3 + p3))) * s2 + c3 * (c3 + 2 * f3) + m3;
              else
                c3 = -h3, u3 = -(s2 = Math.max(0, -(d3 * c3 + p3))) * s2 + c3 * (c3 + 2 * f3) + m3;
            else
              c3 <= -l3 ? u3 = -(s2 = Math.max(0, -(-d3 * h3 + p3))) * s2 + (c3 = s2 > 0 ? -h3 : Math.min(Math.max(-h3, -f3), h3)) * (c3 + 2 * f3) + m3 : c3 <= l3 ? (s2 = 0, u3 = (c3 = Math.min(Math.max(-h3, -f3), h3)) * (c3 + 2 * f3) + m3) : u3 = -(s2 = Math.max(0, -(d3 * h3 + p3))) * s2 + (c3 = s2 > 0 ? h3 : Math.min(Math.max(-h3, -f3), h3)) * (c3 + 2 * f3) + m3;
          else
            c3 = d3 > 0 ? -h3 : h3, u3 = -(s2 = Math.max(0, -(d3 * c3 + p3))) * s2 + c3 * (c3 + 2 * f3) + m3;
          return a2 && a2.copy(this.direction).multiplyScalar(s2).add(this.origin), o2 && o2.copy(t3).multiplyScalar(c3).add(e3), u3;
        };
      }(), intersectSphere: function() {
        var e3 = new Ht();
        return function(t3, n3) {
          e3.subVectors(t3.center, this.origin);
          var r3 = e3.dot(this.direction), i3 = e3.dot(e3) - r3 * r3, a2 = t3.radius * t3.radius;
          if (i3 > a2)
            return null;
          var o2 = Math.sqrt(a2 - i3), s2 = r3 - o2, c3 = r3 + o2;
          return s2 < 0 && c3 < 0 ? null : s2 < 0 ? this.at(c3, n3) : this.at(s2, n3);
        };
      }(), intersectsSphere: function(e3) {
        return this.distanceToPoint(e3.center) <= e3.radius;
      }, distanceToPlane: function(e3) {
        var t3 = e3.normal.dot(this.direction);
        if (0 === t3)
          return 0 === e3.distanceToPoint(this.origin) ? 0 : null;
        var n3 = -(this.origin.dot(e3.normal) + e3.constant) / t3;
        return n3 >= 0 ? n3 : null;
      }, intersectPlane: function(e3, t3) {
        var n3 = this.distanceToPlane(e3);
        return null === n3 ? null : this.at(n3, t3);
      }, intersectsPlane: function(e3) {
        var t3 = e3.distanceToPoint(this.origin);
        return 0 === t3 || e3.normal.dot(this.direction) * t3 < 0;
      }, intersectBox: function(e3, t3) {
        var n3, r3, i3, a2, o2, s2, c3 = 1 / this.direction.x, u3 = 1 / this.direction.y, l3 = 1 / this.direction.z, h3 = this.origin;
        return c3 >= 0 ? (n3 = (e3.min.x - h3.x) * c3, r3 = (e3.max.x - h3.x) * c3) : (n3 = (e3.max.x - h3.x) * c3, r3 = (e3.min.x - h3.x) * c3), u3 >= 0 ? (i3 = (e3.min.y - h3.y) * u3, a2 = (e3.max.y - h3.y) * u3) : (i3 = (e3.max.y - h3.y) * u3, a2 = (e3.min.y - h3.y) * u3), n3 > a2 || i3 > r3 ? null : ((i3 > n3 || n3 != n3) && (n3 = i3), (a2 < r3 || r3 != r3) && (r3 = a2), l3 >= 0 ? (o2 = (e3.min.z - h3.z) * l3, s2 = (e3.max.z - h3.z) * l3) : (o2 = (e3.max.z - h3.z) * l3, s2 = (e3.min.z - h3.z) * l3), n3 > s2 || o2 > r3 ? null : ((o2 > n3 || n3 != n3) && (n3 = o2), (s2 < r3 || r3 != r3) && (r3 = s2), r3 < 0 ? null : this.at(n3 >= 0 ? n3 : r3, t3)));
      }, intersectsBox: function() {
        var e3 = new Ht();
        return function(t3) {
          return null !== this.intersectBox(t3, e3);
        };
      }(), intersectTriangle: function() {
        var e3 = new Ht(), t3 = new Ht(), n3 = new Ht(), r3 = new Ht();
        return function(i3, a2, o2, s2, c3) {
          t3.subVectors(a2, i3), n3.subVectors(o2, i3), r3.crossVectors(t3, n3);
          var u3, l3 = this.direction.dot(r3);
          if (l3 > 0) {
            if (s2)
              return null;
            u3 = 1;
          } else {
            if (!(l3 < 0))
              return null;
            u3 = -1, l3 = -l3;
          }
          e3.subVectors(this.origin, i3);
          var h3 = u3 * this.direction.dot(n3.crossVectors(e3, n3));
          if (h3 < 0)
            return null;
          var d3 = u3 * this.direction.dot(t3.cross(e3));
          if (d3 < 0)
            return null;
          if (h3 + d3 > l3)
            return null;
          var p3 = -u3 * e3.dot(r3);
          return p3 < 0 ? null : this.at(p3 / l3, c3);
        };
      }(), applyMatrix4: function(e3) {
        return this.origin.applyMatrix4(e3), this.direction.transformDirection(e3), this;
      }, equals: function(e3) {
        return e3.origin.equals(this.origin) && e3.direction.equals(this.direction);
      } }), Object.assign(Hn, { getNormal: function() {
        var e3 = new Ht();
        return function(t3, n3, r3, i3) {
          void 0 === i3 && (console.warn("THREE.Triangle: .getNormal() target is now required"), i3 = new Ht()), i3.subVectors(r3, n3), e3.subVectors(t3, n3), i3.cross(e3);
          var a2 = i3.lengthSq();
          return a2 > 0 ? i3.multiplyScalar(1 / Math.sqrt(a2)) : i3.set(0, 0, 0);
        };
      }(), getBarycoord: function() {
        var e3 = new Ht(), t3 = new Ht(), n3 = new Ht();
        return function(r3, i3, a2, o2, s2) {
          e3.subVectors(o2, i3), t3.subVectors(a2, i3), n3.subVectors(r3, i3);
          var c3 = e3.dot(e3), u3 = e3.dot(t3), l3 = e3.dot(n3), h3 = t3.dot(t3), d3 = t3.dot(n3), p3 = c3 * h3 - u3 * u3;
          if (void 0 === s2 && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), s2 = new Ht()), 0 === p3)
            return s2.set(-2, -1, -1);
          var f3 = 1 / p3, m3 = (h3 * l3 - u3 * d3) * f3, g3 = (c3 * d3 - u3 * l3) * f3;
          return s2.set(1 - m3 - g3, g3, m3);
        };
      }(), containsPoint: function() {
        var e3 = new Ht();
        return function(t3, n3, r3, i3) {
          return Hn.getBarycoord(t3, n3, r3, i3, e3), e3.x >= 0 && e3.y >= 0 && e3.x + e3.y <= 1;
        };
      }() }), Object.assign(Hn.prototype, { set: function(e3, t3, n3) {
        return this.a.copy(e3), this.b.copy(t3), this.c.copy(n3), this;
      }, setFromPointsAndIndices: function(e3, t3, n3, r3) {
        return this.a.copy(e3[t3]), this.b.copy(e3[n3]), this.c.copy(e3[r3]), this;
      }, clone: function() {
        return new this.constructor().copy(this);
      }, copy: function(e3) {
        return this.a.copy(e3.a), this.b.copy(e3.b), this.c.copy(e3.c), this;
      }, getArea: function() {
        var e3 = new Ht(), t3 = new Ht();
        return function() {
          return e3.subVectors(this.c, this.b), t3.subVectors(this.a, this.b), 0.5 * e3.cross(t3).length();
        };
      }(), getMidpoint: function(e3) {
        return void 0 === e3 && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), e3 = new Ht()), e3.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
      }, getNormal: function(e3) {
        return Hn.getNormal(this.a, this.b, this.c, e3);
      }, getPlane: function(e3) {
        return void 0 === e3 && (console.warn("THREE.Triangle: .getPlane() target is now required"), e3 = new Ht()), e3.setFromCoplanarPoints(this.a, this.b, this.c);
      }, getBarycoord: function(e3, t3) {
        return Hn.getBarycoord(e3, this.a, this.b, this.c, t3);
      }, containsPoint: function(e3) {
        return Hn.containsPoint(e3, this.a, this.b, this.c);
      }, intersectsBox: function(e3) {
        return e3.intersectsTriangle(this);
      }, closestPointToPoint: function() {
        var e3 = new Ht(), t3 = new Ht(), n3 = new Ht(), r3 = new Ht(), i3 = new Ht(), a2 = new Ht();
        return function(o2, s2) {
          void 0 === s2 && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), s2 = new Ht());
          var c3, u3, l3 = this.a, h3 = this.b, d3 = this.c;
          e3.subVectors(h3, l3), t3.subVectors(d3, l3), r3.subVectors(o2, l3);
          var p3 = e3.dot(r3), f3 = t3.dot(r3);
          if (p3 <= 0 && f3 <= 0)
            return s2.copy(l3);
          i3.subVectors(o2, h3);
          var m3 = e3.dot(i3), g3 = t3.dot(i3);
          if (m3 >= 0 && g3 <= m3)
            return s2.copy(h3);
          var v3 = p3 * g3 - m3 * f3;
          if (v3 <= 0 && p3 >= 0 && m3 <= 0)
            return c3 = p3 / (p3 - m3), s2.copy(l3).addScaledVector(e3, c3);
          a2.subVectors(o2, d3);
          var y3 = e3.dot(a2), x3 = t3.dot(a2);
          if (x3 >= 0 && y3 <= x3)
            return s2.copy(d3);
          var b3 = y3 * f3 - p3 * x3;
          if (b3 <= 0 && f3 >= 0 && x3 <= 0)
            return u3 = f3 / (f3 - x3), s2.copy(l3).addScaledVector(t3, u3);
          var w3 = m3 * x3 - y3 * g3;
          if (w3 <= 0 && g3 - m3 >= 0 && y3 - x3 >= 0)
            return n3.subVectors(d3, h3), u3 = (g3 - m3) / (g3 - m3 + (y3 - x3)), s2.copy(h3).addScaledVector(n3, u3);
          var _3 = 1 / (w3 + b3 + v3);
          return c3 = b3 * _3, u3 = v3 * _3, s2.copy(l3).addScaledVector(e3, c3).addScaledVector(t3, u3);
        };
      }(), equals: function(e3) {
        return e3.a.equals(this.a) && e3.b.equals(this.b) && e3.c.equals(this.c);
      } }), kn.prototype = Object.assign(Object.create(dn.prototype), { constructor: kn, isMesh: true, setDrawMode: function(e3) {
        this.drawMode = e3;
      }, copy: function(e3) {
        return dn.prototype.copy.call(this, e3), this.drawMode = e3.drawMode, void 0 !== e3.morphTargetInfluences && (this.morphTargetInfluences = e3.morphTargetInfluences.slice()), void 0 !== e3.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e3.morphTargetDictionary)), this;
      }, updateMorphTargets: function() {
        var e3, t3, n3, r3 = this.geometry;
        if (r3.isBufferGeometry) {
          var i3 = r3.morphAttributes, a2 = Object.keys(i3);
          if (a2.length > 0) {
            var o2 = i3[a2[0]];
            if (void 0 !== o2)
              for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e3 = 0, t3 = o2.length; e3 < t3; e3++)
                n3 = o2[e3].name || String(e3), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n3] = e3;
          }
        } else {
          var s2 = r3.morphTargets;
          if (void 0 !== s2 && s2.length > 0)
            for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e3 = 0, t3 = s2.length; e3 < t3; e3++)
              n3 = s2[e3].name || String(e3), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n3] = e3;
        }
      }, raycast: function() {
        var e3 = new Gt(), t3 = new zn(), n3 = new Kt(), r3 = new Ht(), i3 = new Ht(), a2 = new Ht(), o2 = new Ht(), s2 = new Ht(), c3 = new Ht(), u3 = new Ft(), l3 = new Ft(), h3 = new Ft(), d3 = new Ht(), p3 = new Ht(), f3 = new Ht();
        function m3(e4, t4, n4, r4, i4, a3, o3) {
          return Hn.getBarycoord(e4, t4, n4, r4, d3), i4.multiplyScalar(d3.x), a3.multiplyScalar(d3.y), o3.multiplyScalar(d3.z), i4.add(a3).add(o3), i4.clone();
        }
        function y3(e4, t4, n4, r4, i4, a3, o3, s3) {
          if (null === (t4.side === g2 ? r4.intersectTriangle(o3, a3, i4, true, s3) : r4.intersectTriangle(i4, a3, o3, t4.side !== v2, s3)))
            return null;
          f3.copy(s3), f3.applyMatrix4(e4.matrixWorld);
          var c4 = n4.ray.origin.distanceTo(f3);
          return c4 < n4.near || c4 > n4.far ? null : { distance: c4, point: f3.clone(), object: e4 };
        }
        function x3(e4, t4, n4, o3, s3, c4, d4, f4, g3) {
          r3.fromBufferAttribute(s3, d4), i3.fromBufferAttribute(s3, f4), a2.fromBufferAttribute(s3, g3);
          var v3 = y3(e4, t4, n4, o3, r3, i3, a2, p3);
          if (v3) {
            c4 && (u3.fromBufferAttribute(c4, d4), l3.fromBufferAttribute(c4, f4), h3.fromBufferAttribute(c4, g3), v3.uv = m3(p3, r3, i3, a2, u3, l3, h3));
            var x4 = new mn(d4, f4, g3);
            Hn.getNormal(r3, i3, a2, x4.normal), v3.face = x4;
          }
          return v3;
        }
        return function(d4, f4) {
          var g3, v3 = this.geometry, b3 = this.material, w3 = this.matrixWorld;
          if (void 0 !== b3 && (null === v3.boundingSphere && v3.computeBoundingSphere(), n3.copy(v3.boundingSphere), n3.applyMatrix4(w3), false !== d4.ray.intersectsSphere(n3) && (e3.getInverse(w3), t3.copy(d4.ray).applyMatrix4(e3), null === v3.boundingBox || false !== t3.intersectsBox(v3.boundingBox)))) {
            if (v3.isBufferGeometry) {
              var _3, M3, E3, T3, S3, A3, L3, R3, C3, P3 = v3.index, O3 = v3.attributes.position, N3 = v3.attributes.uv, I3 = v3.groups, D3 = v3.drawRange;
              if (null !== P3)
                if (Array.isArray(b3))
                  for (T3 = 0, A3 = I3.length; T3 < A3; T3++)
                    for (C3 = b3[(R3 = I3[T3]).materialIndex], S3 = Math.max(R3.start, D3.start), L3 = Math.min(R3.start + R3.count, D3.start + D3.count); S3 < L3; S3 += 3)
                      _3 = P3.getX(S3), M3 = P3.getX(S3 + 1), E3 = P3.getX(S3 + 2), (g3 = x3(this, C3, d4, t3, O3, N3, _3, M3, E3)) && (g3.faceIndex = Math.floor(S3 / 3), f4.push(g3));
                else
                  for (T3 = Math.max(0, D3.start), A3 = Math.min(P3.count, D3.start + D3.count); T3 < A3; T3 += 3)
                    _3 = P3.getX(T3), M3 = P3.getX(T3 + 1), E3 = P3.getX(T3 + 2), (g3 = x3(this, b3, d4, t3, O3, N3, _3, M3, E3)) && (g3.faceIndex = Math.floor(T3 / 3), f4.push(g3));
              else if (void 0 !== O3)
                if (Array.isArray(b3))
                  for (T3 = 0, A3 = I3.length; T3 < A3; T3++)
                    for (C3 = b3[(R3 = I3[T3]).materialIndex], S3 = Math.max(R3.start, D3.start), L3 = Math.min(R3.start + R3.count, D3.start + D3.count); S3 < L3; S3 += 3)
                      (g3 = x3(this, C3, d4, t3, O3, N3, _3 = S3, M3 = S3 + 1, E3 = S3 + 2)) && (g3.faceIndex = Math.floor(S3 / 3), f4.push(g3));
                else
                  for (T3 = Math.max(0, D3.start), A3 = Math.min(O3.count, D3.start + D3.count); T3 < A3; T3 += 3)
                    (g3 = x3(this, b3, d4, t3, O3, N3, _3 = T3, M3 = T3 + 1, E3 = T3 + 2)) && (g3.faceIndex = Math.floor(T3 / 3), f4.push(g3));
            } else if (v3.isGeometry) {
              var U3, B3, F3, G3, z3 = Array.isArray(b3), H3 = v3.vertices, k3 = v3.faces, j2 = v3.faceVertexUvs[0];
              j2.length > 0 && (G3 = j2);
              for (var V3 = 0, W3 = k3.length; V3 < W3; V3++) {
                var X3 = k3[V3], q3 = z3 ? b3[X3.materialIndex] : b3;
                if (void 0 !== q3) {
                  if (U3 = H3[X3.a], B3 = H3[X3.b], F3 = H3[X3.c], true === q3.morphTargets) {
                    var Y3 = v3.morphTargets, Z3 = this.morphTargetInfluences;
                    r3.set(0, 0, 0), i3.set(0, 0, 0), a2.set(0, 0, 0);
                    for (var J3 = 0, K3 = Y3.length; J3 < K3; J3++) {
                      var Q3 = Z3[J3];
                      if (0 !== Q3) {
                        var $2 = Y3[J3].vertices;
                        r3.addScaledVector(o2.subVectors($2[X3.a], U3), Q3), i3.addScaledVector(s2.subVectors($2[X3.b], B3), Q3), a2.addScaledVector(c3.subVectors($2[X3.c], F3), Q3);
                      }
                    }
                    r3.add(U3), i3.add(B3), a2.add(F3), U3 = r3, B3 = i3, F3 = a2;
                  }
                  if (g3 = y3(this, q3, d4, t3, U3, B3, F3, p3)) {
                    if (G3 && G3[V3]) {
                      var ee3 = G3[V3];
                      u3.copy(ee3[0]), l3.copy(ee3[1]), h3.copy(ee3[2]), g3.uv = m3(p3, U3, B3, F3, u3, l3, h3);
                    }
                    g3.face = X3, g3.faceIndex = V3, f4.push(g3);
                  }
                }
              }
            }
          }
        };
      }(), clone: function() {
        return new this.constructor(this.geometry, this.material).copy(this);
      } }), Vn.prototype = Object.create(Wt.prototype), Vn.prototype.constructor = Vn, Vn.prototype.isCubeTexture = true, Object.defineProperty(Vn.prototype, "images", { get: function() {
        return this.image;
      }, set: function(e3) {
        this.image = e3;
      } });
      var Wn = new Wt(), Xn = new Vn();
      function qn() {
        this.seq = [], this.map = {};
      }
      var Yn = [], Zn = [], Jn = new Float32Array(16), Kn = new Float32Array(9), Qn = new Float32Array(4);
      function $n(e3, t3, n3) {
        var r3 = e3[0];
        if (r3 <= 0 || r3 > 0)
          return e3;
        var i3 = t3 * n3, a2 = Yn[i3];
        if (void 0 === a2 && (a2 = new Float32Array(i3), Yn[i3] = a2), 0 !== t3) {
          r3.toArray(a2, 0);
          for (var o2 = 1, s2 = 0; o2 !== t3; ++o2)
            s2 += n3, e3[o2].toArray(a2, s2);
        }
        return a2;
      }
      function er(e3, t3) {
        if (e3.length !== t3.length)
          return false;
        for (var n3 = 0, r3 = e3.length; n3 < r3; n3++)
          if (e3[n3] !== t3[n3])
            return false;
        return true;
      }
      function tr(e3, t3) {
        for (var n3 = 0, r3 = t3.length; n3 < r3; n3++)
          e3[n3] = t3[n3];
      }
      function nr(e3, t3) {
        var n3 = Zn[t3];
        void 0 === n3 && (n3 = new Int32Array(t3), Zn[t3] = n3);
        for (var r3 = 0; r3 !== t3; ++r3)
          n3[r3] = e3.allocTextureUnit();
        return n3;
      }
      function rr(e3, t3) {
        var n3 = this.cache;
        n3[0] !== t3 && (e3.uniform1f(this.addr, t3), n3[0] = t3);
      }
      function ir(e3, t3) {
        var n3 = this.cache;
        n3[0] !== t3 && (e3.uniform1i(this.addr, t3), n3[0] = t3);
      }
      function ar(e3, t3) {
        var n3 = this.cache;
        if (void 0 !== t3.x)
          n3[0] === t3.x && n3[1] === t3.y || (e3.uniform2f(this.addr, t3.x, t3.y), n3[0] = t3.x, n3[1] = t3.y);
        else {
          if (er(n3, t3))
            return;
          e3.uniform2fv(this.addr, t3), tr(n3, t3);
        }
      }
      function or(e3, t3) {
        var n3 = this.cache;
        if (void 0 !== t3.x)
          n3[0] === t3.x && n3[1] === t3.y && n3[2] === t3.z || (e3.uniform3f(this.addr, t3.x, t3.y, t3.z), n3[0] = t3.x, n3[1] = t3.y, n3[2] = t3.z);
        else if (void 0 !== t3.r)
          n3[0] === t3.r && n3[1] === t3.g && n3[2] === t3.b || (e3.uniform3f(this.addr, t3.r, t3.g, t3.b), n3[0] = t3.r, n3[1] = t3.g, n3[2] = t3.b);
        else {
          if (er(n3, t3))
            return;
          e3.uniform3fv(this.addr, t3), tr(n3, t3);
        }
      }
      function sr(e3, t3) {
        var n3 = this.cache;
        if (void 0 !== t3.x)
          n3[0] === t3.x && n3[1] === t3.y && n3[2] === t3.z && n3[3] === t3.w || (e3.uniform4f(this.addr, t3.x, t3.y, t3.z, t3.w), n3[0] = t3.x, n3[1] = t3.y, n3[2] = t3.z, n3[3] = t3.w);
        else {
          if (er(n3, t3))
            return;
          e3.uniform4fv(this.addr, t3), tr(n3, t3);
        }
      }
      function cr(e3, t3) {
        var n3 = this.cache, r3 = t3.elements;
        if (void 0 === r3) {
          if (er(n3, t3))
            return;
          e3.uniformMatrix2fv(this.addr, false, t3), tr(n3, t3);
        } else {
          if (er(n3, r3))
            return;
          Qn.set(r3), e3.uniformMatrix2fv(this.addr, false, Qn), tr(n3, r3);
        }
      }
      function ur(e3, t3) {
        var n3 = this.cache, r3 = t3.elements;
        if (void 0 === r3) {
          if (er(n3, t3))
            return;
          e3.uniformMatrix3fv(this.addr, false, t3), tr(n3, t3);
        } else {
          if (er(n3, r3))
            return;
          Kn.set(r3), e3.uniformMatrix3fv(this.addr, false, Kn), tr(n3, r3);
        }
      }
      function lr(e3, t3) {
        var n3 = this.cache, r3 = t3.elements;
        if (void 0 === r3) {
          if (er(n3, t3))
            return;
          e3.uniformMatrix4fv(this.addr, false, t3), tr(n3, t3);
        } else {
          if (er(n3, r3))
            return;
          Jn.set(r3), e3.uniformMatrix4fv(this.addr, false, Jn), tr(n3, r3);
        }
      }
      function hr(e3, t3, n3) {
        var r3 = this.cache, i3 = n3.allocTextureUnit();
        r3[0] !== i3 && (e3.uniform1i(this.addr, i3), r3[0] = i3), n3.setTexture2D(t3 || Wn, i3);
      }
      function dr(e3, t3, n3) {
        var r3 = this.cache, i3 = n3.allocTextureUnit();
        r3[0] !== i3 && (e3.uniform1i(this.addr, i3), r3[0] = i3), n3.setTextureCube(t3 || Xn, i3);
      }
      function pr(e3, t3) {
        var n3 = this.cache;
        er(n3, t3) || (e3.uniform2iv(this.addr, t3), tr(n3, t3));
      }
      function fr(e3, t3) {
        var n3 = this.cache;
        er(n3, t3) || (e3.uniform3iv(this.addr, t3), tr(n3, t3));
      }
      function mr(e3, t3) {
        var n3 = this.cache;
        er(n3, t3) || (e3.uniform4iv(this.addr, t3), tr(n3, t3));
      }
      function gr(e3, t3) {
        var n3 = this.cache;
        er(n3, t3) || (e3.uniform1fv(this.addr, t3), tr(n3, t3));
      }
      function vr(e3, t3) {
        var n3 = this.cache;
        er(n3, t3) || (e3.uniform1iv(this.addr, t3), tr(n3, t3));
      }
      function yr(e3, t3) {
        var n3 = this.cache, r3 = $n(t3, this.size, 2);
        er(n3, r3) || (e3.uniform2fv(this.addr, r3), this.updateCache(r3));
      }
      function xr(e3, t3) {
        var n3 = this.cache, r3 = $n(t3, this.size, 3);
        er(n3, r3) || (e3.uniform3fv(this.addr, r3), this.updateCache(r3));
      }
      function br(e3, t3) {
        var n3 = this.cache, r3 = $n(t3, this.size, 4);
        er(n3, r3) || (e3.uniform4fv(this.addr, r3), this.updateCache(r3));
      }
      function wr(e3, t3) {
        var n3 = this.cache, r3 = $n(t3, this.size, 4);
        er(n3, r3) || (e3.uniformMatrix2fv(this.addr, false, r3), this.updateCache(r3));
      }
      function _r(e3, t3) {
        var n3 = this.cache, r3 = $n(t3, this.size, 9);
        er(n3, r3) || (e3.uniformMatrix3fv(this.addr, false, r3), this.updateCache(r3));
      }
      function Mr(e3, t3) {
        var n3 = this.cache, r3 = $n(t3, this.size, 16);
        er(n3, r3) || (e3.uniformMatrix4fv(this.addr, false, r3), this.updateCache(r3));
      }
      function Er(e3, t3, n3) {
        var r3 = this.cache, i3 = t3.length, a2 = nr(n3, i3);
        false === er(r3, a2) && (e3.uniform1iv(this.addr, a2), tr(r3, a2));
        for (var o2 = 0; o2 !== i3; ++o2)
          n3.setTexture2D(t3[o2] || Wn, a2[o2]);
      }
      function Tr(e3, t3, n3) {
        var r3 = this.cache, i3 = t3.length, a2 = nr(n3, i3);
        false === er(r3, a2) && (e3.uniform1iv(this.addr, a2), tr(r3, a2));
        for (var o2 = 0; o2 !== i3; ++o2)
          n3.setTextureCube(t3[o2] || Xn, a2[o2]);
      }
      function Sr(e3, t3, n3) {
        this.id = e3, this.addr = n3, this.cache = [], this.setValue = function(e4) {
          switch (e4) {
            case 5126:
              return rr;
            case 35664:
              return ar;
            case 35665:
              return or;
            case 35666:
              return sr;
            case 35674:
              return cr;
            case 35675:
              return ur;
            case 35676:
              return lr;
            case 35678:
            case 36198:
              return hr;
            case 35680:
              return dr;
            case 5124:
            case 35670:
              return ir;
            case 35667:
            case 35671:
              return pr;
            case 35668:
            case 35672:
              return fr;
            case 35669:
            case 35673:
              return mr;
          }
        }(t3.type);
      }
      function Ar(e3, t3, n3) {
        this.id = e3, this.addr = n3, this.cache = [], this.size = t3.size, this.setValue = function(e4) {
          switch (e4) {
            case 5126:
              return gr;
            case 35664:
              return yr;
            case 35665:
              return xr;
            case 35666:
              return br;
            case 35674:
              return wr;
            case 35675:
              return _r;
            case 35676:
              return Mr;
            case 35678:
              return Er;
            case 35680:
              return Tr;
            case 5124:
            case 35670:
              return vr;
            case 35667:
            case 35671:
              return pr;
            case 35668:
            case 35672:
              return fr;
            case 35669:
            case 35673:
              return mr;
          }
        }(t3.type);
      }
      function Lr(e3) {
        this.id = e3, qn.call(this);
      }
      Ar.prototype.updateCache = function(e3) {
        var t3 = this.cache;
        e3 instanceof Float32Array && t3.length !== e3.length && (this.cache = new Float32Array(e3.length)), tr(t3, e3);
      }, Lr.prototype.setValue = function(e3, t3, n3) {
        for (var r3 = this.seq, i3 = 0, a2 = r3.length; i3 !== a2; ++i3) {
          var o2 = r3[i3];
          o2.setValue(e3, t3[o2.id], n3);
        }
      };
      var Rr = /([\w\d_]+)(\])?(\[|\.)?/g;
      function Cr(e3, t3) {
        e3.seq.push(t3), e3.map[t3.id] = t3;
      }
      function Pr(e3, t3, n3) {
        var r3 = e3.name, i3 = r3.length;
        for (Rr.lastIndex = 0; ; ) {
          var a2 = Rr.exec(r3), o2 = Rr.lastIndex, s2 = a2[1], c3 = "]" === a2[2], u3 = a2[3];
          if (c3 && (s2 |= 0), void 0 === u3 || "[" === u3 && o2 + 2 === i3) {
            Cr(n3, void 0 === u3 ? new Sr(s2, e3, t3) : new Ar(s2, e3, t3));
            break;
          }
          var l3 = n3.map[s2];
          void 0 === l3 && Cr(n3, l3 = new Lr(s2)), n3 = l3;
        }
      }
      function Or(e3, t3, n3) {
        qn.call(this), this.renderer = n3;
        for (var r3 = e3.getProgramParameter(t3, e3.ACTIVE_UNIFORMS), i3 = 0; i3 < r3; ++i3) {
          var a2 = e3.getActiveUniform(t3, i3);
          Pr(a2, e3.getUniformLocation(t3, a2.name), this);
        }
      }
      function Nr(e3, t3, n3) {
        var r3 = e3.createShader(t3);
        return e3.shaderSource(r3, n3), e3.compileShader(r3), false === e3.getShaderParameter(r3, e3.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== e3.getShaderInfoLog(r3) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", t3 === e3.VERTEX_SHADER ? "vertex" : "fragment", e3.getShaderInfoLog(r3), function(e4) {
          for (var t4 = e4.split("\n"), n4 = 0; n4 < t4.length; n4++)
            t4[n4] = n4 + 1 + ": " + t4[n4];
          return t4.join("\n");
        }(n3)), r3;
      }
      Or.prototype.setValue = function(e3, t3, n3) {
        var r3 = this.map[t3];
        void 0 !== r3 && r3.setValue(e3, n3, this.renderer);
      }, Or.prototype.setOptional = function(e3, t3, n3) {
        var r3 = t3[n3];
        void 0 !== r3 && this.setValue(e3, n3, r3);
      }, Or.upload = function(e3, t3, n3, r3) {
        for (var i3 = 0, a2 = t3.length; i3 !== a2; ++i3) {
          var o2 = t3[i3], s2 = n3[o2.id];
          false !== s2.needsUpdate && o2.setValue(e3, s2.value, r3);
        }
      }, Or.seqWithValue = function(e3, t3) {
        for (var n3 = [], r3 = 0, i3 = e3.length; r3 !== i3; ++r3) {
          var a2 = e3[r3];
          a2.id in t3 && n3.push(a2);
        }
        return n3;
      };
      var Ir = 0;
      function Dr(e3) {
        switch (e3) {
          case Tt:
            return ["Linear", "( value )"];
          case St:
            return ["sRGB", "( value )"];
          case Lt:
            return ["RGBE", "( value )"];
          case Ct:
            return ["RGBM", "( value, 7.0 )"];
          case Pt:
            return ["RGBM", "( value, 16.0 )"];
          case Ot:
            return ["RGBD", "( value, 256.0 )"];
          case At:
            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
          default:
            throw new Error("unsupported encoding: " + e3);
        }
      }
      function Ur(e3, t3) {
        var n3 = Dr(t3);
        return "vec4 " + e3 + "( vec4 value ) { return " + n3[0] + "ToLinear" + n3[1] + "; }";
      }
      function Br(e3) {
        return "" !== e3;
      }
      function Fr(e3, t3) {
        return e3.replace(/NUM_DIR_LIGHTS/g, t3.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t3.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t3.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t3.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t3.numHemiLights);
      }
      function Gr(e3, t3) {
        return e3.replace(/NUM_CLIPPING_PLANES/g, t3.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t3.numClippingPlanes - t3.numClipIntersection);
      }
      function zr(e3) {
        return e3.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, function(e4, t3) {
          var n3 = en[t3];
          if (void 0 === n3)
            throw new Error("Can not resolve #include <" + t3 + ">");
          return zr(n3);
        });
      }
      function Hr(e3) {
        return e3.replace(/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(e4, t3, n3, r3) {
          for (var i3 = "", a2 = parseInt(t3); a2 < parseInt(n3); a2++)
            i3 += r3.replace(/\[ i \]/g, "[ " + a2 + " ]");
          return i3;
        });
      }
      function kr(e3, t3, n3, r3, i3, a2, o2) {
        var s2 = e3.context, c3 = r3.defines, u3 = i3.vertexShader, l3 = i3.fragmentShader, h3 = "SHADOWMAP_TYPE_BASIC";
        a2.shadowMapType === p2 ? h3 = "SHADOWMAP_TYPE_PCF" : a2.shadowMapType === f2 && (h3 = "SHADOWMAP_TYPE_PCF_SOFT");
        var d3 = "ENVMAP_TYPE_CUBE", m3 = "ENVMAP_MODE_REFLECTION", g3 = "ENVMAP_BLENDING_MULTIPLY";
        if (a2.envMap) {
          switch (r3.envMap.mapping) {
            case ce2:
            case ue2:
              d3 = "ENVMAP_TYPE_CUBE";
              break;
            case pe2:
            case fe2:
              d3 = "ENVMAP_TYPE_CUBE_UV";
              break;
            case le2:
            case he2:
              d3 = "ENVMAP_TYPE_EQUIREC";
              break;
            case de2:
              d3 = "ENVMAP_TYPE_SPHERE";
          }
          switch (r3.envMap.mapping) {
            case ue2:
            case he2:
              m3 = "ENVMAP_MODE_REFRACTION";
          }
          switch (r3.combine) {
            case $:
              g3 = "ENVMAP_BLENDING_MULTIPLY";
              break;
            case ee2:
              g3 = "ENVMAP_BLENDING_MIX";
              break;
            case te2:
              g3 = "ENVMAP_BLENDING_ADD";
          }
        }
        var v3, y3, x3 = e3.gammaFactor > 0 ? e3.gammaFactor : 1, b3 = o2.isWebGL2 ? "" : function(e4, t4, n4) {
          return [(e4 = e4 || {}).derivatives || t4.envMapCubeUV || t4.bumpMap || t4.normalMap && !t4.objectSpaceNormalMap || t4.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (e4.fragDepth || t4.logarithmicDepthBuffer) && n4.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", e4.drawBuffers && n4.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (e4.shaderTextureLOD || t4.envMap) && n4.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Br).join("\n");
        }(r3.extensions, a2, t3), w3 = function(e4) {
          var t4 = [];
          for (var n4 in e4) {
            var r4 = e4[n4];
            false !== r4 && t4.push("#define " + n4 + " " + r4);
          }
          return t4.join("\n");
        }(c3), _3 = s2.createProgram();
        if (r3.isRawShaderMaterial ? ((v3 = [w3].filter(Br).join("\n")).length > 0 && (v3 += "\n"), (y3 = [b3, w3].filter(Br).join("\n")).length > 0 && (y3 += "\n")) : (v3 = ["precision " + a2.precision + " float;", "precision " + a2.precision + " int;", "#define SHADER_NAME " + i3.name, w3, a2.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + x3, "#define MAX_BONES " + a2.maxBones, a2.useFog && a2.fog ? "#define USE_FOG" : "", a2.useFog && a2.fogExp ? "#define FOG_EXP2" : "", a2.map ? "#define USE_MAP" : "", a2.envMap ? "#define USE_ENVMAP" : "", a2.envMap ? "#define " + m3 : "", a2.lightMap ? "#define USE_LIGHTMAP" : "", a2.aoMap ? "#define USE_AOMAP" : "", a2.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a2.bumpMap ? "#define USE_BUMPMAP" : "", a2.normalMap ? "#define USE_NORMALMAP" : "", a2.normalMap && a2.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", a2.displacementMap && a2.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", a2.specularMap ? "#define USE_SPECULARMAP" : "", a2.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a2.metalnessMap ? "#define USE_METALNESSMAP" : "", a2.alphaMap ? "#define USE_ALPHAMAP" : "", a2.vertexColors ? "#define USE_COLOR" : "", a2.flatShading ? "#define FLAT_SHADED" : "", a2.skinning ? "#define USE_SKINNING" : "", a2.useVertexTexture ? "#define BONE_TEXTURE" : "", a2.morphTargets ? "#define USE_MORPHTARGETS" : "", a2.morphNormals && false === a2.flatShading ? "#define USE_MORPHNORMALS" : "", a2.doubleSided ? "#define DOUBLE_SIDED" : "", a2.flipSided ? "#define FLIP_SIDED" : "", a2.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a2.shadowMapEnabled ? "#define " + h3 : "", a2.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", a2.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a2.logarithmicDepthBuffer && (o2.isWebGL2 || t3.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "	attribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(Br).join("\n"), y3 = [b3, "precision " + a2.precision + " float;", "precision " + a2.precision + " int;", "#define SHADER_NAME " + i3.name, w3, a2.alphaTest ? "#define ALPHATEST " + a2.alphaTest + (a2.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + x3, a2.useFog && a2.fog ? "#define USE_FOG" : "", a2.useFog && a2.fogExp ? "#define FOG_EXP2" : "", a2.map ? "#define USE_MAP" : "", a2.envMap ? "#define USE_ENVMAP" : "", a2.envMap ? "#define " + d3 : "", a2.envMap ? "#define " + m3 : "", a2.envMap ? "#define " + g3 : "", a2.lightMap ? "#define USE_LIGHTMAP" : "", a2.aoMap ? "#define USE_AOMAP" : "", a2.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a2.bumpMap ? "#define USE_BUMPMAP" : "", a2.normalMap ? "#define USE_NORMALMAP" : "", a2.normalMap && a2.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", a2.specularMap ? "#define USE_SPECULARMAP" : "", a2.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a2.metalnessMap ? "#define USE_METALNESSMAP" : "", a2.alphaMap ? "#define USE_ALPHAMAP" : "", a2.vertexColors ? "#define USE_COLOR" : "", a2.gradientMap ? "#define USE_GRADIENTMAP" : "", a2.flatShading ? "#define FLAT_SHADED" : "", a2.doubleSided ? "#define DOUBLE_SIDED" : "", a2.flipSided ? "#define FLIP_SIDED" : "", a2.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a2.shadowMapEnabled ? "#define " + h3 : "", a2.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", a2.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", a2.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a2.logarithmicDepthBuffer && (o2.isWebGL2 || t3.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", a2.envMap && (o2.isWebGL2 || t3.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", a2.toneMapping !== ne2 ? "#define TONE_MAPPING" : "", a2.toneMapping !== ne2 ? en.tonemapping_pars_fragment : "", a2.toneMapping !== ne2 ? function(e4, t4) {
          var n4;
          switch (t4) {
            case re2:
              n4 = "Linear";
              break;
            case ie2:
              n4 = "Reinhard";
              break;
            case ae2:
              n4 = "Uncharted2";
              break;
            case oe2:
              n4 = "OptimizedCineon";
              break;
            default:
              throw new Error("unsupported toneMapping: " + t4);
          }
          return "vec3 " + e4 + "( vec3 color ) { return " + n4 + "ToneMapping( color ); }";
        }("toneMapping", a2.toneMapping) : "", a2.dithering ? "#define DITHERING" : "", a2.outputEncoding || a2.mapEncoding || a2.envMapEncoding || a2.emissiveMapEncoding ? en.encodings_pars_fragment : "", a2.mapEncoding ? Ur("mapTexelToLinear", a2.mapEncoding) : "", a2.envMapEncoding ? Ur("envMapTexelToLinear", a2.envMapEncoding) : "", a2.emissiveMapEncoding ? Ur("emissiveMapTexelToLinear", a2.emissiveMapEncoding) : "", a2.outputEncoding ? function(e4, t4) {
          var n4 = Dr(t4);
          return "vec4 " + e4 + "( vec4 value ) { return LinearTo" + n4[0] + n4[1] + "; }";
        }("linearToOutputTexel", a2.outputEncoding) : "", a2.depthPacking ? "#define DEPTH_PACKING " + r3.depthPacking : "", "\n"].filter(Br).join("\n")), u3 = Gr(u3 = Fr(u3 = zr(u3), a2), a2), l3 = Gr(l3 = Fr(l3 = zr(l3), a2), a2), u3 = Hr(u3), l3 = Hr(l3), o2.isWebGL2 && !r3.isRawShaderMaterial) {
          var M3 = false, E3 = /^\s*#version\s+300\s+es\s*\n/;
          r3.isShaderMaterial && null !== u3.match(E3) && null !== l3.match(E3) && (M3 = true, u3 = u3.replace(E3, ""), l3 = l3.replace(E3, "")), v3 = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + v3, y3 = ["#version 300 es\n", "#define varying in", M3 ? "" : "out highp vec4 pc_fragColor;", M3 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + y3;
        }
        var T3 = v3 + u3, S3 = y3 + l3, A3 = Nr(s2, s2.VERTEX_SHADER, T3), L3 = Nr(s2, s2.FRAGMENT_SHADER, S3);
        s2.attachShader(_3, A3), s2.attachShader(_3, L3), void 0 !== r3.index0AttributeName ? s2.bindAttribLocation(_3, 0, r3.index0AttributeName) : true === a2.morphTargets && s2.bindAttribLocation(_3, 0, "position"), s2.linkProgram(_3);
        var R3, C3, P3 = s2.getProgramInfoLog(_3).trim(), O3 = s2.getShaderInfoLog(A3).trim(), N3 = s2.getShaderInfoLog(L3).trim(), I3 = true, D3 = true;
        return false === s2.getProgramParameter(_3, s2.LINK_STATUS) ? (I3 = false, console.error("THREE.WebGLProgram: shader error: ", s2.getError(), "gl.VALIDATE_STATUS", s2.getProgramParameter(_3, s2.VALIDATE_STATUS), "gl.getProgramInfoLog", P3, O3, N3)) : "" !== P3 ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", P3) : "" !== O3 && "" !== N3 || (D3 = false), D3 && (this.diagnostics = { runnable: I3, material: r3, programLog: P3, vertexShader: { log: O3, prefix: v3 }, fragmentShader: { log: N3, prefix: y3 } }), s2.deleteShader(A3), s2.deleteShader(L3), this.getUniforms = function() {
          return void 0 === R3 && (R3 = new Or(s2, _3, e3)), R3;
        }, this.getAttributes = function() {
          return void 0 === C3 && (C3 = function(e4, t4) {
            for (var n4 = {}, r4 = e4.getProgramParameter(t4, e4.ACTIVE_ATTRIBUTES), i4 = 0; i4 < r4; i4++) {
              var a3 = e4.getActiveAttrib(t4, i4).name;
              n4[a3] = e4.getAttribLocation(t4, a3);
            }
            return n4;
          }(s2, _3)), C3;
        }, this.destroy = function() {
          s2.deleteProgram(_3), this.program = void 0;
        }, Object.defineProperties(this, { uniforms: { get: function() {
          return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms();
        } }, attributes: { get: function() {
          return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes();
        } } }), this.name = i3.name, this.id = Ir++, this.code = n3, this.usedTimes = 1, this.program = _3, this.vertexShader = A3, this.fragmentShader = L3, this;
      }
      function jr(e3, t3, n3) {
        var r3 = [], i3 = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "phong", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }, a2 = ["precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];
        function o2(e4, t4) {
          var n4;
          return e4 ? e4.isTexture ? n4 = e4.encoding : e4.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), n4 = e4.texture.encoding) : n4 = Tt, n4 === Tt && t4 && (n4 = At), n4;
        }
        this.getParameters = function(t4, r4, a3, s2, c3, u3, l3) {
          var h3 = i3[t4.type], d3 = l3.isSkinnedMesh ? function(e4) {
            var t5 = e4.skeleton.bones;
            if (n3.floatVertexTextures)
              return 1024;
            var r5 = n3.maxVertexUniforms, i4 = Math.floor((r5 - 20) / 4), a4 = Math.min(i4, t5.length);
            return a4 < t5.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t5.length + " bones. This GPU supports " + a4 + "."), 0) : a4;
          }(l3) : 0, p3 = n3.precision;
          null !== t4.precision && (p3 = n3.getMaxPrecision(t4.precision)) !== t4.precision && console.warn("THREE.WebGLProgram.getParameters:", t4.precision, "not supported, using", p3, "instead.");
          var f3 = e3.getRenderTarget();
          return { shaderID: h3, precision: p3, supportsVertexTextures: n3.vertexTextures, outputEncoding: o2(f3 ? f3.texture : null, e3.gammaOutput), map: !!t4.map, mapEncoding: o2(t4.map, e3.gammaInput), envMap: !!t4.envMap, envMapMode: t4.envMap && t4.envMap.mapping, envMapEncoding: o2(t4.envMap, e3.gammaInput), envMapCubeUV: !!t4.envMap && (t4.envMap.mapping === pe2 || t4.envMap.mapping === fe2), lightMap: !!t4.lightMap, aoMap: !!t4.aoMap, emissiveMap: !!t4.emissiveMap, emissiveMapEncoding: o2(t4.emissiveMap, e3.gammaInput), bumpMap: !!t4.bumpMap, normalMap: !!t4.normalMap, objectSpaceNormalMap: t4.normalMapType === Ut, displacementMap: !!t4.displacementMap, roughnessMap: !!t4.roughnessMap, metalnessMap: !!t4.metalnessMap, specularMap: !!t4.specularMap, alphaMap: !!t4.alphaMap, gradientMap: !!t4.gradientMap, combine: t4.combine, vertexColors: t4.vertexColors, fog: !!s2, useFog: t4.fog, fogExp: s2 && s2.isFogExp2, flatShading: t4.flatShading, sizeAttenuation: t4.sizeAttenuation, logarithmicDepthBuffer: n3.logarithmicDepthBuffer, skinning: t4.skinning && d3 > 0, maxBones: d3, useVertexTexture: n3.floatVertexTextures, morphTargets: t4.morphTargets, morphNormals: t4.morphNormals, maxMorphTargets: e3.maxMorphTargets, maxMorphNormals: e3.maxMorphNormals, numDirLights: r4.directional.length, numPointLights: r4.point.length, numSpotLights: r4.spot.length, numRectAreaLights: r4.rectArea.length, numHemiLights: r4.hemi.length, numClippingPlanes: c3, numClipIntersection: u3, dithering: t4.dithering, shadowMapEnabled: e3.shadowMap.enabled && l3.receiveShadow && a3.length > 0, shadowMapType: e3.shadowMap.type, toneMapping: e3.toneMapping, physicallyCorrectLights: e3.physicallyCorrectLights, premultipliedAlpha: t4.premultipliedAlpha, alphaTest: t4.alphaTest, doubleSided: t4.side === v2, flipSided: t4.side === g2, depthPacking: void 0 !== t4.depthPacking && t4.depthPacking };
        }, this.getProgramCode = function(t4, n4) {
          var r4 = [];
          if (n4.shaderID ? r4.push(n4.shaderID) : (r4.push(t4.fragmentShader), r4.push(t4.vertexShader)), void 0 !== t4.defines)
            for (var i4 in t4.defines)
              r4.push(i4), r4.push(t4.defines[i4]);
          for (var o3 = 0; o3 < a2.length; o3++)
            r4.push(n4[a2[o3]]);
          return r4.push(t4.onBeforeCompile.toString()), r4.push(e3.gammaOutput), r4.join();
        }, this.acquireProgram = function(i4, a3, o3, s2) {
          for (var c3, u3 = 0, l3 = r3.length; u3 < l3; u3++) {
            var h3 = r3[u3];
            if (h3.code === s2) {
              ++(c3 = h3).usedTimes;
              break;
            }
          }
          return void 0 === c3 && (c3 = new kr(e3, t3, s2, i4, a3, o3, n3), r3.push(c3)), c3;
        }, this.releaseProgram = function(e4) {
          if (0 == --e4.usedTimes) {
            var t4 = r3.indexOf(e4);
            r3[t4] = r3[r3.length - 1], r3.pop(), e4.destroy();
          }
        }, this.programs = r3;
      }
      function Vr(e3, t3) {
        return e3.renderOrder !== t3.renderOrder ? e3.renderOrder - t3.renderOrder : e3.program && t3.program && e3.program !== t3.program ? e3.program.id - t3.program.id : e3.material.id !== t3.material.id ? e3.material.id - t3.material.id : e3.z !== t3.z ? e3.z - t3.z : e3.id - t3.id;
      }
      function Wr(e3, t3) {
        return e3.renderOrder !== t3.renderOrder ? e3.renderOrder - t3.renderOrder : e3.z !== t3.z ? t3.z - e3.z : e3.id - t3.id;
      }
      function Xr() {
        var e3 = {};
        return { get: function(t3, n3) {
          var r3 = t3.id + "," + n3.id, i3 = e3[r3];
          return void 0 === i3 && (i3 = new function() {
            var e4 = [], t4 = 0, n4 = [], r4 = [];
            return { opaque: n4, transparent: r4, init: function() {
              t4 = 0, n4.length = 0, r4.length = 0;
            }, push: function(i4, a2, o2, s2, c3) {
              var u3 = e4[t4];
              void 0 === u3 ? (u3 = { id: i4.id, object: i4, geometry: a2, material: o2, program: o2.program, renderOrder: i4.renderOrder, z: s2, group: c3 }, e4[t4] = u3) : (u3.id = i4.id, u3.object = i4, u3.geometry = a2, u3.material = o2, u3.program = o2.program, u3.renderOrder = i4.renderOrder, u3.z = s2, u3.group = c3), (true === o2.transparent ? r4 : n4).push(u3), t4++;
            }, sort: function() {
              n4.length > 1 && n4.sort(Vr), r4.length > 1 && r4.sort(Wr);
            } };
          }(), e3[r3] = i3), i3;
        }, dispose: function() {
          e3 = {};
        } };
      }
      var qr, Yr = 0;
      function Zr() {
        var e3 = new function() {
          var e4 = {};
          return { get: function(t4) {
            if (void 0 !== e4[t4.id])
              return e4[t4.id];
            var n4;
            switch (t4.type) {
              case "DirectionalLight":
                n4 = { direction: new Ht(), color: new rn(), shadow: false, shadowBias: 0, shadowRadius: 1, shadowMapSize: new Ft() };
                break;
              case "SpotLight":
                n4 = { position: new Ht(), direction: new Ht(), color: new rn(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0, shadow: false, shadowBias: 0, shadowRadius: 1, shadowMapSize: new Ft() };
                break;
              case "PointLight":
                n4 = { position: new Ht(), color: new rn(), distance: 0, decay: 0, shadow: false, shadowBias: 0, shadowRadius: 1, shadowMapSize: new Ft(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
                break;
              case "HemisphereLight":
                n4 = { direction: new Ht(), skyColor: new rn(), groundColor: new rn() };
                break;
              case "RectAreaLight":
                n4 = { color: new rn(), position: new Ht(), halfWidth: new Ht(), halfHeight: new Ht() };
            }
            return e4[t4.id] = n4, n4;
          } };
        }(), t3 = { id: Yr++, hash: { stateID: -1, directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, shadowsLength: -1 }, ambient: [0, 0, 0], directional: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], point: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] }, n3 = new Ht(), r3 = new Gt(), i3 = new Gt();
        return { setup: function(a2, o2, s2) {
          for (var c3 = 0, u3 = 0, l3 = 0, h3 = 0, d3 = 0, p3 = 0, f3 = 0, m3 = 0, g3 = s2.matrixWorldInverse, v3 = 0, y3 = a2.length; v3 < y3; v3++) {
            var x3 = a2[v3], b3 = x3.color, w3 = x3.intensity, _3 = x3.distance, M3 = x3.shadow && x3.shadow.map ? x3.shadow.map.texture : null;
            if (x3.isAmbientLight)
              c3 += b3.r * w3, u3 += b3.g * w3, l3 += b3.b * w3;
            else if (x3.isDirectionalLight) {
              if ((T3 = e3.get(x3)).color.copy(x3.color).multiplyScalar(x3.intensity), T3.direction.setFromMatrixPosition(x3.matrixWorld), n3.setFromMatrixPosition(x3.target.matrixWorld), T3.direction.sub(n3), T3.direction.transformDirection(g3), T3.shadow = x3.castShadow, x3.castShadow) {
                var E3 = x3.shadow;
                T3.shadowBias = E3.bias, T3.shadowRadius = E3.radius, T3.shadowMapSize = E3.mapSize;
              }
              t3.directionalShadowMap[h3] = M3, t3.directionalShadowMatrix[h3] = x3.shadow.matrix, t3.directional[h3] = T3, h3++;
            } else if (x3.isSpotLight)
              (T3 = e3.get(x3)).position.setFromMatrixPosition(x3.matrixWorld), T3.position.applyMatrix4(g3), T3.color.copy(b3).multiplyScalar(w3), T3.distance = _3, T3.direction.setFromMatrixPosition(x3.matrixWorld), n3.setFromMatrixPosition(x3.target.matrixWorld), T3.direction.sub(n3), T3.direction.transformDirection(g3), T3.coneCos = Math.cos(x3.angle), T3.penumbraCos = Math.cos(x3.angle * (1 - x3.penumbra)), T3.decay = 0 === x3.distance ? 0 : x3.decay, T3.shadow = x3.castShadow, x3.castShadow && (E3 = x3.shadow, T3.shadowBias = E3.bias, T3.shadowRadius = E3.radius, T3.shadowMapSize = E3.mapSize), t3.spotShadowMap[p3] = M3, t3.spotShadowMatrix[p3] = x3.shadow.matrix, t3.spot[p3] = T3, p3++;
            else if (x3.isRectAreaLight)
              (T3 = e3.get(x3)).color.copy(b3).multiplyScalar(w3), T3.position.setFromMatrixPosition(x3.matrixWorld), T3.position.applyMatrix4(g3), i3.identity(), r3.copy(x3.matrixWorld), r3.premultiply(g3), i3.extractRotation(r3), T3.halfWidth.set(0.5 * x3.width, 0, 0), T3.halfHeight.set(0, 0.5 * x3.height, 0), T3.halfWidth.applyMatrix4(i3), T3.halfHeight.applyMatrix4(i3), t3.rectArea[f3] = T3, f3++;
            else if (x3.isPointLight)
              (T3 = e3.get(x3)).position.setFromMatrixPosition(x3.matrixWorld), T3.position.applyMatrix4(g3), T3.color.copy(x3.color).multiplyScalar(x3.intensity), T3.distance = x3.distance, T3.decay = 0 === x3.distance ? 0 : x3.decay, T3.shadow = x3.castShadow, x3.castShadow && (E3 = x3.shadow, T3.shadowBias = E3.bias, T3.shadowRadius = E3.radius, T3.shadowMapSize = E3.mapSize, T3.shadowCameraNear = E3.camera.near, T3.shadowCameraFar = E3.camera.far), t3.pointShadowMap[d3] = M3, t3.pointShadowMatrix[d3] = x3.shadow.matrix, t3.point[d3] = T3, d3++;
            else if (x3.isHemisphereLight) {
              var T3;
              (T3 = e3.get(x3)).direction.setFromMatrixPosition(x3.matrixWorld), T3.direction.transformDirection(g3), T3.direction.normalize(), T3.skyColor.copy(x3.color).multiplyScalar(w3), T3.groundColor.copy(x3.groundColor).multiplyScalar(w3), t3.hemi[m3] = T3, m3++;
            }
          }
          t3.ambient[0] = c3, t3.ambient[1] = u3, t3.ambient[2] = l3, t3.directional.length = h3, t3.spot.length = p3, t3.rectArea.length = f3, t3.point.length = d3, t3.hemi.length = m3, t3.hash.stateID = t3.id, t3.hash.directionalLength = h3, t3.hash.pointLength = d3, t3.hash.spotLength = p3, t3.hash.rectAreaLength = f3, t3.hash.hemiLength = m3, t3.hash.shadowsLength = o2.length;
        }, state: t3 };
      }
      function Jr() {
        var e3 = new Zr(), t3 = [], n3 = [];
        return { init: function() {
          t3.length = 0, n3.length = 0;
        }, state: { lightsArray: t3, shadowsArray: n3, lights: e3 }, setupLights: function(r3) {
          e3.setup(t3, n3, r3);
        }, pushLight: function(e4) {
          t3.push(e4);
        }, pushShadow: function(e4) {
          n3.push(e4);
        } };
      }
      function Kr(e3) {
        Bn.call(this), this.type = "MeshDepthMaterial", this.depthPacking = Nt, this.skinning = false, this.morphTargets = false, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.setValues(e3);
      }
      function Qr(e3) {
        Bn.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new Ht(), this.nearDistance = 1, this.farDistance = 1e3, this.skinning = false, this.morphTargets = false, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = false, this.lights = false, this.setValues(e3);
      }
      function $r(e3, t3, n3) {
        for (var r3 = new $t(), i3 = new Gt(), a2 = new Ft(), o2 = new Ft(n3, n3), s2 = new Ht(), c3 = new Ht(), u3 = 1, l3 = 2, h3 = 1 + (u3 | l3), d3 = new Array(h3), f3 = new Array(h3), y3 = {}, x3 = { 0: g2, 1: m2, 2: v2 }, b3 = [new Ht(1, 0, 0), new Ht(-1, 0, 0), new Ht(0, 0, 1), new Ht(0, 0, -1), new Ht(0, 1, 0), new Ht(0, -1, 0)], w3 = [new Ht(0, 1, 0), new Ht(0, 1, 0), new Ht(0, 1, 0), new Ht(0, 1, 0), new Ht(0, 0, 1), new Ht(0, 0, -1)], _3 = [new Xt(), new Xt(), new Xt(), new Xt(), new Xt(), new Xt()], M3 = 0; M3 !== h3; ++M3) {
          var E3 = 0 != (M3 & u3), T3 = 0 != (M3 & l3), S3 = new Kr({ depthPacking: It, morphTargets: E3, skinning: T3 });
          d3[M3] = S3;
          var A3 = new Qr({ morphTargets: E3, skinning: T3 });
          f3[M3] = A3;
        }
        var L3 = this;
        function R3(t4, n4, r4, i4, a3, o3) {
          var s3 = t4.geometry, c4 = null, h4 = d3, p3 = t4.customDepthMaterial;
          if (r4 && (h4 = f3, p3 = t4.customDistanceMaterial), p3)
            c4 = p3;
          else {
            var m3 = false;
            n4.morphTargets && (s3 && s3.isBufferGeometry ? m3 = s3.morphAttributes && s3.morphAttributes.position && s3.morphAttributes.position.length > 0 : s3 && s3.isGeometry && (m3 = s3.morphTargets && s3.morphTargets.length > 0)), t4.isSkinnedMesh && false === n4.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", t4);
            var g3 = t4.isSkinnedMesh && n4.skinning, v3 = 0;
            m3 && (v3 |= u3), g3 && (v3 |= l3), c4 = h4[v3];
          }
          if (e3.localClippingEnabled && true === n4.clipShadows && 0 !== n4.clippingPlanes.length) {
            var b4 = c4.uuid, w4 = n4.uuid, _4 = y3[b4];
            void 0 === _4 && (_4 = {}, y3[b4] = _4);
            var M4 = _4[w4];
            void 0 === M4 && (M4 = c4.clone(), _4[w4] = M4), c4 = M4;
          }
          return c4.visible = n4.visible, c4.wireframe = n4.wireframe, c4.side = null != n4.shadowSide ? n4.shadowSide : x3[n4.side], c4.clipShadows = n4.clipShadows, c4.clippingPlanes = n4.clippingPlanes, c4.clipIntersection = n4.clipIntersection, c4.wireframeLinewidth = n4.wireframeLinewidth, c4.linewidth = n4.linewidth, r4 && c4.isMeshDistanceMaterial && (c4.referencePosition.copy(i4), c4.nearDistance = a3, c4.farDistance = o3), c4;
        }
        function C3(n4, i4, a3, o3) {
          if (false !== n4.visible) {
            if (n4.layers.test(i4.layers) && (n4.isMesh || n4.isLine || n4.isPoints) && n4.castShadow && (!n4.frustumCulled || r3.intersectsObject(n4))) {
              n4.modelViewMatrix.multiplyMatrices(a3.matrixWorldInverse, n4.matrixWorld);
              var s3 = t3.update(n4), u4 = n4.material;
              if (Array.isArray(u4))
                for (var l4 = s3.groups, h4 = 0, d4 = l4.length; h4 < d4; h4++) {
                  var p3 = l4[h4], f4 = u4[p3.materialIndex];
                  if (f4 && f4.visible) {
                    var m3 = R3(n4, f4, o3, c3, a3.near, a3.far);
                    e3.renderBufferDirect(a3, null, s3, m3, n4, p3);
                  }
                }
              else if (u4.visible) {
                m3 = R3(n4, u4, o3, c3, a3.near, a3.far);
                e3.renderBufferDirect(a3, null, s3, m3, n4, null);
              }
            }
            for (var g3 = n4.children, v3 = 0, y4 = g3.length; v3 < y4; v3++)
              C3(g3[v3], i4, a3, o3);
          }
        }
        this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = p2, this.render = function(t4, n4, u4) {
          if (false !== L3.enabled && (false !== L3.autoUpdate || false !== L3.needsUpdate) && 0 !== t4.length) {
            var l4, h4 = e3.context, d4 = e3.state;
            d4.disable(h4.BLEND), d4.buffers.color.setClear(1, 1, 1, 1), d4.buffers.depth.setTest(true), d4.setScissorTest(false);
            for (var p3 = 0, f4 = t4.length; p3 < f4; p3++) {
              var m3 = t4[p3], g3 = m3.shadow, v3 = m3 && m3.isPointLight;
              if (void 0 !== g3) {
                var y4 = g3.camera;
                if (a2.copy(g3.mapSize), a2.min(o2), v3) {
                  var x4 = a2.x, M4 = a2.y;
                  _3[0].set(2 * x4, M4, x4, M4), _3[1].set(0, M4, x4, M4), _3[2].set(3 * x4, M4, x4, M4), _3[3].set(x4, M4, x4, M4), _3[4].set(3 * x4, 0, x4, M4), _3[5].set(x4, 0, x4, M4), a2.x *= 4, a2.y *= 2;
                }
                if (null === g3.map) {
                  var E4 = { minFilter: ye2, magFilter: ye2, format: Fe2 };
                  g3.map = new qt(a2.x, a2.y, E4), g3.map.texture.name = m3.name + ".shadowMap", y4.updateProjectionMatrix();
                }
                g3.isSpotLightShadow && g3.update(m3);
                var T4 = g3.map, S4 = g3.matrix;
                c3.setFromMatrixPosition(m3.matrixWorld), y4.position.copy(c3), v3 ? (l4 = 6, S4.makeTranslation(-c3.x, -c3.y, -c3.z)) : (l4 = 1, s2.setFromMatrixPosition(m3.target.matrixWorld), y4.lookAt(s2), y4.updateMatrixWorld(), S4.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), S4.multiply(y4.projectionMatrix), S4.multiply(y4.matrixWorldInverse)), e3.setRenderTarget(T4), e3.clear();
                for (var A4 = 0; A4 < l4; A4++) {
                  if (v3) {
                    s2.copy(y4.position), s2.add(b3[A4]), y4.up.copy(w3[A4]), y4.lookAt(s2), y4.updateMatrixWorld();
                    var R4 = _3[A4];
                    d4.viewport(R4);
                  }
                  i3.multiplyMatrices(y4.projectionMatrix, y4.matrixWorldInverse), r3.setFromMatrix(i3), C3(n4, u4, y4, v3);
                }
              } else
                console.warn("THREE.WebGLShadowMap:", m3, "has no shadow.");
            }
            L3.needsUpdate = false;
          }
        };
      }
      function ei2(e3, t3, n3, r3, i3, a2, o2) {
        var s2, c3 = {};
        function u3(e4, t4) {
          if (e4.width > t4 || e4.height > t4) {
            if ("data" in e4)
              return void console.warn("THREE.WebGLRenderer: image in DataTexture is too big (" + e4.width + "x" + e4.height + ").");
            var n4 = t4 / Math.max(e4.width, e4.height), r4 = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
            return r4.width = Math.floor(e4.width * n4), r4.height = Math.floor(e4.height * n4), r4.getContext("2d").drawImage(e4, 0, 0, e4.width, e4.height, 0, 0, r4.width, r4.height), console.warn("THREE.WebGLRenderer: image is too big (" + e4.width + "x" + e4.height + "). Resized to " + r4.width + "x" + r4.height), r4;
          }
          return e4;
        }
        function l3(e4) {
          return Bt.isPowerOfTwo(e4.width) && Bt.isPowerOfTwo(e4.height);
        }
        function h3(e4, t4) {
          return e4.generateMipmaps && t4 && e4.minFilter !== ye2 && e4.minFilter !== we2;
        }
        function d3(t4, n4, i4, a3) {
          e3.generateMipmap(t4), r3.get(n4).__maxMipLevel = Math.log(Math.max(i4, a3)) * Math.LOG2E;
        }
        function p3(t4, n4) {
          if (!i3.isWebGL2)
            return t4;
          if (t4 === e3.RGB) {
            if (n4 === e3.FLOAT)
              return e3.RGB32F;
            if (n4 === e3.HALF_FLOAT)
              return e3.RGB16F;
            if (n4 === e3.UNSIGNED_BYTE)
              return e3.RGB8;
          }
          if (t4 === e3.RGBA) {
            if (n4 === e3.FLOAT)
              return e3.RGBA32F;
            if (n4 === e3.HALF_FLOAT)
              return e3.RGBA16F;
            if (n4 === e3.UNSIGNED_BYTE)
              return e3.RGBA8;
          }
          return t4;
        }
        function f3(t4) {
          return t4 === ye2 || t4 === xe2 || t4 === be2 ? e3.NEAREST : e3.LINEAR;
        }
        function m3(t4) {
          var n4 = t4.target;
          n4.removeEventListener("dispose", m3), function(t5) {
            var n5 = r3.get(t5);
            if (t5.image && n5.__image__webglTextureCube)
              e3.deleteTexture(n5.__image__webglTextureCube);
            else {
              if (void 0 === n5.__webglInit)
                return;
              e3.deleteTexture(n5.__webglTexture);
            }
            r3.remove(t5);
          }(n4), n4.isVideoTexture && delete c3[n4.id], o2.memory.textures--;
        }
        function g3(t4) {
          var n4 = t4.target;
          n4.removeEventListener("dispose", g3), function(t5) {
            var n5 = r3.get(t5), i4 = r3.get(t5.texture);
            if (!t5)
              return;
            void 0 !== i4.__webglTexture && e3.deleteTexture(i4.__webglTexture);
            t5.depthTexture && t5.depthTexture.dispose();
            if (t5.isWebGLRenderTargetCube)
              for (var a3 = 0; a3 < 6; a3++)
                e3.deleteFramebuffer(n5.__webglFramebuffer[a3]), n5.__webglDepthbuffer && e3.deleteRenderbuffer(n5.__webglDepthbuffer[a3]);
            else
              e3.deleteFramebuffer(n5.__webglFramebuffer), n5.__webglDepthbuffer && e3.deleteRenderbuffer(n5.__webglDepthbuffer);
            r3.remove(t5.texture), r3.remove(t5);
          }(n4), o2.memory.textures--;
        }
        function v3(t4, f4) {
          var g4 = r3.get(t4);
          if (t4.isVideoTexture && function(e4) {
            var t5 = e4.id, n4 = o2.render.frame;
            c3[t5] !== n4 && (c3[t5] = n4, e4.update());
          }(t4), t4.version > 0 && g4.__version !== t4.version) {
            var v4 = t4.image;
            if (void 0 === v4)
              console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
            else {
              if (false !== v4.complete)
                return void function(t5, r4, c4) {
                  void 0 === t5.__webglInit && (t5.__webglInit = true, r4.addEventListener("dispose", m3), t5.__webglTexture = e3.createTexture(), o2.memory.textures++);
                  n3.activeTexture(e3.TEXTURE0 + c4), n3.bindTexture(e3.TEXTURE_2D, t5.__webglTexture), e3.pixelStorei(e3.UNPACK_FLIP_Y_WEBGL, r4.flipY), e3.pixelStorei(e3.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r4.premultiplyAlpha), e3.pixelStorei(e3.UNPACK_ALIGNMENT, r4.unpackAlignment);
                  var f5 = u3(r4.image, i3.maxTextureSize);
                  (function(e4) {
                    return !i3.isWebGL2 && (e4.wrapS !== ge2 || e4.wrapT !== ge2 || e4.minFilter !== ye2 && e4.minFilter !== we2);
                  })(r4) && false === l3(f5) && (f5 = function(e4) {
                    return e4 instanceof HTMLImageElement || e4 instanceof HTMLCanvasElement || e4 instanceof ImageBitmap ? (void 0 === s2 && (s2 = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), s2.width = Bt.floorPowerOfTwo(e4.width), s2.height = Bt.floorPowerOfTwo(e4.height), s2.getContext("2d").drawImage(e4, 0, 0, s2.width, s2.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + e4.width + "x" + e4.height + "). Resized to " + s2.width + "x" + s2.height), s2) : e4;
                  }(f5));
                  var g5 = l3(f5), v5 = a2.convert(r4.format), x4 = a2.convert(r4.type), b4 = p3(v5, x4);
                  y3(e3.TEXTURE_2D, r4, g5);
                  var w4, _3 = r4.mipmaps;
                  if (r4.isDepthTexture) {
                    if (b4 = e3.DEPTH_COMPONENT, r4.type === Ce2) {
                      if (!i3.isWebGL2)
                        throw new Error("Float Depth Texture only supported in WebGL2.0");
                      b4 = e3.DEPTH_COMPONENT32F;
                    } else
                      i3.isWebGL2 && (b4 = e3.DEPTH_COMPONENT16);
                    r4.format === ke2 && b4 === e3.DEPTH_COMPONENT && r4.type !== Ae2 && r4.type !== Re2 && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r4.type = Ae2, x4 = a2.convert(r4.type)), r4.format === je2 && (b4 = e3.DEPTH_STENCIL, r4.type !== De2 && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r4.type = De2, x4 = a2.convert(r4.type))), n3.texImage2D(e3.TEXTURE_2D, 0, b4, f5.width, f5.height, 0, v5, x4, null);
                  } else if (r4.isDataTexture)
                    if (_3.length > 0 && g5) {
                      for (var M3 = 0, E3 = _3.length; M3 < E3; M3++)
                        w4 = _3[M3], n3.texImage2D(e3.TEXTURE_2D, M3, b4, w4.width, w4.height, 0, v5, x4, w4.data);
                      r4.generateMipmaps = false, t5.__maxMipLevel = _3.length - 1;
                    } else
                      n3.texImage2D(e3.TEXTURE_2D, 0, b4, f5.width, f5.height, 0, v5, x4, f5.data), t5.__maxMipLevel = 0;
                  else if (r4.isCompressedTexture) {
                    for (var M3 = 0, E3 = _3.length; M3 < E3; M3++)
                      w4 = _3[M3], r4.format !== Fe2 && r4.format !== Be2 ? n3.getCompressedTextureFormats().indexOf(v5) > -1 ? n3.compressedTexImage2D(e3.TEXTURE_2D, M3, b4, w4.width, w4.height, 0, w4.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n3.texImage2D(e3.TEXTURE_2D, M3, b4, w4.width, w4.height, 0, v5, x4, w4.data);
                    t5.__maxMipLevel = _3.length - 1;
                  } else if (_3.length > 0 && g5) {
                    for (var M3 = 0, E3 = _3.length; M3 < E3; M3++)
                      w4 = _3[M3], n3.texImage2D(e3.TEXTURE_2D, M3, b4, v5, x4, w4);
                    r4.generateMipmaps = false, t5.__maxMipLevel = _3.length - 1;
                  } else
                    n3.texImage2D(e3.TEXTURE_2D, 0, b4, v5, x4, f5), t5.__maxMipLevel = 0;
                  h3(r4, g5) && d3(e3.TEXTURE_2D, r4, f5.width, f5.height);
                  t5.__version = r4.version, r4.onUpdate && r4.onUpdate(r4);
                }(g4, t4, f4);
              console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            }
          }
          n3.activeTexture(e3.TEXTURE0 + f4), n3.bindTexture(e3.TEXTURE_2D, g4.__webglTexture);
        }
        function y3(n4, o3, s3) {
          var c4;
          if (s3 ? (e3.texParameteri(n4, e3.TEXTURE_WRAP_S, a2.convert(o3.wrapS)), e3.texParameteri(n4, e3.TEXTURE_WRAP_T, a2.convert(o3.wrapT)), e3.texParameteri(n4, e3.TEXTURE_MAG_FILTER, a2.convert(o3.magFilter)), e3.texParameteri(n4, e3.TEXTURE_MIN_FILTER, a2.convert(o3.minFilter))) : (e3.texParameteri(n4, e3.TEXTURE_WRAP_S, e3.CLAMP_TO_EDGE), e3.texParameteri(n4, e3.TEXTURE_WRAP_T, e3.CLAMP_TO_EDGE), o3.wrapS === ge2 && o3.wrapT === ge2 || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e3.texParameteri(n4, e3.TEXTURE_MAG_FILTER, f3(o3.magFilter)), e3.texParameteri(n4, e3.TEXTURE_MIN_FILTER, f3(o3.minFilter)), o3.minFilter !== ye2 && o3.minFilter !== we2 && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), c4 = t3.get("EXT_texture_filter_anisotropic")) {
            if (o3.type === Ce2 && null === t3.get("OES_texture_float_linear"))
              return;
            if (o3.type === Pe2 && null === (i3.isWebGL2 || t3.get("OES_texture_half_float_linear")))
              return;
            (o3.anisotropy > 1 || r3.get(o3).__currentAnisotropy) && (e3.texParameterf(n4, c4.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o3.anisotropy, i3.getMaxAnisotropy())), r3.get(o3).__currentAnisotropy = o3.anisotropy);
          }
        }
        function x3(t4, i4, o3, s3) {
          var c4 = a2.convert(i4.texture.format), u4 = a2.convert(i4.texture.type), l4 = p3(c4, u4);
          n3.texImage2D(s3, 0, l4, i4.width, i4.height, 0, c4, u4, null), e3.bindFramebuffer(e3.FRAMEBUFFER, t4), e3.framebufferTexture2D(e3.FRAMEBUFFER, o3, s3, r3.get(i4.texture).__webglTexture, 0), e3.bindFramebuffer(e3.FRAMEBUFFER, null);
        }
        function b3(t4, n4) {
          e3.bindRenderbuffer(e3.RENDERBUFFER, t4), n4.depthBuffer && !n4.stencilBuffer ? (e3.renderbufferStorage(e3.RENDERBUFFER, e3.DEPTH_COMPONENT16, n4.width, n4.height), e3.framebufferRenderbuffer(e3.FRAMEBUFFER, e3.DEPTH_ATTACHMENT, e3.RENDERBUFFER, t4)) : n4.depthBuffer && n4.stencilBuffer ? (e3.renderbufferStorage(e3.RENDERBUFFER, e3.DEPTH_STENCIL, n4.width, n4.height), e3.framebufferRenderbuffer(e3.FRAMEBUFFER, e3.DEPTH_STENCIL_ATTACHMENT, e3.RENDERBUFFER, t4)) : e3.renderbufferStorage(e3.RENDERBUFFER, e3.RGBA4, n4.width, n4.height), e3.bindRenderbuffer(e3.RENDERBUFFER, null);
        }
        function w3(t4) {
          var n4 = r3.get(t4), i4 = true === t4.isWebGLRenderTargetCube;
          if (t4.depthTexture) {
            if (i4)
              throw new Error("target.depthTexture not supported in Cube render targets");
            !function(t5, n5) {
              if (n5 && n5.isWebGLRenderTargetCube)
                throw new Error("Depth Texture with cube render targets is not supported");
              if (e3.bindFramebuffer(e3.FRAMEBUFFER, t5), !n5.depthTexture || !n5.depthTexture.isDepthTexture)
                throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
              r3.get(n5.depthTexture).__webglTexture && n5.depthTexture.image.width === n5.width && n5.depthTexture.image.height === n5.height || (n5.depthTexture.image.width = n5.width, n5.depthTexture.image.height = n5.height, n5.depthTexture.needsUpdate = true), v3(n5.depthTexture, 0);
              var i5 = r3.get(n5.depthTexture).__webglTexture;
              if (n5.depthTexture.format === ke2)
                e3.framebufferTexture2D(e3.FRAMEBUFFER, e3.DEPTH_ATTACHMENT, e3.TEXTURE_2D, i5, 0);
              else {
                if (n5.depthTexture.format !== je2)
                  throw new Error("Unknown depthTexture format");
                e3.framebufferTexture2D(e3.FRAMEBUFFER, e3.DEPTH_STENCIL_ATTACHMENT, e3.TEXTURE_2D, i5, 0);
              }
            }(n4.__webglFramebuffer, t4);
          } else if (i4) {
            n4.__webglDepthbuffer = [];
            for (var a3 = 0; a3 < 6; a3++)
              e3.bindFramebuffer(e3.FRAMEBUFFER, n4.__webglFramebuffer[a3]), n4.__webglDepthbuffer[a3] = e3.createRenderbuffer(), b3(n4.__webglDepthbuffer[a3], t4);
          } else
            e3.bindFramebuffer(e3.FRAMEBUFFER, n4.__webglFramebuffer), n4.__webglDepthbuffer = e3.createRenderbuffer(), b3(n4.__webglDepthbuffer, t4);
          e3.bindFramebuffer(e3.FRAMEBUFFER, null);
        }
        this.setTexture2D = v3, this.setTextureCube = function(t4, s3) {
          var c4 = r3.get(t4);
          if (6 === t4.image.length)
            if (t4.version > 0 && c4.__version !== t4.version) {
              c4.__image__webglTextureCube || (t4.addEventListener("dispose", m3), c4.__image__webglTextureCube = e3.createTexture(), o2.memory.textures++), n3.activeTexture(e3.TEXTURE0 + s3), n3.bindTexture(e3.TEXTURE_CUBE_MAP, c4.__image__webglTextureCube), e3.pixelStorei(e3.UNPACK_FLIP_Y_WEBGL, t4.flipY);
              for (var f4 = t4 && t4.isCompressedTexture, g4 = t4.image[0] && t4.image[0].isDataTexture, v4 = [], x4 = 0; x4 < 6; x4++)
                v4[x4] = f4 || g4 ? g4 ? t4.image[x4].image : t4.image[x4] : u3(t4.image[x4], i3.maxCubemapSize);
              var b4 = v4[0], w4 = l3(b4), _3 = a2.convert(t4.format), M3 = a2.convert(t4.type), E3 = p3(_3, M3);
              for (y3(e3.TEXTURE_CUBE_MAP, t4, w4), x4 = 0; x4 < 6; x4++)
                if (f4)
                  for (var T3, S3 = v4[x4].mipmaps, A3 = 0, L3 = S3.length; A3 < L3; A3++)
                    T3 = S3[A3], t4.format !== Fe2 && t4.format !== Be2 ? n3.getCompressedTextureFormats().indexOf(_3) > -1 ? n3.compressedTexImage2D(e3.TEXTURE_CUBE_MAP_POSITIVE_X + x4, A3, E3, T3.width, T3.height, 0, T3.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n3.texImage2D(e3.TEXTURE_CUBE_MAP_POSITIVE_X + x4, A3, E3, T3.width, T3.height, 0, _3, M3, T3.data);
                else
                  g4 ? n3.texImage2D(e3.TEXTURE_CUBE_MAP_POSITIVE_X + x4, 0, E3, v4[x4].width, v4[x4].height, 0, _3, M3, v4[x4].data) : n3.texImage2D(e3.TEXTURE_CUBE_MAP_POSITIVE_X + x4, 0, E3, _3, M3, v4[x4]);
              c4.__maxMipLevel = f4 ? S3.length - 1 : 0, h3(t4, w4) && d3(e3.TEXTURE_CUBE_MAP, t4, b4.width, b4.height), c4.__version = t4.version, t4.onUpdate && t4.onUpdate(t4);
            } else
              n3.activeTexture(e3.TEXTURE0 + s3), n3.bindTexture(e3.TEXTURE_CUBE_MAP, c4.__image__webglTextureCube);
        }, this.setTextureCubeDynamic = function(t4, i4) {
          n3.activeTexture(e3.TEXTURE0 + i4), n3.bindTexture(e3.TEXTURE_CUBE_MAP, r3.get(t4).__webglTexture);
        }, this.setupRenderTarget = function(t4) {
          var i4 = r3.get(t4), a3 = r3.get(t4.texture);
          t4.addEventListener("dispose", g3), a3.__webglTexture = e3.createTexture(), o2.memory.textures++;
          var s3 = true === t4.isWebGLRenderTargetCube, c4 = l3(t4);
          if (s3) {
            i4.__webglFramebuffer = [];
            for (var u4 = 0; u4 < 6; u4++)
              i4.__webglFramebuffer[u4] = e3.createFramebuffer();
          } else
            i4.__webglFramebuffer = e3.createFramebuffer();
          if (s3) {
            for (n3.bindTexture(e3.TEXTURE_CUBE_MAP, a3.__webglTexture), y3(e3.TEXTURE_CUBE_MAP, t4.texture, c4), u4 = 0; u4 < 6; u4++)
              x3(i4.__webglFramebuffer[u4], t4, e3.COLOR_ATTACHMENT0, e3.TEXTURE_CUBE_MAP_POSITIVE_X + u4);
            h3(t4.texture, c4) && d3(e3.TEXTURE_CUBE_MAP, t4.texture, t4.width, t4.height), n3.bindTexture(e3.TEXTURE_CUBE_MAP, null);
          } else
            n3.bindTexture(e3.TEXTURE_2D, a3.__webglTexture), y3(e3.TEXTURE_2D, t4.texture, c4), x3(i4.__webglFramebuffer, t4, e3.COLOR_ATTACHMENT0, e3.TEXTURE_2D), h3(t4.texture, c4) && d3(e3.TEXTURE_2D, t4.texture, t4.width, t4.height), n3.bindTexture(e3.TEXTURE_2D, null);
          t4.depthBuffer && w3(t4);
        }, this.updateRenderTargetMipmap = function(t4) {
          var i4 = t4.texture;
          if (h3(i4, l3(t4))) {
            var a3 = t4.isWebGLRenderTargetCube ? e3.TEXTURE_CUBE_MAP : e3.TEXTURE_2D, o3 = r3.get(i4).__webglTexture;
            n3.bindTexture(a3, o3), d3(a3, i4, t4.width, t4.height), n3.bindTexture(a3, null);
          }
        };
      }
      function ti2(e3, t3, n3) {
        return { convert: function(r3) {
          var i3;
          if (r3 === me2)
            return e3.REPEAT;
          if (r3 === ge2)
            return e3.CLAMP_TO_EDGE;
          if (r3 === ve2)
            return e3.MIRRORED_REPEAT;
          if (r3 === ye2)
            return e3.NEAREST;
          if (r3 === xe2)
            return e3.NEAREST_MIPMAP_NEAREST;
          if (r3 === be2)
            return e3.NEAREST_MIPMAP_LINEAR;
          if (r3 === we2)
            return e3.LINEAR;
          if (r3 === _e)
            return e3.LINEAR_MIPMAP_NEAREST;
          if (r3 === Me2)
            return e3.LINEAR_MIPMAP_LINEAR;
          if (r3 === Ee2)
            return e3.UNSIGNED_BYTE;
          if (r3 === Oe2)
            return e3.UNSIGNED_SHORT_4_4_4_4;
          if (r3 === Ne2)
            return e3.UNSIGNED_SHORT_5_5_5_1;
          if (r3 === Ie2)
            return e3.UNSIGNED_SHORT_5_6_5;
          if (r3 === Te2)
            return e3.BYTE;
          if (r3 === Se2)
            return e3.SHORT;
          if (r3 === Ae2)
            return e3.UNSIGNED_SHORT;
          if (r3 === Le2)
            return e3.INT;
          if (r3 === Re2)
            return e3.UNSIGNED_INT;
          if (r3 === Ce2)
            return e3.FLOAT;
          if (r3 === Pe2) {
            if (n3.isWebGL2)
              return e3.HALF_FLOAT;
            if (null !== (i3 = t3.get("OES_texture_half_float")))
              return i3.HALF_FLOAT_OES;
          }
          if (r3 === Ue2)
            return e3.ALPHA;
          if (r3 === Be2)
            return e3.RGB;
          if (r3 === Fe2)
            return e3.RGBA;
          if (r3 === Ge2)
            return e3.LUMINANCE;
          if (r3 === ze2)
            return e3.LUMINANCE_ALPHA;
          if (r3 === ke2)
            return e3.DEPTH_COMPONENT;
          if (r3 === je2)
            return e3.DEPTH_STENCIL;
          if (r3 === R2)
            return e3.FUNC_ADD;
          if (r3 === C2)
            return e3.FUNC_SUBTRACT;
          if (r3 === P2)
            return e3.FUNC_REVERSE_SUBTRACT;
          if (r3 === I2)
            return e3.ZERO;
          if (r3 === D2)
            return e3.ONE;
          if (r3 === U2)
            return e3.SRC_COLOR;
          if (r3 === B2)
            return e3.ONE_MINUS_SRC_COLOR;
          if (r3 === F2)
            return e3.SRC_ALPHA;
          if (r3 === G2)
            return e3.ONE_MINUS_SRC_ALPHA;
          if (r3 === z2)
            return e3.DST_ALPHA;
          if (r3 === H2)
            return e3.ONE_MINUS_DST_ALPHA;
          if (r3 === k2)
            return e3.DST_COLOR;
          if (r3 === j)
            return e3.ONE_MINUS_DST_COLOR;
          if (r3 === V2)
            return e3.SRC_ALPHA_SATURATE;
          if ((r3 === Ve2 || r3 === We2 || r3 === Xe2 || r3 === qe2) && null !== (i3 = t3.get("WEBGL_compressed_texture_s3tc"))) {
            if (r3 === Ve2)
              return i3.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (r3 === We2)
              return i3.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (r3 === Xe2)
              return i3.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (r3 === qe2)
              return i3.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          }
          if ((r3 === Ye2 || r3 === Ze2 || r3 === Je2 || r3 === Ke2) && null !== (i3 = t3.get("WEBGL_compressed_texture_pvrtc"))) {
            if (r3 === Ye2)
              return i3.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (r3 === Ze2)
              return i3.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (r3 === Je2)
              return i3.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (r3 === Ke2)
              return i3.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          }
          if (r3 === Qe2 && null !== (i3 = t3.get("WEBGL_compressed_texture_etc1")))
            return i3.COMPRESSED_RGB_ETC1_WEBGL;
          if ((r3 === $e2 || r3 === et || r3 === tt || r3 === nt || r3 === rt || r3 === it || r3 === at || r3 === ot || r3 === st || r3 === ct || r3 === ut || r3 === lt || r3 === ht || r3 === dt) && null !== (i3 = t3.get("WEBGL_compressed_texture_astc")))
            return r3;
          if (r3 === O2 || r3 === N2) {
            if (n3.isWebGL2) {
              if (r3 === O2)
                return e3.MIN;
              if (r3 === N2)
                return e3.MAX;
            }
            if (null !== (i3 = t3.get("EXT_blend_minmax"))) {
              if (r3 === O2)
                return i3.MIN_EXT;
              if (r3 === N2)
                return i3.MAX_EXT;
            }
          }
          if (r3 === De2) {
            if (n3.isWebGL2)
              return e3.UNSIGNED_INT_24_8;
            if (null !== (i3 = t3.get("WEBGL_depth_texture")))
              return i3.UNSIGNED_INT_24_8_WEBGL;
          }
          return 0;
        } };
      }
      function ni2() {
        dn.call(this), this.type = "Group";
      }
      function ri2(e3, t3, n3, r3) {
        pn.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== e3 ? e3 : 50, this.zoom = 1, this.near = void 0 !== n3 ? n3 : 0.1, this.far = void 0 !== r3 ? r3 : 2e3, this.focus = 10, this.aspect = void 0 !== t3 ? t3 : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
      }
      function ii2(e3) {
        ri2.call(this), this.cameras = e3 || [];
      }
      function ai2(e3) {
        var t3 = this, n3 = null, r3 = null, i3 = null, a2 = [], o2 = new Gt(), s2 = new Gt();
        "undefined" != typeof window && "VRFrameData" in window && (r3 = new window.VRFrameData(), window.addEventListener("vrdisplaypresentchange", v3, false));
        var c3 = new Gt(), u3 = new zt(), l3 = new Ht(), h3 = new ri2();
        h3.bounds = new Xt(0, 0, 0.5, 1), h3.layers.enable(1);
        var d3 = new ri2();
        d3.bounds = new Xt(0.5, 0, 0.5, 1), d3.layers.enable(2);
        var p3, f3, m3 = new ii2([h3, d3]);
        function g3() {
          return null !== n3 && true === n3.isPresenting;
        }
        function v3() {
          if (g3()) {
            var r4 = n3.getEyeParameters("left"), i4 = r4.renderWidth, a3 = r4.renderHeight;
            f3 = e3.getPixelRatio(), p3 = e3.getSize(), e3.setDrawingBufferSize(2 * i4, a3, 1), b3.start();
          } else
            t3.enabled && (e3.setDrawingBufferSize(p3.width, p3.height, f3), b3.stop());
        }
        m3.layers.enable(1), m3.layers.enable(2);
        var y3 = [];
        function x3(e4) {
          for (var t4 = navigator.getGamepads && navigator.getGamepads(), n4 = 0, r4 = 0, i4 = t4.length; n4 < i4; n4++) {
            var a3 = t4[n4];
            if (a3 && ("Daydream Controller" === a3.id || "Gear VR Controller" === a3.id || "Oculus Go Controller" === a3.id || "OpenVR Gamepad" === a3.id || a3.id.startsWith("Oculus Touch") || a3.id.startsWith("Spatial Controller"))) {
              if (r4 === e4)
                return a3;
              r4++;
            }
          }
        }
        this.enabled = false, this.userHeight = 1.6, this.getController = function(e4) {
          var t4 = a2[e4];
          return void 0 === t4 && ((t4 = new ni2()).matrixAutoUpdate = false, t4.visible = false, a2[e4] = t4), t4;
        }, this.getDevice = function() {
          return n3;
        }, this.setDevice = function(e4) {
          void 0 !== e4 && (n3 = e4), b3.setContext(e4);
        }, this.setPoseTarget = function(e4) {
          void 0 !== e4 && (i3 = e4);
        }, this.getCamera = function(e4) {
          if (null === n3)
            return e4.position.set(0, t3.userHeight, 0), e4;
          n3.depthNear = e4.near, n3.depthFar = e4.far, n3.getFrameData(r3);
          var p4 = n3.stageParameters;
          p4 ? o2.fromArray(p4.sittingToStandingTransform) : o2.makeTranslation(0, t3.userHeight, 0);
          var f4 = r3.pose, g4 = null !== i3 ? i3 : e4;
          if (g4.matrix.copy(o2), g4.matrix.decompose(g4.position, g4.quaternion, g4.scale), null !== f4.orientation && (u3.fromArray(f4.orientation), g4.quaternion.multiply(u3)), null !== f4.position && (u3.setFromRotationMatrix(o2), l3.fromArray(f4.position), l3.applyQuaternion(u3), g4.position.add(l3)), g4.updateMatrixWorld(), false === n3.isPresenting)
            return e4;
          h3.near = e4.near, d3.near = e4.near, h3.far = e4.far, d3.far = e4.far, m3.matrixWorld.copy(e4.matrixWorld), m3.matrixWorldInverse.copy(e4.matrixWorldInverse), h3.matrixWorldInverse.fromArray(r3.leftViewMatrix), d3.matrixWorldInverse.fromArray(r3.rightViewMatrix), s2.getInverse(o2), h3.matrixWorldInverse.multiply(s2), d3.matrixWorldInverse.multiply(s2);
          var v4 = g4.parent;
          null !== v4 && (c3.getInverse(v4.matrixWorld), h3.matrixWorldInverse.multiply(c3), d3.matrixWorldInverse.multiply(c3)), h3.matrixWorld.getInverse(h3.matrixWorldInverse), d3.matrixWorld.getInverse(d3.matrixWorldInverse), h3.projectionMatrix.fromArray(r3.leftProjectionMatrix), d3.projectionMatrix.fromArray(r3.rightProjectionMatrix), m3.projectionMatrix.copy(h3.projectionMatrix);
          var b4 = n3.getLayers();
          if (b4.length) {
            var w3 = b4[0];
            null !== w3.leftBounds && 4 === w3.leftBounds.length && h3.bounds.fromArray(w3.leftBounds), null !== w3.rightBounds && 4 === w3.rightBounds.length && d3.bounds.fromArray(w3.rightBounds);
          }
          return function() {
            for (var e5 = 0; e5 < a2.length; e5++) {
              var t4 = a2[e5], n4 = x3(e5);
              if (void 0 !== n4 && void 0 !== n4.pose) {
                if (null === n4.pose)
                  return;
                var r4 = n4.pose;
                false === r4.hasPosition && t4.position.set(0.2, -0.6, -0.05), null !== r4.position && t4.position.fromArray(r4.position), null !== r4.orientation && t4.quaternion.fromArray(r4.orientation), t4.matrix.compose(t4.position, t4.quaternion, t4.scale), t4.matrix.premultiply(o2), t4.matrix.decompose(t4.position, t4.quaternion, t4.scale), t4.matrixWorldNeedsUpdate = true, t4.visible = true;
                var i4 = "Daydream Controller" === n4.id ? 0 : 1;
                y3[e5] !== n4.buttons[i4].pressed && (y3[e5] = n4.buttons[i4].pressed, true === y3[e5] ? t4.dispatchEvent({ type: "selectstart" }) : (t4.dispatchEvent({ type: "selectend" }), t4.dispatchEvent({ type: "select" })));
              } else
                t4.visible = false;
            }
          }(), m3;
        }, this.getStandingMatrix = function() {
          return o2;
        }, this.isPresenting = g3;
        var b3 = new sn();
        this.setAnimationLoop = function(e4) {
          b3.setAnimationLoop(e4);
        }, this.submitFrame = function() {
          g3() && n3.submitFrame();
        }, this.dispose = function() {
          "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", v3);
        };
      }
      function oi2(e3) {
        console.log("THREE.WebGLRenderer", i2);
        var t3 = void 0 !== (e3 = e3 || {}).canvas ? e3.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), n3 = void 0 !== e3.context ? e3.context : null, r3 = void 0 !== e3.alpha && e3.alpha, a2 = void 0 === e3.depth || e3.depth, u3 = void 0 === e3.stencil || e3.stencil, l3 = void 0 !== e3.antialias && e3.antialias, h3 = void 0 === e3.premultipliedAlpha || e3.premultipliedAlpha, d3 = void 0 !== e3.preserveDrawingBuffer && e3.preserveDrawingBuffer, p3 = void 0 !== e3.powerPreference ? e3.powerPreference : "default", f3 = null, m3 = null;
        this.domElement = t3, this.context = null, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this.gammaFactor = 2, this.gammaInput = false, this.gammaOutput = false, this.physicallyCorrectLights = false, this.toneMapping = re2, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
        var y3, x3, b3, w3, _3, R3, C3, P3, O3, N3, I3, D3, U3, B3, F3, G3, z3, H3, k3 = this, j2 = false, V3 = null, $2 = null, ee3 = null, te3 = -1, ne3 = { geometry: null, program: null, wireframe: false }, ie3 = null, ae3 = null, oe3 = new Xt(), se3 = new Xt(), ce3 = null, ue3 = 0, le3 = t3.width, he3 = t3.height, de3 = 1, pe3 = new Xt(0, 0, le3, he3), fe3 = new Xt(0, 0, le3, he3), me3 = false, ge3 = new $t(), ve3 = new function() {
          var e4 = this, t4 = null, n4 = 0, r4 = false, i3 = false, a3 = new Qt(), o2 = new kt(), s2 = { value: null, needsUpdate: false };
          function c3() {
            s2.value !== t4 && (s2.value = t4, s2.needsUpdate = n4 > 0), e4.numPlanes = n4, e4.numIntersection = 0;
          }
          function u4(t5, n5, r5, i4) {
            var c4 = null !== t5 ? t5.length : 0, u5 = null;
            if (0 !== c4) {
              if (u5 = s2.value, true !== i4 || null === u5) {
                var l4 = r5 + 4 * c4, h4 = n5.matrixWorldInverse;
                o2.getNormalMatrix(h4), (null === u5 || u5.length < l4) && (u5 = new Float32Array(l4));
                for (var d4 = 0, p4 = r5; d4 !== c4; ++d4, p4 += 4)
                  a3.copy(t5[d4]).applyMatrix4(h4, o2), a3.normal.toArray(u5, p4), u5[p4 + 3] = a3.constant;
              }
              s2.value = u5, s2.needsUpdate = true;
            }
            return e4.numPlanes = c4, u5;
          }
          this.uniform = s2, this.numPlanes = 0, this.numIntersection = 0, this.init = function(e5, i4, a4) {
            var o3 = 0 !== e5.length || i4 || 0 !== n4 || r4;
            return r4 = i4, t4 = u4(e5, a4, 0), n4 = e5.length, o3;
          }, this.beginShadows = function() {
            i3 = true, u4(null);
          }, this.endShadows = function() {
            i3 = false, c3();
          }, this.setState = function(e5, a4, o3, l4, h4, d4) {
            if (!r4 || null === e5 || 0 === e5.length || i3 && !o3)
              i3 ? u4(null) : c3();
            else {
              var p4 = i3 ? 0 : n4, f4 = 4 * p4, m4 = h4.clippingState || null;
              s2.value = m4, m4 = u4(e5, l4, f4, d4);
              for (var g3 = 0; g3 !== f4; ++g3)
                m4[g3] = t4[g3];
              h4.clippingState = m4, this.numIntersection = a4 ? this.numPlanes : 0, this.numPlanes += p4;
            }
          };
        }(), ye3 = false, xe3 = false, be3 = new Gt(), we3 = new Ht();
        function _e2() {
          return null === $2 ? de3 : 1;
        }
        try {
          var Me3 = { alpha: r3, depth: a2, stencil: u3, antialias: l3, premultipliedAlpha: h3, preserveDrawingBuffer: d3, powerPreference: p3 };
          if (t3.addEventListener("webglcontextlost", Le3, false), t3.addEventListener("webglcontextrestored", Re3, false), null === (y3 = n3 || t3.getContext("webgl", Me3) || t3.getContext("experimental-webgl", Me3)))
            throw null !== t3.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
          void 0 === y3.getShaderPrecisionFormat && (y3.getShaderPrecisionFormat = function() {
            return { rangeMin: 1, rangeMax: 1, precision: 1 };
          });
        } catch (e4) {
          console.error("THREE.WebGLRenderer: " + e4.message);
        }
        function Te3() {
          x3 = new function(e4) {
            var t4 = {};
            return { get: function(n4) {
              if (void 0 !== t4[n4])
                return t4[n4];
              var r4;
              switch (n4) {
                case "WEBGL_depth_texture":
                  r4 = e4.getExtension("WEBGL_depth_texture") || e4.getExtension("MOZ_WEBGL_depth_texture") || e4.getExtension("WEBKIT_WEBGL_depth_texture");
                  break;
                case "EXT_texture_filter_anisotropic":
                  r4 = e4.getExtension("EXT_texture_filter_anisotropic") || e4.getExtension("MOZ_EXT_texture_filter_anisotropic") || e4.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                  break;
                case "WEBGL_compressed_texture_s3tc":
                  r4 = e4.getExtension("WEBGL_compressed_texture_s3tc") || e4.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e4.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                  break;
                case "WEBGL_compressed_texture_pvrtc":
                  r4 = e4.getExtension("WEBGL_compressed_texture_pvrtc") || e4.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                  break;
                default:
                  r4 = e4.getExtension(n4);
              }
              return null === r4 && console.warn("THREE.WebGLRenderer: " + n4 + " extension not supported."), t4[n4] = r4, r4;
            } };
          }(y3), (b3 = new function(e4, t4, n4) {
            var r4;
            function i3(t5) {
              if ("highp" === t5) {
                if (e4.getShaderPrecisionFormat(e4.VERTEX_SHADER, e4.HIGH_FLOAT).precision > 0 && e4.getShaderPrecisionFormat(e4.FRAGMENT_SHADER, e4.HIGH_FLOAT).precision > 0)
                  return "highp";
                t5 = "mediump";
              }
              return "mediump" === t5 && e4.getShaderPrecisionFormat(e4.VERTEX_SHADER, e4.MEDIUM_FLOAT).precision > 0 && e4.getShaderPrecisionFormat(e4.FRAGMENT_SHADER, e4.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
            }
            var a3 = "undefined" != typeof WebGL2RenderingContext && e4 instanceof WebGL2RenderingContext, o2 = void 0 !== n4.precision ? n4.precision : "highp", s2 = i3(o2);
            s2 !== o2 && (console.warn("THREE.WebGLRenderer:", o2, "not supported, using", s2, "instead."), o2 = s2);
            var c3 = true === n4.logarithmicDepthBuffer, u4 = e4.getParameter(e4.MAX_TEXTURE_IMAGE_UNITS), l4 = e4.getParameter(e4.MAX_VERTEX_TEXTURE_IMAGE_UNITS), h4 = e4.getParameter(e4.MAX_TEXTURE_SIZE), d4 = e4.getParameter(e4.MAX_CUBE_MAP_TEXTURE_SIZE), p4 = e4.getParameter(e4.MAX_VERTEX_ATTRIBS), f4 = e4.getParameter(e4.MAX_VERTEX_UNIFORM_VECTORS), m4 = e4.getParameter(e4.MAX_VARYING_VECTORS), g3 = e4.getParameter(e4.MAX_FRAGMENT_UNIFORM_VECTORS), v3 = l4 > 0, y4 = a3 || !!t4.get("OES_texture_float");
            return { isWebGL2: a3, getMaxAnisotropy: function() {
              if (void 0 !== r4)
                return r4;
              var n5 = t4.get("EXT_texture_filter_anisotropic");
              return r4 = null !== n5 ? e4.getParameter(n5.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
            }, getMaxPrecision: i3, precision: o2, logarithmicDepthBuffer: c3, maxTextures: u4, maxVertexTextures: l4, maxTextureSize: h4, maxCubemapSize: d4, maxAttributes: p4, maxVertexUniforms: f4, maxVaryings: m4, maxFragmentUniforms: g3, vertexTextures: v3, floatFragmentTextures: y4, floatVertexTextures: v3 && y4 };
          }(y3, x3, e3)).isWebGL2 || (x3.get("WEBGL_depth_texture"), x3.get("OES_texture_float"), x3.get("OES_texture_half_float"), x3.get("OES_texture_half_float_linear"), x3.get("OES_standard_derivatives"), x3.get("OES_element_index_uint"), x3.get("ANGLE_instanced_arrays")), x3.get("OES_texture_float_linear"), H3 = new ti2(y3, x3, b3), (w3 = new function(e4, t4, n4, r4) {
            var i3 = new function() {
              var t5 = false, n5 = new Xt(), r5 = null, i4 = new Xt(0, 0, 0, 0);
              return { setMask: function(n6) {
                r5 === n6 || t5 || (e4.colorMask(n6, n6, n6, n6), r5 = n6);
              }, setLocked: function(e5) {
                t5 = e5;
              }, setClear: function(t6, r6, a4, o2, s2) {
                true === s2 && (t6 *= o2, r6 *= o2, a4 *= o2), n5.set(t6, r6, a4, o2), false === i4.equals(n5) && (e4.clearColor(t6, r6, a4, o2), i4.copy(n5));
              }, reset: function() {
                t5 = false, r5 = null, i4.set(-1, 0, 0, 0);
              } };
            }(), a3 = new function() {
              var t5 = false, n5 = null, r5 = null, i4 = null;
              return { setTest: function(t6) {
                t6 ? re3(e4.DEPTH_TEST) : ie4(e4.DEPTH_TEST);
              }, setMask: function(r6) {
                n5 === r6 || t5 || (e4.depthMask(r6), n5 = r6);
              }, setFunc: function(t6) {
                if (r5 !== t6) {
                  if (t6)
                    switch (t6) {
                      case W2:
                        e4.depthFunc(e4.NEVER);
                        break;
                      case X2:
                        e4.depthFunc(e4.ALWAYS);
                        break;
                      case q2:
                        e4.depthFunc(e4.LESS);
                        break;
                      case Y2:
                        e4.depthFunc(e4.LEQUAL);
                        break;
                      case Z2:
                        e4.depthFunc(e4.EQUAL);
                        break;
                      case J2:
                        e4.depthFunc(e4.GEQUAL);
                        break;
                      case K2:
                        e4.depthFunc(e4.GREATER);
                        break;
                      case Q2:
                        e4.depthFunc(e4.NOTEQUAL);
                        break;
                      default:
                        e4.depthFunc(e4.LEQUAL);
                    }
                  else
                    e4.depthFunc(e4.LEQUAL);
                  r5 = t6;
                }
              }, setLocked: function(e5) {
                t5 = e5;
              }, setClear: function(t6) {
                i4 !== t6 && (e4.clearDepth(t6), i4 = t6);
              }, reset: function() {
                t5 = false, n5 = null, r5 = null, i4 = null;
              } };
            }(), u4 = new function() {
              var t5 = false, n5 = null, r5 = null, i4 = null, a4 = null, o2 = null, s2 = null, c3 = null, u5 = null;
              return { setTest: function(t6) {
                t6 ? re3(e4.STENCIL_TEST) : ie4(e4.STENCIL_TEST);
              }, setMask: function(r6) {
                n5 === r6 || t5 || (e4.stencilMask(r6), n5 = r6);
              }, setFunc: function(t6, n6, o3) {
                r5 === t6 && i4 === n6 && a4 === o3 || (e4.stencilFunc(t6, n6, o3), r5 = t6, i4 = n6, a4 = o3);
              }, setOp: function(t6, n6, r6) {
                o2 === t6 && s2 === n6 && c3 === r6 || (e4.stencilOp(t6, n6, r6), o2 = t6, s2 = n6, c3 = r6);
              }, setLocked: function(e5) {
                t5 = e5;
              }, setClear: function(t6) {
                u5 !== t6 && (e4.clearStencil(t6), u5 = t6);
              }, reset: function() {
                t5 = false, n5 = null, r5 = null, i4 = null, a4 = null, o2 = null, s2 = null, c3 = null, u5 = null;
              } };
            }(), l4 = e4.getParameter(e4.MAX_VERTEX_ATTRIBS), h4 = new Uint8Array(l4), d4 = new Uint8Array(l4), p4 = new Uint8Array(l4), f4 = {}, m4 = null, y4 = null, x4 = null, b4 = null, w4 = null, _4 = null, R4 = null, C4 = null, P4 = null, O4 = false, N4 = null, I4 = null, D4 = null, U4 = null, B4 = null, F4 = e4.getParameter(e4.MAX_COMBINED_TEXTURE_IMAGE_UNITS), G4 = false, z4 = 0, H4 = e4.getParameter(e4.VERSION);
            -1 !== H4.indexOf("WebGL") ? (z4 = parseFloat(/^WebGL\ ([0-9])/.exec(H4)[1]), G4 = z4 >= 1) : -1 !== H4.indexOf("OpenGL ES") && (z4 = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(H4)[1]), G4 = z4 >= 2);
            var k4 = null, j3 = {}, V4 = new Xt(), $3 = new Xt();
            function ee4(t5, n5, r5) {
              var i4 = new Uint8Array(4), a4 = e4.createTexture();
              e4.bindTexture(t5, a4), e4.texParameteri(t5, e4.TEXTURE_MIN_FILTER, e4.NEAREST), e4.texParameteri(t5, e4.TEXTURE_MAG_FILTER, e4.NEAREST);
              for (var o2 = 0; o2 < r5; o2++)
                e4.texImage2D(n5 + o2, 0, e4.RGBA, 1, 1, 0, e4.RGBA, e4.UNSIGNED_BYTE, i4);
              return a4;
            }
            var te4 = {};
            function ne4(n5, i4) {
              h4[n5] = 1, 0 === d4[n5] && (e4.enableVertexAttribArray(n5), d4[n5] = 1), p4[n5] !== i4 && ((r4.isWebGL2 ? e4 : t4.get("ANGLE_instanced_arrays"))[r4.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n5, i4), p4[n5] = i4);
            }
            function re3(t5) {
              true !== f4[t5] && (e4.enable(t5), f4[t5] = true);
            }
            function ie4(t5) {
              false !== f4[t5] && (e4.disable(t5), f4[t5] = false);
            }
            function ae4(t5, r5, i4, a4, o2, s2, c3, u5) {
              if (t5 !== M2 ? re3(e4.BLEND) : ie4(e4.BLEND), t5 !== L2) {
                if (t5 !== x4 || u5 !== O4)
                  switch (t5) {
                    case T2:
                      u5 ? (e4.blendEquationSeparate(e4.FUNC_ADD, e4.FUNC_ADD), e4.blendFuncSeparate(e4.ONE, e4.ONE, e4.ONE, e4.ONE)) : (e4.blendEquation(e4.FUNC_ADD), e4.blendFunc(e4.SRC_ALPHA, e4.ONE));
                      break;
                    case S2:
                      u5 ? (e4.blendEquationSeparate(e4.FUNC_ADD, e4.FUNC_ADD), e4.blendFuncSeparate(e4.ZERO, e4.ZERO, e4.ONE_MINUS_SRC_COLOR, e4.ONE_MINUS_SRC_ALPHA)) : (e4.blendEquation(e4.FUNC_ADD), e4.blendFunc(e4.ZERO, e4.ONE_MINUS_SRC_COLOR));
                      break;
                    case A2:
                      u5 ? (e4.blendEquationSeparate(e4.FUNC_ADD, e4.FUNC_ADD), e4.blendFuncSeparate(e4.ZERO, e4.SRC_COLOR, e4.ZERO, e4.SRC_ALPHA)) : (e4.blendEquation(e4.FUNC_ADD), e4.blendFunc(e4.ZERO, e4.SRC_COLOR));
                      break;
                    default:
                      u5 ? (e4.blendEquationSeparate(e4.FUNC_ADD, e4.FUNC_ADD), e4.blendFuncSeparate(e4.ONE, e4.ONE_MINUS_SRC_ALPHA, e4.ONE, e4.ONE_MINUS_SRC_ALPHA)) : (e4.blendEquationSeparate(e4.FUNC_ADD, e4.FUNC_ADD), e4.blendFuncSeparate(e4.SRC_ALPHA, e4.ONE_MINUS_SRC_ALPHA, e4.ONE, e4.ONE_MINUS_SRC_ALPHA));
                  }
                b4 = null, w4 = null, _4 = null, R4 = null, C4 = null, P4 = null;
              } else
                o2 = o2 || r5, s2 = s2 || i4, c3 = c3 || a4, r5 === b4 && o2 === R4 || (e4.blendEquationSeparate(n4.convert(r5), n4.convert(o2)), b4 = r5, R4 = o2), i4 === w4 && a4 === _4 && s2 === C4 && c3 === P4 || (e4.blendFuncSeparate(n4.convert(i4), n4.convert(a4), n4.convert(s2), n4.convert(c3)), w4 = i4, _4 = a4, C4 = s2, P4 = c3);
              x4 = t5, O4 = u5;
            }
            function oe4(t5) {
              N4 !== t5 && (t5 ? e4.frontFace(e4.CW) : e4.frontFace(e4.CCW), N4 = t5);
            }
            function se4(t5) {
              t5 !== o ? (re3(e4.CULL_FACE), t5 !== I4 && (t5 === s ? e4.cullFace(e4.BACK) : t5 === c2 ? e4.cullFace(e4.FRONT) : e4.cullFace(e4.FRONT_AND_BACK))) : ie4(e4.CULL_FACE), I4 = t5;
            }
            function ce4(t5, n5, r5) {
              t5 ? (re3(e4.POLYGON_OFFSET_FILL), U4 === n5 && B4 === r5 || (e4.polygonOffset(n5, r5), U4 = n5, B4 = r5)) : ie4(e4.POLYGON_OFFSET_FILL);
            }
            function ue4(t5) {
              void 0 === t5 && (t5 = e4.TEXTURE0 + F4 - 1), k4 !== t5 && (e4.activeTexture(t5), k4 = t5);
            }
            return te4[e4.TEXTURE_2D] = ee4(e4.TEXTURE_2D, e4.TEXTURE_2D, 1), te4[e4.TEXTURE_CUBE_MAP] = ee4(e4.TEXTURE_CUBE_MAP, e4.TEXTURE_CUBE_MAP_POSITIVE_X, 6), i3.setClear(0, 0, 0, 1), a3.setClear(1), u4.setClear(0), re3(e4.DEPTH_TEST), a3.setFunc(Y2), oe4(false), se4(s), re3(e4.CULL_FACE), re3(e4.BLEND), ae4(E2), { buffers: { color: i3, depth: a3, stencil: u4 }, initAttributes: function() {
              for (var e5 = 0, t5 = h4.length; e5 < t5; e5++)
                h4[e5] = 0;
            }, enableAttribute: function(e5) {
              ne4(e5, 0);
            }, enableAttributeAndDivisor: ne4, disableUnusedAttributes: function() {
              for (var t5 = 0, n5 = d4.length; t5 !== n5; ++t5)
                d4[t5] !== h4[t5] && (e4.disableVertexAttribArray(t5), d4[t5] = 0);
            }, enable: re3, disable: ie4, getCompressedTextureFormats: function() {
              if (null === m4 && (m4 = [], t4.get("WEBGL_compressed_texture_pvrtc") || t4.get("WEBGL_compressed_texture_s3tc") || t4.get("WEBGL_compressed_texture_etc1") || t4.get("WEBGL_compressed_texture_astc")))
                for (var n5 = e4.getParameter(e4.COMPRESSED_TEXTURE_FORMATS), r5 = 0; r5 < n5.length; r5++)
                  m4.push(n5[r5]);
              return m4;
            }, useProgram: function(t5) {
              return y4 !== t5 && (e4.useProgram(t5), y4 = t5, true);
            }, setBlending: ae4, setMaterial: function(t5, n5) {
              t5.side === v2 ? ie4(e4.CULL_FACE) : re3(e4.CULL_FACE);
              var r5 = t5.side === g2;
              n5 && (r5 = !r5), oe4(r5), t5.blending === E2 && false === t5.transparent ? ae4(M2) : ae4(t5.blending, t5.blendEquation, t5.blendSrc, t5.blendDst, t5.blendEquationAlpha, t5.blendSrcAlpha, t5.blendDstAlpha, t5.premultipliedAlpha), a3.setFunc(t5.depthFunc), a3.setTest(t5.depthTest), a3.setMask(t5.depthWrite), i3.setMask(t5.colorWrite), ce4(t5.polygonOffset, t5.polygonOffsetFactor, t5.polygonOffsetUnits);
            }, setFlipSided: oe4, setCullFace: se4, setLineWidth: function(t5) {
              t5 !== D4 && (G4 && e4.lineWidth(t5), D4 = t5);
            }, setPolygonOffset: ce4, setScissorTest: function(t5) {
              t5 ? re3(e4.SCISSOR_TEST) : ie4(e4.SCISSOR_TEST);
            }, activeTexture: ue4, bindTexture: function(t5, n5) {
              null === k4 && ue4();
              var r5 = j3[k4];
              void 0 === r5 && (r5 = { type: void 0, texture: void 0 }, j3[k4] = r5), r5.type === t5 && r5.texture === n5 || (e4.bindTexture(t5, n5 || te4[t5]), r5.type = t5, r5.texture = n5);
            }, compressedTexImage2D: function() {
              try {
                e4.compressedTexImage2D.apply(e4, arguments);
              } catch (e5) {
                console.error("THREE.WebGLState:", e5);
              }
            }, texImage2D: function() {
              try {
                e4.texImage2D.apply(e4, arguments);
              } catch (e5) {
                console.error("THREE.WebGLState:", e5);
              }
            }, scissor: function(t5) {
              false === V4.equals(t5) && (e4.scissor(t5.x, t5.y, t5.z, t5.w), V4.copy(t5));
            }, viewport: function(t5) {
              false === $3.equals(t5) && (e4.viewport(t5.x, t5.y, t5.z, t5.w), $3.copy(t5));
            }, reset: function() {
              for (var t5 = 0; t5 < d4.length; t5++)
                1 === d4[t5] && (e4.disableVertexAttribArray(t5), d4[t5] = 0);
              f4 = {}, m4 = null, k4 = null, j3 = {}, y4 = null, x4 = null, N4 = null, I4 = null, i3.reset(), a3.reset(), u4.reset();
            } };
          }(y3, x3, H3, b3)).scissor(se3.copy(fe3).multiplyScalar(de3)), w3.viewport(oe3.copy(pe3).multiplyScalar(de3)), _3 = new function(e4) {
            var t4 = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
            return { memory: { geometries: 0, textures: 0 }, render: t4, programs: null, autoReset: true, reset: function() {
              t4.frame++, t4.calls = 0, t4.triangles = 0, t4.points = 0, t4.lines = 0;
            }, update: function(n4, r4, i3) {
              switch (i3 = i3 || 1, t4.calls++, r4) {
                case e4.TRIANGLES:
                  t4.triangles += i3 * (n4 / 3);
                  break;
                case e4.TRIANGLE_STRIP:
                case e4.TRIANGLE_FAN:
                  t4.triangles += i3 * (n4 - 2);
                  break;
                case e4.LINES:
                  t4.lines += i3 * (n4 / 2);
                  break;
                case e4.LINE_STRIP:
                  t4.lines += i3 * (n4 - 1);
                  break;
                case e4.LINE_LOOP:
                  t4.lines += i3 * n4;
                  break;
                case e4.POINTS:
                  t4.points += i3 * n4;
                  break;
                default:
                  console.error("THREE.WebGLInfo: Unknown draw mode:", r4);
              }
            } };
          }(y3), R3 = new function() {
            var e4 = /* @__PURE__ */ new WeakMap();
            return { get: function(t4) {
              var n4 = e4.get(t4);
              return void 0 === n4 && (n4 = {}, e4.set(t4, n4)), n4;
            }, remove: function(t4) {
              e4.delete(t4);
            }, update: function(t4, n4, r4) {
              e4.get(t4)[n4] = r4;
            }, dispose: function() {
              e4 = /* @__PURE__ */ new WeakMap();
            } };
          }(), C3 = new ei2(y3, x3, w3, R3, b3, H3, _3), P3 = new cn(y3), O3 = new function(e4, t4, n4) {
            var r4 = {}, i3 = {};
            function a3(e5) {
              var o2 = e5.target, s2 = r4[o2.id];
              for (var c3 in null !== s2.index && t4.remove(s2.index), s2.attributes)
                t4.remove(s2.attributes[c3]);
              o2.removeEventListener("dispose", a3), delete r4[o2.id];
              var u4 = i3[s2.id];
              u4 && (t4.remove(u4), delete i3[s2.id]), n4.memory.geometries--;
            }
            return { get: function(e5, t5) {
              var i4 = r4[t5.id];
              return i4 || (t5.addEventListener("dispose", a3), t5.isBufferGeometry ? i4 = t5 : t5.isGeometry && (void 0 === t5._bufferGeometry && (t5._bufferGeometry = new Pn().setFromObject(e5)), i4 = t5._bufferGeometry), r4[t5.id] = i4, n4.memory.geometries++, i4);
            }, update: function(n5) {
              var r5 = n5.index, i4 = n5.attributes;
              for (var a4 in null !== r5 && t4.update(r5, e4.ELEMENT_ARRAY_BUFFER), i4)
                t4.update(i4[a4], e4.ARRAY_BUFFER);
              var o2 = n5.morphAttributes;
              for (var a4 in o2)
                for (var s2 = o2[a4], c3 = 0, u4 = s2.length; c3 < u4; c3++)
                  t4.update(s2[c3], e4.ARRAY_BUFFER);
            }, getWireframeAttribute: function(n5) {
              var r5 = i3[n5.id];
              if (r5)
                return r5;
              var a4, o2 = [], s2 = n5.index, c3 = n5.attributes;
              if (null !== s2)
                for (var u4 = 0, l4 = (a4 = s2.array).length; u4 < l4; u4 += 3) {
                  var h4 = a4[u4 + 0], d4 = a4[u4 + 1], p4 = a4[u4 + 2];
                  o2.push(h4, d4, d4, p4, p4, h4);
                }
              else
                for (u4 = 0, l4 = (a4 = c3.position.array).length / 3 - 1; u4 < l4; u4 += 3)
                  h4 = u4 + 0, d4 = u4 + 1, p4 = u4 + 2, o2.push(h4, d4, d4, p4, p4, h4);
              return r5 = new (Rn(o2) > 65535 ? Tn : Mn)(o2, 1), t4.update(r5, e4.ELEMENT_ARRAY_BUFFER), i3[n5.id] = r5, r5;
            } };
          }(y3, P3, _3), N3 = new function(e4, t4) {
            var n4 = {};
            return { update: function(r4) {
              var i3 = t4.render.frame, a3 = r4.geometry, o2 = e4.get(r4, a3);
              return n4[o2.id] !== i3 && (a3.isGeometry && o2.updateFromObject(r4), e4.update(o2), n4[o2.id] = i3), o2;
            }, dispose: function() {
              n4 = {};
            } };
          }(O3, _3), F3 = new function(e4) {
            var t4 = {}, n4 = new Float32Array(8);
            return { update: function(r4, i3, a3, o2) {
              var s2 = r4.morphTargetInfluences, c3 = s2.length, u4 = t4[i3.id];
              if (void 0 === u4) {
                u4 = [];
                for (var l4 = 0; l4 < c3; l4++)
                  u4[l4] = [l4, 0];
                t4[i3.id] = u4;
              }
              var h4 = a3.morphTargets && i3.morphAttributes.position, d4 = a3.morphNormals && i3.morphAttributes.normal;
              for (l4 = 0; l4 < c3; l4++)
                0 !== (p4 = u4[l4])[1] && (h4 && i3.removeAttribute("morphTarget" + l4), d4 && i3.removeAttribute("morphNormal" + l4));
              for (l4 = 0; l4 < c3; l4++)
                (p4 = u4[l4])[0] = l4, p4[1] = s2[l4];
              for (u4.sort(jn), l4 = 0; l4 < 8; l4++) {
                var p4;
                if (p4 = u4[l4]) {
                  var f4 = p4[0], m4 = p4[1];
                  if (m4) {
                    h4 && i3.addAttribute("morphTarget" + l4, h4[f4]), d4 && i3.addAttribute("morphNormal" + l4, d4[f4]), n4[l4] = m4;
                    continue;
                  }
                }
                n4[l4] = 0;
              }
              o2.getUniforms().setValue(e4, "morphTargetInfluences", n4);
            } };
          }(y3), I3 = new jr(k3, x3, b3), D3 = new Xr(), U3 = new function() {
            var e4 = {};
            return { get: function(t4, n4) {
              var r4;
              return void 0 === e4[t4.id] ? (r4 = new Jr(), e4[t4.id] = {}, e4[t4.id][n4.id] = r4) : void 0 === e4[t4.id][n4.id] ? (r4 = new Jr(), e4[t4.id][n4.id] = r4) : r4 = e4[t4.id][n4.id], r4;
            }, dispose: function() {
              e4 = {};
            } };
          }(), B3 = new function(e4, t4, n4, r4) {
            var i3, a3, o2, s2 = new rn(0), c3 = 0;
            function u4(e5, n5) {
              t4.buffers.color.setClear(e5.r, e5.g, e5.b, n5, r4);
            }
            return { getClearColor: function() {
              return s2;
            }, setClearColor: function(e5, t5) {
              s2.set(e5), u4(s2, c3 = void 0 !== t5 ? t5 : 1);
            }, getClearAlpha: function() {
              return c3;
            }, setClearAlpha: function(e5) {
              u4(s2, c3 = e5);
            }, render: function(t5, r5, l4, h4) {
              var d4 = r5.background;
              null === d4 ? u4(s2, c3) : d4 && d4.isColor && (u4(d4, 1), h4 = true), (e4.autoClear || h4) && e4.clear(e4.autoClearColor, e4.autoClearDepth, e4.autoClearStencil), d4 && d4.isCubeTexture ? (void 0 === o2 && ((o2 = new kn(new Nn(1, 1, 1), new Gn({ uniforms: on.cube.uniforms, vertexShader: on.cube.vertexShader, fragmentShader: on.cube.fragmentShader, side: g2, depthTest: true, depthWrite: false, fog: false }))).geometry.removeAttribute("normal"), o2.geometry.removeAttribute("uv"), o2.onBeforeRender = function(e5, t6, n5) {
                this.matrixWorld.copyPosition(n5.matrixWorld);
              }, n4.update(o2)), o2.material.uniforms.tCube.value = d4, t5.push(o2, o2.geometry, o2.material, 0, null)) : d4 && d4.isTexture && (void 0 === i3 && (i3 = new fn(-1, 1, 1, -1, 0, 1), a3 = new kn(new Dn(2, 2), new Fn({ depthTest: false, depthWrite: false, fog: false })), n4.update(a3)), a3.material.map = d4, e4.renderBufferDirect(i3, null, a3.geometry, a3.material, a3, null));
            } };
          }(k3, w3, N3, h3), G3 = new function(e4, t4, n4, r4) {
            var i3;
            this.setMode = function(e5) {
              i3 = e5;
            }, this.render = function(t5, r5) {
              e4.drawArrays(i3, t5, r5), n4.update(r5, i3);
            }, this.renderInstances = function(a3, o2, s2) {
              var c3;
              if (r4.isWebGL2)
                c3 = e4;
              else if (null === (c3 = t4.get("ANGLE_instanced_arrays")))
                return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
              c3[r4.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](i3, o2, s2, a3.maxInstancedCount), n4.update(s2, i3, a3.maxInstancedCount);
            };
          }(y3, x3, _3, b3), z3 = new function(e4, t4, n4, r4) {
            var i3, a3, o2;
            this.setMode = function(e5) {
              i3 = e5;
            }, this.setIndex = function(e5) {
              a3 = e5.type, o2 = e5.bytesPerElement;
            }, this.render = function(t5, r5) {
              e4.drawElements(i3, r5, a3, t5 * o2), n4.update(r5, i3);
            }, this.renderInstances = function(s2, c3, u4) {
              var l4;
              if (r4.isWebGL2)
                l4 = e4;
              else if (null === (l4 = t4.get("ANGLE_instanced_arrays")))
                return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
              l4[r4.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](i3, u4, a3, c3 * o2, s2.maxInstancedCount), n4.update(u4, i3, s2.maxInstancedCount);
            };
          }(y3, x3, _3, b3), _3.programs = I3.programs, k3.context = y3, k3.capabilities = b3, k3.extensions = x3, k3.properties = R3, k3.renderLists = D3, k3.state = w3, k3.info = _3;
        }
        Te3();
        var Se3 = "xr" in navigator ? new function(e4) {
          var t4 = e4.context, n4 = null, r4 = null, i3 = null, a3 = null, o2 = [], s2 = [];
          function c3() {
            return null !== r4 && null !== i3;
          }
          var u4 = new ri2();
          u4.layers.enable(1), u4.viewport = new Xt();
          var l4 = new ri2();
          l4.layers.enable(2), l4.viewport = new Xt();
          var h4 = new ii2([u4, l4]);
          function d4(e5) {
            var t5 = o2[s2.indexOf(e5.inputSource)];
            t5 && t5.dispatchEvent({ type: e5.type });
          }
          function p4() {
            e4.setFramebuffer(null), g3.stop();
          }
          function f4(e5, t5) {
            null === t5 ? e5.matrixWorld.copy(e5.matrix) : e5.matrixWorld.multiplyMatrices(t5.matrixWorld, e5.matrix), e5.matrixWorldInverse.getInverse(e5.matrixWorld);
          }
          h4.layers.enable(1), h4.layers.enable(2), this.enabled = false, this.getController = function(e5) {
            var t5 = o2[e5];
            return void 0 === t5 && ((t5 = new ni2()).matrixAutoUpdate = false, t5.visible = false, o2[e5] = t5), t5;
          }, this.getDevice = function() {
            return n4;
          }, this.setDevice = function(e5) {
            void 0 !== e5 && (n4 = e5), e5 instanceof XRDevice && t4.setCompatibleXRDevice(e5);
          }, this.setSession = function(n5, a4) {
            null !== (r4 = n5) && (r4.addEventListener("select", d4), r4.addEventListener("selectstart", d4), r4.addEventListener("selectend", d4), r4.addEventListener("end", p4), r4.baseLayer = new XRWebGLLayer(r4, t4), r4.requestFrameOfReference(a4.frameOfReferenceType).then(function(t5) {
              i3 = t5, e4.setFramebuffer(r4.baseLayer.framebuffer), g3.setContext(r4), g3.start();
            }), s2 = r4.getInputSources(), r4.addEventListener("inputsourceschange", function() {
              s2 = r4.getInputSources(), console.log(s2);
            }));
          }, this.getCamera = function(e5) {
            if (c3()) {
              var t5 = e5.parent, n5 = h4.cameras;
              f4(h4, t5);
              for (var r5 = 0; r5 < n5.length; r5++)
                f4(n5[r5], t5);
              e5.matrixWorld.copy(h4.matrixWorld);
              for (var i4 = e5.children, a4 = (r5 = 0, i4.length); r5 < a4; r5++)
                i4[r5].updateMatrixWorld(true);
              return h4;
            }
            return e5;
          }, this.isPresenting = c3;
          var m4 = null, g3 = new sn();
          g3.setAnimationLoop(function(e5, t5) {
            if (null !== (a3 = t5.getDevicePose(i3)))
              for (var n5 = r4.baseLayer, c4 = t5.views, u5 = 0; u5 < c4.length; u5++) {
                var l5 = c4[u5], d5 = n5.getViewport(l5), p5 = a3.getViewMatrix(l5), f5 = h4.cameras[u5];
                f5.matrix.fromArray(p5).getInverse(f5.matrix), f5.projectionMatrix.fromArray(l5.projectionMatrix), f5.viewport.set(d5.x, d5.y, d5.width, d5.height), 0 === u5 && (h4.matrix.copy(f5.matrix), h4.projectionMatrix.copy(f5.projectionMatrix));
              }
            for (u5 = 0; u5 < o2.length; u5++) {
              var g4 = o2[u5], v3 = s2[u5];
              if (v3) {
                var y4 = t5.getInputPose(v3, i3);
                if (null !== y4) {
                  g4.matrix.elements = y4.pointerMatrix, g4.matrix.decompose(g4.position, g4.rotation, g4.scale), g4.visible = true;
                  continue;
                }
              }
              g4.visible = false;
            }
            m4 && m4(e5);
          }), this.setAnimationLoop = function(e5) {
            m4 = e5;
          }, this.dispose = function() {
          }, this.getStandingMatrix = function() {
            return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."), new THREE.Matrix4();
          }, this.submitFrame = function() {
          };
        }(k3) : new ai2(k3);
        this.vr = Se3;
        var Ae3 = new $r(k3, N3, b3.maxTextureSize);
        function Le3(e4) {
          e4.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), j2 = true;
        }
        function Re3() {
          console.log("THREE.WebGLRenderer: Context Restored."), j2 = false, Te3();
        }
        function Oe3(e4) {
          var t4 = e4.target;
          t4.removeEventListener("dispose", Oe3), function(e5) {
            Ne3(e5), R3.remove(e5);
          }(t4);
        }
        function Ne3(e4) {
          var t4 = R3.get(e4).program;
          e4.program = void 0, void 0 !== t4 && I3.releaseProgram(t4);
        }
        this.shadowMap = Ae3, this.getContext = function() {
          return y3;
        }, this.getContextAttributes = function() {
          return y3.getContextAttributes();
        }, this.forceContextLoss = function() {
          var e4 = x3.get("WEBGL_lose_context");
          e4 && e4.loseContext();
        }, this.forceContextRestore = function() {
          var e4 = x3.get("WEBGL_lose_context");
          e4 && e4.restoreContext();
        }, this.getPixelRatio = function() {
          return de3;
        }, this.setPixelRatio = function(e4) {
          void 0 !== e4 && (de3 = e4, this.setSize(le3, he3, false));
        }, this.getSize = function() {
          return { width: le3, height: he3 };
        }, this.setSize = function(e4, n4, r4) {
          Se3.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (le3 = e4, he3 = n4, t3.width = e4 * de3, t3.height = n4 * de3, false !== r4 && (t3.style.width = e4 + "px", t3.style.height = n4 + "px"), this.setViewport(0, 0, e4, n4));
        }, this.getDrawingBufferSize = function() {
          return { width: le3 * de3, height: he3 * de3 };
        }, this.setDrawingBufferSize = function(e4, n4, r4) {
          le3 = e4, he3 = n4, de3 = r4, t3.width = e4 * r4, t3.height = n4 * r4, this.setViewport(0, 0, e4, n4);
        }, this.getCurrentViewport = function() {
          return oe3;
        }, this.setViewport = function(e4, t4, n4, r4) {
          pe3.set(e4, he3 - t4 - r4, n4, r4), w3.viewport(oe3.copy(pe3).multiplyScalar(de3));
        }, this.setScissor = function(e4, t4, n4, r4) {
          fe3.set(e4, he3 - t4 - r4, n4, r4), w3.scissor(se3.copy(fe3).multiplyScalar(de3));
        }, this.setScissorTest = function(e4) {
          w3.setScissorTest(me3 = e4);
        }, this.getClearColor = function() {
          return B3.getClearColor();
        }, this.setClearColor = function() {
          B3.setClearColor.apply(B3, arguments);
        }, this.getClearAlpha = function() {
          return B3.getClearAlpha();
        }, this.setClearAlpha = function() {
          B3.setClearAlpha.apply(B3, arguments);
        }, this.clear = function(e4, t4, n4) {
          var r4 = 0;
          (void 0 === e4 || e4) && (r4 |= y3.COLOR_BUFFER_BIT), (void 0 === t4 || t4) && (r4 |= y3.DEPTH_BUFFER_BIT), (void 0 === n4 || n4) && (r4 |= y3.STENCIL_BUFFER_BIT), y3.clear(r4);
        }, this.clearColor = function() {
          this.clear(true, false, false);
        }, this.clearDepth = function() {
          this.clear(false, true, false);
        }, this.clearStencil = function() {
          this.clear(false, false, true);
        }, this.clearTarget = function(e4, t4, n4, r4) {
          this.setRenderTarget(e4), this.clear(t4, n4, r4);
        }, this.dispose = function() {
          t3.removeEventListener("webglcontextlost", Le3, false), t3.removeEventListener("webglcontextrestored", Re3, false), D3.dispose(), U3.dispose(), R3.dispose(), N3.dispose(), Se3.dispose(), De3.stop();
        }, this.renderBufferImmediate = function(e4, t4) {
          w3.initAttributes();
          var n4 = R3.get(e4);
          e4.hasPositions && !n4.position && (n4.position = y3.createBuffer()), e4.hasNormals && !n4.normal && (n4.normal = y3.createBuffer()), e4.hasUvs && !n4.uv && (n4.uv = y3.createBuffer()), e4.hasColors && !n4.color && (n4.color = y3.createBuffer());
          var r4 = t4.getAttributes();
          e4.hasPositions && (y3.bindBuffer(y3.ARRAY_BUFFER, n4.position), y3.bufferData(y3.ARRAY_BUFFER, e4.positionArray, y3.DYNAMIC_DRAW), w3.enableAttribute(r4.position), y3.vertexAttribPointer(r4.position, 3, y3.FLOAT, false, 0, 0)), e4.hasNormals && (y3.bindBuffer(y3.ARRAY_BUFFER, n4.normal), y3.bufferData(y3.ARRAY_BUFFER, e4.normalArray, y3.DYNAMIC_DRAW), w3.enableAttribute(r4.normal), y3.vertexAttribPointer(r4.normal, 3, y3.FLOAT, false, 0, 0)), e4.hasUvs && (y3.bindBuffer(y3.ARRAY_BUFFER, n4.uv), y3.bufferData(y3.ARRAY_BUFFER, e4.uvArray, y3.DYNAMIC_DRAW), w3.enableAttribute(r4.uv), y3.vertexAttribPointer(r4.uv, 2, y3.FLOAT, false, 0, 0)), e4.hasColors && (y3.bindBuffer(y3.ARRAY_BUFFER, n4.color), y3.bufferData(y3.ARRAY_BUFFER, e4.colorArray, y3.DYNAMIC_DRAW), w3.enableAttribute(r4.color), y3.vertexAttribPointer(r4.color, 3, y3.FLOAT, false, 0, 0)), w3.disableUnusedAttributes(), y3.drawArrays(y3.TRIANGLES, 0, e4.count), e4.count = 0;
        }, this.renderBufferDirect = function(e4, t4, n4, r4, i3, a3) {
          var o2 = i3.isMesh && i3.normalMatrix.determinant() < 0;
          w3.setMaterial(r4, o2);
          var s2 = ze3(e4, t4, r4, i3), c3 = false;
          ne3.geometry === n4.id && ne3.program === s2.id && ne3.wireframe === (true === r4.wireframe) || (ne3.geometry = n4.id, ne3.program = s2.id, ne3.wireframe = true === r4.wireframe, c3 = true), i3.morphTargetInfluences && (F3.update(i3, n4, r4, s2), c3 = true);
          var u4, l4 = n4.index, h4 = n4.attributes.position, d4 = 1;
          true === r4.wireframe && (l4 = O3.getWireframeAttribute(n4), d4 = 2);
          var p4 = G3;
          null !== l4 && (u4 = P3.get(l4), (p4 = z3).setIndex(u4)), c3 && (!function(e5, t5, n5) {
            if (n5 && n5.isInstancedBufferGeometry & !b3.isWebGL2 && null === x3.get("ANGLE_instanced_arrays"))
              return void console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            w3.initAttributes();
            var r5 = n5.attributes, i4 = t5.getAttributes(), a4 = e5.defaultAttributeValues;
            for (var o3 in i4) {
              var s3 = i4[o3];
              if (s3 >= 0) {
                var c4 = r5[o3];
                if (void 0 !== c4) {
                  var u5 = c4.normalized, l5 = c4.itemSize, h5 = P3.get(c4);
                  if (void 0 === h5)
                    continue;
                  var d5 = h5.buffer, p5 = h5.type, f5 = h5.bytesPerElement;
                  if (c4.isInterleavedBufferAttribute) {
                    var m5 = c4.data, g4 = m5.stride, v4 = c4.offset;
                    m5 && m5.isInstancedInterleavedBuffer ? (w3.enableAttributeAndDivisor(s3, m5.meshPerAttribute), void 0 === n5.maxInstancedCount && (n5.maxInstancedCount = m5.meshPerAttribute * m5.count)) : w3.enableAttribute(s3), y3.bindBuffer(y3.ARRAY_BUFFER, d5), y3.vertexAttribPointer(s3, l5, p5, u5, g4 * f5, v4 * f5);
                  } else
                    c4.isInstancedBufferAttribute ? (w3.enableAttributeAndDivisor(s3, c4.meshPerAttribute), void 0 === n5.maxInstancedCount && (n5.maxInstancedCount = c4.meshPerAttribute * c4.count)) : w3.enableAttribute(s3), y3.bindBuffer(y3.ARRAY_BUFFER, d5), y3.vertexAttribPointer(s3, l5, p5, u5, 0, 0);
                } else if (void 0 !== a4) {
                  var _5 = a4[o3];
                  if (void 0 !== _5)
                    switch (_5.length) {
                      case 2:
                        y3.vertexAttrib2fv(s3, _5);
                        break;
                      case 3:
                        y3.vertexAttrib3fv(s3, _5);
                        break;
                      case 4:
                        y3.vertexAttrib4fv(s3, _5);
                        break;
                      default:
                        y3.vertexAttrib1fv(s3, _5);
                    }
                }
              }
            }
            w3.disableUnusedAttributes();
          }(r4, s2, n4), null !== l4 && y3.bindBuffer(y3.ELEMENT_ARRAY_BUFFER, u4.buffer));
          var f4 = 1 / 0;
          null !== l4 ? f4 = l4.count : void 0 !== h4 && (f4 = h4.count);
          var m4 = n4.drawRange.start * d4, g3 = n4.drawRange.count * d4, v3 = null !== a3 ? a3.start * d4 : 0, _4 = null !== a3 ? a3.count * d4 : 1 / 0, M3 = Math.max(m4, v3), E3 = Math.min(f4, m4 + g3, v3 + _4) - 1, T3 = Math.max(0, E3 - M3 + 1);
          if (0 !== T3) {
            if (i3.isMesh)
              if (true === r4.wireframe)
                w3.setLineWidth(r4.wireframeLinewidth * _e2()), p4.setMode(y3.LINES);
              else
                switch (i3.drawMode) {
                  case _t5:
                    p4.setMode(y3.TRIANGLES);
                    break;
                  case Mt:
                    p4.setMode(y3.TRIANGLE_STRIP);
                    break;
                  case Et:
                    p4.setMode(y3.TRIANGLE_FAN);
                }
            else if (i3.isLine) {
              var S3 = r4.linewidth;
              void 0 === S3 && (S3 = 1), w3.setLineWidth(S3 * _e2()), i3.isLineSegments ? p4.setMode(y3.LINES) : i3.isLineLoop ? p4.setMode(y3.LINE_LOOP) : p4.setMode(y3.LINE_STRIP);
            } else
              i3.isPoints ? p4.setMode(y3.POINTS) : i3.isSprite && p4.setMode(y3.TRIANGLES);
            n4 && n4.isInstancedBufferGeometry ? n4.maxInstancedCount > 0 && p4.renderInstances(n4, M3, T3) : p4.render(M3, T3);
          }
        }, this.compile = function(e4, t4) {
          (m3 = U3.get(e4, t4)).init(), e4.traverse(function(e5) {
            e5.isLight && (m3.pushLight(e5), e5.castShadow && m3.pushShadow(e5));
          }), m3.setupLights(t4), e4.traverse(function(t5) {
            if (t5.material)
              if (Array.isArray(t5.material))
                for (var n4 = 0; n4 < t5.material.length; n4++)
                  Ge3(t5.material[n4], e4.fog, t5);
              else
                Ge3(t5.material, e4.fog, t5);
          });
        };
        var Ie3 = null;
        var De3 = new sn();
        function Ue3(e4, t4, n4, r4) {
          for (var i3 = 0, a3 = e4.length; i3 < a3; i3++) {
            var o2 = e4[i3], s2 = o2.object, c3 = o2.geometry, u4 = void 0 === r4 ? o2.material : r4, l4 = o2.group;
            if (n4.isArrayCamera) {
              ae3 = n4;
              for (var h4 = n4.cameras, d4 = 0, p4 = h4.length; d4 < p4; d4++) {
                var f4 = h4[d4];
                if (s2.layers.test(f4.layers)) {
                  if ("viewport" in f4)
                    w3.viewport(oe3.copy(f4.viewport));
                  else {
                    var m4 = f4.bounds, g3 = m4.x * le3, v3 = m4.y * he3, y4 = m4.z * le3, x4 = m4.w * he3;
                    w3.viewport(oe3.set(g3, v3, y4, x4).multiplyScalar(de3));
                  }
                  Be3(s2, t4, f4, c3, u4, l4);
                }
              }
            } else
              ae3 = null, Be3(s2, t4, n4, c3, u4, l4);
          }
        }
        function Be3(e4, t4, n4, r4, i3, a3) {
          if (e4.onBeforeRender(k3, t4, n4, r4, i3, a3), m3 = U3.get(t4, ae3 || n4), e4.modelViewMatrix.multiplyMatrices(n4.matrixWorldInverse, e4.matrixWorld), e4.normalMatrix.getNormalMatrix(e4.modelViewMatrix), e4.isImmediateRenderObject) {
            w3.setMaterial(i3);
            var o2 = ze3(n4, t4.fog, i3, e4);
            ne3.geometry = null, ne3.program = null, ne3.wireframe = false, function(e5, t5) {
              e5.render(function(e6) {
                k3.renderBufferImmediate(e6, t5);
              });
            }(e4, o2);
          } else
            k3.renderBufferDirect(n4, t4.fog, r4, i3, e4, a3);
          e4.onAfterRender(k3, t4, n4, r4, i3, a3), m3 = U3.get(t4, ae3 || n4);
        }
        function Ge3(e4, t4, n4) {
          var r4 = R3.get(e4), i3 = m3.state.lights, a3 = m3.state.shadowsArray, o2 = r4.lightsHash, s2 = i3.state.hash, c3 = I3.getParameters(e4, i3.state, a3, t4, ve3.numPlanes, ve3.numIntersection, n4), u4 = I3.getProgramCode(e4, c3), l4 = r4.program, h4 = true;
          if (void 0 === l4)
            e4.addEventListener("dispose", Oe3);
          else if (l4.code !== u4)
            Ne3(e4);
          else if (o2.stateID !== s2.stateID || o2.directionalLength !== s2.directionalLength || o2.pointLength !== s2.pointLength || o2.spotLength !== s2.spotLength || o2.rectAreaLength !== s2.rectAreaLength || o2.hemiLength !== s2.hemiLength || o2.shadowsLength !== s2.shadowsLength)
            o2.stateID = s2.stateID, o2.directionalLength = s2.directionalLength, o2.pointLength = s2.pointLength, o2.spotLength = s2.spotLength, o2.rectAreaLength = s2.rectAreaLength, o2.hemiLength = s2.hemiLength, o2.shadowsLength = s2.shadowsLength, h4 = false;
          else {
            if (void 0 !== c3.shaderID)
              return;
            h4 = false;
          }
          if (h4) {
            if (c3.shaderID) {
              var d4 = on[c3.shaderID];
              r4.shader = { name: e4.type, uniforms: tn.clone(d4.uniforms), vertexShader: d4.vertexShader, fragmentShader: d4.fragmentShader };
            } else
              r4.shader = { name: e4.type, uniforms: e4.uniforms, vertexShader: e4.vertexShader, fragmentShader: e4.fragmentShader };
            e4.onBeforeCompile(r4.shader, k3), u4 = I3.getProgramCode(e4, c3), l4 = I3.acquireProgram(e4, r4.shader, c3, u4), r4.program = l4, e4.program = l4;
          }
          var p4 = l4.getAttributes();
          if (e4.morphTargets) {
            e4.numSupportedMorphTargets = 0;
            for (var f4 = 0; f4 < k3.maxMorphTargets; f4++)
              p4["morphTarget" + f4] >= 0 && e4.numSupportedMorphTargets++;
          }
          if (e4.morphNormals) {
            e4.numSupportedMorphNormals = 0;
            for (f4 = 0; f4 < k3.maxMorphNormals; f4++)
              p4["morphNormal" + f4] >= 0 && e4.numSupportedMorphNormals++;
          }
          var g3 = r4.shader.uniforms;
          (e4.isShaderMaterial || e4.isRawShaderMaterial) && true !== e4.clipping || (r4.numClippingPlanes = ve3.numPlanes, r4.numIntersection = ve3.numIntersection, g3.clippingPlanes = ve3.uniform), r4.fog = t4, void 0 === o2 && (r4.lightsHash = o2 = {}), o2.stateID = s2.stateID, o2.directionalLength = s2.directionalLength, o2.pointLength = s2.pointLength, o2.spotLength = s2.spotLength, o2.rectAreaLength = s2.rectAreaLength, o2.hemiLength = s2.hemiLength, o2.shadowsLength = s2.shadowsLength, e4.lights && (g3.ambientLightColor.value = i3.state.ambient, g3.directionalLights.value = i3.state.directional, g3.spotLights.value = i3.state.spot, g3.rectAreaLights.value = i3.state.rectArea, g3.pointLights.value = i3.state.point, g3.hemisphereLights.value = i3.state.hemi, g3.directionalShadowMap.value = i3.state.directionalShadowMap, g3.directionalShadowMatrix.value = i3.state.directionalShadowMatrix, g3.spotShadowMap.value = i3.state.spotShadowMap, g3.spotShadowMatrix.value = i3.state.spotShadowMatrix, g3.pointShadowMap.value = i3.state.pointShadowMap, g3.pointShadowMatrix.value = i3.state.pointShadowMatrix);
          var v3 = r4.program.getUniforms(), y4 = Or.seqWithValue(v3.seq, g3);
          r4.uniformsList = y4;
        }
        function ze3(e4, t4, n4, r4) {
          ue3 = 0;
          var i3 = R3.get(n4), a3 = m3.state.lights, o2 = i3.lightsHash, s2 = a3.state.hash;
          if (ye3 && (xe3 || e4 !== ie3)) {
            var c3 = e4 === ie3 && n4.id === te3;
            ve3.setState(n4.clippingPlanes, n4.clipIntersection, n4.clipShadows, e4, i3, c3);
          }
          false === n4.needsUpdate && (void 0 === i3.program ? n4.needsUpdate = true : n4.fog && i3.fog !== t4 ? n4.needsUpdate = true : (!n4.lights || o2.stateID === s2.stateID && o2.directionalLength === s2.directionalLength && o2.pointLength === s2.pointLength && o2.spotLength === s2.spotLength && o2.rectAreaLength === s2.rectAreaLength && o2.hemiLength === s2.hemiLength && o2.shadowsLength === s2.shadowsLength) && (void 0 === i3.numClippingPlanes || i3.numClippingPlanes === ve3.numPlanes && i3.numIntersection === ve3.numIntersection) || (n4.needsUpdate = true)), n4.needsUpdate && (Ge3(n4, t4, r4), n4.needsUpdate = false);
          var u4 = false, l4 = false, h4 = false, d4 = i3.program, p4 = d4.getUniforms(), f4 = i3.shader.uniforms;
          if (w3.useProgram(d4.program) && (u4 = true, l4 = true, h4 = true), n4.id !== te3 && (te3 = n4.id, l4 = true), u4 || e4 !== ie3) {
            if (p4.setValue(y3, "projectionMatrix", e4.projectionMatrix), b3.logarithmicDepthBuffer && p4.setValue(y3, "logDepthBufFC", 2 / (Math.log(e4.far + 1) / Math.LN2)), ie3 !== (ae3 || e4) && (ie3 = ae3 || e4, l4 = true, h4 = true), n4.isShaderMaterial || n4.isMeshPhongMaterial || n4.isMeshStandardMaterial || n4.envMap) {
              var v3 = p4.map.cameraPosition;
              void 0 !== v3 && v3.setValue(y3, we3.setFromMatrixPosition(e4.matrixWorld));
            }
            (n4.isMeshPhongMaterial || n4.isMeshLambertMaterial || n4.isMeshBasicMaterial || n4.isMeshStandardMaterial || n4.isShaderMaterial || n4.skinning) && p4.setValue(y3, "viewMatrix", e4.matrixWorldInverse);
          }
          if (n4.skinning) {
            p4.setOptional(y3, r4, "bindMatrix"), p4.setOptional(y3, r4, "bindMatrixInverse");
            var x4 = r4.skeleton;
            if (x4) {
              var _4 = x4.bones;
              if (b3.floatVertexTextures) {
                if (void 0 === x4.boneTexture) {
                  var M3 = Math.sqrt(4 * _4.length);
                  M3 = Bt.ceilPowerOfTwo(M3), M3 = Math.max(M3, 4);
                  var E3 = new Float32Array(M3 * M3 * 4);
                  E3.set(x4.boneMatrices);
                  var T3 = new Zt(E3, M3, M3, Fe2, Ce2);
                  T3.needsUpdate = true, x4.boneMatrices = E3, x4.boneTexture = T3, x4.boneTextureSize = M3;
                }
                p4.setValue(y3, "boneTexture", x4.boneTexture), p4.setValue(y3, "boneTextureSize", x4.boneTextureSize);
              } else
                p4.setOptional(y3, x4, "boneMatrices");
            }
          }
          return l4 && (p4.setValue(y3, "toneMappingExposure", k3.toneMappingExposure), p4.setValue(y3, "toneMappingWhitePoint", k3.toneMappingWhitePoint), n4.lights && function(e5, t5) {
            e5.ambientLightColor.needsUpdate = t5, e5.directionalLights.needsUpdate = t5, e5.pointLights.needsUpdate = t5, e5.spotLights.needsUpdate = t5, e5.rectAreaLights.needsUpdate = t5, e5.hemisphereLights.needsUpdate = t5;
          }(f4, h4), t4 && n4.fog && function(e5, t5) {
            e5.fogColor.value = t5.color, t5.isFog ? (e5.fogNear.value = t5.near, e5.fogFar.value = t5.far) : t5.isFogExp2 && (e5.fogDensity.value = t5.density);
          }(f4, t4), n4.isMeshBasicMaterial ? He3(f4, n4) : n4.isMeshLambertMaterial ? (He3(f4, n4), function(e5, t5) {
            t5.emissiveMap && (e5.emissiveMap.value = t5.emissiveMap);
          }(f4, n4)) : n4.isMeshPhongMaterial ? (He3(f4, n4), n4.isMeshToonMaterial ? function(e5, t5) {
            ke3(e5, t5), t5.gradientMap && (e5.gradientMap.value = t5.gradientMap);
          }(f4, n4) : ke3(f4, n4)) : n4.isMeshStandardMaterial ? (He3(f4, n4), n4.isMeshPhysicalMaterial ? function(e5, t5) {
            je3(e5, t5), e5.reflectivity.value = t5.reflectivity, e5.clearCoat.value = t5.clearCoat, e5.clearCoatRoughness.value = t5.clearCoatRoughness;
          }(f4, n4) : je3(f4, n4)) : n4.isMeshDepthMaterial ? (He3(f4, n4), function(e5, t5) {
            t5.displacementMap && (e5.displacementMap.value = t5.displacementMap, e5.displacementScale.value = t5.displacementScale, e5.displacementBias.value = t5.displacementBias);
          }(f4, n4)) : n4.isMeshDistanceMaterial ? (He3(f4, n4), function(e5, t5) {
            t5.displacementMap && (e5.displacementMap.value = t5.displacementMap, e5.displacementScale.value = t5.displacementScale, e5.displacementBias.value = t5.displacementBias);
            e5.referencePosition.value.copy(t5.referencePosition), e5.nearDistance.value = t5.nearDistance, e5.farDistance.value = t5.farDistance;
          }(f4, n4)) : n4.isMeshNormalMaterial ? (He3(f4, n4), function(e5, t5) {
            t5.bumpMap && (e5.bumpMap.value = t5.bumpMap, e5.bumpScale.value = t5.bumpScale, t5.side === g2 && (e5.bumpScale.value *= -1));
            t5.normalMap && (e5.normalMap.value = t5.normalMap, e5.normalScale.value.copy(t5.normalScale), t5.side === g2 && e5.normalScale.value.negate());
            t5.displacementMap && (e5.displacementMap.value = t5.displacementMap, e5.displacementScale.value = t5.displacementScale, e5.displacementBias.value = t5.displacementBias);
          }(f4, n4)) : n4.isLineBasicMaterial ? (function(e5, t5) {
            e5.diffuse.value = t5.color, e5.opacity.value = t5.opacity;
          }(f4, n4), n4.isLineDashedMaterial && function(e5, t5) {
            e5.dashSize.value = t5.dashSize, e5.totalSize.value = t5.dashSize + t5.gapSize, e5.scale.value = t5.scale;
          }(f4, n4)) : n4.isPointsMaterial ? function(e5, t5) {
            e5.diffuse.value = t5.color, e5.opacity.value = t5.opacity, e5.size.value = t5.size * de3, e5.scale.value = 0.5 * he3, e5.map.value = t5.map, null !== t5.map && (true === t5.map.matrixAutoUpdate && t5.map.updateMatrix(), e5.uvTransform.value.copy(t5.map.matrix));
          }(f4, n4) : n4.isSpriteMaterial ? function(e5, t5) {
            e5.diffuse.value = t5.color, e5.opacity.value = t5.opacity, e5.rotation.value = t5.rotation, e5.map.value = t5.map, null !== t5.map && (true === t5.map.matrixAutoUpdate && t5.map.updateMatrix(), e5.uvTransform.value.copy(t5.map.matrix));
          }(f4, n4) : n4.isShadowMaterial && (f4.color.value = n4.color, f4.opacity.value = n4.opacity), void 0 !== f4.ltc_1 && (f4.ltc_1.value = an.LTC_1), void 0 !== f4.ltc_2 && (f4.ltc_2.value = an.LTC_2), Or.upload(y3, i3.uniformsList, f4, k3)), n4.isShaderMaterial && true === n4.uniformsNeedUpdate && (Or.upload(y3, i3.uniformsList, f4, k3), n4.uniformsNeedUpdate = false), n4.isSpriteMaterial && p4.setValue(y3, "center", r4.center), p4.setValue(y3, "modelViewMatrix", r4.modelViewMatrix), p4.setValue(y3, "normalMatrix", r4.normalMatrix), p4.setValue(y3, "modelMatrix", r4.matrixWorld), d4;
        }
        function He3(e4, t4) {
          var n4;
          e4.opacity.value = t4.opacity, t4.color && (e4.diffuse.value = t4.color), t4.emissive && e4.emissive.value.copy(t4.emissive).multiplyScalar(t4.emissiveIntensity), t4.map && (e4.map.value = t4.map), t4.alphaMap && (e4.alphaMap.value = t4.alphaMap), t4.specularMap && (e4.specularMap.value = t4.specularMap), t4.envMap && (e4.envMap.value = t4.envMap, e4.flipEnvMap.value = t4.envMap && t4.envMap.isCubeTexture ? -1 : 1, e4.reflectivity.value = t4.reflectivity, e4.refractionRatio.value = t4.refractionRatio, e4.maxMipLevel.value = R3.get(t4.envMap).__maxMipLevel), t4.lightMap && (e4.lightMap.value = t4.lightMap, e4.lightMapIntensity.value = t4.lightMapIntensity), t4.aoMap && (e4.aoMap.value = t4.aoMap, e4.aoMapIntensity.value = t4.aoMapIntensity), t4.map ? n4 = t4.map : t4.specularMap ? n4 = t4.specularMap : t4.displacementMap ? n4 = t4.displacementMap : t4.normalMap ? n4 = t4.normalMap : t4.bumpMap ? n4 = t4.bumpMap : t4.roughnessMap ? n4 = t4.roughnessMap : t4.metalnessMap ? n4 = t4.metalnessMap : t4.alphaMap ? n4 = t4.alphaMap : t4.emissiveMap && (n4 = t4.emissiveMap), void 0 !== n4 && (n4.isWebGLRenderTarget && (n4 = n4.texture), true === n4.matrixAutoUpdate && n4.updateMatrix(), e4.uvTransform.value.copy(n4.matrix));
        }
        function ke3(e4, t4) {
          e4.specular.value = t4.specular, e4.shininess.value = Math.max(t4.shininess, 1e-4), t4.emissiveMap && (e4.emissiveMap.value = t4.emissiveMap), t4.bumpMap && (e4.bumpMap.value = t4.bumpMap, e4.bumpScale.value = t4.bumpScale, t4.side === g2 && (e4.bumpScale.value *= -1)), t4.normalMap && (e4.normalMap.value = t4.normalMap, e4.normalScale.value.copy(t4.normalScale), t4.side === g2 && e4.normalScale.value.negate()), t4.displacementMap && (e4.displacementMap.value = t4.displacementMap, e4.displacementScale.value = t4.displacementScale, e4.displacementBias.value = t4.displacementBias);
        }
        function je3(e4, t4) {
          e4.roughness.value = t4.roughness, e4.metalness.value = t4.metalness, t4.roughnessMap && (e4.roughnessMap.value = t4.roughnessMap), t4.metalnessMap && (e4.metalnessMap.value = t4.metalnessMap), t4.emissiveMap && (e4.emissiveMap.value = t4.emissiveMap), t4.bumpMap && (e4.bumpMap.value = t4.bumpMap, e4.bumpScale.value = t4.bumpScale, t4.side === g2 && (e4.bumpScale.value *= -1)), t4.normalMap && (e4.normalMap.value = t4.normalMap, e4.normalScale.value.copy(t4.normalScale), t4.side === g2 && e4.normalScale.value.negate()), t4.displacementMap && (e4.displacementMap.value = t4.displacementMap, e4.displacementScale.value = t4.displacementScale, e4.displacementBias.value = t4.displacementBias), t4.envMap && (e4.envMapIntensity.value = t4.envMapIntensity);
        }
        De3.setAnimationLoop(function(e4) {
          Se3.isPresenting() || Ie3 && Ie3(e4);
        }), "undefined" != typeof window && De3.setContext(window), this.setAnimationLoop = function(e4) {
          Ie3 = e4, Se3.setAnimationLoop(e4), De3.start();
        }, this.render = function(e4, t4, n4, r4) {
          if (t4 && t4.isCamera) {
            if (!j2) {
              ne3.geometry = null, ne3.program = null, ne3.wireframe = false, te3 = -1, ie3 = null, true === e4.autoUpdate && e4.updateMatrixWorld(), null === t4.parent && t4.updateMatrixWorld(), Se3.enabled && (t4 = Se3.getCamera(t4)), (m3 = U3.get(e4, t4)).init(), e4.onBeforeRender(k3, e4, t4, n4), be3.multiplyMatrices(t4.projectionMatrix, t4.matrixWorldInverse), ge3.setFromMatrix(be3), xe3 = this.localClippingEnabled, ye3 = ve3.init(this.clippingPlanes, xe3, t4), (f3 = D3.get(e4, t4)).init(), function e5(t5, n5, r5) {
                if (false === t5.visible)
                  return;
                var i4 = t5.layers.test(n5.layers);
                if (i4) {
                  if (t5.isLight)
                    m3.pushLight(t5), t5.castShadow && m3.pushShadow(t5);
                  else if (t5.isSprite) {
                    if (!t5.frustumCulled || ge3.intersectsSprite(t5)) {
                      r5 && we3.setFromMatrixPosition(t5.matrixWorld).applyMatrix4(be3);
                      var a4 = N3.update(t5), o3 = t5.material;
                      f3.push(t5, a4, o3, we3.z, null);
                    }
                  } else if (t5.isImmediateRenderObject)
                    r5 && we3.setFromMatrixPosition(t5.matrixWorld).applyMatrix4(be3), f3.push(t5, null, t5.material, we3.z, null);
                  else if ((t5.isMesh || t5.isLine || t5.isPoints) && (t5.isSkinnedMesh && t5.skeleton.update(), !t5.frustumCulled || ge3.intersectsObject(t5))) {
                    r5 && we3.setFromMatrixPosition(t5.matrixWorld).applyMatrix4(be3);
                    var a4 = N3.update(t5), o3 = t5.material;
                    if (Array.isArray(o3))
                      for (var s3 = a4.groups, c3 = 0, u4 = s3.length; c3 < u4; c3++) {
                        var l4 = s3[c3], h4 = o3[l4.materialIndex];
                        h4 && h4.visible && f3.push(t5, a4, h4, we3.z, l4);
                      }
                    else
                      o3.visible && f3.push(t5, a4, o3, we3.z, null);
                  }
                }
                var d4 = t5.children;
                for (var c3 = 0, u4 = d4.length; c3 < u4; c3++)
                  e5(d4[c3], n5, r5);
              }(e4, t4, k3.sortObjects), true === k3.sortObjects && f3.sort(), ye3 && ve3.beginShadows();
              var i3 = m3.state.shadowsArray;
              Ae3.render(i3, e4, t4), m3.setupLights(t4), ye3 && ve3.endShadows(), this.info.autoReset && this.info.reset(), void 0 === n4 && (n4 = null), this.setRenderTarget(n4), B3.render(f3, e4, t4, r4);
              var a3 = f3.opaque, o2 = f3.transparent;
              if (e4.overrideMaterial) {
                var s2 = e4.overrideMaterial;
                a3.length && Ue3(a3, e4, t4, s2), o2.length && Ue3(o2, e4, t4, s2);
              } else
                a3.length && Ue3(a3, e4, t4), o2.length && Ue3(o2, e4, t4);
              n4 && C3.updateRenderTargetMipmap(n4), w3.buffers.depth.setTest(true), w3.buffers.depth.setMask(true), w3.buffers.color.setMask(true), w3.setPolygonOffset(false), e4.onAfterRender(k3, e4, t4), Se3.enabled && Se3.submitFrame(), f3 = null, m3 = null;
            }
          } else
            console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        }, this.allocTextureUnit = function() {
          var e4 = ue3;
          return e4 >= b3.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + e4 + " texture units while this GPU supports only " + b3.maxTextures), ue3 += 1, e4;
        }, this.setTexture2D = function() {
          var e4 = false;
          return function(t4, n4) {
            t4 && t4.isWebGLRenderTarget && (e4 || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), e4 = true), t4 = t4.texture), C3.setTexture2D(t4, n4);
          };
        }(), this.setTexture = function() {
          var e4 = false;
          return function(t4, n4) {
            e4 || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), e4 = true), C3.setTexture2D(t4, n4);
          };
        }(), this.setTextureCube = function() {
          var e4 = false;
          return function(t4, n4) {
            t4 && t4.isWebGLRenderTargetCube && (e4 || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), e4 = true), t4 = t4.texture), t4 && t4.isCubeTexture || Array.isArray(t4.image) && 6 === t4.image.length ? C3.setTextureCube(t4, n4) : C3.setTextureCubeDynamic(t4, n4);
          };
        }(), this.setFramebuffer = function(e4) {
          V3 = e4;
        }, this.getRenderTarget = function() {
          return $2;
        }, this.setRenderTarget = function(e4) {
          $2 = e4, e4 && void 0 === R3.get(e4).__webglFramebuffer && C3.setupRenderTarget(e4);
          var t4 = V3, n4 = false;
          if (e4) {
            var r4 = R3.get(e4).__webglFramebuffer;
            e4.isWebGLRenderTargetCube ? (t4 = r4[e4.activeCubeFace], n4 = true) : t4 = r4, oe3.copy(e4.viewport), se3.copy(e4.scissor), ce3 = e4.scissorTest;
          } else
            oe3.copy(pe3).multiplyScalar(de3), se3.copy(fe3).multiplyScalar(de3), ce3 = me3;
          if (ee3 !== t4 && (y3.bindFramebuffer(y3.FRAMEBUFFER, t4), ee3 = t4), w3.viewport(oe3), w3.scissor(se3), w3.setScissorTest(ce3), n4) {
            var i3 = R3.get(e4.texture);
            y3.framebufferTexture2D(y3.FRAMEBUFFER, y3.COLOR_ATTACHMENT0, y3.TEXTURE_CUBE_MAP_POSITIVE_X + e4.activeCubeFace, i3.__webglTexture, e4.activeMipMapLevel);
          }
        }, this.readRenderTargetPixels = function(e4, t4, n4, r4, i3, a3) {
          if (e4 && e4.isWebGLRenderTarget) {
            var o2 = R3.get(e4).__webglFramebuffer;
            if (o2) {
              var s2 = false;
              o2 !== ee3 && (y3.bindFramebuffer(y3.FRAMEBUFFER, o2), s2 = true);
              try {
                var c3 = e4.texture, u4 = c3.format, l4 = c3.type;
                if (u4 !== Fe2 && H3.convert(u4) !== y3.getParameter(y3.IMPLEMENTATION_COLOR_READ_FORMAT))
                  return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                if (!(l4 === Ee2 || H3.convert(l4) === y3.getParameter(y3.IMPLEMENTATION_COLOR_READ_TYPE) || l4 === Ce2 && (b3.isWebGL2 || x3.get("OES_texture_float") || x3.get("WEBGL_color_buffer_float")) || l4 === Pe2 && (b3.isWebGL2 ? x3.get("EXT_color_buffer_float") : x3.get("EXT_color_buffer_half_float"))))
                  return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                y3.checkFramebufferStatus(y3.FRAMEBUFFER) === y3.FRAMEBUFFER_COMPLETE ? t4 >= 0 && t4 <= e4.width - r4 && n4 >= 0 && n4 <= e4.height - i3 && y3.readPixels(t4, n4, r4, i3, H3.convert(u4), H3.convert(l4), a3) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
              } finally {
                s2 && y3.bindFramebuffer(y3.FRAMEBUFFER, ee3);
              }
            }
          } else
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        }, this.copyFramebufferToTexture = function(e4, t4, n4) {
          var r4 = t4.image.width, i3 = t4.image.height, a3 = H3.convert(t4.format);
          this.setTexture2D(t4, 0), y3.copyTexImage2D(y3.TEXTURE_2D, n4 || 0, a3, e4.x, e4.y, r4, i3, 0);
        }, this.copyTextureToTexture = function(e4, t4, n4, r4) {
          var i3 = t4.image.width, a3 = t4.image.height, o2 = H3.convert(n4.format), s2 = H3.convert(n4.type);
          this.setTexture2D(n4, 0), t4.isDataTexture ? y3.texSubImage2D(y3.TEXTURE_2D, r4 || 0, e4.x, e4.y, i3, a3, o2, s2, t4.image.data) : y3.texSubImage2D(y3.TEXTURE_2D, r4 || 0, e4.x, e4.y, o2, s2, t4.image);
        };
      }
      function si2(e3, t3) {
        this.name = "", this.color = new rn(e3), this.density = void 0 !== t3 ? t3 : 25e-5;
      }
      function ci2(e3, t3, n3) {
        this.name = "", this.color = new rn(e3), this.near = void 0 !== t3 ? t3 : 1, this.far = void 0 !== n3 ? n3 : 1e3;
      }
      function ui2() {
        dn.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = true;
      }
      function li2(e3, t3) {
        this.array = e3, this.stride = t3, this.count = void 0 !== e3 ? e3.length / t3 : 0, this.dynamic = false, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
      }
      function hi2(e3, t3, n3, r3) {
        this.data = e3, this.itemSize = t3, this.offset = n3, this.normalized = true === r3;
      }
      function di2(e3) {
        Bn.call(this), this.type = "SpriteMaterial", this.color = new rn(16777215), this.map = null, this.rotation = 0, this.lights = false, this.transparent = true, this.setValues(e3);
      }
      function pi2(e3) {
        if (dn.call(this), this.type = "Sprite", void 0 === qr) {
          qr = new Pn();
          var t3 = new li2(new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]), 5);
          qr.setIndex([0, 1, 2, 0, 2, 3]), qr.addAttribute("position", new hi2(t3, 3, 0, false)), qr.addAttribute("uv", new hi2(t3, 2, 3, false));
        }
        this.geometry = qr, this.material = void 0 !== e3 ? e3 : new di2(), this.center = new Ft(0.5, 0.5);
      }
      function fi2() {
        dn.call(this), this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: true, value: [] } });
      }
      function mi2(e3, t3) {
        if (e3 = e3 || [], this.bones = e3.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === t3)
          this.calculateInverses();
        else if (this.bones.length === t3.length)
          this.boneInverses = t3.slice(0);
        else {
          console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
          for (var n3 = 0, r3 = this.bones.length; n3 < r3; n3++)
            this.boneInverses.push(new Gt());
        }
      }
      function gi2() {
        dn.call(this), this.type = "Bone";
      }
      function vi2(e3, t3) {
        kn.call(this, e3, t3), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Gt(), this.bindMatrixInverse = new Gt();
        var n3 = new mi2(this.initBones());
        this.bind(n3, this.matrixWorld), this.normalizeSkinWeights();
      }
      function yi2(e3) {
        Bn.call(this), this.type = "LineBasicMaterial", this.color = new rn(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = false, this.setValues(e3);
      }
      function xi2(e3, t3, n3) {
        1 === n3 && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), dn.call(this), this.type = "Line", this.geometry = void 0 !== e3 ? e3 : new Pn(), this.material = void 0 !== t3 ? t3 : new yi2({ color: 16777215 * Math.random() });
      }
      function bi2(e3, t3) {
        xi2.call(this, e3, t3), this.type = "LineSegments";
      }
      function wi2(e3, t3) {
        xi2.call(this, e3, t3), this.type = "LineLoop";
      }
      function _i(e3) {
        Bn.call(this), this.type = "PointsMaterial", this.color = new rn(16777215), this.map = null, this.size = 1, this.sizeAttenuation = true, this.morphTargets = false, this.lights = false, this.setValues(e3);
      }
      function Mi2(e3, t3) {
        dn.call(this), this.type = "Points", this.geometry = void 0 !== e3 ? e3 : new Pn(), this.material = void 0 !== t3 ? t3 : new _i({ color: 16777215 * Math.random() });
      }
      function Ei2(e3, t3, n3, r3, i3, a2, o2, s2, c3) {
        Wt.call(this, e3, t3, n3, r3, i3, a2, o2, s2, c3), this.generateMipmaps = false;
      }
      function Ti2(e3, t3, n3, r3, i3, a2, o2, s2, c3, u3, l3, h3) {
        Wt.call(this, null, a2, o2, s2, c3, u3, r3, i3, l3, h3), this.image = { width: t3, height: n3 }, this.mipmaps = e3, this.flipY = false, this.generateMipmaps = false;
      }
      function Si2(e3, t3, n3, r3, i3, a2, o2, s2, c3) {
        Wt.call(this, e3, t3, n3, r3, i3, a2, o2, s2, c3), this.needsUpdate = true;
      }
      function Ai2(e3, t3, n3, r3, i3, a2, o2, s2, c3, u3) {
        if ((u3 = void 0 !== u3 ? u3 : ke2) !== ke2 && u3 !== je2)
          throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === n3 && u3 === ke2 && (n3 = Ae2), void 0 === n3 && u3 === je2 && (n3 = De2), Wt.call(this, null, r3, i3, a2, o2, s2, u3, n3, c3), this.image = { width: e3, height: t3 }, this.magFilter = void 0 !== o2 ? o2 : ye2, this.minFilter = void 0 !== s2 ? s2 : ye2, this.flipY = false, this.generateMipmaps = false;
      }
      function Li2(e3) {
        Pn.call(this), this.type = "WireframeGeometry";
        var t3, n3, r3, i3, a2, o2, s2, c3, u3, l3, h3 = [], d3 = [0, 0], p3 = {}, f3 = ["a", "b", "c"];
        if (e3 && e3.isGeometry) {
          var m3 = e3.faces;
          for (t3 = 0, r3 = m3.length; t3 < r3; t3++) {
            var g3 = m3[t3];
            for (n3 = 0; n3 < 3; n3++)
              s2 = g3[f3[n3]], c3 = g3[f3[(n3 + 1) % 3]], d3[0] = Math.min(s2, c3), d3[1] = Math.max(s2, c3), void 0 === p3[u3 = d3[0] + "," + d3[1]] && (p3[u3] = { index1: d3[0], index2: d3[1] });
          }
          for (u3 in p3)
            o2 = p3[u3], l3 = e3.vertices[o2.index1], h3.push(l3.x, l3.y, l3.z), l3 = e3.vertices[o2.index2], h3.push(l3.x, l3.y, l3.z);
        } else if (e3 && e3.isBufferGeometry) {
          var v3, y3, x3, b3, w3, _3, M3;
          if (l3 = new Ht(), null !== e3.index) {
            for (v3 = e3.attributes.position, y3 = e3.index, 0 === (x3 = e3.groups).length && (x3 = [{ start: 0, count: y3.count, materialIndex: 0 }]), i3 = 0, a2 = x3.length; i3 < a2; ++i3)
              for (t3 = w3 = (b3 = x3[i3]).start, r3 = w3 + b3.count; t3 < r3; t3 += 3)
                for (n3 = 0; n3 < 3; n3++)
                  s2 = y3.getX(t3 + n3), c3 = y3.getX(t3 + (n3 + 1) % 3), d3[0] = Math.min(s2, c3), d3[1] = Math.max(s2, c3), void 0 === p3[u3 = d3[0] + "," + d3[1]] && (p3[u3] = { index1: d3[0], index2: d3[1] });
            for (u3 in p3)
              o2 = p3[u3], l3.fromBufferAttribute(v3, o2.index1), h3.push(l3.x, l3.y, l3.z), l3.fromBufferAttribute(v3, o2.index2), h3.push(l3.x, l3.y, l3.z);
          } else
            for (t3 = 0, r3 = (v3 = e3.attributes.position).count / 3; t3 < r3; t3++)
              for (n3 = 0; n3 < 3; n3++)
                _3 = 3 * t3 + n3, l3.fromBufferAttribute(v3, _3), h3.push(l3.x, l3.y, l3.z), M3 = 3 * t3 + (n3 + 1) % 3, l3.fromBufferAttribute(v3, M3), h3.push(l3.x, l3.y, l3.z);
        }
        this.addAttribute("position", new Sn(h3, 3));
      }
      function Ri2(e3, t3, n3) {
        vn.call(this), this.type = "ParametricGeometry", this.parameters = { func: e3, slices: t3, stacks: n3 }, this.fromBufferGeometry(new Ci2(e3, t3, n3)), this.mergeVertices();
      }
      function Ci2(e3, t3, n3) {
        Pn.call(this), this.type = "ParametricBufferGeometry", this.parameters = { func: e3, slices: t3, stacks: n3 };
        var r3, i3, a2 = [], o2 = [], s2 = [], c3 = [], u3 = new Ht(), l3 = new Ht(), h3 = new Ht(), d3 = new Ht(), p3 = new Ht();
        e3.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
        var f3 = t3 + 1;
        for (r3 = 0; r3 <= n3; r3++) {
          var m3 = r3 / n3;
          for (i3 = 0; i3 <= t3; i3++) {
            var g3 = i3 / t3;
            e3(g3, m3, l3), o2.push(l3.x, l3.y, l3.z), g3 - 1e-5 >= 0 ? (e3(g3 - 1e-5, m3, h3), d3.subVectors(l3, h3)) : (e3(g3 + 1e-5, m3, h3), d3.subVectors(h3, l3)), m3 - 1e-5 >= 0 ? (e3(g3, m3 - 1e-5, h3), p3.subVectors(l3, h3)) : (e3(g3, m3 + 1e-5, h3), p3.subVectors(h3, l3)), u3.crossVectors(d3, p3).normalize(), s2.push(u3.x, u3.y, u3.z), c3.push(g3, m3);
          }
        }
        for (r3 = 0; r3 < n3; r3++)
          for (i3 = 0; i3 < t3; i3++) {
            var v3 = r3 * f3 + i3, y3 = r3 * f3 + i3 + 1, x3 = (r3 + 1) * f3 + i3 + 1, b3 = (r3 + 1) * f3 + i3;
            a2.push(v3, y3, b3), a2.push(y3, x3, b3);
          }
        this.setIndex(a2), this.addAttribute("position", new Sn(o2, 3)), this.addAttribute("normal", new Sn(s2, 3)), this.addAttribute("uv", new Sn(c3, 2));
      }
      function Pi2(e3, t3, n3, r3) {
        vn.call(this), this.type = "PolyhedronGeometry", this.parameters = { vertices: e3, indices: t3, radius: n3, detail: r3 }, this.fromBufferGeometry(new Oi2(e3, t3, n3, r3)), this.mergeVertices();
      }
      function Oi2(e3, t3, n3, r3) {
        Pn.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = { vertices: e3, indices: t3, radius: n3, detail: r3 }, n3 = n3 || 1;
        var i3 = [], a2 = [];
        function o2(e4, t4, n4, r4) {
          var i4, a3, o3 = Math.pow(2, r4), c4 = [];
          for (i4 = 0; i4 <= o3; i4++) {
            c4[i4] = [];
            var u4 = e4.clone().lerp(n4, i4 / o3), l4 = t4.clone().lerp(n4, i4 / o3), h4 = o3 - i4;
            for (a3 = 0; a3 <= h4; a3++)
              c4[i4][a3] = 0 === a3 && i4 === o3 ? u4 : u4.clone().lerp(l4, a3 / h4);
          }
          for (i4 = 0; i4 < o3; i4++)
            for (a3 = 0; a3 < 2 * (o3 - i4) - 1; a3++) {
              var d3 = Math.floor(a3 / 2);
              a3 % 2 == 0 ? (s2(c4[i4][d3 + 1]), s2(c4[i4 + 1][d3]), s2(c4[i4][d3])) : (s2(c4[i4][d3 + 1]), s2(c4[i4 + 1][d3 + 1]), s2(c4[i4 + 1][d3]));
            }
        }
        function s2(e4) {
          i3.push(e4.x, e4.y, e4.z);
        }
        function c3(t4, n4) {
          var r4 = 3 * t4;
          n4.x = e3[r4 + 0], n4.y = e3[r4 + 1], n4.z = e3[r4 + 2];
        }
        function u3(e4, t4, n4, r4) {
          r4 < 0 && 1 === e4.x && (a2[t4] = e4.x - 1), 0 === n4.x && 0 === n4.z && (a2[t4] = r4 / 2 / Math.PI + 0.5);
        }
        function l3(e4) {
          return Math.atan2(e4.z, -e4.x);
        }
        function h3(e4) {
          return Math.atan2(-e4.y, Math.sqrt(e4.x * e4.x + e4.z * e4.z));
        }
        !function(e4) {
          for (var n4 = new Ht(), r4 = new Ht(), i4 = new Ht(), a3 = 0; a3 < t3.length; a3 += 3)
            c3(t3[a3 + 0], n4), c3(t3[a3 + 1], r4), c3(t3[a3 + 2], i4), o2(n4, r4, i4, e4);
        }(r3 = r3 || 0), function(e4) {
          for (var t4 = new Ht(), n4 = 0; n4 < i3.length; n4 += 3)
            t4.x = i3[n4 + 0], t4.y = i3[n4 + 1], t4.z = i3[n4 + 2], t4.normalize().multiplyScalar(e4), i3[n4 + 0] = t4.x, i3[n4 + 1] = t4.y, i3[n4 + 2] = t4.z;
        }(n3), function() {
          for (var e4 = new Ht(), t4 = 0; t4 < i3.length; t4 += 3) {
            e4.x = i3[t4 + 0], e4.y = i3[t4 + 1], e4.z = i3[t4 + 2];
            var n4 = l3(e4) / 2 / Math.PI + 0.5, r4 = h3(e4) / Math.PI + 0.5;
            a2.push(n4, 1 - r4);
          }
          (function() {
            for (var e5 = new Ht(), t5 = new Ht(), n5 = new Ht(), r5 = new Ht(), o3 = new Ft(), s3 = new Ft(), c4 = new Ft(), h4 = 0, d3 = 0; h4 < i3.length; h4 += 9, d3 += 6) {
              e5.set(i3[h4 + 0], i3[h4 + 1], i3[h4 + 2]), t5.set(i3[h4 + 3], i3[h4 + 4], i3[h4 + 5]), n5.set(i3[h4 + 6], i3[h4 + 7], i3[h4 + 8]), o3.set(a2[d3 + 0], a2[d3 + 1]), s3.set(a2[d3 + 2], a2[d3 + 3]), c4.set(a2[d3 + 4], a2[d3 + 5]), r5.copy(e5).add(t5).add(n5).divideScalar(3);
              var p3 = l3(r5);
              u3(o3, d3 + 0, e5, p3), u3(s3, d3 + 2, t5, p3), u3(c4, d3 + 4, n5, p3);
            }
          })(), function() {
            for (var e5 = 0; e5 < a2.length; e5 += 6) {
              var t5 = a2[e5 + 0], n5 = a2[e5 + 2], r5 = a2[e5 + 4], i4 = Math.max(t5, n5, r5), o3 = Math.min(t5, n5, r5);
              i4 > 0.9 && o3 < 0.1 && (t5 < 0.2 && (a2[e5 + 0] += 1), n5 < 0.2 && (a2[e5 + 2] += 1), r5 < 0.2 && (a2[e5 + 4] += 1));
            }
          }();
        }(), this.addAttribute("position", new Sn(i3, 3)), this.addAttribute("normal", new Sn(i3.slice(), 3)), this.addAttribute("uv", new Sn(a2, 2)), 0 === r3 ? this.computeVertexNormals() : this.normalizeNormals();
      }
      function Ni2(e3, t3) {
        vn.call(this), this.type = "TetrahedronGeometry", this.parameters = { radius: e3, detail: t3 }, this.fromBufferGeometry(new Ii2(e3, t3)), this.mergeVertices();
      }
      function Ii2(e3, t3) {
        Oi2.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e3, t3), this.type = "TetrahedronBufferGeometry", this.parameters = { radius: e3, detail: t3 };
      }
      function Di2(e3, t3) {
        vn.call(this), this.type = "OctahedronGeometry", this.parameters = { radius: e3, detail: t3 }, this.fromBufferGeometry(new Ui2(e3, t3)), this.mergeVertices();
      }
      function Ui2(e3, t3) {
        Oi2.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e3, t3), this.type = "OctahedronBufferGeometry", this.parameters = { radius: e3, detail: t3 };
      }
      function Bi2(e3, t3) {
        vn.call(this), this.type = "IcosahedronGeometry", this.parameters = { radius: e3, detail: t3 }, this.fromBufferGeometry(new Fi2(e3, t3)), this.mergeVertices();
      }
      function Fi2(e3, t3) {
        var n3 = (1 + Math.sqrt(5)) / 2, r3 = [-1, n3, 0, 1, n3, 0, -1, -n3, 0, 1, -n3, 0, 0, -1, n3, 0, 1, n3, 0, -1, -n3, 0, 1, -n3, n3, 0, -1, n3, 0, 1, -n3, 0, -1, -n3, 0, 1];
        Oi2.call(this, r3, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e3, t3), this.type = "IcosahedronBufferGeometry", this.parameters = { radius: e3, detail: t3 };
      }
      function Gi2(e3, t3) {
        vn.call(this), this.type = "DodecahedronGeometry", this.parameters = { radius: e3, detail: t3 }, this.fromBufferGeometry(new zi2(e3, t3)), this.mergeVertices();
      }
      function zi2(e3, t3) {
        var n3 = (1 + Math.sqrt(5)) / 2, r3 = 1 / n3, i3 = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r3, -n3, 0, -r3, n3, 0, r3, -n3, 0, r3, n3, -r3, -n3, 0, -r3, n3, 0, r3, -n3, 0, r3, n3, 0, -n3, 0, -r3, n3, 0, -r3, -n3, 0, r3, n3, 0, r3];
        Oi2.call(this, i3, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e3, t3), this.type = "DodecahedronBufferGeometry", this.parameters = { radius: e3, detail: t3 };
      }
      function Hi2(e3, t3, n3, r3, i3, a2) {
        vn.call(this), this.type = "TubeGeometry", this.parameters = { path: e3, tubularSegments: t3, radius: n3, radialSegments: r3, closed: i3 }, void 0 !== a2 && console.warn("THREE.TubeGeometry: taper has been removed.");
        var o2 = new ki2(e3, t3, n3, r3, i3);
        this.tangents = o2.tangents, this.normals = o2.normals, this.binormals = o2.binormals, this.fromBufferGeometry(o2), this.mergeVertices();
      }
      function ki2(e3, t3, n3, r3, i3) {
        Pn.call(this), this.type = "TubeBufferGeometry", this.parameters = { path: e3, tubularSegments: t3, radius: n3, radialSegments: r3, closed: i3 }, t3 = t3 || 64, n3 = n3 || 1, r3 = r3 || 8, i3 = i3 || false;
        var a2 = e3.computeFrenetFrames(t3, i3);
        this.tangents = a2.tangents, this.normals = a2.normals, this.binormals = a2.binormals;
        var o2, s2, c3 = new Ht(), u3 = new Ht(), l3 = new Ft(), h3 = new Ht(), d3 = [], p3 = [], f3 = [], m3 = [];
        function g3(i4) {
          h3 = e3.getPointAt(i4 / t3, h3);
          var o3 = a2.normals[i4], l4 = a2.binormals[i4];
          for (s2 = 0; s2 <= r3; s2++) {
            var f4 = s2 / r3 * Math.PI * 2, m4 = Math.sin(f4), g4 = -Math.cos(f4);
            u3.x = g4 * o3.x + m4 * l4.x, u3.y = g4 * o3.y + m4 * l4.y, u3.z = g4 * o3.z + m4 * l4.z, u3.normalize(), p3.push(u3.x, u3.y, u3.z), c3.x = h3.x + n3 * u3.x, c3.y = h3.y + n3 * u3.y, c3.z = h3.z + n3 * u3.z, d3.push(c3.x, c3.y, c3.z);
          }
        }
        !function() {
          for (o2 = 0; o2 < t3; o2++)
            g3(o2);
          g3(false === i3 ? t3 : 0), function() {
            for (o2 = 0; o2 <= t3; o2++)
              for (s2 = 0; s2 <= r3; s2++)
                l3.x = o2 / t3, l3.y = s2 / r3, f3.push(l3.x, l3.y);
          }(), function() {
            for (s2 = 1; s2 <= t3; s2++)
              for (o2 = 1; o2 <= r3; o2++) {
                var e4 = (r3 + 1) * (s2 - 1) + (o2 - 1), n4 = (r3 + 1) * s2 + (o2 - 1), i4 = (r3 + 1) * s2 + o2, a3 = (r3 + 1) * (s2 - 1) + o2;
                m3.push(e4, n4, a3), m3.push(n4, i4, a3);
              }
          }();
        }(), this.setIndex(m3), this.addAttribute("position", new Sn(d3, 3)), this.addAttribute("normal", new Sn(p3, 3)), this.addAttribute("uv", new Sn(f3, 2));
      }
      function ji2(e3, t3, n3, r3, i3, a2, o2) {
        vn.call(this), this.type = "TorusKnotGeometry", this.parameters = { radius: e3, tube: t3, tubularSegments: n3, radialSegments: r3, p: i3, q: a2 }, void 0 !== o2 && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new Vi2(e3, t3, n3, r3, i3, a2)), this.mergeVertices();
      }
      function Vi2(e3, t3, n3, r3, i3, a2) {
        Pn.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = { radius: e3, tube: t3, tubularSegments: n3, radialSegments: r3, p: i3, q: a2 }, e3 = e3 || 1, t3 = t3 || 0.4, n3 = Math.floor(n3) || 64, r3 = Math.floor(r3) || 8, i3 = i3 || 2, a2 = a2 || 3;
        var o2, s2, c3 = [], u3 = [], l3 = [], h3 = [], d3 = new Ht(), p3 = new Ht(), f3 = new Ht(), m3 = new Ht(), g3 = new Ht(), v3 = new Ht(), y3 = new Ht();
        for (o2 = 0; o2 <= n3; ++o2) {
          var x3 = o2 / n3 * i3 * Math.PI * 2;
          for (A3(x3, i3, a2, e3, f3), A3(x3 + 0.01, i3, a2, e3, m3), v3.subVectors(m3, f3), y3.addVectors(m3, f3), g3.crossVectors(v3, y3), y3.crossVectors(g3, v3), g3.normalize(), y3.normalize(), s2 = 0; s2 <= r3; ++s2) {
            var b3 = s2 / r3 * Math.PI * 2, w3 = -t3 * Math.cos(b3), _3 = t3 * Math.sin(b3);
            d3.x = f3.x + (w3 * y3.x + _3 * g3.x), d3.y = f3.y + (w3 * y3.y + _3 * g3.y), d3.z = f3.z + (w3 * y3.z + _3 * g3.z), u3.push(d3.x, d3.y, d3.z), p3.subVectors(d3, f3).normalize(), l3.push(p3.x, p3.y, p3.z), h3.push(o2 / n3), h3.push(s2 / r3);
          }
        }
        for (s2 = 1; s2 <= n3; s2++)
          for (o2 = 1; o2 <= r3; o2++) {
            var M3 = (r3 + 1) * (s2 - 1) + (o2 - 1), E3 = (r3 + 1) * s2 + (o2 - 1), T3 = (r3 + 1) * s2 + o2, S3 = (r3 + 1) * (s2 - 1) + o2;
            c3.push(M3, E3, S3), c3.push(E3, T3, S3);
          }
        function A3(e4, t4, n4, r4, i4) {
          var a3 = Math.cos(e4), o3 = Math.sin(e4), s3 = n4 / t4 * e4, c4 = Math.cos(s3);
          i4.x = r4 * (2 + c4) * 0.5 * a3, i4.y = r4 * (2 + c4) * o3 * 0.5, i4.z = r4 * Math.sin(s3) * 0.5;
        }
        this.setIndex(c3), this.addAttribute("position", new Sn(u3, 3)), this.addAttribute("normal", new Sn(l3, 3)), this.addAttribute("uv", new Sn(h3, 2));
      }
      function Wi2(e3, t3, n3, r3, i3) {
        vn.call(this), this.type = "TorusGeometry", this.parameters = { radius: e3, tube: t3, radialSegments: n3, tubularSegments: r3, arc: i3 }, this.fromBufferGeometry(new Xi2(e3, t3, n3, r3, i3)), this.mergeVertices();
      }
      function Xi2(e3, t3, n3, r3, i3) {
        Pn.call(this), this.type = "TorusBufferGeometry", this.parameters = { radius: e3, tube: t3, radialSegments: n3, tubularSegments: r3, arc: i3 }, e3 = e3 || 1, t3 = t3 || 0.4, n3 = Math.floor(n3) || 8, r3 = Math.floor(r3) || 6, i3 = i3 || 2 * Math.PI;
        var a2, o2, s2 = [], c3 = [], u3 = [], l3 = [], h3 = new Ht(), d3 = new Ht(), p3 = new Ht();
        for (a2 = 0; a2 <= n3; a2++)
          for (o2 = 0; o2 <= r3; o2++) {
            var f3 = o2 / r3 * i3, m3 = a2 / n3 * Math.PI * 2;
            d3.x = (e3 + t3 * Math.cos(m3)) * Math.cos(f3), d3.y = (e3 + t3 * Math.cos(m3)) * Math.sin(f3), d3.z = t3 * Math.sin(m3), c3.push(d3.x, d3.y, d3.z), h3.x = e3 * Math.cos(f3), h3.y = e3 * Math.sin(f3), p3.subVectors(d3, h3).normalize(), u3.push(p3.x, p3.y, p3.z), l3.push(o2 / r3), l3.push(a2 / n3);
          }
        for (a2 = 1; a2 <= n3; a2++)
          for (o2 = 1; o2 <= r3; o2++) {
            var g3 = (r3 + 1) * a2 + o2 - 1, v3 = (r3 + 1) * (a2 - 1) + o2 - 1, y3 = (r3 + 1) * (a2 - 1) + o2, x3 = (r3 + 1) * a2 + o2;
            s2.push(g3, v3, x3), s2.push(v3, y3, x3);
          }
        this.setIndex(s2), this.addAttribute("position", new Sn(c3, 3)), this.addAttribute("normal", new Sn(u3, 3)), this.addAttribute("uv", new Sn(l3, 2));
      }
      Kr.prototype = Object.create(Bn.prototype), Kr.prototype.constructor = Kr, Kr.prototype.isMeshDepthMaterial = true, Kr.prototype.copy = function(e3) {
        return Bn.prototype.copy.call(this, e3), this.depthPacking = e3.depthPacking, this.skinning = e3.skinning, this.morphTargets = e3.morphTargets, this.map = e3.map, this.alphaMap = e3.alphaMap, this.displacementMap = e3.displacementMap, this.displacementScale = e3.displacementScale, this.displacementBias = e3.displacementBias, this.wireframe = e3.wireframe, this.wireframeLinewidth = e3.wireframeLinewidth, this;
      }, Qr.prototype = Object.create(Bn.prototype), Qr.prototype.constructor = Qr, Qr.prototype.isMeshDistanceMaterial = true, Qr.prototype.copy = function(e3) {
        return Bn.prototype.copy.call(this, e3), this.referencePosition.copy(e3.referencePosition), this.nearDistance = e3.nearDistance, this.farDistance = e3.farDistance, this.skinning = e3.skinning, this.morphTargets = e3.morphTargets, this.map = e3.map, this.alphaMap = e3.alphaMap, this.displacementMap = e3.displacementMap, this.displacementScale = e3.displacementScale, this.displacementBias = e3.displacementBias, this;
      }, ni2.prototype = Object.assign(Object.create(dn.prototype), { constructor: ni2, isGroup: true }), ri2.prototype = Object.assign(Object.create(pn.prototype), { constructor: ri2, isPerspectiveCamera: true, copy: function(e3, t3) {
        return pn.prototype.copy.call(this, e3, t3), this.fov = e3.fov, this.zoom = e3.zoom, this.near = e3.near, this.far = e3.far, this.focus = e3.focus, this.aspect = e3.aspect, this.view = null === e3.view ? null : Object.assign({}, e3.view), this.filmGauge = e3.filmGauge, this.filmOffset = e3.filmOffset, this;
      }, setFocalLength: function(e3) {
        var t3 = 0.5 * this.getFilmHeight() / e3;
        this.fov = 2 * Bt.RAD2DEG * Math.atan(t3), this.updateProjectionMatrix();
      }, getFocalLength: function() {
        var e3 = Math.tan(0.5 * Bt.DEG2RAD * this.fov);
        return 0.5 * this.getFilmHeight() / e3;
      }, getEffectiveFOV: function() {
        return 2 * Bt.RAD2DEG * Math.atan(Math.tan(0.5 * Bt.DEG2RAD * this.fov) / this.zoom);
      }, getFilmWidth: function() {
        return this.filmGauge * Math.min(this.aspect, 1);
      }, getFilmHeight: function() {
        return this.filmGauge / Math.max(this.aspect, 1);
      }, setViewOffset: function(e3, t3, n3, r3, i3, a2) {
        this.aspect = e3 / t3, null === this.view && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = e3, this.view.fullHeight = t3, this.view.offsetX = n3, this.view.offsetY = r3, this.view.width = i3, this.view.height = a2, this.updateProjectionMatrix();
      }, clearViewOffset: function() {
        null !== this.view && (this.view.enabled = false), this.updateProjectionMatrix();
      }, updateProjectionMatrix: function() {
        var e3 = this.near, t3 = e3 * Math.tan(0.5 * Bt.DEG2RAD * this.fov) / this.zoom, n3 = 2 * t3, r3 = this.aspect * n3, i3 = -0.5 * r3, a2 = this.view;
        if (null !== this.view && this.view.enabled) {
          var o2 = a2.fullWidth, s2 = a2.fullHeight;
          i3 += a2.offsetX * r3 / o2, t3 -= a2.offsetY * n3 / s2, r3 *= a2.width / o2, n3 *= a2.height / s2;
        }
        var c3 = this.filmOffset;
        0 !== c3 && (i3 += e3 * c3 / this.getFilmWidth()), this.projectionMatrix.makePerspective(i3, i3 + r3, t3, t3 - n3, e3, this.far);
      }, toJSON: function(e3) {
        var t3 = dn.prototype.toJSON.call(this, e3);
        return t3.object.fov = this.fov, t3.object.zoom = this.zoom, t3.object.near = this.near, t3.object.far = this.far, t3.object.focus = this.focus, t3.object.aspect = this.aspect, null !== this.view && (t3.object.view = Object.assign({}, this.view)), t3.object.filmGauge = this.filmGauge, t3.object.filmOffset = this.filmOffset, t3;
      } }), ii2.prototype = Object.assign(Object.create(ri2.prototype), { constructor: ii2, isArrayCamera: true }), si2.prototype.isFogExp2 = true, si2.prototype.clone = function() {
        return new si2(this.color, this.density);
      }, si2.prototype.toJSON = function() {
        return { type: "FogExp2", color: this.color.getHex(), density: this.density };
      }, ci2.prototype.isFog = true, ci2.prototype.clone = function() {
        return new ci2(this.color, this.near, this.far);
      }, ci2.prototype.toJSON = function() {
        return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far };
      }, ui2.prototype = Object.assign(Object.create(dn.prototype), { constructor: ui2, copy: function(e3, t3) {
        return dn.prototype.copy.call(this, e3, t3), null !== e3.background && (this.background = e3.background.clone()), null !== e3.fog && (this.fog = e3.fog.clone()), null !== e3.overrideMaterial && (this.overrideMaterial = e3.overrideMaterial.clone()), this.autoUpdate = e3.autoUpdate, this.matrixAutoUpdate = e3.matrixAutoUpdate, this;
      }, toJSON: function(e3) {
        var t3 = dn.prototype.toJSON.call(this, e3);
        return null !== this.background && (t3.object.background = this.background.toJSON(e3)), null !== this.fog && (t3.object.fog = this.fog.toJSON()), t3;
      } }), Object.defineProperty(li2.prototype, "needsUpdate", { set: function(e3) {
        true === e3 && this.version++;
      } }), Object.assign(li2.prototype, { isInterleavedBuffer: true, onUploadCallback: function() {
      }, setArray: function(e3) {
        if (Array.isArray(e3))
          throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        return this.count = void 0 !== e3 ? e3.length / this.stride : 0, this.array = e3, this;
      }, setDynamic: function(e3) {
        return this.dynamic = e3, this;
      }, copy: function(e3) {
        return this.array = new e3.array.constructor(e3.array), this.count = e3.count, this.stride = e3.stride, this.dynamic = e3.dynamic, this;
      }, copyAt: function(e3, t3, n3) {
        e3 *= this.stride, n3 *= t3.stride;
        for (var r3 = 0, i3 = this.stride; r3 < i3; r3++)
          this.array[e3 + r3] = t3.array[n3 + r3];
        return this;
      }, set: function(e3, t3) {
        return void 0 === t3 && (t3 = 0), this.array.set(e3, t3), this;
      }, clone: function() {
        return new this.constructor().copy(this);
      }, onUpload: function(e3) {
        return this.onUploadCallback = e3, this;
      } }), Object.defineProperties(hi2.prototype, { count: { get: function() {
        return this.data.count;
      } }, array: { get: function() {
        return this.data.array;
      } } }), Object.assign(hi2.prototype, { isInterleavedBufferAttribute: true, setX: function(e3, t3) {
        return this.data.array[e3 * this.data.stride + this.offset] = t3, this;
      }, setY: function(e3, t3) {
        return this.data.array[e3 * this.data.stride + this.offset + 1] = t3, this;
      }, setZ: function(e3, t3) {
        return this.data.array[e3 * this.data.stride + this.offset + 2] = t3, this;
      }, setW: function(e3, t3) {
        return this.data.array[e3 * this.data.stride + this.offset + 3] = t3, this;
      }, getX: function(e3) {
        return this.data.array[e3 * this.data.stride + this.offset];
      }, getY: function(e3) {
        return this.data.array[e3 * this.data.stride + this.offset + 1];
      }, getZ: function(e3) {
        return this.data.array[e3 * this.data.stride + this.offset + 2];
      }, getW: function(e3) {
        return this.data.array[e3 * this.data.stride + this.offset + 3];
      }, setXY: function(e3, t3, n3) {
        return e3 = e3 * this.data.stride + this.offset, this.data.array[e3 + 0] = t3, this.data.array[e3 + 1] = n3, this;
      }, setXYZ: function(e3, t3, n3, r3) {
        return e3 = e3 * this.data.stride + this.offset, this.data.array[e3 + 0] = t3, this.data.array[e3 + 1] = n3, this.data.array[e3 + 2] = r3, this;
      }, setXYZW: function(e3, t3, n3, r3, i3) {
        return e3 = e3 * this.data.stride + this.offset, this.data.array[e3 + 0] = t3, this.data.array[e3 + 1] = n3, this.data.array[e3 + 2] = r3, this.data.array[e3 + 3] = i3, this;
      } }), di2.prototype = Object.create(Bn.prototype), di2.prototype.constructor = di2, di2.prototype.isSpriteMaterial = true, di2.prototype.copy = function(e3) {
        return Bn.prototype.copy.call(this, e3), this.color.copy(e3.color), this.map = e3.map, this.rotation = e3.rotation, this;
      }, pi2.prototype = Object.assign(Object.create(dn.prototype), { constructor: pi2, isSprite: true, raycast: function() {
        var e3 = new Ht(), t3 = new Ht(), n3 = new Ht(), r3 = new Ft(), i3 = new Ft(), a2 = new Gt(), o2 = new Ht(), s2 = new Ht(), c3 = new Ht();
        function u3(e4, t4, n4, o3, s3, c4) {
          r3.subVectors(e4, n4).addScalar(0.5).multiply(o3), void 0 !== s3 ? (i3.x = c4 * r3.x - s3 * r3.y, i3.y = s3 * r3.x + c4 * r3.y) : i3.copy(r3), e4.copy(t4), e4.x += i3.x, e4.y += i3.y, e4.applyMatrix4(a2);
        }
        return function(r4, i4) {
          t3.setFromMatrixScale(this.matrixWorld), a2.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld), n3.setFromMatrixPosition(this.modelViewMatrix);
          var l3, h3, d3 = this.material.rotation;
          0 !== d3 && (h3 = Math.cos(d3), l3 = Math.sin(d3));
          var p3 = this.center;
          u3(o2.set(-0.5, -0.5, 0), n3, p3, t3, l3, h3), u3(s2.set(0.5, -0.5, 0), n3, p3, t3, l3, h3), u3(c3.set(0.5, 0.5, 0), n3, p3, t3, l3, h3);
          var f3 = r4.ray.intersectTriangle(o2, s2, c3, false, e3);
          if (null !== f3 || (u3(s2.set(-0.5, 0.5, 0), n3, p3, t3, l3, h3), null !== (f3 = r4.ray.intersectTriangle(o2, c3, s2, false, e3)))) {
            var m3 = r4.ray.origin.distanceTo(e3);
            m3 < r4.near || m3 > r4.far || i4.push({ distance: m3, point: e3.clone(), face: null, object: this });
          }
        };
      }(), clone: function() {
        return new this.constructor(this.material).copy(this);
      }, copy: function(e3) {
        return dn.prototype.copy.call(this, e3), void 0 !== e3.center && this.center.copy(e3.center), this;
      } }), fi2.prototype = Object.assign(Object.create(dn.prototype), { constructor: fi2, copy: function(e3) {
        dn.prototype.copy.call(this, e3, false);
        for (var t3 = e3.levels, n3 = 0, r3 = t3.length; n3 < r3; n3++) {
          var i3 = t3[n3];
          this.addLevel(i3.object.clone(), i3.distance);
        }
        return this;
      }, addLevel: function(e3, t3) {
        void 0 === t3 && (t3 = 0), t3 = Math.abs(t3);
        for (var n3 = this.levels, r3 = 0; r3 < n3.length && !(t3 < n3[r3].distance); r3++)
          ;
        n3.splice(r3, 0, { distance: t3, object: e3 }), this.add(e3);
      }, getObjectForDistance: function(e3) {
        for (var t3 = this.levels, n3 = 1, r3 = t3.length; n3 < r3 && !(e3 < t3[n3].distance); n3++)
          ;
        return t3[n3 - 1].object;
      }, raycast: function() {
        var e3 = new Ht();
        return function(t3, n3) {
          e3.setFromMatrixPosition(this.matrixWorld);
          var r3 = t3.ray.origin.distanceTo(e3);
          this.getObjectForDistance(r3).raycast(t3, n3);
        };
      }(), update: function() {
        var e3 = new Ht(), t3 = new Ht();
        return function(n3) {
          var r3 = this.levels;
          if (r3.length > 1) {
            e3.setFromMatrixPosition(n3.matrixWorld), t3.setFromMatrixPosition(this.matrixWorld);
            var i3 = e3.distanceTo(t3);
            r3[0].object.visible = true;
            for (var a2 = 1, o2 = r3.length; a2 < o2 && i3 >= r3[a2].distance; a2++)
              r3[a2 - 1].object.visible = false, r3[a2].object.visible = true;
            for (; a2 < o2; a2++)
              r3[a2].object.visible = false;
          }
        };
      }(), toJSON: function(e3) {
        var t3 = dn.prototype.toJSON.call(this, e3);
        t3.object.levels = [];
        for (var n3 = this.levels, r3 = 0, i3 = n3.length; r3 < i3; r3++) {
          var a2 = n3[r3];
          t3.object.levels.push({ object: a2.object.uuid, distance: a2.distance });
        }
        return t3;
      } }), Object.assign(mi2.prototype, { calculateInverses: function() {
        this.boneInverses = [];
        for (var e3 = 0, t3 = this.bones.length; e3 < t3; e3++) {
          var n3 = new Gt();
          this.bones[e3] && n3.getInverse(this.bones[e3].matrixWorld), this.boneInverses.push(n3);
        }
      }, pose: function() {
        var e3, t3, n3;
        for (t3 = 0, n3 = this.bones.length; t3 < n3; t3++)
          (e3 = this.bones[t3]) && e3.matrixWorld.getInverse(this.boneInverses[t3]);
        for (t3 = 0, n3 = this.bones.length; t3 < n3; t3++)
          (e3 = this.bones[t3]) && (e3.parent && e3.parent.isBone ? (e3.matrix.getInverse(e3.parent.matrixWorld), e3.matrix.multiply(e3.matrixWorld)) : e3.matrix.copy(e3.matrixWorld), e3.matrix.decompose(e3.position, e3.quaternion, e3.scale));
      }, update: function() {
        var e3 = new Gt(), t3 = new Gt();
        return function() {
          for (var n3 = this.bones, r3 = this.boneInverses, i3 = this.boneMatrices, a2 = this.boneTexture, o2 = 0, s2 = n3.length; o2 < s2; o2++) {
            var c3 = n3[o2] ? n3[o2].matrixWorld : t3;
            e3.multiplyMatrices(c3, r3[o2]), e3.toArray(i3, 16 * o2);
          }
          void 0 !== a2 && (a2.needsUpdate = true);
        };
      }(), clone: function() {
        return new mi2(this.bones, this.boneInverses);
      }, getBoneByName: function(e3) {
        for (var t3 = 0, n3 = this.bones.length; t3 < n3; t3++) {
          var r3 = this.bones[t3];
          if (r3.name === e3)
            return r3;
        }
      } }), gi2.prototype = Object.assign(Object.create(dn.prototype), { constructor: gi2, isBone: true }), vi2.prototype = Object.assign(Object.create(kn.prototype), { constructor: vi2, isSkinnedMesh: true, initBones: function() {
        var e3, t3, n3, r3, i3 = [];
        if (this.geometry && void 0 !== this.geometry.bones) {
          for (n3 = 0, r3 = this.geometry.bones.length; n3 < r3; n3++)
            t3 = this.geometry.bones[n3], e3 = new gi2(), i3.push(e3), e3.name = t3.name, e3.position.fromArray(t3.pos), e3.quaternion.fromArray(t3.rotq), void 0 !== t3.scl && e3.scale.fromArray(t3.scl);
          for (n3 = 0, r3 = this.geometry.bones.length; n3 < r3; n3++)
            -1 !== (t3 = this.geometry.bones[n3]).parent && null !== t3.parent && void 0 !== i3[t3.parent] ? i3[t3.parent].add(i3[n3]) : this.add(i3[n3]);
        }
        return this.updateMatrixWorld(true), i3;
      }, bind: function(e3, t3) {
        this.skeleton = e3, void 0 === t3 && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), t3 = this.matrixWorld), this.bindMatrix.copy(t3), this.bindMatrixInverse.getInverse(t3);
      }, pose: function() {
        this.skeleton.pose();
      }, normalizeSkinWeights: function() {
        var e3, t3;
        if (this.geometry && this.geometry.isGeometry)
          for (t3 = 0; t3 < this.geometry.skinWeights.length; t3++) {
            var n3 = this.geometry.skinWeights[t3];
            (e3 = 1 / n3.manhattanLength()) !== 1 / 0 ? n3.multiplyScalar(e3) : n3.set(1, 0, 0, 0);
          }
        else if (this.geometry && this.geometry.isBufferGeometry) {
          var r3 = new Xt(), i3 = this.geometry.attributes.skinWeight;
          for (t3 = 0; t3 < i3.count; t3++)
            r3.x = i3.getX(t3), r3.y = i3.getY(t3), r3.z = i3.getZ(t3), r3.w = i3.getW(t3), (e3 = 1 / r3.manhattanLength()) !== 1 / 0 ? r3.multiplyScalar(e3) : r3.set(1, 0, 0, 0), i3.setXYZW(t3, r3.x, r3.y, r3.z, r3.w);
        }
      }, updateMatrixWorld: function(e3) {
        kn.prototype.updateMatrixWorld.call(this, e3), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
      }, clone: function() {
        return new this.constructor(this.geometry, this.material).copy(this);
      } }), yi2.prototype = Object.create(Bn.prototype), yi2.prototype.constructor = yi2, yi2.prototype.isLineBasicMaterial = true, yi2.prototype.copy = function(e3) {
        return Bn.prototype.copy.call(this, e3), this.color.copy(e3.color), this.linewidth = e3.linewidth, this.linecap = e3.linecap, this.linejoin = e3.linejoin, this;
      }, xi2.prototype = Object.assign(Object.create(dn.prototype), { constructor: xi2, isLine: true, computeLineDistances: function() {
        var e3 = new Ht(), t3 = new Ht();
        return function() {
          var n3 = this.geometry;
          if (n3.isBufferGeometry)
            if (null === n3.index) {
              for (var r3 = n3.attributes.position, i3 = [0], a2 = 1, o2 = r3.count; a2 < o2; a2++)
                e3.fromBufferAttribute(r3, a2 - 1), t3.fromBufferAttribute(r3, a2), i3[a2] = i3[a2 - 1], i3[a2] += e3.distanceTo(t3);
              n3.addAttribute("lineDistance", new Sn(i3, 1));
            } else
              console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          else if (n3.isGeometry) {
            var s2 = n3.vertices;
            (i3 = n3.lineDistances)[0] = 0;
            for (a2 = 1, o2 = s2.length; a2 < o2; a2++)
              i3[a2] = i3[a2 - 1], i3[a2] += s2[a2 - 1].distanceTo(s2[a2]);
          }
          return this;
        };
      }(), raycast: function() {
        var e3 = new Gt(), t3 = new zn(), n3 = new Kt();
        return function(r3, i3) {
          var a2 = r3.linePrecision, o2 = a2 * a2, s2 = this.geometry, c3 = this.matrixWorld;
          if (null === s2.boundingSphere && s2.computeBoundingSphere(), n3.copy(s2.boundingSphere), n3.applyMatrix4(c3), false !== r3.ray.intersectsSphere(n3)) {
            e3.getInverse(c3), t3.copy(r3.ray).applyMatrix4(e3);
            var u3 = new Ht(), l3 = new Ht(), h3 = new Ht(), d3 = new Ht(), p3 = this && this.isLineSegments ? 2 : 1;
            if (s2.isBufferGeometry) {
              var f3 = s2.index, m3 = s2.attributes.position.array;
              if (null !== f3)
                for (var g3 = f3.array, v3 = 0, y3 = g3.length - 1; v3 < y3; v3 += p3) {
                  var x3 = g3[v3], b3 = g3[v3 + 1];
                  if (u3.fromArray(m3, 3 * x3), l3.fromArray(m3, 3 * b3), !(t3.distanceSqToSegment(u3, l3, d3, h3) > o2))
                    d3.applyMatrix4(this.matrixWorld), (M3 = r3.ray.origin.distanceTo(d3)) < r3.near || M3 > r3.far || i3.push({ distance: M3, point: h3.clone().applyMatrix4(this.matrixWorld), index: v3, face: null, faceIndex: null, object: this });
                }
              else
                for (v3 = 0, y3 = m3.length / 3 - 1; v3 < y3; v3 += p3) {
                  if (u3.fromArray(m3, 3 * v3), l3.fromArray(m3, 3 * v3 + 3), !(t3.distanceSqToSegment(u3, l3, d3, h3) > o2))
                    d3.applyMatrix4(this.matrixWorld), (M3 = r3.ray.origin.distanceTo(d3)) < r3.near || M3 > r3.far || i3.push({ distance: M3, point: h3.clone().applyMatrix4(this.matrixWorld), index: v3, face: null, faceIndex: null, object: this });
                }
            } else if (s2.isGeometry) {
              var w3 = s2.vertices, _3 = w3.length;
              for (v3 = 0; v3 < _3 - 1; v3 += p3) {
                var M3;
                if (!(t3.distanceSqToSegment(w3[v3], w3[v3 + 1], d3, h3) > o2))
                  d3.applyMatrix4(this.matrixWorld), (M3 = r3.ray.origin.distanceTo(d3)) < r3.near || M3 > r3.far || i3.push({ distance: M3, point: h3.clone().applyMatrix4(this.matrixWorld), index: v3, face: null, faceIndex: null, object: this });
              }
            }
          }
        };
      }(), clone: function() {
        return new this.constructor(this.geometry, this.material).copy(this);
      } }), bi2.prototype = Object.assign(Object.create(xi2.prototype), { constructor: bi2, isLineSegments: true, computeLineDistances: function() {
        var e3 = new Ht(), t3 = new Ht();
        return function() {
          var n3 = this.geometry;
          if (n3.isBufferGeometry)
            if (null === n3.index) {
              for (var r3 = n3.attributes.position, i3 = [], a2 = 0, o2 = r3.count; a2 < o2; a2 += 2)
                e3.fromBufferAttribute(r3, a2), t3.fromBufferAttribute(r3, a2 + 1), i3[a2] = 0 === a2 ? 0 : i3[a2 - 1], i3[a2 + 1] = i3[a2] + e3.distanceTo(t3);
              n3.addAttribute("lineDistance", new Sn(i3, 1));
            } else
              console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          else if (n3.isGeometry) {
            var s2 = n3.vertices;
            for (i3 = n3.lineDistances, a2 = 0, o2 = s2.length; a2 < o2; a2 += 2)
              e3.copy(s2[a2]), t3.copy(s2[a2 + 1]), i3[a2] = 0 === a2 ? 0 : i3[a2 - 1], i3[a2 + 1] = i3[a2] + e3.distanceTo(t3);
          }
          return this;
        };
      }() }), wi2.prototype = Object.assign(Object.create(xi2.prototype), { constructor: wi2, isLineLoop: true }), _i.prototype = Object.create(Bn.prototype), _i.prototype.constructor = _i, _i.prototype.isPointsMaterial = true, _i.prototype.copy = function(e3) {
        return Bn.prototype.copy.call(this, e3), this.color.copy(e3.color), this.map = e3.map, this.size = e3.size, this.sizeAttenuation = e3.sizeAttenuation, this.morphTargets = e3.morphTargets, this;
      }, Mi2.prototype = Object.assign(Object.create(dn.prototype), { constructor: Mi2, isPoints: true, raycast: function() {
        var e3 = new Gt(), t3 = new zn(), n3 = new Kt();
        return function(r3, i3) {
          var a2 = this, o2 = this.geometry, s2 = this.matrixWorld, c3 = r3.params.Points.threshold;
          if (null === o2.boundingSphere && o2.computeBoundingSphere(), n3.copy(o2.boundingSphere), n3.applyMatrix4(s2), n3.radius += c3, false !== r3.ray.intersectsSphere(n3)) {
            e3.getInverse(s2), t3.copy(r3.ray).applyMatrix4(e3);
            var u3 = c3 / ((this.scale.x + this.scale.y + this.scale.z) / 3), l3 = u3 * u3, h3 = new Ht(), d3 = new Ht();
            if (o2.isBufferGeometry) {
              var p3 = o2.index, f3 = o2.attributes.position.array;
              if (null !== p3)
                for (var m3 = p3.array, g3 = 0, v3 = m3.length; g3 < v3; g3++) {
                  var y3 = m3[g3];
                  h3.fromArray(f3, 3 * y3), w3(h3, y3);
                }
              else {
                g3 = 0;
                for (var x3 = f3.length / 3; g3 < x3; g3++)
                  h3.fromArray(f3, 3 * g3), w3(h3, g3);
              }
            } else {
              var b3 = o2.vertices;
              for (g3 = 0, x3 = b3.length; g3 < x3; g3++)
                w3(b3[g3], g3);
            }
          }
          function w3(e4, n4) {
            var o3 = t3.distanceSqToPoint(e4);
            if (o3 < l3) {
              t3.closestPointToPoint(e4, d3), d3.applyMatrix4(s2);
              var c4 = r3.ray.origin.distanceTo(d3);
              if (c4 < r3.near || c4 > r3.far)
                return;
              i3.push({ distance: c4, distanceToRay: Math.sqrt(o3), point: d3.clone(), index: n4, face: null, object: a2 });
            }
          }
        };
      }(), clone: function() {
        return new this.constructor(this.geometry, this.material).copy(this);
      } }), Ei2.prototype = Object.assign(Object.create(Wt.prototype), { constructor: Ei2, isVideoTexture: true, update: function() {
        var e3 = this.image;
        e3.readyState >= e3.HAVE_CURRENT_DATA && (this.needsUpdate = true);
      } }), Ti2.prototype = Object.create(Wt.prototype), Ti2.prototype.constructor = Ti2, Ti2.prototype.isCompressedTexture = true, Si2.prototype = Object.create(Wt.prototype), Si2.prototype.constructor = Si2, Si2.prototype.isCanvasTexture = true, Ai2.prototype = Object.create(Wt.prototype), Ai2.prototype.constructor = Ai2, Ai2.prototype.isDepthTexture = true, Li2.prototype = Object.create(Pn.prototype), Li2.prototype.constructor = Li2, Ri2.prototype = Object.create(vn.prototype), Ri2.prototype.constructor = Ri2, Ci2.prototype = Object.create(Pn.prototype), Ci2.prototype.constructor = Ci2, Pi2.prototype = Object.create(vn.prototype), Pi2.prototype.constructor = Pi2, Oi2.prototype = Object.create(Pn.prototype), Oi2.prototype.constructor = Oi2, Ni2.prototype = Object.create(vn.prototype), Ni2.prototype.constructor = Ni2, Ii2.prototype = Object.create(Oi2.prototype), Ii2.prototype.constructor = Ii2, Di2.prototype = Object.create(vn.prototype), Di2.prototype.constructor = Di2, Ui2.prototype = Object.create(Oi2.prototype), Ui2.prototype.constructor = Ui2, Bi2.prototype = Object.create(vn.prototype), Bi2.prototype.constructor = Bi2, Fi2.prototype = Object.create(Oi2.prototype), Fi2.prototype.constructor = Fi2, Gi2.prototype = Object.create(vn.prototype), Gi2.prototype.constructor = Gi2, zi2.prototype = Object.create(Oi2.prototype), zi2.prototype.constructor = zi2, Hi2.prototype = Object.create(vn.prototype), Hi2.prototype.constructor = Hi2, ki2.prototype = Object.create(Pn.prototype), ki2.prototype.constructor = ki2, ji2.prototype = Object.create(vn.prototype), ji2.prototype.constructor = ji2, Vi2.prototype = Object.create(Pn.prototype), Vi2.prototype.constructor = Vi2, Wi2.prototype = Object.create(vn.prototype), Wi2.prototype.constructor = Wi2, Xi2.prototype = Object.create(Pn.prototype), Xi2.prototype.constructor = Xi2;
      var qi2 = function(e3, t3, n3) {
        n3 = n3 || 2;
        var r3, i3, a2, o2, s2, c3, u3, l3 = t3 && t3.length, h3 = l3 ? t3[0] * n3 : e3.length, d3 = Yi2(e3, 0, h3, n3, true), p3 = [];
        if (!d3)
          return p3;
        if (l3 && (d3 = function(e4, t4, n4, r4) {
          var i4, a3, o3, s3, c4, u4 = [];
          for (i4 = 0, a3 = t4.length; i4 < a3; i4++)
            o3 = t4[i4] * r4, s3 = i4 < a3 - 1 ? t4[i4 + 1] * r4 : e4.length, (c4 = Yi2(e4, o3, s3, r4, false)) === c4.next && (c4.steiner = true), u4.push(ia2(c4));
          for (u4.sort(ta2), i4 = 0; i4 < u4.length; i4++)
            na(u4[i4], n4), n4 = Zi2(n4, n4.next);
          return n4;
        }(e3, t3, d3, n3)), e3.length > 80 * n3) {
          r3 = a2 = e3[0], i3 = o2 = e3[1];
          for (var f3 = n3; f3 < h3; f3 += n3)
            s2 = e3[f3], c3 = e3[f3 + 1], s2 < r3 && (r3 = s2), c3 < i3 && (i3 = c3), s2 > a2 && (a2 = s2), c3 > o2 && (o2 = c3);
          u3 = 0 !== (u3 = Math.max(a2 - r3, o2 - i3)) ? 1 / u3 : 0;
        }
        return Ji2(d3, p3, n3, r3, i3, u3), p3;
      };
      function Yi2(e3, t3, n3, r3, i3) {
        var a2, o2;
        if (i3 === function(e4, t4, n4, r4) {
          for (var i4 = 0, a3 = t4, o3 = n4 - r4; a3 < n4; a3 += r4)
            i4 += (e4[o3] - e4[a3]) * (e4[a3 + 1] + e4[o3 + 1]), o3 = a3;
          return i4;
        }(e3, t3, n3, r3) > 0)
          for (a2 = t3; a2 < n3; a2 += r3)
            o2 = da2(a2, e3[a2], e3[a2 + 1], o2);
        else
          for (a2 = n3 - r3; a2 >= t3; a2 -= r3)
            o2 = da2(a2, e3[a2], e3[a2 + 1], o2);
        return o2 && ca2(o2, o2.next) && (pa2(o2), o2 = o2.next), o2;
      }
      function Zi2(e3, t3) {
        if (!e3)
          return e3;
        t3 || (t3 = e3);
        var n3, r3 = e3;
        do {
          if (n3 = false, r3.steiner || !ca2(r3, r3.next) && 0 !== sa2(r3.prev, r3, r3.next))
            r3 = r3.next;
          else {
            if (pa2(r3), (r3 = t3 = r3.prev) === r3.next)
              break;
            n3 = true;
          }
        } while (n3 || r3 !== t3);
        return t3;
      }
      function Ji2(e3, t3, n3, r3, i3, a2, o2) {
        if (e3) {
          !o2 && a2 && function(e4, t4, n4, r4) {
            var i4 = e4;
            do {
              null === i4.z && (i4.z = ra2(i4.x, i4.y, t4, n4, r4)), i4.prevZ = i4.prev, i4.nextZ = i4.next, i4 = i4.next;
            } while (i4 !== e4);
            i4.prevZ.nextZ = null, i4.prevZ = null, function(e5) {
              var t5, n5, r5, i5, a3, o3, s3, c4, u4 = 1;
              do {
                for (n5 = e5, e5 = null, a3 = null, o3 = 0; n5; ) {
                  for (o3++, r5 = n5, s3 = 0, t5 = 0; t5 < u4 && (s3++, r5 = r5.nextZ); t5++)
                    ;
                  for (c4 = u4; s3 > 0 || c4 > 0 && r5; )
                    0 !== s3 && (0 === c4 || !r5 || n5.z <= r5.z) ? (i5 = n5, n5 = n5.nextZ, s3--) : (i5 = r5, r5 = r5.nextZ, c4--), a3 ? a3.nextZ = i5 : e5 = i5, i5.prevZ = a3, a3 = i5;
                  n5 = r5;
                }
                a3.nextZ = null, u4 *= 2;
              } while (o3 > 1);
            }(i4);
          }(e3, r3, i3, a2);
          for (var s2, c3, u3 = e3; e3.prev !== e3.next; )
            if (s2 = e3.prev, c3 = e3.next, a2 ? Qi2(e3, r3, i3, a2) : Ki2(e3))
              t3.push(s2.i / n3), t3.push(e3.i / n3), t3.push(c3.i / n3), pa2(e3), e3 = c3.next, u3 = c3.next;
            else if ((e3 = c3) === u3) {
              o2 ? 1 === o2 ? Ji2(e3 = $i2(e3, t3, n3), t3, n3, r3, i3, a2, 2) : 2 === o2 && ea2(e3, t3, n3, r3, i3, a2) : Ji2(Zi2(e3), t3, n3, r3, i3, a2, 1);
              break;
            }
        }
      }
      function Ki2(e3) {
        var t3 = e3.prev, n3 = e3, r3 = e3.next;
        if (sa2(t3, n3, r3) >= 0)
          return false;
        for (var i3 = e3.next.next; i3 !== e3.prev; ) {
          if (aa2(t3.x, t3.y, n3.x, n3.y, r3.x, r3.y, i3.x, i3.y) && sa2(i3.prev, i3, i3.next) >= 0)
            return false;
          i3 = i3.next;
        }
        return true;
      }
      function Qi2(e3, t3, n3, r3) {
        var i3 = e3.prev, a2 = e3, o2 = e3.next;
        if (sa2(i3, a2, o2) >= 0)
          return false;
        for (var s2 = i3.x < a2.x ? i3.x < o2.x ? i3.x : o2.x : a2.x < o2.x ? a2.x : o2.x, c3 = i3.y < a2.y ? i3.y < o2.y ? i3.y : o2.y : a2.y < o2.y ? a2.y : o2.y, u3 = i3.x > a2.x ? i3.x > o2.x ? i3.x : o2.x : a2.x > o2.x ? a2.x : o2.x, l3 = i3.y > a2.y ? i3.y > o2.y ? i3.y : o2.y : a2.y > o2.y ? a2.y : o2.y, h3 = ra2(s2, c3, t3, n3, r3), d3 = ra2(u3, l3, t3, n3, r3), p3 = e3.nextZ; p3 && p3.z <= d3; ) {
          if (p3 !== e3.prev && p3 !== e3.next && aa2(i3.x, i3.y, a2.x, a2.y, o2.x, o2.y, p3.x, p3.y) && sa2(p3.prev, p3, p3.next) >= 0)
            return false;
          p3 = p3.nextZ;
        }
        for (p3 = e3.prevZ; p3 && p3.z >= h3; ) {
          if (p3 !== e3.prev && p3 !== e3.next && aa2(i3.x, i3.y, a2.x, a2.y, o2.x, o2.y, p3.x, p3.y) && sa2(p3.prev, p3, p3.next) >= 0)
            return false;
          p3 = p3.prevZ;
        }
        return true;
      }
      function $i2(e3, t3, n3) {
        var r3 = e3;
        do {
          var i3 = r3.prev, a2 = r3.next.next;
          !ca2(i3, a2) && ua2(i3, r3, r3.next, a2) && la2(i3, a2) && la2(a2, i3) && (t3.push(i3.i / n3), t3.push(r3.i / n3), t3.push(a2.i / n3), pa2(r3), pa2(r3.next), r3 = e3 = a2), r3 = r3.next;
        } while (r3 !== e3);
        return r3;
      }
      function ea2(e3, t3, n3, r3, i3, a2) {
        var o2 = e3;
        do {
          for (var s2 = o2.next.next; s2 !== o2.prev; ) {
            if (o2.i !== s2.i && oa2(o2, s2)) {
              var c3 = ha2(o2, s2);
              return o2 = Zi2(o2, o2.next), c3 = Zi2(c3, c3.next), Ji2(o2, t3, n3, r3, i3, a2), void Ji2(c3, t3, n3, r3, i3, a2);
            }
            s2 = s2.next;
          }
          o2 = o2.next;
        } while (o2 !== e3);
      }
      function ta2(e3, t3) {
        return e3.x - t3.x;
      }
      function na(e3, t3) {
        if (t3 = function(e4, t4) {
          var n4, r3 = t4, i3 = e4.x, a2 = e4.y, o2 = -1 / 0;
          do {
            if (a2 <= r3.y && a2 >= r3.next.y && r3.next.y !== r3.y) {
              var s2 = r3.x + (a2 - r3.y) * (r3.next.x - r3.x) / (r3.next.y - r3.y);
              if (s2 <= i3 && s2 > o2) {
                if (o2 = s2, s2 === i3) {
                  if (a2 === r3.y)
                    return r3;
                  if (a2 === r3.next.y)
                    return r3.next;
                }
                n4 = r3.x < r3.next.x ? r3 : r3.next;
              }
            }
            r3 = r3.next;
          } while (r3 !== t4);
          if (!n4)
            return null;
          if (i3 === o2)
            return n4.prev;
          var c3, u3 = n4, l3 = n4.x, h3 = n4.y, d3 = 1 / 0;
          r3 = n4.next;
          for (; r3 !== u3; )
            i3 >= r3.x && r3.x >= l3 && i3 !== r3.x && aa2(a2 < h3 ? i3 : o2, a2, l3, h3, a2 < h3 ? o2 : i3, a2, r3.x, r3.y) && ((c3 = Math.abs(a2 - r3.y) / (i3 - r3.x)) < d3 || c3 === d3 && r3.x > n4.x) && la2(r3, e4) && (n4 = r3, d3 = c3), r3 = r3.next;
          return n4;
        }(e3, t3)) {
          var n3 = ha2(t3, e3);
          Zi2(n3, n3.next);
        }
      }
      function ra2(e3, t3, n3, r3, i3) {
        return (e3 = 1431655765 & ((e3 = 858993459 & ((e3 = 252645135 & ((e3 = 16711935 & ((e3 = 32767 * (e3 - n3) * i3) | e3 << 8)) | e3 << 4)) | e3 << 2)) | e3 << 1)) | (t3 = 1431655765 & ((t3 = 858993459 & ((t3 = 252645135 & ((t3 = 16711935 & ((t3 = 32767 * (t3 - r3) * i3) | t3 << 8)) | t3 << 4)) | t3 << 2)) | t3 << 1)) << 1;
      }
      function ia2(e3) {
        var t3 = e3, n3 = e3;
        do {
          t3.x < n3.x && (n3 = t3), t3 = t3.next;
        } while (t3 !== e3);
        return n3;
      }
      function aa2(e3, t3, n3, r3, i3, a2, o2, s2) {
        return (i3 - o2) * (t3 - s2) - (e3 - o2) * (a2 - s2) >= 0 && (e3 - o2) * (r3 - s2) - (n3 - o2) * (t3 - s2) >= 0 && (n3 - o2) * (a2 - s2) - (i3 - o2) * (r3 - s2) >= 0;
      }
      function oa2(e3, t3) {
        return e3.next.i !== t3.i && e3.prev.i !== t3.i && !function(e4, t4) {
          var n3 = e4;
          do {
            if (n3.i !== e4.i && n3.next.i !== e4.i && n3.i !== t4.i && n3.next.i !== t4.i && ua2(n3, n3.next, e4, t4))
              return true;
            n3 = n3.next;
          } while (n3 !== e4);
          return false;
        }(e3, t3) && la2(e3, t3) && la2(t3, e3) && function(e4, t4) {
          var n3 = e4, r3 = false, i3 = (e4.x + t4.x) / 2, a2 = (e4.y + t4.y) / 2;
          do {
            n3.y > a2 != n3.next.y > a2 && n3.next.y !== n3.y && i3 < (n3.next.x - n3.x) * (a2 - n3.y) / (n3.next.y - n3.y) + n3.x && (r3 = !r3), n3 = n3.next;
          } while (n3 !== e4);
          return r3;
        }(e3, t3);
      }
      function sa2(e3, t3, n3) {
        return (t3.y - e3.y) * (n3.x - t3.x) - (t3.x - e3.x) * (n3.y - t3.y);
      }
      function ca2(e3, t3) {
        return e3.x === t3.x && e3.y === t3.y;
      }
      function ua2(e3, t3, n3, r3) {
        return !!(ca2(e3, t3) && ca2(n3, r3) || ca2(e3, r3) && ca2(n3, t3)) || sa2(e3, t3, n3) > 0 != sa2(e3, t3, r3) > 0 && sa2(n3, r3, e3) > 0 != sa2(n3, r3, t3) > 0;
      }
      function la2(e3, t3) {
        return sa2(e3.prev, e3, e3.next) < 0 ? sa2(e3, t3, e3.next) >= 0 && sa2(e3, e3.prev, t3) >= 0 : sa2(e3, t3, e3.prev) < 0 || sa2(e3, e3.next, t3) < 0;
      }
      function ha2(e3, t3) {
        var n3 = new fa2(e3.i, e3.x, e3.y), r3 = new fa2(t3.i, t3.x, t3.y), i3 = e3.next, a2 = t3.prev;
        return e3.next = t3, t3.prev = e3, n3.next = i3, i3.prev = n3, r3.next = n3, n3.prev = r3, a2.next = r3, r3.prev = a2, r3;
      }
      function da2(e3, t3, n3, r3) {
        var i3 = new fa2(e3, t3, n3);
        return r3 ? (i3.next = r3.next, i3.prev = r3, r3.next.prev = i3, r3.next = i3) : (i3.prev = i3, i3.next = i3), i3;
      }
      function pa2(e3) {
        e3.next.prev = e3.prev, e3.prev.next = e3.next, e3.prevZ && (e3.prevZ.nextZ = e3.nextZ), e3.nextZ && (e3.nextZ.prevZ = e3.prevZ);
      }
      function fa2(e3, t3, n3) {
        this.i = e3, this.x = t3, this.y = n3, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
      }
      var ma2 = { area: function(e3) {
        for (var t3 = e3.length, n3 = 0, r3 = t3 - 1, i3 = 0; i3 < t3; r3 = i3++)
          n3 += e3[r3].x * e3[i3].y - e3[i3].x * e3[r3].y;
        return 0.5 * n3;
      }, isClockWise: function(e3) {
        return ma2.area(e3) < 0;
      }, triangulateShape: function(e3, t3) {
        var n3 = [], r3 = [], i3 = [];
        ga(e3), va2(n3, e3);
        var a2 = e3.length;
        t3.forEach(ga);
        for (var o2 = 0; o2 < t3.length; o2++)
          r3.push(a2), a2 += t3[o2].length, va2(n3, t3[o2]);
        var s2 = qi2(n3, r3);
        for (o2 = 0; o2 < s2.length; o2 += 3)
          i3.push(s2.slice(o2, o2 + 3));
        return i3;
      } };
      function ga(e3) {
        var t3 = e3.length;
        t3 > 2 && e3[t3 - 1].equals(e3[0]) && e3.pop();
      }
      function va2(e3, t3) {
        for (var n3 = 0; n3 < t3.length; n3++)
          e3.push(t3[n3].x), e3.push(t3[n3].y);
      }
      function ya2(e3, t3) {
        vn.call(this), this.type = "ExtrudeGeometry", this.parameters = { shapes: e3, options: t3 }, this.fromBufferGeometry(new xa(e3, t3)), this.mergeVertices();
      }
      function xa(e3, t3) {
        Pn.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = { shapes: e3, options: t3 };
        for (var n3 = this, r3 = [], i3 = [], a2 = 0, o2 = (e3 = Array.isArray(e3) ? e3 : [e3]).length; a2 < o2; a2++) {
          s2(e3[a2]);
        }
        function s2(e4) {
          var a3 = [], o3 = void 0 !== t3.curveSegments ? t3.curveSegments : 12, s3 = void 0 !== t3.steps ? t3.steps : 1, c3 = void 0 !== t3.depth ? t3.depth : 100, u3 = void 0 === t3.bevelEnabled || t3.bevelEnabled, l3 = void 0 !== t3.bevelThickness ? t3.bevelThickness : 6, h3 = void 0 !== t3.bevelSize ? t3.bevelSize : l3 - 2, d3 = void 0 !== t3.bevelSegments ? t3.bevelSegments : 3, p3 = t3.extrudePath, f3 = void 0 !== t3.UVGenerator ? t3.UVGenerator : ba;
          void 0 !== t3.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), c3 = t3.amount);
          var m3, g3, v3, y3, x3, b3, w3, _3, M3 = false;
          p3 && (m3 = p3.getSpacedPoints(s3), M3 = true, u3 = false, g3 = p3.computeFrenetFrames(s3, false), v3 = new Ht(), y3 = new Ht(), x3 = new Ht()), u3 || (d3 = 0, l3 = 0, h3 = 0);
          var E3 = e4.extractPoints(o3), T3 = E3.shape, S3 = E3.holes;
          if (!ma2.isClockWise(T3))
            for (T3 = T3.reverse(), w3 = 0, _3 = S3.length; w3 < _3; w3++)
              b3 = S3[w3], ma2.isClockWise(b3) && (S3[w3] = b3.reverse());
          var A3 = ma2.triangulateShape(T3, S3), L3 = T3;
          for (w3 = 0, _3 = S3.length; w3 < _3; w3++)
            b3 = S3[w3], T3 = T3.concat(b3);
          function R3(e5, t4, n4) {
            return t4 || console.error("THREE.ExtrudeGeometry: vec does not exist"), t4.clone().multiplyScalar(n4).add(e5);
          }
          var C3, P3, O3, N3, I3, D3, U3 = T3.length, B3 = A3.length;
          function F3(e5, t4, n4) {
            var r4, i4, a4, o4 = e5.x - t4.x, s4 = e5.y - t4.y, c4 = n4.x - e5.x, u4 = n4.y - e5.y, l4 = o4 * o4 + s4 * s4, h4 = o4 * u4 - s4 * c4;
            if (Math.abs(h4) > Number.EPSILON) {
              var d4 = Math.sqrt(l4), p4 = Math.sqrt(c4 * c4 + u4 * u4), f4 = t4.x - s4 / d4, m4 = t4.y + o4 / d4, g4 = ((n4.x - u4 / p4 - f4) * u4 - (n4.y + c4 / p4 - m4) * c4) / (o4 * u4 - s4 * c4), v4 = (r4 = f4 + o4 * g4 - e5.x) * r4 + (i4 = m4 + s4 * g4 - e5.y) * i4;
              if (v4 <= 2)
                return new Ft(r4, i4);
              a4 = Math.sqrt(v4 / 2);
            } else {
              var y4 = false;
              o4 > Number.EPSILON ? c4 > Number.EPSILON && (y4 = true) : o4 < -Number.EPSILON ? c4 < -Number.EPSILON && (y4 = true) : Math.sign(s4) === Math.sign(u4) && (y4 = true), y4 ? (r4 = -s4, i4 = o4, a4 = Math.sqrt(l4)) : (r4 = o4, i4 = s4, a4 = Math.sqrt(l4 / 2));
            }
            return new Ft(r4 / a4, i4 / a4);
          }
          for (var G3 = [], z3 = 0, H3 = L3.length, k3 = H3 - 1, j2 = z3 + 1; z3 < H3; z3++, k3++, j2++)
            k3 === H3 && (k3 = 0), j2 === H3 && (j2 = 0), G3[z3] = F3(L3[z3], L3[k3], L3[j2]);
          var V3, W3, X3 = [], q3 = G3.concat();
          for (w3 = 0, _3 = S3.length; w3 < _3; w3++) {
            for (b3 = S3[w3], V3 = [], z3 = 0, k3 = (H3 = b3.length) - 1, j2 = z3 + 1; z3 < H3; z3++, k3++, j2++)
              k3 === H3 && (k3 = 0), j2 === H3 && (j2 = 0), V3[z3] = F3(b3[z3], b3[k3], b3[j2]);
            X3.push(V3), q3 = q3.concat(V3);
          }
          for (C3 = 0; C3 < d3; C3++) {
            for (O3 = C3 / d3, N3 = l3 * Math.cos(O3 * Math.PI / 2), P3 = h3 * Math.sin(O3 * Math.PI / 2), z3 = 0, H3 = L3.length; z3 < H3; z3++)
              Z3((I3 = R3(L3[z3], G3[z3], P3)).x, I3.y, -N3);
            for (w3 = 0, _3 = S3.length; w3 < _3; w3++)
              for (b3 = S3[w3], V3 = X3[w3], z3 = 0, H3 = b3.length; z3 < H3; z3++)
                Z3((I3 = R3(b3[z3], V3[z3], P3)).x, I3.y, -N3);
          }
          for (P3 = h3, z3 = 0; z3 < U3; z3++)
            I3 = u3 ? R3(T3[z3], q3[z3], P3) : T3[z3], M3 ? (y3.copy(g3.normals[0]).multiplyScalar(I3.x), v3.copy(g3.binormals[0]).multiplyScalar(I3.y), x3.copy(m3[0]).add(y3).add(v3), Z3(x3.x, x3.y, x3.z)) : Z3(I3.x, I3.y, 0);
          for (W3 = 1; W3 <= s3; W3++)
            for (z3 = 0; z3 < U3; z3++)
              I3 = u3 ? R3(T3[z3], q3[z3], P3) : T3[z3], M3 ? (y3.copy(g3.normals[W3]).multiplyScalar(I3.x), v3.copy(g3.binormals[W3]).multiplyScalar(I3.y), x3.copy(m3[W3]).add(y3).add(v3), Z3(x3.x, x3.y, x3.z)) : Z3(I3.x, I3.y, c3 / s3 * W3);
          for (C3 = d3 - 1; C3 >= 0; C3--) {
            for (O3 = C3 / d3, N3 = l3 * Math.cos(O3 * Math.PI / 2), P3 = h3 * Math.sin(O3 * Math.PI / 2), z3 = 0, H3 = L3.length; z3 < H3; z3++)
              Z3((I3 = R3(L3[z3], G3[z3], P3)).x, I3.y, c3 + N3);
            for (w3 = 0, _3 = S3.length; w3 < _3; w3++)
              for (b3 = S3[w3], V3 = X3[w3], z3 = 0, H3 = b3.length; z3 < H3; z3++)
                I3 = R3(b3[z3], V3[z3], P3), M3 ? Z3(I3.x, I3.y + m3[s3 - 1].y, m3[s3 - 1].x + N3) : Z3(I3.x, I3.y, c3 + N3);
          }
          function Y3(e5, t4) {
            var n4, r4;
            for (z3 = e5.length; --z3 >= 0; ) {
              n4 = z3, (r4 = z3 - 1) < 0 && (r4 = e5.length - 1);
              var i4 = 0, a4 = s3 + 2 * d3;
              for (i4 = 0; i4 < a4; i4++) {
                var o4 = U3 * i4, c4 = U3 * (i4 + 1);
                K3(t4 + n4 + o4, t4 + r4 + o4, t4 + r4 + c4, t4 + n4 + c4);
              }
            }
          }
          function Z3(e5, t4, n4) {
            a3.push(e5), a3.push(t4), a3.push(n4);
          }
          function J3(e5, t4, i4) {
            Q3(e5), Q3(t4), Q3(i4);
            var a4 = r3.length / 3, o4 = f3.generateTopUV(n3, r3, a4 - 3, a4 - 2, a4 - 1);
            $2(o4[0]), $2(o4[1]), $2(o4[2]);
          }
          function K3(e5, t4, i4, a4) {
            Q3(e5), Q3(t4), Q3(a4), Q3(t4), Q3(i4), Q3(a4);
            var o4 = r3.length / 3, s4 = f3.generateSideWallUV(n3, r3, o4 - 6, o4 - 3, o4 - 2, o4 - 1);
            $2(s4[0]), $2(s4[1]), $2(s4[3]), $2(s4[1]), $2(s4[2]), $2(s4[3]);
          }
          function Q3(e5) {
            r3.push(a3[3 * e5 + 0]), r3.push(a3[3 * e5 + 1]), r3.push(a3[3 * e5 + 2]);
          }
          function $2(e5) {
            i3.push(e5.x), i3.push(e5.y);
          }
          !function() {
            var e5 = r3.length / 3;
            if (u3) {
              var t4 = 0, i4 = U3 * t4;
              for (z3 = 0; z3 < B3; z3++)
                J3((D3 = A3[z3])[2] + i4, D3[1] + i4, D3[0] + i4);
              for (i4 = U3 * (t4 = s3 + 2 * d3), z3 = 0; z3 < B3; z3++)
                J3((D3 = A3[z3])[0] + i4, D3[1] + i4, D3[2] + i4);
            } else {
              for (z3 = 0; z3 < B3; z3++)
                J3((D3 = A3[z3])[2], D3[1], D3[0]);
              for (z3 = 0; z3 < B3; z3++)
                J3((D3 = A3[z3])[0] + U3 * s3, D3[1] + U3 * s3, D3[2] + U3 * s3);
            }
            n3.addGroup(e5, r3.length / 3 - e5, 0);
          }(), function() {
            var e5 = r3.length / 3, t4 = 0;
            for (Y3(L3, t4), t4 += L3.length, w3 = 0, _3 = S3.length; w3 < _3; w3++)
              Y3(b3 = S3[w3], t4), t4 += b3.length;
            n3.addGroup(e5, r3.length / 3 - e5, 1);
          }();
        }
        this.addAttribute("position", new Sn(r3, 3)), this.addAttribute("uv", new Sn(i3, 2)), this.computeVertexNormals();
      }
      ya2.prototype = Object.create(vn.prototype), ya2.prototype.constructor = ya2, ya2.prototype.toJSON = function() {
        var e3 = vn.prototype.toJSON.call(this);
        return wa2(this.parameters.shapes, this.parameters.options, e3);
      }, xa.prototype = Object.create(Pn.prototype), xa.prototype.constructor = xa, xa.prototype.toJSON = function() {
        var e3 = Pn.prototype.toJSON.call(this);
        return wa2(this.parameters.shapes, this.parameters.options, e3);
      };
      var ba = { generateTopUV: function(e3, t3, n3, r3, i3) {
        var a2 = t3[3 * n3], o2 = t3[3 * n3 + 1], s2 = t3[3 * r3], c3 = t3[3 * r3 + 1], u3 = t3[3 * i3], l3 = t3[3 * i3 + 1];
        return [new Ft(a2, o2), new Ft(s2, c3), new Ft(u3, l3)];
      }, generateSideWallUV: function(e3, t3, n3, r3, i3, a2) {
        var o2 = t3[3 * n3], s2 = t3[3 * n3 + 1], c3 = t3[3 * n3 + 2], u3 = t3[3 * r3], l3 = t3[3 * r3 + 1], h3 = t3[3 * r3 + 2], d3 = t3[3 * i3], p3 = t3[3 * i3 + 1], f3 = t3[3 * i3 + 2], m3 = t3[3 * a2], g3 = t3[3 * a2 + 1], v3 = t3[3 * a2 + 2];
        return Math.abs(s2 - l3) < 0.01 ? [new Ft(o2, 1 - c3), new Ft(u3, 1 - h3), new Ft(d3, 1 - f3), new Ft(m3, 1 - v3)] : [new Ft(s2, 1 - c3), new Ft(l3, 1 - h3), new Ft(p3, 1 - f3), new Ft(g3, 1 - v3)];
      } };
      function wa2(e3, t3, n3) {
        if (n3.shapes = [], Array.isArray(e3))
          for (var r3 = 0, i3 = e3.length; r3 < i3; r3++) {
            var a2 = e3[r3];
            n3.shapes.push(a2.uuid);
          }
        else
          n3.shapes.push(e3.uuid);
        return void 0 !== t3.extrudePath && (n3.options.extrudePath = t3.extrudePath.toJSON()), n3;
      }
      function _a(e3, t3) {
        vn.call(this), this.type = "TextGeometry", this.parameters = { text: e3, parameters: t3 }, this.fromBufferGeometry(new Ma2(e3, t3)), this.mergeVertices();
      }
      function Ma2(e3, t3) {
        var n3 = (t3 = t3 || {}).font;
        if (!n3 || !n3.isFont)
          return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new vn();
        var r3 = n3.generateShapes(e3, t3.size);
        t3.depth = void 0 !== t3.height ? t3.height : 50, void 0 === t3.bevelThickness && (t3.bevelThickness = 10), void 0 === t3.bevelSize && (t3.bevelSize = 8), void 0 === t3.bevelEnabled && (t3.bevelEnabled = false), xa.call(this, r3, t3), this.type = "TextBufferGeometry";
      }
      function Ea2(e3, t3, n3, r3, i3, a2, o2) {
        vn.call(this), this.type = "SphereGeometry", this.parameters = { radius: e3, widthSegments: t3, heightSegments: n3, phiStart: r3, phiLength: i3, thetaStart: a2, thetaLength: o2 }, this.fromBufferGeometry(new Ta2(e3, t3, n3, r3, i3, a2, o2)), this.mergeVertices();
      }
      function Ta2(e3, t3, n3, r3, i3, a2, o2) {
        Pn.call(this), this.type = "SphereBufferGeometry", this.parameters = { radius: e3, widthSegments: t3, heightSegments: n3, phiStart: r3, phiLength: i3, thetaStart: a2, thetaLength: o2 }, e3 = e3 || 1, t3 = Math.max(3, Math.floor(t3) || 8), n3 = Math.max(2, Math.floor(n3) || 6), r3 = void 0 !== r3 ? r3 : 0, i3 = void 0 !== i3 ? i3 : 2 * Math.PI;
        var s2, c3, u3 = (a2 = void 0 !== a2 ? a2 : 0) + (o2 = void 0 !== o2 ? o2 : Math.PI), l3 = 0, h3 = [], d3 = new Ht(), p3 = new Ht(), f3 = [], m3 = [], g3 = [], v3 = [];
        for (c3 = 0; c3 <= n3; c3++) {
          var y3 = [], x3 = c3 / n3;
          for (s2 = 0; s2 <= t3; s2++) {
            var b3 = s2 / t3;
            d3.x = -e3 * Math.cos(r3 + b3 * i3) * Math.sin(a2 + x3 * o2), d3.y = e3 * Math.cos(a2 + x3 * o2), d3.z = e3 * Math.sin(r3 + b3 * i3) * Math.sin(a2 + x3 * o2), m3.push(d3.x, d3.y, d3.z), p3.set(d3.x, d3.y, d3.z).normalize(), g3.push(p3.x, p3.y, p3.z), v3.push(b3, 1 - x3), y3.push(l3++);
          }
          h3.push(y3);
        }
        for (c3 = 0; c3 < n3; c3++)
          for (s2 = 0; s2 < t3; s2++) {
            var w3 = h3[c3][s2 + 1], _3 = h3[c3][s2], M3 = h3[c3 + 1][s2], E3 = h3[c3 + 1][s2 + 1];
            (0 !== c3 || a2 > 0) && f3.push(w3, _3, E3), (c3 !== n3 - 1 || u3 < Math.PI) && f3.push(_3, M3, E3);
          }
        this.setIndex(f3), this.addAttribute("position", new Sn(m3, 3)), this.addAttribute("normal", new Sn(g3, 3)), this.addAttribute("uv", new Sn(v3, 2));
      }
      function Sa2(e3, t3, n3, r3, i3, a2) {
        vn.call(this), this.type = "RingGeometry", this.parameters = { innerRadius: e3, outerRadius: t3, thetaSegments: n3, phiSegments: r3, thetaStart: i3, thetaLength: a2 }, this.fromBufferGeometry(new Aa2(e3, t3, n3, r3, i3, a2)), this.mergeVertices();
      }
      function Aa2(e3, t3, n3, r3, i3, a2) {
        Pn.call(this), this.type = "RingBufferGeometry", this.parameters = { innerRadius: e3, outerRadius: t3, thetaSegments: n3, phiSegments: r3, thetaStart: i3, thetaLength: a2 }, e3 = e3 || 0.5, t3 = t3 || 1, i3 = void 0 !== i3 ? i3 : 0, a2 = void 0 !== a2 ? a2 : 2 * Math.PI, n3 = void 0 !== n3 ? Math.max(3, n3) : 8;
        var o2, s2, c3, u3 = [], l3 = [], h3 = [], d3 = [], p3 = e3, f3 = (t3 - e3) / (r3 = void 0 !== r3 ? Math.max(1, r3) : 1), m3 = new Ht(), g3 = new Ft();
        for (s2 = 0; s2 <= r3; s2++) {
          for (c3 = 0; c3 <= n3; c3++)
            o2 = i3 + c3 / n3 * a2, m3.x = p3 * Math.cos(o2), m3.y = p3 * Math.sin(o2), l3.push(m3.x, m3.y, m3.z), h3.push(0, 0, 1), g3.x = (m3.x / t3 + 1) / 2, g3.y = (m3.y / t3 + 1) / 2, d3.push(g3.x, g3.y);
          p3 += f3;
        }
        for (s2 = 0; s2 < r3; s2++) {
          var v3 = s2 * (n3 + 1);
          for (c3 = 0; c3 < n3; c3++) {
            var y3 = o2 = c3 + v3, x3 = o2 + n3 + 1, b3 = o2 + n3 + 2, w3 = o2 + 1;
            u3.push(y3, x3, w3), u3.push(x3, b3, w3);
          }
        }
        this.setIndex(u3), this.addAttribute("position", new Sn(l3, 3)), this.addAttribute("normal", new Sn(h3, 3)), this.addAttribute("uv", new Sn(d3, 2));
      }
      function La2(e3, t3, n3, r3) {
        vn.call(this), this.type = "LatheGeometry", this.parameters = { points: e3, segments: t3, phiStart: n3, phiLength: r3 }, this.fromBufferGeometry(new Ra2(e3, t3, n3, r3)), this.mergeVertices();
      }
      function Ra2(e3, t3, n3, r3) {
        Pn.call(this), this.type = "LatheBufferGeometry", this.parameters = { points: e3, segments: t3, phiStart: n3, phiLength: r3 }, t3 = Math.floor(t3) || 12, n3 = n3 || 0, r3 = r3 || 2 * Math.PI, r3 = Bt.clamp(r3, 0, 2 * Math.PI);
        var i3, a2, o2, s2 = [], c3 = [], u3 = [], l3 = 1 / t3, h3 = new Ht(), d3 = new Ft();
        for (a2 = 0; a2 <= t3; a2++) {
          var p3 = n3 + a2 * l3 * r3, f3 = Math.sin(p3), m3 = Math.cos(p3);
          for (o2 = 0; o2 <= e3.length - 1; o2++)
            h3.x = e3[o2].x * f3, h3.y = e3[o2].y, h3.z = e3[o2].x * m3, c3.push(h3.x, h3.y, h3.z), d3.x = a2 / t3, d3.y = o2 / (e3.length - 1), u3.push(d3.x, d3.y);
        }
        for (a2 = 0; a2 < t3; a2++)
          for (o2 = 0; o2 < e3.length - 1; o2++) {
            var g3 = i3 = o2 + a2 * e3.length, v3 = i3 + e3.length, y3 = i3 + e3.length + 1, x3 = i3 + 1;
            s2.push(g3, v3, x3), s2.push(v3, y3, x3);
          }
        if (this.setIndex(s2), this.addAttribute("position", new Sn(c3, 3)), this.addAttribute("uv", new Sn(u3, 2)), this.computeVertexNormals(), r3 === 2 * Math.PI) {
          var b3 = this.attributes.normal.array, w3 = new Ht(), _3 = new Ht(), M3 = new Ht();
          for (i3 = t3 * e3.length * 3, a2 = 0, o2 = 0; a2 < e3.length; a2++, o2 += 3)
            w3.x = b3[o2 + 0], w3.y = b3[o2 + 1], w3.z = b3[o2 + 2], _3.x = b3[i3 + o2 + 0], _3.y = b3[i3 + o2 + 1], _3.z = b3[i3 + o2 + 2], M3.addVectors(w3, _3).normalize(), b3[o2 + 0] = b3[i3 + o2 + 0] = M3.x, b3[o2 + 1] = b3[i3 + o2 + 1] = M3.y, b3[o2 + 2] = b3[i3 + o2 + 2] = M3.z;
        }
      }
      function Ca2(e3, t3) {
        vn.call(this), this.type = "ShapeGeometry", "object" == typeof t3 && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), t3 = t3.curveSegments), this.parameters = { shapes: e3, curveSegments: t3 }, this.fromBufferGeometry(new Pa2(e3, t3)), this.mergeVertices();
      }
      function Pa2(e3, t3) {
        Pn.call(this), this.type = "ShapeBufferGeometry", this.parameters = { shapes: e3, curveSegments: t3 }, t3 = t3 || 12;
        var n3 = [], r3 = [], i3 = [], a2 = [], o2 = 0, s2 = 0;
        if (false === Array.isArray(e3))
          u3(e3);
        else
          for (var c3 = 0; c3 < e3.length; c3++)
            u3(e3[c3]), this.addGroup(o2, s2, c3), o2 += s2, s2 = 0;
        function u3(e4) {
          var o3, c4, u4, l3 = r3.length / 3, h3 = e4.extractPoints(t3), d3 = h3.shape, p3 = h3.holes;
          if (false === ma2.isClockWise(d3))
            for (d3 = d3.reverse(), o3 = 0, c4 = p3.length; o3 < c4; o3++)
              u4 = p3[o3], true === ma2.isClockWise(u4) && (p3[o3] = u4.reverse());
          var f3 = ma2.triangulateShape(d3, p3);
          for (o3 = 0, c4 = p3.length; o3 < c4; o3++)
            u4 = p3[o3], d3 = d3.concat(u4);
          for (o3 = 0, c4 = d3.length; o3 < c4; o3++) {
            var m3 = d3[o3];
            r3.push(m3.x, m3.y, 0), i3.push(0, 0, 1), a2.push(m3.x, m3.y);
          }
          for (o3 = 0, c4 = f3.length; o3 < c4; o3++) {
            var g3 = f3[o3], v3 = g3[0] + l3, y3 = g3[1] + l3, x3 = g3[2] + l3;
            n3.push(v3, y3, x3), s2 += 3;
          }
        }
        this.setIndex(n3), this.addAttribute("position", new Sn(r3, 3)), this.addAttribute("normal", new Sn(i3, 3)), this.addAttribute("uv", new Sn(a2, 2));
      }
      function Oa2(e3, t3) {
        if (t3.shapes = [], Array.isArray(e3))
          for (var n3 = 0, r3 = e3.length; n3 < r3; n3++) {
            var i3 = e3[n3];
            t3.shapes.push(i3.uuid);
          }
        else
          t3.shapes.push(e3.uuid);
        return t3;
      }
      function Na2(e3, t3) {
        Pn.call(this), this.type = "EdgesGeometry", this.parameters = { thresholdAngle: t3 }, t3 = void 0 !== t3 ? t3 : 1;
        var n3, r3, i3, a2, o2 = [], s2 = Math.cos(Bt.DEG2RAD * t3), c3 = [0, 0], u3 = {}, l3 = ["a", "b", "c"];
        e3.isBufferGeometry ? (a2 = new vn()).fromBufferGeometry(e3) : a2 = e3.clone(), a2.mergeVertices(), a2.computeFaceNormals();
        for (var h3 = a2.vertices, d3 = a2.faces, p3 = 0, f3 = d3.length; p3 < f3; p3++)
          for (var m3 = d3[p3], g3 = 0; g3 < 3; g3++)
            n3 = m3[l3[g3]], r3 = m3[l3[(g3 + 1) % 3]], c3[0] = Math.min(n3, r3), c3[1] = Math.max(n3, r3), void 0 === u3[i3 = c3[0] + "," + c3[1]] ? u3[i3] = { index1: c3[0], index2: c3[1], face1: p3, face2: void 0 } : u3[i3].face2 = p3;
        for (i3 in u3) {
          var v3 = u3[i3];
          if (void 0 === v3.face2 || d3[v3.face1].normal.dot(d3[v3.face2].normal) <= s2) {
            var y3 = h3[v3.index1];
            o2.push(y3.x, y3.y, y3.z), y3 = h3[v3.index2], o2.push(y3.x, y3.y, y3.z);
          }
        }
        this.addAttribute("position", new Sn(o2, 3));
      }
      function Ia2(e3, t3, n3, r3, i3, a2, o2, s2) {
        vn.call(this), this.type = "CylinderGeometry", this.parameters = { radiusTop: e3, radiusBottom: t3, height: n3, radialSegments: r3, heightSegments: i3, openEnded: a2, thetaStart: o2, thetaLength: s2 }, this.fromBufferGeometry(new Da2(e3, t3, n3, r3, i3, a2, o2, s2)), this.mergeVertices();
      }
      function Da2(e3, t3, n3, r3, i3, a2, o2, s2) {
        Pn.call(this), this.type = "CylinderBufferGeometry", this.parameters = { radiusTop: e3, radiusBottom: t3, height: n3, radialSegments: r3, heightSegments: i3, openEnded: a2, thetaStart: o2, thetaLength: s2 };
        var c3 = this;
        e3 = void 0 !== e3 ? e3 : 1, t3 = void 0 !== t3 ? t3 : 1, n3 = n3 || 1, r3 = Math.floor(r3) || 8, i3 = Math.floor(i3) || 1, a2 = void 0 !== a2 && a2, o2 = void 0 !== o2 ? o2 : 0, s2 = void 0 !== s2 ? s2 : 2 * Math.PI;
        var u3 = [], l3 = [], h3 = [], d3 = [], p3 = 0, f3 = [], m3 = n3 / 2, g3 = 0;
        function v3(n4) {
          var i4, a3, f4, v4 = new Ft(), y3 = new Ht(), x3 = 0, b3 = true === n4 ? e3 : t3, w3 = true === n4 ? 1 : -1;
          for (a3 = p3, i4 = 1; i4 <= r3; i4++)
            l3.push(0, m3 * w3, 0), h3.push(0, w3, 0), d3.push(0.5, 0.5), p3++;
          for (f4 = p3, i4 = 0; i4 <= r3; i4++) {
            var _3 = i4 / r3 * s2 + o2, M3 = Math.cos(_3), E3 = Math.sin(_3);
            y3.x = b3 * E3, y3.y = m3 * w3, y3.z = b3 * M3, l3.push(y3.x, y3.y, y3.z), h3.push(0, w3, 0), v4.x = 0.5 * M3 + 0.5, v4.y = 0.5 * E3 * w3 + 0.5, d3.push(v4.x, v4.y), p3++;
          }
          for (i4 = 0; i4 < r3; i4++) {
            var T3 = a3 + i4, S3 = f4 + i4;
            true === n4 ? u3.push(S3, S3 + 1, T3) : u3.push(S3 + 1, S3, T3), x3 += 3;
          }
          c3.addGroup(g3, x3, true === n4 ? 1 : 2), g3 += x3;
        }
        !function() {
          var a3, v4, y3 = new Ht(), x3 = new Ht(), b3 = 0, w3 = (t3 - e3) / n3;
          for (v4 = 0; v4 <= i3; v4++) {
            var _3 = [], M3 = v4 / i3, E3 = M3 * (t3 - e3) + e3;
            for (a3 = 0; a3 <= r3; a3++) {
              var T3 = a3 / r3, S3 = T3 * s2 + o2, A3 = Math.sin(S3), L3 = Math.cos(S3);
              x3.x = E3 * A3, x3.y = -M3 * n3 + m3, x3.z = E3 * L3, l3.push(x3.x, x3.y, x3.z), y3.set(A3, w3, L3).normalize(), h3.push(y3.x, y3.y, y3.z), d3.push(T3, 1 - M3), _3.push(p3++);
            }
            f3.push(_3);
          }
          for (a3 = 0; a3 < r3; a3++)
            for (v4 = 0; v4 < i3; v4++) {
              var R3 = f3[v4][a3], C3 = f3[v4 + 1][a3], P3 = f3[v4 + 1][a3 + 1], O3 = f3[v4][a3 + 1];
              u3.push(R3, C3, O3), u3.push(C3, P3, O3), b3 += 6;
            }
          c3.addGroup(g3, b3, 0), g3 += b3;
        }(), false === a2 && (e3 > 0 && v3(true), t3 > 0 && v3(false)), this.setIndex(u3), this.addAttribute("position", new Sn(l3, 3)), this.addAttribute("normal", new Sn(h3, 3)), this.addAttribute("uv", new Sn(d3, 2));
      }
      function Ua2(e3, t3, n3, r3, i3, a2, o2) {
        Ia2.call(this, 0, e3, t3, n3, r3, i3, a2, o2), this.type = "ConeGeometry", this.parameters = { radius: e3, height: t3, radialSegments: n3, heightSegments: r3, openEnded: i3, thetaStart: a2, thetaLength: o2 };
      }
      function Ba2(e3, t3, n3, r3, i3, a2, o2) {
        Da2.call(this, 0, e3, t3, n3, r3, i3, a2, o2), this.type = "ConeBufferGeometry", this.parameters = { radius: e3, height: t3, radialSegments: n3, heightSegments: r3, openEnded: i3, thetaStart: a2, thetaLength: o2 };
      }
      function Fa2(e3, t3, n3, r3) {
        vn.call(this), this.type = "CircleGeometry", this.parameters = { radius: e3, segments: t3, thetaStart: n3, thetaLength: r3 }, this.fromBufferGeometry(new Ga2(e3, t3, n3, r3)), this.mergeVertices();
      }
      function Ga2(e3, t3, n3, r3) {
        Pn.call(this), this.type = "CircleBufferGeometry", this.parameters = { radius: e3, segments: t3, thetaStart: n3, thetaLength: r3 }, e3 = e3 || 1, t3 = void 0 !== t3 ? Math.max(3, t3) : 8, n3 = void 0 !== n3 ? n3 : 0, r3 = void 0 !== r3 ? r3 : 2 * Math.PI;
        var i3, a2, o2 = [], s2 = [], c3 = [], u3 = [], l3 = new Ht(), h3 = new Ft();
        for (s2.push(0, 0, 0), c3.push(0, 0, 1), u3.push(0.5, 0.5), a2 = 0, i3 = 3; a2 <= t3; a2++, i3 += 3) {
          var d3 = n3 + a2 / t3 * r3;
          l3.x = e3 * Math.cos(d3), l3.y = e3 * Math.sin(d3), s2.push(l3.x, l3.y, l3.z), c3.push(0, 0, 1), h3.x = (s2[i3] / e3 + 1) / 2, h3.y = (s2[i3 + 1] / e3 + 1) / 2, u3.push(h3.x, h3.y);
        }
        for (i3 = 1; i3 <= t3; i3++)
          o2.push(i3, i3 + 1, 0);
        this.setIndex(o2), this.addAttribute("position", new Sn(s2, 3)), this.addAttribute("normal", new Sn(c3, 3)), this.addAttribute("uv", new Sn(u3, 2));
      }
      _a.prototype = Object.create(vn.prototype), _a.prototype.constructor = _a, Ma2.prototype = Object.create(xa.prototype), Ma2.prototype.constructor = Ma2, Ea2.prototype = Object.create(vn.prototype), Ea2.prototype.constructor = Ea2, Ta2.prototype = Object.create(Pn.prototype), Ta2.prototype.constructor = Ta2, Sa2.prototype = Object.create(vn.prototype), Sa2.prototype.constructor = Sa2, Aa2.prototype = Object.create(Pn.prototype), Aa2.prototype.constructor = Aa2, La2.prototype = Object.create(vn.prototype), La2.prototype.constructor = La2, Ra2.prototype = Object.create(Pn.prototype), Ra2.prototype.constructor = Ra2, Ca2.prototype = Object.create(vn.prototype), Ca2.prototype.constructor = Ca2, Ca2.prototype.toJSON = function() {
        var e3 = vn.prototype.toJSON.call(this);
        return Oa2(this.parameters.shapes, e3);
      }, Pa2.prototype = Object.create(Pn.prototype), Pa2.prototype.constructor = Pa2, Pa2.prototype.toJSON = function() {
        var e3 = Pn.prototype.toJSON.call(this);
        return Oa2(this.parameters.shapes, e3);
      }, Na2.prototype = Object.create(Pn.prototype), Na2.prototype.constructor = Na2, Ia2.prototype = Object.create(vn.prototype), Ia2.prototype.constructor = Ia2, Da2.prototype = Object.create(Pn.prototype), Da2.prototype.constructor = Da2, Ua2.prototype = Object.create(Ia2.prototype), Ua2.prototype.constructor = Ua2, Ba2.prototype = Object.create(Da2.prototype), Ba2.prototype.constructor = Ba2, Fa2.prototype = Object.create(vn.prototype), Fa2.prototype.constructor = Fa2, Ga2.prototype = Object.create(Pn.prototype), Ga2.prototype.constructor = Ga2;
      var za2 = Object.freeze({ WireframeGeometry: Li2, ParametricGeometry: Ri2, ParametricBufferGeometry: Ci2, TetrahedronGeometry: Ni2, TetrahedronBufferGeometry: Ii2, OctahedronGeometry: Di2, OctahedronBufferGeometry: Ui2, IcosahedronGeometry: Bi2, IcosahedronBufferGeometry: Fi2, DodecahedronGeometry: Gi2, DodecahedronBufferGeometry: zi2, PolyhedronGeometry: Pi2, PolyhedronBufferGeometry: Oi2, TubeGeometry: Hi2, TubeBufferGeometry: ki2, TorusKnotGeometry: ji2, TorusKnotBufferGeometry: Vi2, TorusGeometry: Wi2, TorusBufferGeometry: Xi2, TextGeometry: _a, TextBufferGeometry: Ma2, SphereGeometry: Ea2, SphereBufferGeometry: Ta2, RingGeometry: Sa2, RingBufferGeometry: Aa2, PlaneGeometry: In, PlaneBufferGeometry: Dn, LatheGeometry: La2, LatheBufferGeometry: Ra2, ShapeGeometry: Ca2, ShapeBufferGeometry: Pa2, ExtrudeGeometry: ya2, ExtrudeBufferGeometry: xa, EdgesGeometry: Na2, ConeGeometry: Ua2, ConeBufferGeometry: Ba2, CylinderGeometry: Ia2, CylinderBufferGeometry: Da2, CircleGeometry: Fa2, CircleBufferGeometry: Ga2, BoxGeometry: On, BoxBufferGeometry: Nn });
      function Ha2(e3) {
        Bn.call(this), this.type = "ShadowMaterial", this.color = new rn(0), this.transparent = true, this.setValues(e3);
      }
      function ka2(e3) {
        Gn.call(this, e3), this.type = "RawShaderMaterial";
      }
      function ja2(e3) {
        Bn.call(this), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new rn(16777215), this.roughness = 0.5, this.metalness = 0.5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new rn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Dt, this.normalScale = new Ft(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = false, this.morphTargets = false, this.morphNormals = false, this.setValues(e3);
      }
      function Va2(e3) {
        ja2.call(this), this.defines = { PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.reflectivity = 0.5, this.clearCoat = 0, this.clearCoatRoughness = 0, this.setValues(e3);
      }
      function Wa2(e3) {
        Bn.call(this), this.type = "MeshPhongMaterial", this.color = new rn(16777215), this.specular = new rn(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new rn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Dt, this.normalScale = new Ft(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = $, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = false, this.morphTargets = false, this.morphNormals = false, this.setValues(e3);
      }
      function Xa2(e3) {
        Wa2.call(this), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(e3);
      }
      function qa2(e3) {
        Bn.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Dt, this.normalScale = new Ft(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.skinning = false, this.morphTargets = false, this.morphNormals = false, this.setValues(e3);
      }
      function Ya2(e3) {
        Bn.call(this), this.type = "MeshLambertMaterial", this.color = new rn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new rn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = $, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = false, this.morphTargets = false, this.morphNormals = false, this.setValues(e3);
      }
      function Za2(e3) {
        yi2.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e3);
      }
      Ha2.prototype = Object.create(Bn.prototype), Ha2.prototype.constructor = Ha2, Ha2.prototype.isShadowMaterial = true, Ha2.prototype.copy = function(e3) {
        return Bn.prototype.copy.call(this, e3), this.color.copy(e3.color), this;
      }, ka2.prototype = Object.create(Gn.prototype), ka2.prototype.constructor = ka2, ka2.prototype.isRawShaderMaterial = true, ja2.prototype = Object.create(Bn.prototype), ja2.prototype.constructor = ja2, ja2.prototype.isMeshStandardMaterial = true, ja2.prototype.copy = function(e3) {
        return Bn.prototype.copy.call(this, e3), this.defines = { STANDARD: "" }, this.color.copy(e3.color), this.roughness = e3.roughness, this.metalness = e3.metalness, this.map = e3.map, this.lightMap = e3.lightMap, this.lightMapIntensity = e3.lightMapIntensity, this.aoMap = e3.aoMap, this.aoMapIntensity = e3.aoMapIntensity, this.emissive.copy(e3.emissive), this.emissiveMap = e3.emissiveMap, this.emissiveIntensity = e3.emissiveIntensity, this.bumpMap = e3.bumpMap, this.bumpScale = e3.bumpScale, this.normalMap = e3.normalMap, this.normalMapType = e3.normalMapType, this.normalScale.copy(e3.normalScale), this.displacementMap = e3.displacementMap, this.displacementScale = e3.displacementScale, this.displacementBias = e3.displacementBias, this.roughnessMap = e3.roughnessMap, this.metalnessMap = e3.metalnessMap, this.alphaMap = e3.alphaMap, this.envMap = e3.envMap, this.envMapIntensity = e3.envMapIntensity, this.refractionRatio = e3.refractionRatio, this.wireframe = e3.wireframe, this.wireframeLinewidth = e3.wireframeLinewidth, this.wireframeLinecap = e3.wireframeLinecap, this.wireframeLinejoin = e3.wireframeLinejoin, this.skinning = e3.skinning, this.morphTargets = e3.morphTargets, this.morphNormals = e3.morphNormals, this;
      }, Va2.prototype = Object.create(ja2.prototype), Va2.prototype.constructor = Va2, Va2.prototype.isMeshPhysicalMaterial = true, Va2.prototype.copy = function(e3) {
        return ja2.prototype.copy.call(this, e3), this.defines = { PHYSICAL: "" }, this.reflectivity = e3.reflectivity, this.clearCoat = e3.clearCoat, this.clearCoatRoughness = e3.clearCoatRoughness, this;
      }, Wa2.prototype = Object.create(Bn.prototype), Wa2.prototype.constructor = Wa2, Wa2.prototype.isMeshPhongMaterial = true, Wa2.prototype.copy = function(e3) {
        return Bn.prototype.copy.call(this, e3), this.color.copy(e3.color), this.specular.copy(e3.specular), this.shininess = e3.shininess, this.map = e3.map, this.lightMap = e3.lightMap, this.lightMapIntensity = e3.lightMapIntensity, this.aoMap = e3.aoMap, this.aoMapIntensity = e3.aoMapIntensity, this.emissive.copy(e3.emissive), this.emissiveMap = e3.emissiveMap, this.emissiveIntensity = e3.emissiveIntensity, this.bumpMap = e3.bumpMap, this.bumpScale = e3.bumpScale, this.normalMap = e3.normalMap, this.normalMapType = e3.normalMapType, this.normalScale.copy(e3.normalScale), this.displacementMap = e3.displacementMap, this.displacementScale = e3.displacementScale, this.displacementBias = e3.displacementBias, this.specularMap = e3.specularMap, this.alphaMap = e3.alphaMap, this.envMap = e3.envMap, this.combine = e3.combine, this.reflectivity = e3.reflectivity, this.refractionRatio = e3.refractionRatio, this.wireframe = e3.wireframe, this.wireframeLinewidth = e3.wireframeLinewidth, this.wireframeLinecap = e3.wireframeLinecap, this.wireframeLinejoin = e3.wireframeLinejoin, this.skinning = e3.skinning, this.morphTargets = e3.morphTargets, this.morphNormals = e3.morphNormals, this;
      }, Xa2.prototype = Object.create(Wa2.prototype), Xa2.prototype.constructor = Xa2, Xa2.prototype.isMeshToonMaterial = true, Xa2.prototype.copy = function(e3) {
        return Wa2.prototype.copy.call(this, e3), this.gradientMap = e3.gradientMap, this;
      }, qa2.prototype = Object.create(Bn.prototype), qa2.prototype.constructor = qa2, qa2.prototype.isMeshNormalMaterial = true, qa2.prototype.copy = function(e3) {
        return Bn.prototype.copy.call(this, e3), this.bumpMap = e3.bumpMap, this.bumpScale = e3.bumpScale, this.normalMap = e3.normalMap, this.normalMapType = e3.normalMapType, this.normalScale.copy(e3.normalScale), this.displacementMap = e3.displacementMap, this.displacementScale = e3.displacementScale, this.displacementBias = e3.displacementBias, this.wireframe = e3.wireframe, this.wireframeLinewidth = e3.wireframeLinewidth, this.skinning = e3.skinning, this.morphTargets = e3.morphTargets, this.morphNormals = e3.morphNormals, this;
      }, Ya2.prototype = Object.create(Bn.prototype), Ya2.prototype.constructor = Ya2, Ya2.prototype.isMeshLambertMaterial = true, Ya2.prototype.copy = function(e3) {
        return Bn.prototype.copy.call(this, e3), this.color.copy(e3.color), this.map = e3.map, this.lightMap = e3.lightMap, this.lightMapIntensity = e3.lightMapIntensity, this.aoMap = e3.aoMap, this.aoMapIntensity = e3.aoMapIntensity, this.emissive.copy(e3.emissive), this.emissiveMap = e3.emissiveMap, this.emissiveIntensity = e3.emissiveIntensity, this.specularMap = e3.specularMap, this.alphaMap = e3.alphaMap, this.envMap = e3.envMap, this.combine = e3.combine, this.reflectivity = e3.reflectivity, this.refractionRatio = e3.refractionRatio, this.wireframe = e3.wireframe, this.wireframeLinewidth = e3.wireframeLinewidth, this.wireframeLinecap = e3.wireframeLinecap, this.wireframeLinejoin = e3.wireframeLinejoin, this.skinning = e3.skinning, this.morphTargets = e3.morphTargets, this.morphNormals = e3.morphNormals, this;
      }, Za2.prototype = Object.create(yi2.prototype), Za2.prototype.constructor = Za2, Za2.prototype.isLineDashedMaterial = true, Za2.prototype.copy = function(e3) {
        return yi2.prototype.copy.call(this, e3), this.scale = e3.scale, this.dashSize = e3.dashSize, this.gapSize = e3.gapSize, this;
      };
      var Ja2 = Object.freeze({ ShadowMaterial: Ha2, SpriteMaterial: di2, RawShaderMaterial: ka2, ShaderMaterial: Gn, PointsMaterial: _i, MeshPhysicalMaterial: Va2, MeshStandardMaterial: ja2, MeshPhongMaterial: Wa2, MeshToonMaterial: Xa2, MeshNormalMaterial: qa2, MeshLambertMaterial: Ya2, MeshDepthMaterial: Kr, MeshDistanceMaterial: Qr, MeshBasicMaterial: Fn, LineDashedMaterial: Za2, LineBasicMaterial: yi2, Material: Bn }), Ka2 = { enabled: false, files: {}, add: function(e3, t3) {
        false !== this.enabled && (this.files[e3] = t3);
      }, get: function(e3) {
        if (false !== this.enabled)
          return this.files[e3];
      }, remove: function(e3) {
        delete this.files[e3];
      }, clear: function() {
        this.files = {};
      } };
      function Qa2(e3, t3, n3) {
        var r3 = this, i3 = false, a2 = 0, o2 = 0, s2 = void 0;
        this.onStart = void 0, this.onLoad = e3, this.onProgress = t3, this.onError = n3, this.itemStart = function(e4) {
          o2++, false === i3 && void 0 !== r3.onStart && r3.onStart(e4, a2, o2), i3 = true;
        }, this.itemEnd = function(e4) {
          a2++, void 0 !== r3.onProgress && r3.onProgress(e4, a2, o2), a2 === o2 && (i3 = false, void 0 !== r3.onLoad && r3.onLoad());
        }, this.itemError = function(e4) {
          void 0 !== r3.onError && r3.onError(e4);
        }, this.resolveURL = function(e4) {
          return s2 ? s2(e4) : e4;
        }, this.setURLModifier = function(e4) {
          return s2 = e4, this;
        };
      }
      var $a = new Qa2(), eo = {};
      function to(e3) {
        this.manager = void 0 !== e3 ? e3 : $a;
      }
      function no(e3) {
        this.manager = void 0 !== e3 ? e3 : $a, this._parser = null;
      }
      function ro(e3) {
        this.manager = void 0 !== e3 ? e3 : $a, this._parser = null;
      }
      function io(e3) {
        this.manager = void 0 !== e3 ? e3 : $a;
      }
      function ao(e3) {
        this.manager = void 0 !== e3 ? e3 : $a;
      }
      function oo(e3) {
        this.manager = void 0 !== e3 ? e3 : $a;
      }
      function so() {
        this.type = "Curve", this.arcLengthDivisions = 200;
      }
      function co(e3, t3, n3, r3, i3, a2, o2, s2) {
        so.call(this), this.type = "EllipseCurve", this.aX = e3 || 0, this.aY = t3 || 0, this.xRadius = n3 || 1, this.yRadius = r3 || 1, this.aStartAngle = i3 || 0, this.aEndAngle = a2 || 2 * Math.PI, this.aClockwise = o2 || false, this.aRotation = s2 || 0;
      }
      function uo(e3, t3, n3, r3, i3, a2) {
        co.call(this, e3, t3, n3, n3, r3, i3, a2), this.type = "ArcCurve";
      }
      function lo() {
        var e3 = 0, t3 = 0, n3 = 0, r3 = 0;
        function i3(i4, a2, o2, s2) {
          e3 = i4, t3 = o2, n3 = -3 * i4 + 3 * a2 - 2 * o2 - s2, r3 = 2 * i4 - 2 * a2 + o2 + s2;
        }
        return { initCatmullRom: function(e4, t4, n4, r4, a2) {
          i3(t4, n4, a2 * (n4 - e4), a2 * (r4 - t4));
        }, initNonuniformCatmullRom: function(e4, t4, n4, r4, a2, o2, s2) {
          var c3 = (t4 - e4) / a2 - (n4 - e4) / (a2 + o2) + (n4 - t4) / o2, u3 = (n4 - t4) / o2 - (r4 - t4) / (o2 + s2) + (r4 - n4) / s2;
          i3(t4, n4, c3 *= o2, u3 *= o2);
        }, calc: function(i4) {
          var a2 = i4 * i4;
          return e3 + t3 * i4 + n3 * a2 + r3 * (a2 * i4);
        } };
      }
      Object.assign(to.prototype, { load: function(e3, t3, n3, r3) {
        void 0 === e3 && (e3 = ""), void 0 !== this.path && (e3 = this.path + e3), e3 = this.manager.resolveURL(e3);
        var i3 = this, a2 = Ka2.get(e3);
        if (void 0 !== a2)
          return i3.manager.itemStart(e3), setTimeout(function() {
            t3 && t3(a2), i3.manager.itemEnd(e3);
          }, 0), a2;
        if (void 0 === eo[e3]) {
          var o2 = e3.match(/^data:(.*?)(;base64)?,(.*)$/);
          if (o2) {
            var s2 = o2[1], c3 = !!o2[2], u3 = o2[3];
            u3 = window.decodeURIComponent(u3), c3 && (u3 = window.atob(u3));
            try {
              var l3, h3 = (this.responseType || "").toLowerCase();
              switch (h3) {
                case "arraybuffer":
                case "blob":
                  for (var d3 = new Uint8Array(u3.length), p3 = 0; p3 < u3.length; p3++)
                    d3[p3] = u3.charCodeAt(p3);
                  l3 = "blob" === h3 ? new Blob([d3.buffer], { type: s2 }) : d3.buffer;
                  break;
                case "document":
                  var f3 = new DOMParser();
                  l3 = f3.parseFromString(u3, s2);
                  break;
                case "json":
                  l3 = JSON.parse(u3);
                  break;
                default:
                  l3 = u3;
              }
              window.setTimeout(function() {
                t3 && t3(l3), i3.manager.itemEnd(e3);
              }, 0);
            } catch (t4) {
              window.setTimeout(function() {
                r3 && r3(t4), i3.manager.itemEnd(e3), i3.manager.itemError(e3);
              }, 0);
            }
          } else {
            eo[e3] = [], eo[e3].push({ onLoad: t3, onProgress: n3, onError: r3 });
            var m3 = new XMLHttpRequest();
            for (var g3 in m3.open("GET", e3, true), m3.addEventListener("load", function(t4) {
              var n4 = this.response;
              Ka2.add(e3, n4);
              var r4 = eo[e3];
              if (delete eo[e3], 200 === this.status || 0 === this.status) {
                0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                for (var a3 = 0, o3 = r4.length; a3 < o3; a3++) {
                  (s3 = r4[a3]).onLoad && s3.onLoad(n4);
                }
                i3.manager.itemEnd(e3);
              } else {
                for (a3 = 0, o3 = r4.length; a3 < o3; a3++) {
                  var s3;
                  (s3 = r4[a3]).onError && s3.onError(t4);
                }
                i3.manager.itemEnd(e3), i3.manager.itemError(e3);
              }
            }, false), m3.addEventListener("progress", function(t4) {
              for (var n4 = eo[e3], r4 = 0, i4 = n4.length; r4 < i4; r4++) {
                var a3 = n4[r4];
                a3.onProgress && a3.onProgress(t4);
              }
            }, false), m3.addEventListener("error", function(t4) {
              var n4 = eo[e3];
              delete eo[e3];
              for (var r4 = 0, a3 = n4.length; r4 < a3; r4++) {
                var o3 = n4[r4];
                o3.onError && o3.onError(t4);
              }
              i3.manager.itemEnd(e3), i3.manager.itemError(e3);
            }, false), void 0 !== this.responseType && (m3.responseType = this.responseType), void 0 !== this.withCredentials && (m3.withCredentials = this.withCredentials), m3.overrideMimeType && m3.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader)
              m3.setRequestHeader(g3, this.requestHeader[g3]);
            m3.send(null);
          }
          return i3.manager.itemStart(e3), m3;
        }
        eo[e3].push({ onLoad: t3, onProgress: n3, onError: r3 });
      }, setPath: function(e3) {
        return this.path = e3, this;
      }, setResponseType: function(e3) {
        return this.responseType = e3, this;
      }, setWithCredentials: function(e3) {
        return this.withCredentials = e3, this;
      }, setMimeType: function(e3) {
        return this.mimeType = e3, this;
      }, setRequestHeader: function(e3) {
        return this.requestHeader = e3, this;
      } }), Object.assign(no.prototype, { load: function(e3, t3, n3, r3) {
        var i3 = this, a2 = [], o2 = new Ti2();
        o2.image = a2;
        var s2 = new to(this.manager);
        function c3(c4) {
          s2.load(e3[c4], function(e4) {
            var n4 = i3._parser(e4, true);
            a2[c4] = { width: n4.width, height: n4.height, format: n4.format, mipmaps: n4.mipmaps }, 6 === (u3 += 1) && (1 === n4.mipmapCount && (o2.minFilter = we2), o2.format = n4.format, o2.needsUpdate = true, t3 && t3(o2));
          }, n3, r3);
        }
        if (s2.setPath(this.path), s2.setResponseType("arraybuffer"), Array.isArray(e3))
          for (var u3 = 0, l3 = 0, h3 = e3.length; l3 < h3; ++l3)
            c3(l3);
        else
          s2.load(e3, function(e4) {
            var n4 = i3._parser(e4, true);
            if (n4.isCubemap)
              for (var r4 = n4.mipmaps.length / n4.mipmapCount, s3 = 0; s3 < r4; s3++) {
                a2[s3] = { mipmaps: [] };
                for (var c4 = 0; c4 < n4.mipmapCount; c4++)
                  a2[s3].mipmaps.push(n4.mipmaps[s3 * n4.mipmapCount + c4]), a2[s3].format = n4.format, a2[s3].width = n4.width, a2[s3].height = n4.height;
              }
            else
              o2.image.width = n4.width, o2.image.height = n4.height, o2.mipmaps = n4.mipmaps;
            1 === n4.mipmapCount && (o2.minFilter = we2), o2.format = n4.format, o2.needsUpdate = true, t3 && t3(o2);
          }, n3, r3);
        return o2;
      }, setPath: function(e3) {
        return this.path = e3, this;
      } }), Object.assign(ro.prototype, { load: function(e3, t3, n3, r3) {
        var i3 = this, a2 = new Zt(), o2 = new to(this.manager);
        return o2.setResponseType("arraybuffer"), o2.load(e3, function(e4) {
          var n4 = i3._parser(e4);
          n4 && (void 0 !== n4.image ? a2.image = n4.image : void 0 !== n4.data && (a2.image.width = n4.width, a2.image.height = n4.height, a2.image.data = n4.data), a2.wrapS = void 0 !== n4.wrapS ? n4.wrapS : ge2, a2.wrapT = void 0 !== n4.wrapT ? n4.wrapT : ge2, a2.magFilter = void 0 !== n4.magFilter ? n4.magFilter : we2, a2.minFilter = void 0 !== n4.minFilter ? n4.minFilter : Me2, a2.anisotropy = void 0 !== n4.anisotropy ? n4.anisotropy : 1, void 0 !== n4.format && (a2.format = n4.format), void 0 !== n4.type && (a2.type = n4.type), void 0 !== n4.mipmaps && (a2.mipmaps = n4.mipmaps), 1 === n4.mipmapCount && (a2.minFilter = we2), a2.needsUpdate = true, t3 && t3(a2, n4));
        }, n3, r3), a2;
      } }), Object.assign(io.prototype, { crossOrigin: "anonymous", load: function(e3, t3, n3, r3) {
        void 0 === e3 && (e3 = ""), void 0 !== this.path && (e3 = this.path + e3), e3 = this.manager.resolveURL(e3);
        var i3 = this, a2 = Ka2.get(e3);
        if (void 0 !== a2)
          return i3.manager.itemStart(e3), setTimeout(function() {
            t3 && t3(a2), i3.manager.itemEnd(e3);
          }, 0), a2;
        var o2 = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
        function s2() {
          o2.removeEventListener("load", s2, false), o2.removeEventListener("error", c3, false), Ka2.add(e3, this), t3 && t3(this), i3.manager.itemEnd(e3);
        }
        function c3(t4) {
          o2.removeEventListener("load", s2, false), o2.removeEventListener("error", c3, false), r3 && r3(t4), i3.manager.itemEnd(e3), i3.manager.itemError(e3);
        }
        return o2.addEventListener("load", s2, false), o2.addEventListener("error", c3, false), "data:" !== e3.substr(0, 5) && void 0 !== this.crossOrigin && (o2.crossOrigin = this.crossOrigin), i3.manager.itemStart(e3), o2.src = e3, o2;
      }, setCrossOrigin: function(e3) {
        return this.crossOrigin = e3, this;
      }, setPath: function(e3) {
        return this.path = e3, this;
      } }), Object.assign(ao.prototype, { crossOrigin: "anonymous", load: function(e3, t3, n3, r3) {
        var i3 = new Vn(), a2 = new io(this.manager);
        a2.setCrossOrigin(this.crossOrigin), a2.setPath(this.path);
        var o2 = 0;
        function s2(n4) {
          a2.load(e3[n4], function(e4) {
            i3.images[n4] = e4, 6 === ++o2 && (i3.needsUpdate = true, t3 && t3(i3));
          }, void 0, r3);
        }
        for (var c3 = 0; c3 < e3.length; ++c3)
          s2(c3);
        return i3;
      }, setCrossOrigin: function(e3) {
        return this.crossOrigin = e3, this;
      }, setPath: function(e3) {
        return this.path = e3, this;
      } }), Object.assign(oo.prototype, { crossOrigin: "anonymous", load: function(e3, t3, n3, r3) {
        var i3 = new Wt(), a2 = new io(this.manager);
        return a2.setCrossOrigin(this.crossOrigin), a2.setPath(this.path), a2.load(e3, function(n4) {
          i3.image = n4;
          var r4 = e3.search(/\.(jpg|jpeg)$/) > 0 || 0 === e3.search(/^data\:image\/jpeg/);
          i3.format = r4 ? Be2 : Fe2, i3.needsUpdate = true, void 0 !== t3 && t3(i3);
        }, n3, r3), i3;
      }, setCrossOrigin: function(e3) {
        return this.crossOrigin = e3, this;
      }, setPath: function(e3) {
        return this.path = e3, this;
      } }), Object.assign(so.prototype, { getPoint: function() {
        return console.warn("THREE.Curve: .getPoint() not implemented."), null;
      }, getPointAt: function(e3, t3) {
        var n3 = this.getUtoTmapping(e3);
        return this.getPoint(n3, t3);
      }, getPoints: function(e3) {
        void 0 === e3 && (e3 = 5);
        for (var t3 = [], n3 = 0; n3 <= e3; n3++)
          t3.push(this.getPoint(n3 / e3));
        return t3;
      }, getSpacedPoints: function(e3) {
        void 0 === e3 && (e3 = 5);
        for (var t3 = [], n3 = 0; n3 <= e3; n3++)
          t3.push(this.getPointAt(n3 / e3));
        return t3;
      }, getLength: function() {
        var e3 = this.getLengths();
        return e3[e3.length - 1];
      }, getLengths: function(e3) {
        if (void 0 === e3 && (e3 = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === e3 + 1 && !this.needsUpdate)
          return this.cacheArcLengths;
        this.needsUpdate = false;
        var t3, n3, r3 = [], i3 = this.getPoint(0), a2 = 0;
        for (r3.push(0), n3 = 1; n3 <= e3; n3++)
          a2 += (t3 = this.getPoint(n3 / e3)).distanceTo(i3), r3.push(a2), i3 = t3;
        return this.cacheArcLengths = r3, r3;
      }, updateArcLengths: function() {
        this.needsUpdate = true, this.getLengths();
      }, getUtoTmapping: function(e3, t3) {
        var n3, r3 = this.getLengths(), i3 = 0, a2 = r3.length;
        n3 = t3 || e3 * r3[a2 - 1];
        for (var o2, s2 = 0, c3 = a2 - 1; s2 <= c3; )
          if ((o2 = r3[i3 = Math.floor(s2 + (c3 - s2) / 2)] - n3) < 0)
            s2 = i3 + 1;
          else {
            if (!(o2 > 0)) {
              c3 = i3;
              break;
            }
            c3 = i3 - 1;
          }
        if (r3[i3 = c3] === n3)
          return i3 / (a2 - 1);
        var u3 = r3[i3];
        return (i3 + (n3 - u3) / (r3[i3 + 1] - u3)) / (a2 - 1);
      }, getTangent: function(e3) {
        var t3 = e3 - 1e-4, n3 = e3 + 1e-4;
        t3 < 0 && (t3 = 0), n3 > 1 && (n3 = 1);
        var r3 = this.getPoint(t3);
        return this.getPoint(n3).clone().sub(r3).normalize();
      }, getTangentAt: function(e3) {
        var t3 = this.getUtoTmapping(e3);
        return this.getTangent(t3);
      }, computeFrenetFrames: function(e3, t3) {
        var n3, r3, i3, a2 = new Ht(), o2 = [], s2 = [], c3 = [], u3 = new Ht(), l3 = new Gt();
        for (n3 = 0; n3 <= e3; n3++)
          r3 = n3 / e3, o2[n3] = this.getTangentAt(r3), o2[n3].normalize();
        s2[0] = new Ht(), c3[0] = new Ht();
        var h3 = Number.MAX_VALUE, d3 = Math.abs(o2[0].x), p3 = Math.abs(o2[0].y), f3 = Math.abs(o2[0].z);
        for (d3 <= h3 && (h3 = d3, a2.set(1, 0, 0)), p3 <= h3 && (h3 = p3, a2.set(0, 1, 0)), f3 <= h3 && a2.set(0, 0, 1), u3.crossVectors(o2[0], a2).normalize(), s2[0].crossVectors(o2[0], u3), c3[0].crossVectors(o2[0], s2[0]), n3 = 1; n3 <= e3; n3++)
          s2[n3] = s2[n3 - 1].clone(), c3[n3] = c3[n3 - 1].clone(), u3.crossVectors(o2[n3 - 1], o2[n3]), u3.length() > Number.EPSILON && (u3.normalize(), i3 = Math.acos(Bt.clamp(o2[n3 - 1].dot(o2[n3]), -1, 1)), s2[n3].applyMatrix4(l3.makeRotationAxis(u3, i3))), c3[n3].crossVectors(o2[n3], s2[n3]);
        if (true === t3)
          for (i3 = Math.acos(Bt.clamp(s2[0].dot(s2[e3]), -1, 1)), i3 /= e3, o2[0].dot(u3.crossVectors(s2[0], s2[e3])) > 0 && (i3 = -i3), n3 = 1; n3 <= e3; n3++)
            s2[n3].applyMatrix4(l3.makeRotationAxis(o2[n3], i3 * n3)), c3[n3].crossVectors(o2[n3], s2[n3]);
        return { tangents: o2, normals: s2, binormals: c3 };
      }, clone: function() {
        return new this.constructor().copy(this);
      }, copy: function(e3) {
        return this.arcLengthDivisions = e3.arcLengthDivisions, this;
      }, toJSON: function() {
        var e3 = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } };
        return e3.arcLengthDivisions = this.arcLengthDivisions, e3.type = this.type, e3;
      }, fromJSON: function(e3) {
        return this.arcLengthDivisions = e3.arcLengthDivisions, this;
      } }), co.prototype = Object.create(so.prototype), co.prototype.constructor = co, co.prototype.isEllipseCurve = true, co.prototype.getPoint = function(e3, t3) {
        for (var n3 = t3 || new Ft(), r3 = 2 * Math.PI, i3 = this.aEndAngle - this.aStartAngle, a2 = Math.abs(i3) < Number.EPSILON; i3 < 0; )
          i3 += r3;
        for (; i3 > r3; )
          i3 -= r3;
        i3 < Number.EPSILON && (i3 = a2 ? 0 : r3), true !== this.aClockwise || a2 || (i3 === r3 ? i3 = -r3 : i3 -= r3);
        var o2 = this.aStartAngle + e3 * i3, s2 = this.aX + this.xRadius * Math.cos(o2), c3 = this.aY + this.yRadius * Math.sin(o2);
        if (0 !== this.aRotation) {
          var u3 = Math.cos(this.aRotation), l3 = Math.sin(this.aRotation), h3 = s2 - this.aX, d3 = c3 - this.aY;
          s2 = h3 * u3 - d3 * l3 + this.aX, c3 = h3 * l3 + d3 * u3 + this.aY;
        }
        return n3.set(s2, c3);
      }, co.prototype.copy = function(e3) {
        return so.prototype.copy.call(this, e3), this.aX = e3.aX, this.aY = e3.aY, this.xRadius = e3.xRadius, this.yRadius = e3.yRadius, this.aStartAngle = e3.aStartAngle, this.aEndAngle = e3.aEndAngle, this.aClockwise = e3.aClockwise, this.aRotation = e3.aRotation, this;
      }, co.prototype.toJSON = function() {
        var e3 = so.prototype.toJSON.call(this);
        return e3.aX = this.aX, e3.aY = this.aY, e3.xRadius = this.xRadius, e3.yRadius = this.yRadius, e3.aStartAngle = this.aStartAngle, e3.aEndAngle = this.aEndAngle, e3.aClockwise = this.aClockwise, e3.aRotation = this.aRotation, e3;
      }, co.prototype.fromJSON = function(e3) {
        return so.prototype.fromJSON.call(this, e3), this.aX = e3.aX, this.aY = e3.aY, this.xRadius = e3.xRadius, this.yRadius = e3.yRadius, this.aStartAngle = e3.aStartAngle, this.aEndAngle = e3.aEndAngle, this.aClockwise = e3.aClockwise, this.aRotation = e3.aRotation, this;
      }, uo.prototype = Object.create(co.prototype), uo.prototype.constructor = uo, uo.prototype.isArcCurve = true;
      var ho = new Ht(), po = new lo(), fo = new lo(), mo = new lo();
      function go(e3, t3, n3, r3) {
        so.call(this), this.type = "CatmullRomCurve3", this.points = e3 || [], this.closed = t3 || false, this.curveType = n3 || "centripetal", this.tension = r3 || 0.5;
      }
      function vo(e3, t3, n3, r3, i3) {
        var a2 = 0.5 * (r3 - t3), o2 = 0.5 * (i3 - n3), s2 = e3 * e3;
        return (2 * n3 - 2 * r3 + a2 + o2) * (e3 * s2) + (-3 * n3 + 3 * r3 - 2 * a2 - o2) * s2 + a2 * e3 + n3;
      }
      function yo(e3, t3, n3, r3) {
        return function(e4, t4) {
          var n4 = 1 - e4;
          return n4 * n4 * t4;
        }(e3, t3) + function(e4, t4) {
          return 2 * (1 - e4) * e4 * t4;
        }(e3, n3) + function(e4, t4) {
          return e4 * e4 * t4;
        }(e3, r3);
      }
      function xo(e3, t3, n3, r3, i3) {
        return function(e4, t4) {
          var n4 = 1 - e4;
          return n4 * n4 * n4 * t4;
        }(e3, t3) + function(e4, t4) {
          var n4 = 1 - e4;
          return 3 * n4 * n4 * e4 * t4;
        }(e3, n3) + function(e4, t4) {
          return 3 * (1 - e4) * e4 * e4 * t4;
        }(e3, r3) + function(e4, t4) {
          return e4 * e4 * e4 * t4;
        }(e3, i3);
      }
      function bo(e3, t3, n3, r3) {
        so.call(this), this.type = "CubicBezierCurve", this.v0 = e3 || new Ft(), this.v1 = t3 || new Ft(), this.v2 = n3 || new Ft(), this.v3 = r3 || new Ft();
      }
      function wo(e3, t3, n3, r3) {
        so.call(this), this.type = "CubicBezierCurve3", this.v0 = e3 || new Ht(), this.v1 = t3 || new Ht(), this.v2 = n3 || new Ht(), this.v3 = r3 || new Ht();
      }
      function _o(e3, t3) {
        so.call(this), this.type = "LineCurve", this.v1 = e3 || new Ft(), this.v2 = t3 || new Ft();
      }
      function Mo(e3, t3) {
        so.call(this), this.type = "LineCurve3", this.v1 = e3 || new Ht(), this.v2 = t3 || new Ht();
      }
      function Eo(e3, t3, n3) {
        so.call(this), this.type = "QuadraticBezierCurve", this.v0 = e3 || new Ft(), this.v1 = t3 || new Ft(), this.v2 = n3 || new Ft();
      }
      function To(e3, t3, n3) {
        so.call(this), this.type = "QuadraticBezierCurve3", this.v0 = e3 || new Ht(), this.v1 = t3 || new Ht(), this.v2 = n3 || new Ht();
      }
      function So(e3) {
        so.call(this), this.type = "SplineCurve", this.points = e3 || [];
      }
      go.prototype = Object.create(so.prototype), go.prototype.constructor = go, go.prototype.isCatmullRomCurve3 = true, go.prototype.getPoint = function(e3, t3) {
        var n3, r3, i3, a2, o2 = t3 || new Ht(), s2 = this.points, c3 = s2.length, u3 = (c3 - (this.closed ? 0 : 1)) * e3, l3 = Math.floor(u3), h3 = u3 - l3;
        if (this.closed ? l3 += l3 > 0 ? 0 : (Math.floor(Math.abs(l3) / c3) + 1) * c3 : 0 === h3 && l3 === c3 - 1 && (l3 = c3 - 2, h3 = 1), this.closed || l3 > 0 ? n3 = s2[(l3 - 1) % c3] : (ho.subVectors(s2[0], s2[1]).add(s2[0]), n3 = ho), r3 = s2[l3 % c3], i3 = s2[(l3 + 1) % c3], this.closed || l3 + 2 < c3 ? a2 = s2[(l3 + 2) % c3] : (ho.subVectors(s2[c3 - 1], s2[c3 - 2]).add(s2[c3 - 1]), a2 = ho), "centripetal" === this.curveType || "chordal" === this.curveType) {
          var d3 = "chordal" === this.curveType ? 0.5 : 0.25, p3 = Math.pow(n3.distanceToSquared(r3), d3), f3 = Math.pow(r3.distanceToSquared(i3), d3), m3 = Math.pow(i3.distanceToSquared(a2), d3);
          f3 < 1e-4 && (f3 = 1), p3 < 1e-4 && (p3 = f3), m3 < 1e-4 && (m3 = f3), po.initNonuniformCatmullRom(n3.x, r3.x, i3.x, a2.x, p3, f3, m3), fo.initNonuniformCatmullRom(n3.y, r3.y, i3.y, a2.y, p3, f3, m3), mo.initNonuniformCatmullRom(n3.z, r3.z, i3.z, a2.z, p3, f3, m3);
        } else
          "catmullrom" === this.curveType && (po.initCatmullRom(n3.x, r3.x, i3.x, a2.x, this.tension), fo.initCatmullRom(n3.y, r3.y, i3.y, a2.y, this.tension), mo.initCatmullRom(n3.z, r3.z, i3.z, a2.z, this.tension));
        return o2.set(po.calc(h3), fo.calc(h3), mo.calc(h3)), o2;
      }, go.prototype.copy = function(e3) {
        so.prototype.copy.call(this, e3), this.points = [];
        for (var t3 = 0, n3 = e3.points.length; t3 < n3; t3++) {
          var r3 = e3.points[t3];
          this.points.push(r3.clone());
        }
        return this.closed = e3.closed, this.curveType = e3.curveType, this.tension = e3.tension, this;
      }, go.prototype.toJSON = function() {
        var e3 = so.prototype.toJSON.call(this);
        e3.points = [];
        for (var t3 = 0, n3 = this.points.length; t3 < n3; t3++) {
          var r3 = this.points[t3];
          e3.points.push(r3.toArray());
        }
        return e3.closed = this.closed, e3.curveType = this.curveType, e3.tension = this.tension, e3;
      }, go.prototype.fromJSON = function(e3) {
        so.prototype.fromJSON.call(this, e3), this.points = [];
        for (var t3 = 0, n3 = e3.points.length; t3 < n3; t3++) {
          var r3 = e3.points[t3];
          this.points.push(new Ht().fromArray(r3));
        }
        return this.closed = e3.closed, this.curveType = e3.curveType, this.tension = e3.tension, this;
      }, bo.prototype = Object.create(so.prototype), bo.prototype.constructor = bo, bo.prototype.isCubicBezierCurve = true, bo.prototype.getPoint = function(e3, t3) {
        var n3 = t3 || new Ft(), r3 = this.v0, i3 = this.v1, a2 = this.v2, o2 = this.v3;
        return n3.set(xo(e3, r3.x, i3.x, a2.x, o2.x), xo(e3, r3.y, i3.y, a2.y, o2.y)), n3;
      }, bo.prototype.copy = function(e3) {
        return so.prototype.copy.call(this, e3), this.v0.copy(e3.v0), this.v1.copy(e3.v1), this.v2.copy(e3.v2), this.v3.copy(e3.v3), this;
      }, bo.prototype.toJSON = function() {
        var e3 = so.prototype.toJSON.call(this);
        return e3.v0 = this.v0.toArray(), e3.v1 = this.v1.toArray(), e3.v2 = this.v2.toArray(), e3.v3 = this.v3.toArray(), e3;
      }, bo.prototype.fromJSON = function(e3) {
        return so.prototype.fromJSON.call(this, e3), this.v0.fromArray(e3.v0), this.v1.fromArray(e3.v1), this.v2.fromArray(e3.v2), this.v3.fromArray(e3.v3), this;
      }, wo.prototype = Object.create(so.prototype), wo.prototype.constructor = wo, wo.prototype.isCubicBezierCurve3 = true, wo.prototype.getPoint = function(e3, t3) {
        var n3 = t3 || new Ht(), r3 = this.v0, i3 = this.v1, a2 = this.v2, o2 = this.v3;
        return n3.set(xo(e3, r3.x, i3.x, a2.x, o2.x), xo(e3, r3.y, i3.y, a2.y, o2.y), xo(e3, r3.z, i3.z, a2.z, o2.z)), n3;
      }, wo.prototype.copy = function(e3) {
        return so.prototype.copy.call(this, e3), this.v0.copy(e3.v0), this.v1.copy(e3.v1), this.v2.copy(e3.v2), this.v3.copy(e3.v3), this;
      }, wo.prototype.toJSON = function() {
        var e3 = so.prototype.toJSON.call(this);
        return e3.v0 = this.v0.toArray(), e3.v1 = this.v1.toArray(), e3.v2 = this.v2.toArray(), e3.v3 = this.v3.toArray(), e3;
      }, wo.prototype.fromJSON = function(e3) {
        return so.prototype.fromJSON.call(this, e3), this.v0.fromArray(e3.v0), this.v1.fromArray(e3.v1), this.v2.fromArray(e3.v2), this.v3.fromArray(e3.v3), this;
      }, _o.prototype = Object.create(so.prototype), _o.prototype.constructor = _o, _o.prototype.isLineCurve = true, _o.prototype.getPoint = function(e3, t3) {
        var n3 = t3 || new Ft();
        return 1 === e3 ? n3.copy(this.v2) : (n3.copy(this.v2).sub(this.v1), n3.multiplyScalar(e3).add(this.v1)), n3;
      }, _o.prototype.getPointAt = function(e3, t3) {
        return this.getPoint(e3, t3);
      }, _o.prototype.getTangent = function() {
        return this.v2.clone().sub(this.v1).normalize();
      }, _o.prototype.copy = function(e3) {
        return so.prototype.copy.call(this, e3), this.v1.copy(e3.v1), this.v2.copy(e3.v2), this;
      }, _o.prototype.toJSON = function() {
        var e3 = so.prototype.toJSON.call(this);
        return e3.v1 = this.v1.toArray(), e3.v2 = this.v2.toArray(), e3;
      }, _o.prototype.fromJSON = function(e3) {
        return so.prototype.fromJSON.call(this, e3), this.v1.fromArray(e3.v1), this.v2.fromArray(e3.v2), this;
      }, Mo.prototype = Object.create(so.prototype), Mo.prototype.constructor = Mo, Mo.prototype.isLineCurve3 = true, Mo.prototype.getPoint = function(e3, t3) {
        var n3 = t3 || new Ht();
        return 1 === e3 ? n3.copy(this.v2) : (n3.copy(this.v2).sub(this.v1), n3.multiplyScalar(e3).add(this.v1)), n3;
      }, Mo.prototype.getPointAt = function(e3, t3) {
        return this.getPoint(e3, t3);
      }, Mo.prototype.copy = function(e3) {
        return so.prototype.copy.call(this, e3), this.v1.copy(e3.v1), this.v2.copy(e3.v2), this;
      }, Mo.prototype.toJSON = function() {
        var e3 = so.prototype.toJSON.call(this);
        return e3.v1 = this.v1.toArray(), e3.v2 = this.v2.toArray(), e3;
      }, Mo.prototype.fromJSON = function(e3) {
        return so.prototype.fromJSON.call(this, e3), this.v1.fromArray(e3.v1), this.v2.fromArray(e3.v2), this;
      }, Eo.prototype = Object.create(so.prototype), Eo.prototype.constructor = Eo, Eo.prototype.isQuadraticBezierCurve = true, Eo.prototype.getPoint = function(e3, t3) {
        var n3 = t3 || new Ft(), r3 = this.v0, i3 = this.v1, a2 = this.v2;
        return n3.set(yo(e3, r3.x, i3.x, a2.x), yo(e3, r3.y, i3.y, a2.y)), n3;
      }, Eo.prototype.copy = function(e3) {
        return so.prototype.copy.call(this, e3), this.v0.copy(e3.v0), this.v1.copy(e3.v1), this.v2.copy(e3.v2), this;
      }, Eo.prototype.toJSON = function() {
        var e3 = so.prototype.toJSON.call(this);
        return e3.v0 = this.v0.toArray(), e3.v1 = this.v1.toArray(), e3.v2 = this.v2.toArray(), e3;
      }, Eo.prototype.fromJSON = function(e3) {
        return so.prototype.fromJSON.call(this, e3), this.v0.fromArray(e3.v0), this.v1.fromArray(e3.v1), this.v2.fromArray(e3.v2), this;
      }, To.prototype = Object.create(so.prototype), To.prototype.constructor = To, To.prototype.isQuadraticBezierCurve3 = true, To.prototype.getPoint = function(e3, t3) {
        var n3 = t3 || new Ht(), r3 = this.v0, i3 = this.v1, a2 = this.v2;
        return n3.set(yo(e3, r3.x, i3.x, a2.x), yo(e3, r3.y, i3.y, a2.y), yo(e3, r3.z, i3.z, a2.z)), n3;
      }, To.prototype.copy = function(e3) {
        return so.prototype.copy.call(this, e3), this.v0.copy(e3.v0), this.v1.copy(e3.v1), this.v2.copy(e3.v2), this;
      }, To.prototype.toJSON = function() {
        var e3 = so.prototype.toJSON.call(this);
        return e3.v0 = this.v0.toArray(), e3.v1 = this.v1.toArray(), e3.v2 = this.v2.toArray(), e3;
      }, To.prototype.fromJSON = function(e3) {
        return so.prototype.fromJSON.call(this, e3), this.v0.fromArray(e3.v0), this.v1.fromArray(e3.v1), this.v2.fromArray(e3.v2), this;
      }, So.prototype = Object.create(so.prototype), So.prototype.constructor = So, So.prototype.isSplineCurve = true, So.prototype.getPoint = function(e3, t3) {
        var n3 = t3 || new Ft(), r3 = this.points, i3 = (r3.length - 1) * e3, a2 = Math.floor(i3), o2 = i3 - a2, s2 = r3[0 === a2 ? a2 : a2 - 1], c3 = r3[a2], u3 = r3[a2 > r3.length - 2 ? r3.length - 1 : a2 + 1], l3 = r3[a2 > r3.length - 3 ? r3.length - 1 : a2 + 2];
        return n3.set(vo(o2, s2.x, c3.x, u3.x, l3.x), vo(o2, s2.y, c3.y, u3.y, l3.y)), n3;
      }, So.prototype.copy = function(e3) {
        so.prototype.copy.call(this, e3), this.points = [];
        for (var t3 = 0, n3 = e3.points.length; t3 < n3; t3++) {
          var r3 = e3.points[t3];
          this.points.push(r3.clone());
        }
        return this;
      }, So.prototype.toJSON = function() {
        var e3 = so.prototype.toJSON.call(this);
        e3.points = [];
        for (var t3 = 0, n3 = this.points.length; t3 < n3; t3++) {
          var r3 = this.points[t3];
          e3.points.push(r3.toArray());
        }
        return e3;
      }, So.prototype.fromJSON = function(e3) {
        so.prototype.fromJSON.call(this, e3), this.points = [];
        for (var t3 = 0, n3 = e3.points.length; t3 < n3; t3++) {
          var r3 = e3.points[t3];
          this.points.push(new Ft().fromArray(r3));
        }
        return this;
      };
      var Ao = Object.freeze({ ArcCurve: uo, CatmullRomCurve3: go, CubicBezierCurve: bo, CubicBezierCurve3: wo, EllipseCurve: co, LineCurve: _o, LineCurve3: Mo, QuadraticBezierCurve: Eo, QuadraticBezierCurve3: To, SplineCurve: So });
      function Lo() {
        so.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = false;
      }
      function Ro(e3) {
        Lo.call(this), this.type = "Path", this.currentPoint = new Ft(), e3 && this.setFromPoints(e3);
      }
      function Co(e3) {
        Ro.call(this, e3), this.uuid = Bt.generateUUID(), this.type = "Shape", this.holes = [];
      }
      function Po(e3, t3) {
        dn.call(this), this.type = "Light", this.color = new rn(e3), this.intensity = void 0 !== t3 ? t3 : 1, this.receiveShadow = void 0;
      }
      function Oo(e3, t3, n3) {
        Po.call(this, e3, n3), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(dn.DefaultUp), this.updateMatrix(), this.groundColor = new rn(t3);
      }
      function No(e3) {
        this.camera = e3, this.bias = 0, this.radius = 1, this.mapSize = new Ft(512, 512), this.map = null, this.matrix = new Gt();
      }
      function Io() {
        No.call(this, new ri2(50, 1, 0.5, 500));
      }
      function Do(e3, t3, n3, r3, i3, a2) {
        Po.call(this, e3, t3), this.type = "SpotLight", this.position.copy(dn.DefaultUp), this.updateMatrix(), this.target = new dn(), Object.defineProperty(this, "power", { get: function() {
          return this.intensity * Math.PI;
        }, set: function(e4) {
          this.intensity = e4 / Math.PI;
        } }), this.distance = void 0 !== n3 ? n3 : 0, this.angle = void 0 !== r3 ? r3 : Math.PI / 3, this.penumbra = void 0 !== i3 ? i3 : 0, this.decay = void 0 !== a2 ? a2 : 1, this.shadow = new Io();
      }
      function Uo(e3, t3, n3, r3) {
        Po.call(this, e3, t3), this.type = "PointLight", Object.defineProperty(this, "power", { get: function() {
          return 4 * this.intensity * Math.PI;
        }, set: function(e4) {
          this.intensity = e4 / (4 * Math.PI);
        } }), this.distance = void 0 !== n3 ? n3 : 0, this.decay = void 0 !== r3 ? r3 : 1, this.shadow = new No(new ri2(90, 1, 0.5, 500));
      }
      function Bo() {
        No.call(this, new fn(-5, 5, 5, -5, 0.5, 500));
      }
      function Fo(e3, t3) {
        Po.call(this, e3, t3), this.type = "DirectionalLight", this.position.copy(dn.DefaultUp), this.updateMatrix(), this.target = new dn(), this.shadow = new Bo();
      }
      function Go(e3, t3) {
        Po.call(this, e3, t3), this.type = "AmbientLight", this.castShadow = void 0;
      }
      function zo(e3, t3, n3, r3) {
        Po.call(this, e3, t3), this.type = "RectAreaLight", this.width = void 0 !== n3 ? n3 : 10, this.height = void 0 !== r3 ? r3 : 10;
      }
      Lo.prototype = Object.assign(Object.create(so.prototype), { constructor: Lo, add: function(e3) {
        this.curves.push(e3);
      }, closePath: function() {
        var e3 = this.curves[0].getPoint(0), t3 = this.curves[this.curves.length - 1].getPoint(1);
        e3.equals(t3) || this.curves.push(new _o(t3, e3));
      }, getPoint: function(e3) {
        for (var t3 = e3 * this.getLength(), n3 = this.getCurveLengths(), r3 = 0; r3 < n3.length; ) {
          if (n3[r3] >= t3) {
            var i3 = n3[r3] - t3, a2 = this.curves[r3], o2 = a2.getLength(), s2 = 0 === o2 ? 0 : 1 - i3 / o2;
            return a2.getPointAt(s2);
          }
          r3++;
        }
        return null;
      }, getLength: function() {
        var e3 = this.getCurveLengths();
        return e3[e3.length - 1];
      }, updateArcLengths: function() {
        this.needsUpdate = true, this.cacheLengths = null, this.getCurveLengths();
      }, getCurveLengths: function() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
          return this.cacheLengths;
        for (var e3 = [], t3 = 0, n3 = 0, r3 = this.curves.length; n3 < r3; n3++)
          t3 += this.curves[n3].getLength(), e3.push(t3);
        return this.cacheLengths = e3, e3;
      }, getSpacedPoints: function(e3) {
        void 0 === e3 && (e3 = 40);
        for (var t3 = [], n3 = 0; n3 <= e3; n3++)
          t3.push(this.getPoint(n3 / e3));
        return this.autoClose && t3.push(t3[0]), t3;
      }, getPoints: function(e3) {
        e3 = e3 || 12;
        for (var t3, n3 = [], r3 = 0, i3 = this.curves; r3 < i3.length; r3++)
          for (var a2 = i3[r3], o2 = a2 && a2.isEllipseCurve ? 2 * e3 : a2 && (a2.isLineCurve || a2.isLineCurve3) ? 1 : a2 && a2.isSplineCurve ? e3 * a2.points.length : e3, s2 = a2.getPoints(o2), c3 = 0; c3 < s2.length; c3++) {
            var u3 = s2[c3];
            t3 && t3.equals(u3) || (n3.push(u3), t3 = u3);
          }
        return this.autoClose && n3.length > 1 && !n3[n3.length - 1].equals(n3[0]) && n3.push(n3[0]), n3;
      }, copy: function(e3) {
        so.prototype.copy.call(this, e3), this.curves = [];
        for (var t3 = 0, n3 = e3.curves.length; t3 < n3; t3++) {
          var r3 = e3.curves[t3];
          this.curves.push(r3.clone());
        }
        return this.autoClose = e3.autoClose, this;
      }, toJSON: function() {
        var e3 = so.prototype.toJSON.call(this);
        e3.autoClose = this.autoClose, e3.curves = [];
        for (var t3 = 0, n3 = this.curves.length; t3 < n3; t3++) {
          var r3 = this.curves[t3];
          e3.curves.push(r3.toJSON());
        }
        return e3;
      }, fromJSON: function(e3) {
        so.prototype.fromJSON.call(this, e3), this.autoClose = e3.autoClose, this.curves = [];
        for (var t3 = 0, n3 = e3.curves.length; t3 < n3; t3++) {
          var r3 = e3.curves[t3];
          this.curves.push(new Ao[r3.type]().fromJSON(r3));
        }
        return this;
      } }), Ro.prototype = Object.assign(Object.create(Lo.prototype), { constructor: Ro, setFromPoints: function(e3) {
        this.moveTo(e3[0].x, e3[0].y);
        for (var t3 = 1, n3 = e3.length; t3 < n3; t3++)
          this.lineTo(e3[t3].x, e3[t3].y);
      }, moveTo: function(e3, t3) {
        this.currentPoint.set(e3, t3);
      }, lineTo: function(e3, t3) {
        var n3 = new _o(this.currentPoint.clone(), new Ft(e3, t3));
        this.curves.push(n3), this.currentPoint.set(e3, t3);
      }, quadraticCurveTo: function(e3, t3, n3, r3) {
        var i3 = new Eo(this.currentPoint.clone(), new Ft(e3, t3), new Ft(n3, r3));
        this.curves.push(i3), this.currentPoint.set(n3, r3);
      }, bezierCurveTo: function(e3, t3, n3, r3, i3, a2) {
        var o2 = new bo(this.currentPoint.clone(), new Ft(e3, t3), new Ft(n3, r3), new Ft(i3, a2));
        this.curves.push(o2), this.currentPoint.set(i3, a2);
      }, splineThru: function(e3) {
        var t3 = new So([this.currentPoint.clone()].concat(e3));
        this.curves.push(t3), this.currentPoint.copy(e3[e3.length - 1]);
      }, arc: function(e3, t3, n3, r3, i3, a2) {
        var o2 = this.currentPoint.x, s2 = this.currentPoint.y;
        this.absarc(e3 + o2, t3 + s2, n3, r3, i3, a2);
      }, absarc: function(e3, t3, n3, r3, i3, a2) {
        this.absellipse(e3, t3, n3, n3, r3, i3, a2);
      }, ellipse: function(e3, t3, n3, r3, i3, a2, o2, s2) {
        var c3 = this.currentPoint.x, u3 = this.currentPoint.y;
        this.absellipse(e3 + c3, t3 + u3, n3, r3, i3, a2, o2, s2);
      }, absellipse: function(e3, t3, n3, r3, i3, a2, o2, s2) {
        var c3 = new co(e3, t3, n3, r3, i3, a2, o2, s2);
        if (this.curves.length > 0) {
          var u3 = c3.getPoint(0);
          u3.equals(this.currentPoint) || this.lineTo(u3.x, u3.y);
        }
        this.curves.push(c3);
        var l3 = c3.getPoint(1);
        this.currentPoint.copy(l3);
      }, copy: function(e3) {
        return Lo.prototype.copy.call(this, e3), this.currentPoint.copy(e3.currentPoint), this;
      }, toJSON: function() {
        var e3 = Lo.prototype.toJSON.call(this);
        return e3.currentPoint = this.currentPoint.toArray(), e3;
      }, fromJSON: function(e3) {
        return Lo.prototype.fromJSON.call(this, e3), this.currentPoint.fromArray(e3.currentPoint), this;
      } }), Co.prototype = Object.assign(Object.create(Ro.prototype), { constructor: Co, getPointsHoles: function(e3) {
        for (var t3 = [], n3 = 0, r3 = this.holes.length; n3 < r3; n3++)
          t3[n3] = this.holes[n3].getPoints(e3);
        return t3;
      }, extractPoints: function(e3) {
        return { shape: this.getPoints(e3), holes: this.getPointsHoles(e3) };
      }, copy: function(e3) {
        Ro.prototype.copy.call(this, e3), this.holes = [];
        for (var t3 = 0, n3 = e3.holes.length; t3 < n3; t3++) {
          var r3 = e3.holes[t3];
          this.holes.push(r3.clone());
        }
        return this;
      }, toJSON: function() {
        var e3 = Ro.prototype.toJSON.call(this);
        e3.uuid = this.uuid, e3.holes = [];
        for (var t3 = 0, n3 = this.holes.length; t3 < n3; t3++) {
          var r3 = this.holes[t3];
          e3.holes.push(r3.toJSON());
        }
        return e3;
      }, fromJSON: function(e3) {
        Ro.prototype.fromJSON.call(this, e3), this.uuid = e3.uuid, this.holes = [];
        for (var t3 = 0, n3 = e3.holes.length; t3 < n3; t3++) {
          var r3 = e3.holes[t3];
          this.holes.push(new Ro().fromJSON(r3));
        }
        return this;
      } }), Po.prototype = Object.assign(Object.create(dn.prototype), { constructor: Po, isLight: true, copy: function(e3) {
        return dn.prototype.copy.call(this, e3), this.color.copy(e3.color), this.intensity = e3.intensity, this;
      }, toJSON: function(e3) {
        var t3 = dn.prototype.toJSON.call(this, e3);
        return t3.object.color = this.color.getHex(), t3.object.intensity = this.intensity, void 0 !== this.groundColor && (t3.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t3.object.distance = this.distance), void 0 !== this.angle && (t3.object.angle = this.angle), void 0 !== this.decay && (t3.object.decay = this.decay), void 0 !== this.penumbra && (t3.object.penumbra = this.penumbra), void 0 !== this.shadow && (t3.object.shadow = this.shadow.toJSON()), t3;
      } }), Oo.prototype = Object.assign(Object.create(Po.prototype), { constructor: Oo, isHemisphereLight: true, copy: function(e3) {
        return Po.prototype.copy.call(this, e3), this.groundColor.copy(e3.groundColor), this;
      } }), Object.assign(No.prototype, { copy: function(e3) {
        return this.camera = e3.camera.clone(), this.bias = e3.bias, this.radius = e3.radius, this.mapSize.copy(e3.mapSize), this;
      }, clone: function() {
        return new this.constructor().copy(this);
      }, toJSON: function() {
        var e3 = {};
        return 0 !== this.bias && (e3.bias = this.bias), 1 !== this.radius && (e3.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e3.mapSize = this.mapSize.toArray()), e3.camera = this.camera.toJSON(false).object, delete e3.camera.matrix, e3;
      } }), Io.prototype = Object.assign(Object.create(No.prototype), { constructor: Io, isSpotLightShadow: true, update: function(e3) {
        var t3 = this.camera, n3 = 2 * Bt.RAD2DEG * e3.angle, r3 = this.mapSize.width / this.mapSize.height, i3 = e3.distance || t3.far;
        n3 === t3.fov && r3 === t3.aspect && i3 === t3.far || (t3.fov = n3, t3.aspect = r3, t3.far = i3, t3.updateProjectionMatrix());
      } }), Do.prototype = Object.assign(Object.create(Po.prototype), { constructor: Do, isSpotLight: true, copy: function(e3) {
        return Po.prototype.copy.call(this, e3), this.distance = e3.distance, this.angle = e3.angle, this.penumbra = e3.penumbra, this.decay = e3.decay, this.target = e3.target.clone(), this.shadow = e3.shadow.clone(), this;
      } }), Uo.prototype = Object.assign(Object.create(Po.prototype), { constructor: Uo, isPointLight: true, copy: function(e3) {
        return Po.prototype.copy.call(this, e3), this.distance = e3.distance, this.decay = e3.decay, this.shadow = e3.shadow.clone(), this;
      } }), Bo.prototype = Object.assign(Object.create(No.prototype), { constructor: Bo }), Fo.prototype = Object.assign(Object.create(Po.prototype), { constructor: Fo, isDirectionalLight: true, copy: function(e3) {
        return Po.prototype.copy.call(this, e3), this.target = e3.target.clone(), this.shadow = e3.shadow.clone(), this;
      } }), Go.prototype = Object.assign(Object.create(Po.prototype), { constructor: Go, isAmbientLight: true }), zo.prototype = Object.assign(Object.create(Po.prototype), { constructor: zo, isRectAreaLight: true, copy: function(e3) {
        return Po.prototype.copy.call(this, e3), this.width = e3.width, this.height = e3.height, this;
      }, toJSON: function(e3) {
        var t3 = Po.prototype.toJSON.call(this, e3);
        return t3.object.width = this.width, t3.object.height = this.height, t3;
      } });
      var Ho = { arraySlice: function(e3, t3, n3) {
        return Ho.isTypedArray(e3) ? new e3.constructor(e3.subarray(t3, void 0 !== n3 ? n3 : e3.length)) : e3.slice(t3, n3);
      }, convertArray: function(e3, t3, n3) {
        return !e3 || !n3 && e3.constructor === t3 ? e3 : "number" == typeof t3.BYTES_PER_ELEMENT ? new t3(e3) : Array.prototype.slice.call(e3);
      }, isTypedArray: function(e3) {
        return ArrayBuffer.isView(e3) && !(e3 instanceof DataView);
      }, getKeyframeOrder: function(e3) {
        for (var t3 = e3.length, n3 = new Array(t3), r3 = 0; r3 !== t3; ++r3)
          n3[r3] = r3;
        return n3.sort(function(t4, n4) {
          return e3[t4] - e3[n4];
        }), n3;
      }, sortedArray: function(e3, t3, n3) {
        for (var r3 = e3.length, i3 = new e3.constructor(r3), a2 = 0, o2 = 0; o2 !== r3; ++a2)
          for (var s2 = n3[a2] * t3, c3 = 0; c3 !== t3; ++c3)
            i3[o2++] = e3[s2 + c3];
        return i3;
      }, flattenJSON: function(e3, t3, n3, r3) {
        for (var i3 = 1, a2 = e3[0]; void 0 !== a2 && void 0 === a2[r3]; )
          a2 = e3[i3++];
        if (void 0 !== a2) {
          var o2 = a2[r3];
          if (void 0 !== o2)
            if (Array.isArray(o2))
              do {
                void 0 !== (o2 = a2[r3]) && (t3.push(a2.time), n3.push.apply(n3, o2)), a2 = e3[i3++];
              } while (void 0 !== a2);
            else if (void 0 !== o2.toArray)
              do {
                void 0 !== (o2 = a2[r3]) && (t3.push(a2.time), o2.toArray(n3, n3.length)), a2 = e3[i3++];
              } while (void 0 !== a2);
            else
              do {
                void 0 !== (o2 = a2[r3]) && (t3.push(a2.time), n3.push(o2)), a2 = e3[i3++];
              } while (void 0 !== a2);
        }
      } };
      function ko(e3, t3, n3, r3) {
        this.parameterPositions = e3, this._cachedIndex = 0, this.resultBuffer = void 0 !== r3 ? r3 : new t3.constructor(n3), this.sampleValues = t3, this.valueSize = n3;
      }
      function jo(e3, t3, n3, r3) {
        ko.call(this, e3, t3, n3, r3), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0;
      }
      function Vo(e3, t3, n3, r3) {
        ko.call(this, e3, t3, n3, r3);
      }
      function Wo(e3, t3, n3, r3) {
        ko.call(this, e3, t3, n3, r3);
      }
      function Xo(e3, t3, n3, r3) {
        if (void 0 === e3)
          throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === t3 || 0 === t3.length)
          throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e3);
        this.name = e3, this.times = Ho.convertArray(t3, this.TimeBufferType), this.values = Ho.convertArray(n3, this.ValueBufferType), this.setInterpolation(r3 || this.DefaultInterpolation);
      }
      function qo(e3, t3, n3) {
        Xo.call(this, e3, t3, n3);
      }
      function Yo(e3, t3, n3, r3) {
        Xo.call(this, e3, t3, n3, r3);
      }
      function Zo(e3, t3, n3, r3) {
        Xo.call(this, e3, t3, n3, r3);
      }
      function Jo(e3, t3, n3, r3) {
        ko.call(this, e3, t3, n3, r3);
      }
      function Ko(e3, t3, n3, r3) {
        Xo.call(this, e3, t3, n3, r3);
      }
      function Qo(e3, t3, n3, r3) {
        Xo.call(this, e3, t3, n3, r3);
      }
      function $o(e3, t3, n3, r3) {
        Xo.call(this, e3, t3, n3, r3);
      }
      function es(e3, t3, n3) {
        this.name = e3, this.tracks = n3, this.duration = void 0 !== t3 ? t3 : -1, this.uuid = Bt.generateUUID(), this.duration < 0 && this.resetDuration();
      }
      function ts(e3) {
        if (void 0 === e3.type)
          throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        var t3 = function(e4) {
          switch (e4.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
              return Zo;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
              return $o;
            case "color":
              return Yo;
            case "quaternion":
              return Ko;
            case "bool":
            case "boolean":
              return qo;
            case "string":
              return Qo;
          }
          throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e4);
        }(e3.type);
        if (void 0 === e3.times) {
          var n3 = [], r3 = [];
          Ho.flattenJSON(e3.keys, n3, r3, "value"), e3.times = n3, e3.values = r3;
        }
        return void 0 !== t3.parse ? t3.parse(e3) : new t3(e3.name, e3.times, e3.values, e3.interpolation);
      }
      function ns(e3) {
        this.manager = void 0 !== e3 ? e3 : $a, this.textures = {};
      }
      function rs(e3) {
        this.manager = void 0 !== e3 ? e3 : $a;
      }
      Object.assign(ko.prototype, { evaluate: function(e3) {
        var t3 = this.parameterPositions, n3 = this._cachedIndex, r3 = t3[n3], i3 = t3[n3 - 1];
        e: {
          t: {
            var a2;
            n: {
              r:
                if (!(e3 < r3)) {
                  for (var o2 = n3 + 2; ; ) {
                    if (void 0 === r3) {
                      if (e3 < i3)
                        break r;
                      return n3 = t3.length, this._cachedIndex = n3, this.afterEnd_(n3 - 1, e3, i3);
                    }
                    if (n3 === o2)
                      break;
                    if (i3 = r3, e3 < (r3 = t3[++n3]))
                      break t;
                  }
                  a2 = t3.length;
                  break n;
                }
              if (e3 >= i3)
                break e;
              var s2 = t3[1];
              e3 < s2 && (n3 = 2, i3 = s2);
              for (o2 = n3 - 2; ; ) {
                if (void 0 === i3)
                  return this._cachedIndex = 0, this.beforeStart_(0, e3, r3);
                if (n3 === o2)
                  break;
                if (r3 = i3, e3 >= (i3 = t3[--n3 - 1]))
                  break t;
              }
              a2 = n3, n3 = 0;
            }
            for (; n3 < a2; ) {
              var c3 = n3 + a2 >>> 1;
              e3 < t3[c3] ? a2 = c3 : n3 = c3 + 1;
            }
            if (r3 = t3[n3], void 0 === (i3 = t3[n3 - 1]))
              return this._cachedIndex = 0, this.beforeStart_(0, e3, r3);
            if (void 0 === r3)
              return n3 = t3.length, this._cachedIndex = n3, this.afterEnd_(n3 - 1, i3, e3);
          }
          this._cachedIndex = n3, this.intervalChanged_(n3, i3, r3);
        }
        return this.interpolate_(n3, i3, e3, r3);
      }, settings: null, DefaultSettings_: {}, getSettings_: function() {
        return this.settings || this.DefaultSettings_;
      }, copySampleValue_: function(e3) {
        for (var t3 = this.resultBuffer, n3 = this.sampleValues, r3 = this.valueSize, i3 = e3 * r3, a2 = 0; a2 !== r3; ++a2)
          t3[a2] = n3[i3 + a2];
        return t3;
      }, interpolate_: function() {
        throw new Error("call to abstract method");
      }, intervalChanged_: function() {
      } }), Object.assign(ko.prototype, { beforeStart_: ko.prototype.copySampleValue_, afterEnd_: ko.prototype.copySampleValue_ }), jo.prototype = Object.assign(Object.create(ko.prototype), { constructor: jo, DefaultSettings_: { endingStart: xt, endingEnd: xt }, intervalChanged_: function(e3, t3, n3) {
        var r3 = this.parameterPositions, i3 = e3 - 2, a2 = e3 + 1, o2 = r3[i3], s2 = r3[a2];
        if (void 0 === o2)
          switch (this.getSettings_().endingStart) {
            case bt:
              i3 = e3, o2 = 2 * t3 - n3;
              break;
            case wt:
              o2 = t3 + r3[i3 = r3.length - 2] - r3[i3 + 1];
              break;
            default:
              i3 = e3, o2 = n3;
          }
        if (void 0 === s2)
          switch (this.getSettings_().endingEnd) {
            case bt:
              a2 = e3, s2 = 2 * n3 - t3;
              break;
            case wt:
              a2 = 1, s2 = n3 + r3[1] - r3[0];
              break;
            default:
              a2 = e3 - 1, s2 = t3;
          }
        var c3 = 0.5 * (n3 - t3), u3 = this.valueSize;
        this._weightPrev = c3 / (t3 - o2), this._weightNext = c3 / (s2 - n3), this._offsetPrev = i3 * u3, this._offsetNext = a2 * u3;
      }, interpolate_: function(e3, t3, n3, r3) {
        for (var i3 = this.resultBuffer, a2 = this.sampleValues, o2 = this.valueSize, s2 = e3 * o2, c3 = s2 - o2, u3 = this._offsetPrev, l3 = this._offsetNext, h3 = this._weightPrev, d3 = this._weightNext, p3 = (n3 - t3) / (r3 - t3), f3 = p3 * p3, m3 = f3 * p3, g3 = -h3 * m3 + 2 * h3 * f3 - h3 * p3, v3 = (1 + h3) * m3 + (-1.5 - 2 * h3) * f3 + (-0.5 + h3) * p3 + 1, y3 = (-1 - d3) * m3 + (1.5 + d3) * f3 + 0.5 * p3, x3 = d3 * m3 - d3 * f3, b3 = 0; b3 !== o2; ++b3)
          i3[b3] = g3 * a2[u3 + b3] + v3 * a2[c3 + b3] + y3 * a2[s2 + b3] + x3 * a2[l3 + b3];
        return i3;
      } }), Vo.prototype = Object.assign(Object.create(ko.prototype), { constructor: Vo, interpolate_: function(e3, t3, n3, r3) {
        for (var i3 = this.resultBuffer, a2 = this.sampleValues, o2 = this.valueSize, s2 = e3 * o2, c3 = s2 - o2, u3 = (n3 - t3) / (r3 - t3), l3 = 1 - u3, h3 = 0; h3 !== o2; ++h3)
          i3[h3] = a2[c3 + h3] * l3 + a2[s2 + h3] * u3;
        return i3;
      } }), Wo.prototype = Object.assign(Object.create(ko.prototype), { constructor: Wo, interpolate_: function(e3) {
        return this.copySampleValue_(e3 - 1);
      } }), Object.assign(Xo, { toJSON: function(e3) {
        var t3, n3 = e3.constructor;
        if (void 0 !== n3.toJSON)
          t3 = n3.toJSON(e3);
        else {
          t3 = { name: e3.name, times: Ho.convertArray(e3.times, Array), values: Ho.convertArray(e3.values, Array) };
          var r3 = e3.getInterpolation();
          r3 !== e3.DefaultInterpolation && (t3.interpolation = r3);
        }
        return t3.type = e3.ValueTypeName, t3;
      } }), Object.assign(Xo.prototype, { constructor: Xo, TimeBufferType: Float32Array, ValueBufferType: Float32Array, DefaultInterpolation: vt, InterpolantFactoryMethodDiscrete: function(e3) {
        return new Wo(this.times, this.values, this.getValueSize(), e3);
      }, InterpolantFactoryMethodLinear: function(e3) {
        return new Vo(this.times, this.values, this.getValueSize(), e3);
      }, InterpolantFactoryMethodSmooth: function(e3) {
        return new jo(this.times, this.values, this.getValueSize(), e3);
      }, setInterpolation: function(e3) {
        var t3;
        switch (e3) {
          case gt:
            t3 = this.InterpolantFactoryMethodDiscrete;
            break;
          case vt:
            t3 = this.InterpolantFactoryMethodLinear;
            break;
          case yt:
            t3 = this.InterpolantFactoryMethodSmooth;
        }
        if (void 0 === t3) {
          var n3 = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
          if (void 0 === this.createInterpolant) {
            if (e3 === this.DefaultInterpolation)
              throw new Error(n3);
            this.setInterpolation(this.DefaultInterpolation);
          }
          return console.warn("THREE.KeyframeTrack:", n3), this;
        }
        return this.createInterpolant = t3, this;
      }, getInterpolation: function() {
        switch (this.createInterpolant) {
          case this.InterpolantFactoryMethodDiscrete:
            return gt;
          case this.InterpolantFactoryMethodLinear:
            return vt;
          case this.InterpolantFactoryMethodSmooth:
            return yt;
        }
      }, getValueSize: function() {
        return this.values.length / this.times.length;
      }, shift: function(e3) {
        if (0 !== e3)
          for (var t3 = this.times, n3 = 0, r3 = t3.length; n3 !== r3; ++n3)
            t3[n3] += e3;
        return this;
      }, scale: function(e3) {
        if (1 !== e3)
          for (var t3 = this.times, n3 = 0, r3 = t3.length; n3 !== r3; ++n3)
            t3[n3] *= e3;
        return this;
      }, trim: function(e3, t3) {
        for (var n3 = this.times, r3 = n3.length, i3 = 0, a2 = r3 - 1; i3 !== r3 && n3[i3] < e3; )
          ++i3;
        for (; -1 !== a2 && n3[a2] > t3; )
          --a2;
        if (++a2, 0 !== i3 || a2 !== r3) {
          i3 >= a2 && (i3 = (a2 = Math.max(a2, 1)) - 1);
          var o2 = this.getValueSize();
          this.times = Ho.arraySlice(n3, i3, a2), this.values = Ho.arraySlice(this.values, i3 * o2, a2 * o2);
        }
        return this;
      }, validate: function() {
        var e3 = true, t3 = this.getValueSize();
        t3 - Math.floor(t3) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e3 = false);
        var n3 = this.times, r3 = this.values, i3 = n3.length;
        0 === i3 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e3 = false);
        for (var a2 = null, o2 = 0; o2 !== i3; o2++) {
          var s2 = n3[o2];
          if ("number" == typeof s2 && isNaN(s2)) {
            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o2, s2), e3 = false;
            break;
          }
          if (null !== a2 && a2 > s2) {
            console.error("THREE.KeyframeTrack: Out of order keys.", this, o2, s2, a2), e3 = false;
            break;
          }
          a2 = s2;
        }
        if (void 0 !== r3 && Ho.isTypedArray(r3)) {
          o2 = 0;
          for (var c3 = r3.length; o2 !== c3; ++o2) {
            var u3 = r3[o2];
            if (isNaN(u3)) {
              console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o2, u3), e3 = false;
              break;
            }
          }
        }
        return e3;
      }, optimize: function() {
        for (var e3 = this.times, t3 = this.values, n3 = this.getValueSize(), r3 = this.getInterpolation() === yt, i3 = 1, a2 = e3.length - 1, o2 = 1; o2 < a2; ++o2) {
          var s2 = false, c3 = e3[o2];
          if (c3 !== e3[o2 + 1] && (1 !== o2 || c3 !== c3[0]))
            if (r3)
              s2 = true;
            else
              for (var u3 = o2 * n3, l3 = u3 - n3, h3 = u3 + n3, d3 = 0; d3 !== n3; ++d3) {
                var p3 = t3[u3 + d3];
                if (p3 !== t3[l3 + d3] || p3 !== t3[h3 + d3]) {
                  s2 = true;
                  break;
                }
              }
          if (s2) {
            if (o2 !== i3) {
              e3[i3] = e3[o2];
              var f3 = o2 * n3, m3 = i3 * n3;
              for (d3 = 0; d3 !== n3; ++d3)
                t3[m3 + d3] = t3[f3 + d3];
            }
            ++i3;
          }
        }
        if (a2 > 0) {
          e3[i3] = e3[a2];
          for (f3 = a2 * n3, m3 = i3 * n3, d3 = 0; d3 !== n3; ++d3)
            t3[m3 + d3] = t3[f3 + d3];
          ++i3;
        }
        return i3 !== e3.length && (this.times = Ho.arraySlice(e3, 0, i3), this.values = Ho.arraySlice(t3, 0, i3 * n3)), this;
      } }), qo.prototype = Object.assign(Object.create(Xo.prototype), { constructor: qo, ValueTypeName: "bool", ValueBufferType: Array, DefaultInterpolation: gt, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), Yo.prototype = Object.assign(Object.create(Xo.prototype), { constructor: Yo, ValueTypeName: "color" }), Zo.prototype = Object.assign(Object.create(Xo.prototype), { constructor: Zo, ValueTypeName: "number" }), Jo.prototype = Object.assign(Object.create(ko.prototype), { constructor: Jo, interpolate_: function(e3, t3, n3, r3) {
        for (var i3 = this.resultBuffer, a2 = this.sampleValues, o2 = this.valueSize, s2 = e3 * o2, c3 = (n3 - t3) / (r3 - t3), u3 = s2 + o2; s2 !== u3; s2 += 4)
          zt.slerpFlat(i3, 0, a2, s2 - o2, a2, s2, c3);
        return i3;
      } }), Ko.prototype = Object.assign(Object.create(Xo.prototype), { constructor: Ko, ValueTypeName: "quaternion", DefaultInterpolation: vt, InterpolantFactoryMethodLinear: function(e3) {
        return new Jo(this.times, this.values, this.getValueSize(), e3);
      }, InterpolantFactoryMethodSmooth: void 0 }), Qo.prototype = Object.assign(Object.create(Xo.prototype), { constructor: Qo, ValueTypeName: "string", ValueBufferType: Array, DefaultInterpolation: gt, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), $o.prototype = Object.assign(Object.create(Xo.prototype), { constructor: $o, ValueTypeName: "vector" }), Object.assign(es, { parse: function(e3) {
        for (var t3 = [], n3 = e3.tracks, r3 = 1 / (e3.fps || 1), i3 = 0, a2 = n3.length; i3 !== a2; ++i3)
          t3.push(ts(n3[i3]).scale(r3));
        return new es(e3.name, e3.duration, t3);
      }, toJSON: function(e3) {
        for (var t3 = [], n3 = e3.tracks, r3 = { name: e3.name, duration: e3.duration, tracks: t3, uuid: e3.uuid }, i3 = 0, a2 = n3.length; i3 !== a2; ++i3)
          t3.push(Xo.toJSON(n3[i3]));
        return r3;
      }, CreateFromMorphTargetSequence: function(e3, t3, n3, r3) {
        for (var i3 = t3.length, a2 = [], o2 = 0; o2 < i3; o2++) {
          var s2 = [], c3 = [];
          s2.push((o2 + i3 - 1) % i3, o2, (o2 + 1) % i3), c3.push(0, 1, 0);
          var u3 = Ho.getKeyframeOrder(s2);
          s2 = Ho.sortedArray(s2, 1, u3), c3 = Ho.sortedArray(c3, 1, u3), r3 || 0 !== s2[0] || (s2.push(i3), c3.push(c3[0])), a2.push(new Zo(".morphTargetInfluences[" + t3[o2].name + "]", s2, c3).scale(1 / n3));
        }
        return new es(e3, -1, a2);
      }, findByName: function(e3, t3) {
        var n3 = e3;
        if (!Array.isArray(e3)) {
          var r3 = e3;
          n3 = r3.geometry && r3.geometry.animations || r3.animations;
        }
        for (var i3 = 0; i3 < n3.length; i3++)
          if (n3[i3].name === t3)
            return n3[i3];
        return null;
      }, CreateClipsFromMorphTargetSequences: function(e3, t3, n3) {
        for (var r3 = {}, i3 = /^([\w-]*?)([\d]+)$/, a2 = 0, o2 = e3.length; a2 < o2; a2++) {
          var s2 = e3[a2], c3 = s2.name.match(i3);
          if (c3 && c3.length > 1) {
            var u3 = r3[h3 = c3[1]];
            u3 || (r3[h3] = u3 = []), u3.push(s2);
          }
        }
        var l3 = [];
        for (var h3 in r3)
          l3.push(es.CreateFromMorphTargetSequence(h3, r3[h3], t3, n3));
        return l3;
      }, parseAnimation: function(e3, t3) {
        if (!e3)
          return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
        for (var n3 = function(e4, t4, n4, r4, i4) {
          if (0 !== n4.length) {
            var a3 = [], o3 = [];
            Ho.flattenJSON(n4, a3, o3, r4), 0 !== a3.length && i4.push(new e4(t4, a3, o3));
          }
        }, r3 = [], i3 = e3.name || "default", a2 = e3.length || -1, o2 = e3.fps || 30, s2 = e3.hierarchy || [], c3 = 0; c3 < s2.length; c3++) {
          var u3 = s2[c3].keys;
          if (u3 && 0 !== u3.length)
            if (u3[0].morphTargets) {
              for (var l3 = {}, h3 = 0; h3 < u3.length; h3++)
                if (u3[h3].morphTargets)
                  for (var d3 = 0; d3 < u3[h3].morphTargets.length; d3++)
                    l3[u3[h3].morphTargets[d3]] = -1;
              for (var p3 in l3) {
                var f3 = [], m3 = [];
                for (d3 = 0; d3 !== u3[h3].morphTargets.length; ++d3) {
                  var g3 = u3[h3];
                  f3.push(g3.time), m3.push(g3.morphTarget === p3 ? 1 : 0);
                }
                r3.push(new Zo(".morphTargetInfluence[" + p3 + "]", f3, m3));
              }
              a2 = l3.length * (o2 || 1);
            } else {
              var v3 = ".bones[" + t3[c3].name + "]";
              n3($o, v3 + ".position", u3, "pos", r3), n3(Ko, v3 + ".quaternion", u3, "rot", r3), n3($o, v3 + ".scale", u3, "scl", r3);
            }
        }
        return 0 === r3.length ? null : new es(i3, a2, r3);
      } }), Object.assign(es.prototype, { resetDuration: function() {
        for (var e3 = 0, t3 = 0, n3 = this.tracks.length; t3 !== n3; ++t3) {
          var r3 = this.tracks[t3];
          e3 = Math.max(e3, r3.times[r3.times.length - 1]);
        }
        return this.duration = e3, this;
      }, trim: function() {
        for (var e3 = 0; e3 < this.tracks.length; e3++)
          this.tracks[e3].trim(0, this.duration);
        return this;
      }, validate: function() {
        for (var e3 = true, t3 = 0; t3 < this.tracks.length; t3++)
          e3 = e3 && this.tracks[t3].validate();
        return e3;
      }, optimize: function() {
        for (var e3 = 0; e3 < this.tracks.length; e3++)
          this.tracks[e3].optimize();
        return this;
      } }), Object.assign(ns.prototype, { load: function(e3, t3, n3, r3) {
        var i3 = this;
        new to(i3.manager).load(e3, function(e4) {
          t3(i3.parse(JSON.parse(e4)));
        }, n3, r3);
      }, setTextures: function(e3) {
        this.textures = e3;
      }, parse: function(e3) {
        var t3 = this.textures;
        function n3(e4) {
          return void 0 === t3[e4] && console.warn("THREE.MaterialLoader: Undefined texture", e4), t3[e4];
        }
        var r3 = new Ja2[e3.type]();
        if (void 0 !== e3.uuid && (r3.uuid = e3.uuid), void 0 !== e3.name && (r3.name = e3.name), void 0 !== e3.color && r3.color.setHex(e3.color), void 0 !== e3.roughness && (r3.roughness = e3.roughness), void 0 !== e3.metalness && (r3.metalness = e3.metalness), void 0 !== e3.emissive && r3.emissive.setHex(e3.emissive), void 0 !== e3.specular && r3.specular.setHex(e3.specular), void 0 !== e3.shininess && (r3.shininess = e3.shininess), void 0 !== e3.clearCoat && (r3.clearCoat = e3.clearCoat), void 0 !== e3.clearCoatRoughness && (r3.clearCoatRoughness = e3.clearCoatRoughness), void 0 !== e3.uniforms && (r3.uniforms = e3.uniforms), void 0 !== e3.vertexShader && (r3.vertexShader = e3.vertexShader), void 0 !== e3.fragmentShader && (r3.fragmentShader = e3.fragmentShader), void 0 !== e3.vertexColors && (r3.vertexColors = e3.vertexColors), void 0 !== e3.fog && (r3.fog = e3.fog), void 0 !== e3.flatShading && (r3.flatShading = e3.flatShading), void 0 !== e3.blending && (r3.blending = e3.blending), void 0 !== e3.side && (r3.side = e3.side), void 0 !== e3.opacity && (r3.opacity = e3.opacity), void 0 !== e3.transparent && (r3.transparent = e3.transparent), void 0 !== e3.alphaTest && (r3.alphaTest = e3.alphaTest), void 0 !== e3.depthTest && (r3.depthTest = e3.depthTest), void 0 !== e3.depthWrite && (r3.depthWrite = e3.depthWrite), void 0 !== e3.colorWrite && (r3.colorWrite = e3.colorWrite), void 0 !== e3.wireframe && (r3.wireframe = e3.wireframe), void 0 !== e3.wireframeLinewidth && (r3.wireframeLinewidth = e3.wireframeLinewidth), void 0 !== e3.wireframeLinecap && (r3.wireframeLinecap = e3.wireframeLinecap), void 0 !== e3.wireframeLinejoin && (r3.wireframeLinejoin = e3.wireframeLinejoin), void 0 !== e3.rotation && (r3.rotation = e3.rotation), 1 !== e3.linewidth && (r3.linewidth = e3.linewidth), void 0 !== e3.dashSize && (r3.dashSize = e3.dashSize), void 0 !== e3.gapSize && (r3.gapSize = e3.gapSize), void 0 !== e3.scale && (r3.scale = e3.scale), void 0 !== e3.polygonOffset && (r3.polygonOffset = e3.polygonOffset), void 0 !== e3.polygonOffsetFactor && (r3.polygonOffsetFactor = e3.polygonOffsetFactor), void 0 !== e3.polygonOffsetUnits && (r3.polygonOffsetUnits = e3.polygonOffsetUnits), void 0 !== e3.skinning && (r3.skinning = e3.skinning), void 0 !== e3.morphTargets && (r3.morphTargets = e3.morphTargets), void 0 !== e3.dithering && (r3.dithering = e3.dithering), void 0 !== e3.visible && (r3.visible = e3.visible), void 0 !== e3.userData && (r3.userData = e3.userData), void 0 !== e3.shading && (r3.flatShading = 1 === e3.shading), void 0 !== e3.size && (r3.size = e3.size), void 0 !== e3.sizeAttenuation && (r3.sizeAttenuation = e3.sizeAttenuation), void 0 !== e3.map && (r3.map = n3(e3.map)), void 0 !== e3.alphaMap && (r3.alphaMap = n3(e3.alphaMap), r3.transparent = true), void 0 !== e3.bumpMap && (r3.bumpMap = n3(e3.bumpMap)), void 0 !== e3.bumpScale && (r3.bumpScale = e3.bumpScale), void 0 !== e3.normalMap && (r3.normalMap = n3(e3.normalMap)), void 0 !== e3.normalMapType && (r3.normalMapType = e3.normalMapType), void 0 !== e3.normalScale) {
          var i3 = e3.normalScale;
          false === Array.isArray(i3) && (i3 = [i3, i3]), r3.normalScale = new Ft().fromArray(i3);
        }
        return void 0 !== e3.displacementMap && (r3.displacementMap = n3(e3.displacementMap)), void 0 !== e3.displacementScale && (r3.displacementScale = e3.displacementScale), void 0 !== e3.displacementBias && (r3.displacementBias = e3.displacementBias), void 0 !== e3.roughnessMap && (r3.roughnessMap = n3(e3.roughnessMap)), void 0 !== e3.metalnessMap && (r3.metalnessMap = n3(e3.metalnessMap)), void 0 !== e3.emissiveMap && (r3.emissiveMap = n3(e3.emissiveMap)), void 0 !== e3.emissiveIntensity && (r3.emissiveIntensity = e3.emissiveIntensity), void 0 !== e3.specularMap && (r3.specularMap = n3(e3.specularMap)), void 0 !== e3.envMap && (r3.envMap = n3(e3.envMap)), void 0 !== e3.reflectivity && (r3.reflectivity = e3.reflectivity), void 0 !== e3.lightMap && (r3.lightMap = n3(e3.lightMap)), void 0 !== e3.lightMapIntensity && (r3.lightMapIntensity = e3.lightMapIntensity), void 0 !== e3.aoMap && (r3.aoMap = n3(e3.aoMap)), void 0 !== e3.aoMapIntensity && (r3.aoMapIntensity = e3.aoMapIntensity), void 0 !== e3.gradientMap && (r3.gradientMap = n3(e3.gradientMap)), r3;
      } }), Object.assign(rs.prototype, { load: function(e3, t3, n3, r3) {
        var i3 = this;
        new to(i3.manager).load(e3, function(e4) {
          t3(i3.parse(JSON.parse(e4)));
        }, n3, r3);
      }, parse: function(e3) {
        var t3 = new Pn(), n3 = e3.data.index;
        if (void 0 !== n3) {
          var r3 = new is[n3.type](n3.array);
          t3.setIndex(new yn(r3, 1));
        }
        var i3 = e3.data.attributes;
        for (var a2 in i3) {
          var o2 = i3[a2];
          r3 = new is[o2.type](o2.array);
          t3.addAttribute(a2, new yn(r3, o2.itemSize, o2.normalized));
        }
        var s2 = e3.data.groups || e3.data.drawcalls || e3.data.offsets;
        if (void 0 !== s2)
          for (var c3 = 0, u3 = s2.length; c3 !== u3; ++c3) {
            var l3 = s2[c3];
            t3.addGroup(l3.start, l3.count, l3.materialIndex);
          }
        var h3 = e3.data.boundingSphere;
        if (void 0 !== h3) {
          var d3 = new Ht();
          void 0 !== h3.center && d3.fromArray(h3.center), t3.boundingSphere = new Kt(d3, h3.radius);
        }
        return t3;
      } });
      var is = { Int8Array, Uint8Array, Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array };
      function as() {
      }
      as.Handlers = { handlers: [], add: function(e3, t3) {
        this.handlers.push(e3, t3);
      }, get: function(e3) {
        for (var t3 = this.handlers, n3 = 0, r3 = t3.length; n3 < r3; n3 += 2) {
          var i3 = t3[n3], a2 = t3[n3 + 1];
          if (i3.test(e3))
            return a2;
        }
        return null;
      } }, Object.assign(as.prototype, { crossOrigin: "anonymous", onLoadStart: function() {
      }, onLoadProgress: function() {
      }, onLoadComplete: function() {
      }, initMaterials: function(e3, t3, n3) {
        for (var r3 = [], i3 = 0; i3 < e3.length; ++i3)
          r3[i3] = this.createMaterial(e3[i3], t3, n3);
        return r3;
      }, createMaterial: function() {
        var e3 = { NoBlending: M2, NormalBlending: E2, AdditiveBlending: T2, SubtractiveBlending: S2, MultiplyBlending: A2, CustomBlending: L2 }, t3 = new rn(), n3 = new oo(), r3 = new ns();
        return function(i3, a2, o2) {
          var s2 = {};
          function c3(e4, t4, r4, i4, c4) {
            var u4, l4 = a2 + e4, h4 = as.Handlers.get(l4);
            null !== h4 ? u4 = h4.load(l4) : (n3.setCrossOrigin(o2), u4 = n3.load(l4)), void 0 !== t4 && (u4.repeat.fromArray(t4), 1 !== t4[0] && (u4.wrapS = me2), 1 !== t4[1] && (u4.wrapT = me2)), void 0 !== r4 && u4.offset.fromArray(r4), void 0 !== i4 && ("repeat" === i4[0] && (u4.wrapS = me2), "mirror" === i4[0] && (u4.wrapS = ve2), "repeat" === i4[1] && (u4.wrapT = me2), "mirror" === i4[1] && (u4.wrapT = ve2)), void 0 !== c4 && (u4.anisotropy = c4);
            var d3 = Bt.generateUUID();
            return s2[d3] = u4, d3;
          }
          var u3 = { uuid: Bt.generateUUID(), type: "MeshLambertMaterial" };
          for (var l3 in i3) {
            var h3 = i3[l3];
            switch (l3) {
              case "DbgColor":
              case "DbgIndex":
              case "opticalDensity":
              case "illumination":
                break;
              case "DbgName":
                u3.name = h3;
                break;
              case "blending":
                u3.blending = e3[h3];
                break;
              case "colorAmbient":
              case "mapAmbient":
                console.warn("THREE.Loader.createMaterial:", l3, "is no longer supported.");
                break;
              case "colorDiffuse":
                u3.color = t3.fromArray(h3).getHex();
                break;
              case "colorSpecular":
                u3.specular = t3.fromArray(h3).getHex();
                break;
              case "colorEmissive":
                u3.emissive = t3.fromArray(h3).getHex();
                break;
              case "specularCoef":
                u3.shininess = h3;
                break;
              case "shading":
                "basic" === h3.toLowerCase() && (u3.type = "MeshBasicMaterial"), "phong" === h3.toLowerCase() && (u3.type = "MeshPhongMaterial"), "standard" === h3.toLowerCase() && (u3.type = "MeshStandardMaterial");
                break;
              case "mapDiffuse":
                u3.map = c3(h3, i3.mapDiffuseRepeat, i3.mapDiffuseOffset, i3.mapDiffuseWrap, i3.mapDiffuseAnisotropy);
                break;
              case "mapDiffuseRepeat":
              case "mapDiffuseOffset":
              case "mapDiffuseWrap":
              case "mapDiffuseAnisotropy":
                break;
              case "mapEmissive":
                u3.emissiveMap = c3(h3, i3.mapEmissiveRepeat, i3.mapEmissiveOffset, i3.mapEmissiveWrap, i3.mapEmissiveAnisotropy);
                break;
              case "mapEmissiveRepeat":
              case "mapEmissiveOffset":
              case "mapEmissiveWrap":
              case "mapEmissiveAnisotropy":
                break;
              case "mapLight":
                u3.lightMap = c3(h3, i3.mapLightRepeat, i3.mapLightOffset, i3.mapLightWrap, i3.mapLightAnisotropy);
                break;
              case "mapLightRepeat":
              case "mapLightOffset":
              case "mapLightWrap":
              case "mapLightAnisotropy":
                break;
              case "mapAO":
                u3.aoMap = c3(h3, i3.mapAORepeat, i3.mapAOOffset, i3.mapAOWrap, i3.mapAOAnisotropy);
                break;
              case "mapAORepeat":
              case "mapAOOffset":
              case "mapAOWrap":
              case "mapAOAnisotropy":
                break;
              case "mapBump":
                u3.bumpMap = c3(h3, i3.mapBumpRepeat, i3.mapBumpOffset, i3.mapBumpWrap, i3.mapBumpAnisotropy);
                break;
              case "mapBumpScale":
                u3.bumpScale = h3;
                break;
              case "mapBumpRepeat":
              case "mapBumpOffset":
              case "mapBumpWrap":
              case "mapBumpAnisotropy":
                break;
              case "mapNormal":
                u3.normalMap = c3(h3, i3.mapNormalRepeat, i3.mapNormalOffset, i3.mapNormalWrap, i3.mapNormalAnisotropy);
                break;
              case "mapNormalFactor":
                u3.normalScale = h3;
                break;
              case "mapNormalRepeat":
              case "mapNormalOffset":
              case "mapNormalWrap":
              case "mapNormalAnisotropy":
                break;
              case "mapSpecular":
                u3.specularMap = c3(h3, i3.mapSpecularRepeat, i3.mapSpecularOffset, i3.mapSpecularWrap, i3.mapSpecularAnisotropy);
                break;
              case "mapSpecularRepeat":
              case "mapSpecularOffset":
              case "mapSpecularWrap":
              case "mapSpecularAnisotropy":
                break;
              case "mapMetalness":
                u3.metalnessMap = c3(h3, i3.mapMetalnessRepeat, i3.mapMetalnessOffset, i3.mapMetalnessWrap, i3.mapMetalnessAnisotropy);
                break;
              case "mapMetalnessRepeat":
              case "mapMetalnessOffset":
              case "mapMetalnessWrap":
              case "mapMetalnessAnisotropy":
                break;
              case "mapRoughness":
                u3.roughnessMap = c3(h3, i3.mapRoughnessRepeat, i3.mapRoughnessOffset, i3.mapRoughnessWrap, i3.mapRoughnessAnisotropy);
                break;
              case "mapRoughnessRepeat":
              case "mapRoughnessOffset":
              case "mapRoughnessWrap":
              case "mapRoughnessAnisotropy":
                break;
              case "mapAlpha":
                u3.alphaMap = c3(h3, i3.mapAlphaRepeat, i3.mapAlphaOffset, i3.mapAlphaWrap, i3.mapAlphaAnisotropy);
                break;
              case "mapAlphaRepeat":
              case "mapAlphaOffset":
              case "mapAlphaWrap":
              case "mapAlphaAnisotropy":
                break;
              case "flipSided":
                u3.side = g2;
                break;
              case "doubleSided":
                u3.side = v2;
                break;
              case "transparency":
                console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), u3.opacity = h3;
                break;
              case "depthTest":
              case "depthWrite":
              case "colorWrite":
              case "opacity":
              case "reflectivity":
              case "transparent":
              case "visible":
              case "wireframe":
                u3[l3] = h3;
                break;
              case "vertexColors":
                true === h3 && (u3.vertexColors = _2), "face" === h3 && (u3.vertexColors = w2);
                break;
              default:
                console.error("THREE.Loader.createMaterial: Unsupported", l3, h3);
            }
          }
          return "MeshBasicMaterial" === u3.type && delete u3.emissive, "MeshPhongMaterial" !== u3.type && delete u3.specular, u3.opacity < 1 && (u3.transparent = true), r3.setTextures(s2), r3.parse(u3);
        };
      }() });
      var os = { decodeText: function(e3) {
        if ("undefined" != typeof TextDecoder)
          return new TextDecoder().decode(e3);
        for (var t3 = "", n3 = 0, r3 = e3.length; n3 < r3; n3++)
          t3 += String.fromCharCode(e3[n3]);
        return decodeURIComponent(escape(t3));
      }, extractUrlBase: function(e3) {
        var t3 = e3.lastIndexOf("/");
        return -1 === t3 ? "./" : e3.substr(0, t3 + 1);
      } };
      function ss(e3) {
        "boolean" == typeof e3 && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), e3 = void 0), this.manager = void 0 !== e3 ? e3 : $a, this.withCredentials = false;
      }
      function cs(e3) {
        this.manager = void 0 !== e3 ? e3 : $a, this.texturePath = "";
      }
      Object.assign(ss.prototype, { crossOrigin: "anonymous", load: function(e3, t3, n3, r3) {
        var i3 = this, a2 = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : os.extractUrlBase(e3), o2 = new to(this.manager);
        o2.setWithCredentials(this.withCredentials), o2.load(e3, function(n4) {
          var r4 = JSON.parse(n4), o3 = r4.metadata;
          if (void 0 !== o3) {
            var s2 = o3.type;
            if (void 0 !== s2 && "object" === s2.toLowerCase())
              return void console.error("THREE.JSONLoader: " + e3 + " should be loaded with THREE.ObjectLoader instead.");
          }
          var c3 = i3.parse(r4, a2);
          t3(c3.geometry, c3.materials);
        }, n3, r3);
      }, setCrossOrigin: function(e3) {
        return this.crossOrigin = e3, this;
      }, setTexturePath: function(e3) {
        return this.texturePath = e3, this;
      }, parse: function() {
        return function(e3, t3) {
          void 0 !== e3.data && (e3 = e3.data), void 0 !== e3.scale ? e3.scale = 1 / e3.scale : e3.scale = 1;
          var n3 = new vn();
          return function(e4, t4) {
            function n4(e5, t5) {
              return e5 & 1 << t5;
            }
            var r3, i3, a2, o2, s2, c3, u3, l3, h3, d3, p3, f3, m3, g3, v3, y3, x3, b3, w3, _3, M3, E3, T3, S3, A3, L3 = e4.faces, R3 = e4.vertices, C3 = e4.normals, P3 = e4.colors, O3 = e4.scale, N3 = 0;
            if (void 0 !== e4.uvs) {
              for (r3 = 0; r3 < e4.uvs.length; r3++)
                e4.uvs[r3].length && N3++;
              for (r3 = 0; r3 < N3; r3++)
                t4.faceVertexUvs[r3] = [];
            }
            for (o2 = 0, s2 = R3.length; o2 < s2; )
              (b3 = new Ht()).x = R3[o2++] * O3, b3.y = R3[o2++] * O3, b3.z = R3[o2++] * O3, t4.vertices.push(b3);
            for (o2 = 0, s2 = L3.length; o2 < s2; )
              if (p3 = n4(d3 = L3[o2++], 0), f3 = n4(d3, 1), m3 = n4(d3, 3), g3 = n4(d3, 4), v3 = n4(d3, 5), y3 = n4(d3, 6), x3 = n4(d3, 7), p3) {
                if ((_3 = new mn()).a = L3[o2], _3.b = L3[o2 + 1], _3.c = L3[o2 + 3], (M3 = new mn()).a = L3[o2 + 1], M3.b = L3[o2 + 2], M3.c = L3[o2 + 3], o2 += 4, f3 && (h3 = L3[o2++], _3.materialIndex = h3, M3.materialIndex = h3), a2 = t4.faces.length, m3)
                  for (r3 = 0; r3 < N3; r3++)
                    for (S3 = e4.uvs[r3], t4.faceVertexUvs[r3][a2] = [], t4.faceVertexUvs[r3][a2 + 1] = [], i3 = 0; i3 < 4; i3++)
                      A3 = new Ft(S3[2 * (l3 = L3[o2++])], S3[2 * l3 + 1]), 2 !== i3 && t4.faceVertexUvs[r3][a2].push(A3), 0 !== i3 && t4.faceVertexUvs[r3][a2 + 1].push(A3);
                if (g3 && (u3 = 3 * L3[o2++], _3.normal.set(C3[u3++], C3[u3++], C3[u3]), M3.normal.copy(_3.normal)), v3)
                  for (r3 = 0; r3 < 4; r3++)
                    u3 = 3 * L3[o2++], T3 = new Ht(C3[u3++], C3[u3++], C3[u3]), 2 !== r3 && _3.vertexNormals.push(T3), 0 !== r3 && M3.vertexNormals.push(T3);
                if (y3 && (E3 = P3[c3 = L3[o2++]], _3.color.setHex(E3), M3.color.setHex(E3)), x3)
                  for (r3 = 0; r3 < 4; r3++)
                    E3 = P3[c3 = L3[o2++]], 2 !== r3 && _3.vertexColors.push(new rn(E3)), 0 !== r3 && M3.vertexColors.push(new rn(E3));
                t4.faces.push(_3), t4.faces.push(M3);
              } else {
                if ((w3 = new mn()).a = L3[o2++], w3.b = L3[o2++], w3.c = L3[o2++], f3 && (h3 = L3[o2++], w3.materialIndex = h3), a2 = t4.faces.length, m3)
                  for (r3 = 0; r3 < N3; r3++)
                    for (S3 = e4.uvs[r3], t4.faceVertexUvs[r3][a2] = [], i3 = 0; i3 < 3; i3++)
                      A3 = new Ft(S3[2 * (l3 = L3[o2++])], S3[2 * l3 + 1]), t4.faceVertexUvs[r3][a2].push(A3);
                if (g3 && (u3 = 3 * L3[o2++], w3.normal.set(C3[u3++], C3[u3++], C3[u3])), v3)
                  for (r3 = 0; r3 < 3; r3++)
                    u3 = 3 * L3[o2++], T3 = new Ht(C3[u3++], C3[u3++], C3[u3]), w3.vertexNormals.push(T3);
                if (y3 && (c3 = L3[o2++], w3.color.setHex(P3[c3])), x3)
                  for (r3 = 0; r3 < 3; r3++)
                    c3 = L3[o2++], w3.vertexColors.push(new rn(P3[c3]));
                t4.faces.push(w3);
              }
          }(e3, n3), function(e4, t4) {
            var n4 = void 0 !== e4.influencesPerVertex ? e4.influencesPerVertex : 2;
            if (e4.skinWeights)
              for (var r3 = 0, i3 = e4.skinWeights.length; r3 < i3; r3 += n4) {
                var a2 = e4.skinWeights[r3], o2 = n4 > 1 ? e4.skinWeights[r3 + 1] : 0, s2 = n4 > 2 ? e4.skinWeights[r3 + 2] : 0, c3 = n4 > 3 ? e4.skinWeights[r3 + 3] : 0;
                t4.skinWeights.push(new Xt(a2, o2, s2, c3));
              }
            if (e4.skinIndices)
              for (r3 = 0, i3 = e4.skinIndices.length; r3 < i3; r3 += n4) {
                var u3 = e4.skinIndices[r3], l3 = n4 > 1 ? e4.skinIndices[r3 + 1] : 0, h3 = n4 > 2 ? e4.skinIndices[r3 + 2] : 0, d3 = n4 > 3 ? e4.skinIndices[r3 + 3] : 0;
                t4.skinIndices.push(new Xt(u3, l3, h3, d3));
              }
            t4.bones = e4.bones, t4.bones && t4.bones.length > 0 && (t4.skinWeights.length !== t4.skinIndices.length || t4.skinIndices.length !== t4.vertices.length) && console.warn("When skinning, number of vertices (" + t4.vertices.length + "), skinIndices (" + t4.skinIndices.length + "), and skinWeights (" + t4.skinWeights.length + ") should match.");
          }(e3, n3), function(e4, t4) {
            var n4 = e4.scale;
            if (void 0 !== e4.morphTargets)
              for (var r3 = 0, i3 = e4.morphTargets.length; r3 < i3; r3++) {
                t4.morphTargets[r3] = {}, t4.morphTargets[r3].name = e4.morphTargets[r3].name, t4.morphTargets[r3].vertices = [];
                for (var a2 = t4.morphTargets[r3].vertices, o2 = e4.morphTargets[r3].vertices, s2 = 0, c3 = o2.length; s2 < c3; s2 += 3) {
                  var u3 = new Ht();
                  u3.x = o2[s2] * n4, u3.y = o2[s2 + 1] * n4, u3.z = o2[s2 + 2] * n4, a2.push(u3);
                }
              }
            if (void 0 !== e4.morphColors && e4.morphColors.length > 0) {
              console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
              var l3 = t4.faces, h3 = e4.morphColors[0].colors;
              for (r3 = 0, i3 = l3.length; r3 < i3; r3++)
                l3[r3].color.fromArray(h3, 3 * r3);
            }
          }(e3, n3), function(e4, t4) {
            var n4 = [], r3 = [];
            void 0 !== e4.animation && r3.push(e4.animation), void 0 !== e4.animations && (e4.animations.length ? r3 = r3.concat(e4.animations) : r3.push(e4.animations));
            for (var i3 = 0; i3 < r3.length; i3++) {
              var a2 = es.parseAnimation(r3[i3], t4.bones);
              a2 && n4.push(a2);
            }
            if (t4.morphTargets) {
              var o2 = es.CreateClipsFromMorphTargetSequences(t4.morphTargets, 10);
              n4 = n4.concat(o2);
            }
            n4.length > 0 && (t4.animations = n4);
          }(e3, n3), n3.computeFaceNormals(), n3.computeBoundingSphere(), void 0 === e3.materials || 0 === e3.materials.length ? { geometry: n3 } : { geometry: n3, materials: as.prototype.initMaterials(e3.materials, t3, this.crossOrigin) };
        };
      }() }), Object.assign(cs.prototype, { crossOrigin: "anonymous", load: function(e3, t3, n3, r3) {
        "" === this.texturePath && (this.texturePath = e3.substring(0, e3.lastIndexOf("/") + 1));
        var i3 = this;
        new to(i3.manager).load(e3, function(n4) {
          var a2 = null;
          try {
            a2 = JSON.parse(n4);
          } catch (t4) {
            return void 0 !== r3 && r3(t4), void console.error("THREE:ObjectLoader: Can't parse " + e3 + ".", t4.message);
          }
          var o2 = a2.metadata;
          void 0 !== o2 && void 0 !== o2.type && "geometry" !== o2.type.toLowerCase() ? i3.parse(a2, t3) : console.error("THREE.ObjectLoader: Can't load " + e3 + ". Use THREE.JSONLoader instead.");
        }, n3, r3);
      }, setTexturePath: function(e3) {
        return this.texturePath = e3, this;
      }, setCrossOrigin: function(e3) {
        return this.crossOrigin = e3, this;
      }, parse: function(e3, t3) {
        var n3 = this.parseShape(e3.shapes), r3 = this.parseGeometries(e3.geometries, n3), i3 = this.parseImages(e3.images, function() {
          void 0 !== t3 && t3(s2);
        }), a2 = this.parseTextures(e3.textures, i3), o2 = this.parseMaterials(e3.materials, a2), s2 = this.parseObject(e3.object, r3, o2);
        return e3.animations && (s2.animations = this.parseAnimations(e3.animations)), void 0 !== e3.images && 0 !== e3.images.length || void 0 !== t3 && t3(s2), s2;
      }, parseShape: function(e3) {
        var t3 = {};
        if (void 0 !== e3)
          for (var n3 = 0, r3 = e3.length; n3 < r3; n3++) {
            var i3 = new Co().fromJSON(e3[n3]);
            t3[i3.uuid] = i3;
          }
        return t3;
      }, parseGeometries: function(e3, t3) {
        var n3 = {};
        if (void 0 !== e3)
          for (var r3 = new ss(), i3 = new rs(), a2 = 0, o2 = e3.length; a2 < o2; a2++) {
            var s2, c3 = e3[a2];
            switch (c3.type) {
              case "PlaneGeometry":
              case "PlaneBufferGeometry":
                s2 = new za2[c3.type](c3.width, c3.height, c3.widthSegments, c3.heightSegments);
                break;
              case "BoxGeometry":
              case "BoxBufferGeometry":
              case "CubeGeometry":
                s2 = new za2[c3.type](c3.width, c3.height, c3.depth, c3.widthSegments, c3.heightSegments, c3.depthSegments);
                break;
              case "CircleGeometry":
              case "CircleBufferGeometry":
                s2 = new za2[c3.type](c3.radius, c3.segments, c3.thetaStart, c3.thetaLength);
                break;
              case "CylinderGeometry":
              case "CylinderBufferGeometry":
                s2 = new za2[c3.type](c3.radiusTop, c3.radiusBottom, c3.height, c3.radialSegments, c3.heightSegments, c3.openEnded, c3.thetaStart, c3.thetaLength);
                break;
              case "ConeGeometry":
              case "ConeBufferGeometry":
                s2 = new za2[c3.type](c3.radius, c3.height, c3.radialSegments, c3.heightSegments, c3.openEnded, c3.thetaStart, c3.thetaLength);
                break;
              case "SphereGeometry":
              case "SphereBufferGeometry":
                s2 = new za2[c3.type](c3.radius, c3.widthSegments, c3.heightSegments, c3.phiStart, c3.phiLength, c3.thetaStart, c3.thetaLength);
                break;
              case "DodecahedronGeometry":
              case "DodecahedronBufferGeometry":
              case "IcosahedronGeometry":
              case "IcosahedronBufferGeometry":
              case "OctahedronGeometry":
              case "OctahedronBufferGeometry":
              case "TetrahedronGeometry":
              case "TetrahedronBufferGeometry":
                s2 = new za2[c3.type](c3.radius, c3.detail);
                break;
              case "RingGeometry":
              case "RingBufferGeometry":
                s2 = new za2[c3.type](c3.innerRadius, c3.outerRadius, c3.thetaSegments, c3.phiSegments, c3.thetaStart, c3.thetaLength);
                break;
              case "TorusGeometry":
              case "TorusBufferGeometry":
                s2 = new za2[c3.type](c3.radius, c3.tube, c3.radialSegments, c3.tubularSegments, c3.arc);
                break;
              case "TorusKnotGeometry":
              case "TorusKnotBufferGeometry":
                s2 = new za2[c3.type](c3.radius, c3.tube, c3.tubularSegments, c3.radialSegments, c3.p, c3.q);
                break;
              case "LatheGeometry":
              case "LatheBufferGeometry":
                s2 = new za2[c3.type](c3.points, c3.segments, c3.phiStart, c3.phiLength);
                break;
              case "PolyhedronGeometry":
              case "PolyhedronBufferGeometry":
                s2 = new za2[c3.type](c3.vertices, c3.indices, c3.radius, c3.details);
                break;
              case "ShapeGeometry":
              case "ShapeBufferGeometry":
                for (var u3 = [], l3 = 0, h3 = c3.shapes.length; l3 < h3; l3++) {
                  var d3 = t3[c3.shapes[l3]];
                  u3.push(d3);
                }
                s2 = new za2[c3.type](u3, c3.curveSegments);
                break;
              case "ExtrudeGeometry":
              case "ExtrudeBufferGeometry":
                for (u3 = [], l3 = 0, h3 = c3.shapes.length; l3 < h3; l3++) {
                  d3 = t3[c3.shapes[l3]];
                  u3.push(d3);
                }
                var p3 = c3.options.extrudePath;
                void 0 !== p3 && (c3.options.extrudePath = new Ao[p3.type]().fromJSON(p3)), s2 = new za2[c3.type](u3, c3.options);
                break;
              case "BufferGeometry":
                s2 = i3.parse(c3);
                break;
              case "Geometry":
                s2 = r3.parse(c3, this.texturePath).geometry;
                break;
              default:
                console.warn('THREE.ObjectLoader: Unsupported geometry type "' + c3.type + '"');
                continue;
            }
            s2.uuid = c3.uuid, void 0 !== c3.name && (s2.name = c3.name), true === s2.isBufferGeometry && void 0 !== c3.userData && (s2.userData = c3.userData), n3[c3.uuid] = s2;
          }
        return n3;
      }, parseMaterials: function(e3, t3) {
        var n3 = {};
        if (void 0 !== e3) {
          var r3 = new ns();
          r3.setTextures(t3);
          for (var i3 = 0, a2 = e3.length; i3 < a2; i3++) {
            var o2 = e3[i3];
            if ("MultiMaterial" === o2.type) {
              for (var s2 = [], c3 = 0; c3 < o2.materials.length; c3++)
                s2.push(r3.parse(o2.materials[c3]));
              n3[o2.uuid] = s2;
            } else
              n3[o2.uuid] = r3.parse(o2);
          }
        }
        return n3;
      }, parseAnimations: function(e3) {
        for (var t3 = [], n3 = 0; n3 < e3.length; n3++) {
          var r3 = e3[n3], i3 = es.parse(r3);
          void 0 !== r3.uuid && (i3.uuid = r3.uuid), t3.push(i3);
        }
        return t3;
      }, parseImages: function(e3, t3) {
        var n3 = this, r3 = {};
        function i3(e4) {
          return n3.manager.itemStart(e4), a2.load(e4, function() {
            n3.manager.itemEnd(e4);
          }, void 0, function() {
            n3.manager.itemEnd(e4), n3.manager.itemError(e4);
          });
        }
        if (void 0 !== e3 && e3.length > 0) {
          var a2 = new io(new Qa2(t3));
          a2.setCrossOrigin(this.crossOrigin);
          for (var o2 = 0, s2 = e3.length; o2 < s2; o2++) {
            var c3 = e3[o2], u3 = c3.url;
            if (Array.isArray(u3)) {
              r3[c3.uuid] = [];
              for (var l3 = 0, h3 = u3.length; l3 < h3; l3++) {
                var d3 = u3[l3], p3 = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(d3) ? d3 : n3.texturePath + d3;
                r3[c3.uuid].push(i3(p3));
              }
            } else {
              p3 = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c3.url) ? c3.url : n3.texturePath + c3.url;
              r3[c3.uuid] = i3(p3);
            }
          }
        }
        return r3;
      }, parseTextures: function(e3, t3) {
        function n3(e4, t4) {
          return "number" == typeof e4 ? e4 : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e4), t4[e4]);
        }
        var r3 = {};
        if (void 0 !== e3)
          for (var i3 = 0, a2 = e3.length; i3 < a2; i3++) {
            var o2, s2 = e3[i3];
            void 0 === s2.image && console.warn('THREE.ObjectLoader: No "image" specified for', s2.uuid), void 0 === t3[s2.image] && console.warn("THREE.ObjectLoader: Undefined image", s2.image), (o2 = Array.isArray(t3[s2.image]) ? new Vn(t3[s2.image]) : new Wt(t3[s2.image])).needsUpdate = true, o2.uuid = s2.uuid, void 0 !== s2.name && (o2.name = s2.name), void 0 !== s2.mapping && (o2.mapping = n3(s2.mapping, ls)), void 0 !== s2.offset && o2.offset.fromArray(s2.offset), void 0 !== s2.repeat && o2.repeat.fromArray(s2.repeat), void 0 !== s2.center && o2.center.fromArray(s2.center), void 0 !== s2.rotation && (o2.rotation = s2.rotation), void 0 !== s2.wrap && (o2.wrapS = n3(s2.wrap[0], hs), o2.wrapT = n3(s2.wrap[1], hs)), void 0 !== s2.format && (o2.format = s2.format), void 0 !== s2.minFilter && (o2.minFilter = n3(s2.minFilter, ds)), void 0 !== s2.magFilter && (o2.magFilter = n3(s2.magFilter, ds)), void 0 !== s2.anisotropy && (o2.anisotropy = s2.anisotropy), void 0 !== s2.flipY && (o2.flipY = s2.flipY), r3[s2.uuid] = o2;
          }
        return r3;
      }, parseObject: function(e3, t3, n3) {
        var r3;
        function i3(e4) {
          return void 0 === t3[e4] && console.warn("THREE.ObjectLoader: Undefined geometry", e4), t3[e4];
        }
        function a2(e4) {
          if (void 0 !== e4) {
            if (Array.isArray(e4)) {
              for (var t4 = [], r4 = 0, i4 = e4.length; r4 < i4; r4++) {
                var a3 = e4[r4];
                void 0 === n3[a3] && console.warn("THREE.ObjectLoader: Undefined material", a3), t4.push(n3[a3]);
              }
              return t4;
            }
            return void 0 === n3[e4] && console.warn("THREE.ObjectLoader: Undefined material", e4), n3[e4];
          }
        }
        switch (e3.type) {
          case "Scene":
            r3 = new ui2(), void 0 !== e3.background && Number.isInteger(e3.background) && (r3.background = new rn(e3.background)), void 0 !== e3.fog && ("Fog" === e3.fog.type ? r3.fog = new ci2(e3.fog.color, e3.fog.near, e3.fog.far) : "FogExp2" === e3.fog.type && (r3.fog = new si2(e3.fog.color, e3.fog.density)));
            break;
          case "PerspectiveCamera":
            r3 = new ri2(e3.fov, e3.aspect, e3.near, e3.far), void 0 !== e3.focus && (r3.focus = e3.focus), void 0 !== e3.zoom && (r3.zoom = e3.zoom), void 0 !== e3.filmGauge && (r3.filmGauge = e3.filmGauge), void 0 !== e3.filmOffset && (r3.filmOffset = e3.filmOffset), void 0 !== e3.view && (r3.view = Object.assign({}, e3.view));
            break;
          case "OrthographicCamera":
            r3 = new fn(e3.left, e3.right, e3.top, e3.bottom, e3.near, e3.far), void 0 !== e3.zoom && (r3.zoom = e3.zoom), void 0 !== e3.view && (r3.view = Object.assign({}, e3.view));
            break;
          case "AmbientLight":
            r3 = new Go(e3.color, e3.intensity);
            break;
          case "DirectionalLight":
            r3 = new Fo(e3.color, e3.intensity);
            break;
          case "PointLight":
            r3 = new Uo(e3.color, e3.intensity, e3.distance, e3.decay);
            break;
          case "RectAreaLight":
            r3 = new zo(e3.color, e3.intensity, e3.width, e3.height);
            break;
          case "SpotLight":
            r3 = new Do(e3.color, e3.intensity, e3.distance, e3.angle, e3.penumbra, e3.decay);
            break;
          case "HemisphereLight":
            r3 = new Oo(e3.color, e3.groundColor, e3.intensity);
            break;
          case "SkinnedMesh":
            console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
          case "Mesh":
            var o2 = i3(e3.geometry), s2 = a2(e3.material);
            r3 = o2.bones && o2.bones.length > 0 ? new vi2(o2, s2) : new kn(o2, s2);
            break;
          case "LOD":
            r3 = new fi2();
            break;
          case "Line":
            r3 = new xi2(i3(e3.geometry), a2(e3.material), e3.mode);
            break;
          case "LineLoop":
            r3 = new wi2(i3(e3.geometry), a2(e3.material));
            break;
          case "LineSegments":
            r3 = new bi2(i3(e3.geometry), a2(e3.material));
            break;
          case "PointCloud":
          case "Points":
            r3 = new Mi2(i3(e3.geometry), a2(e3.material));
            break;
          case "Sprite":
            r3 = new pi2(a2(e3.material));
            break;
          case "Group":
            r3 = new ni2();
            break;
          default:
            r3 = new dn();
        }
        if (r3.uuid = e3.uuid, void 0 !== e3.name && (r3.name = e3.name), void 0 !== e3.matrix ? (r3.matrix.fromArray(e3.matrix), void 0 !== e3.matrixAutoUpdate && (r3.matrixAutoUpdate = e3.matrixAutoUpdate), r3.matrixAutoUpdate && r3.matrix.decompose(r3.position, r3.quaternion, r3.scale)) : (void 0 !== e3.position && r3.position.fromArray(e3.position), void 0 !== e3.rotation && r3.rotation.fromArray(e3.rotation), void 0 !== e3.quaternion && r3.quaternion.fromArray(e3.quaternion), void 0 !== e3.scale && r3.scale.fromArray(e3.scale)), void 0 !== e3.castShadow && (r3.castShadow = e3.castShadow), void 0 !== e3.receiveShadow && (r3.receiveShadow = e3.receiveShadow), e3.shadow && (void 0 !== e3.shadow.bias && (r3.shadow.bias = e3.shadow.bias), void 0 !== e3.shadow.radius && (r3.shadow.radius = e3.shadow.radius), void 0 !== e3.shadow.mapSize && r3.shadow.mapSize.fromArray(e3.shadow.mapSize), void 0 !== e3.shadow.camera && (r3.shadow.camera = this.parseObject(e3.shadow.camera))), void 0 !== e3.visible && (r3.visible = e3.visible), void 0 !== e3.frustumCulled && (r3.frustumCulled = e3.frustumCulled), void 0 !== e3.renderOrder && (r3.renderOrder = e3.renderOrder), void 0 !== e3.userData && (r3.userData = e3.userData), void 0 !== e3.layers && (r3.layers.mask = e3.layers), void 0 !== e3.children)
          for (var c3 = e3.children, u3 = 0; u3 < c3.length; u3++)
            r3.add(this.parseObject(c3[u3], t3, n3));
        if ("LOD" === e3.type)
          for (var l3 = e3.levels, h3 = 0; h3 < l3.length; h3++) {
            var d3 = l3[h3], p3 = r3.getObjectByProperty("uuid", d3.object);
            void 0 !== p3 && r3.addLevel(p3, d3.distance);
          }
        return r3;
      } });
      var us, ls = { UVMapping: se2, CubeReflectionMapping: ce2, CubeRefractionMapping: ue2, EquirectangularReflectionMapping: le2, EquirectangularRefractionMapping: he2, SphericalReflectionMapping: de2, CubeUVReflectionMapping: pe2, CubeUVRefractionMapping: fe2 }, hs = { RepeatWrapping: me2, ClampToEdgeWrapping: ge2, MirroredRepeatWrapping: ve2 }, ds = { NearestFilter: ye2, NearestMipMapNearestFilter: xe2, NearestMipMapLinearFilter: be2, LinearFilter: we2, LinearMipMapNearestFilter: _e, LinearMipMapLinearFilter: Me2 };
      function ps(e3) {
        "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = void 0 !== e3 ? e3 : $a, this.options = void 0;
      }
      function fs() {
        this.type = "ShapePath", this.color = new rn(), this.subPaths = [], this.currentPath = null;
      }
      function ms(e3) {
        this.type = "Font", this.data = e3;
      }
      function gs(e3, t3, n3, r3, i3) {
        var a2 = i3.glyphs[e3] || i3.glyphs["?"];
        if (a2) {
          var o2, s2, c3, u3, l3, h3, d3, p3, f3 = new fs();
          if (a2.o)
            for (var m3 = a2._cachedOutline || (a2._cachedOutline = a2.o.split(" ")), g3 = 0, v3 = m3.length; g3 < v3; ) {
              switch (m3[g3++]) {
                case "m":
                  o2 = m3[g3++] * t3 + n3, s2 = m3[g3++] * t3 + r3, f3.moveTo(o2, s2);
                  break;
                case "l":
                  o2 = m3[g3++] * t3 + n3, s2 = m3[g3++] * t3 + r3, f3.lineTo(o2, s2);
                  break;
                case "q":
                  c3 = m3[g3++] * t3 + n3, u3 = m3[g3++] * t3 + r3, l3 = m3[g3++] * t3 + n3, h3 = m3[g3++] * t3 + r3, f3.quadraticCurveTo(l3, h3, c3, u3);
                  break;
                case "b":
                  c3 = m3[g3++] * t3 + n3, u3 = m3[g3++] * t3 + r3, l3 = m3[g3++] * t3 + n3, h3 = m3[g3++] * t3 + r3, d3 = m3[g3++] * t3 + n3, p3 = m3[g3++] * t3 + r3, f3.bezierCurveTo(l3, h3, d3, p3, c3, u3);
              }
            }
          return { offsetX: a2.ha * t3, path: f3 };
        }
      }
      function vs(e3) {
        this.manager = void 0 !== e3 ? e3 : $a;
      }
      ps.prototype = { constructor: ps, setOptions: function(e3) {
        return this.options = e3, this;
      }, load: function(e3, t3, n3, r3) {
        void 0 === e3 && (e3 = ""), void 0 !== this.path && (e3 = this.path + e3), e3 = this.manager.resolveURL(e3);
        var i3 = this, a2 = Ka2.get(e3);
        if (void 0 !== a2)
          return i3.manager.itemStart(e3), setTimeout(function() {
            t3 && t3(a2), i3.manager.itemEnd(e3);
          }, 0), a2;
        fetch(e3).then(function(e4) {
          return e4.blob();
        }).then(function(e4) {
          return createImageBitmap(e4, i3.options);
        }).then(function(n4) {
          Ka2.add(e3, n4), t3 && t3(n4), i3.manager.itemEnd(e3);
        }).catch(function(t4) {
          r3 && r3(t4), i3.manager.itemEnd(e3), i3.manager.itemError(e3);
        });
      }, setCrossOrigin: function() {
        return this;
      }, setPath: function(e3) {
        return this.path = e3, this;
      } }, Object.assign(fs.prototype, { moveTo: function(e3, t3) {
        this.currentPath = new Ro(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e3, t3);
      }, lineTo: function(e3, t3) {
        this.currentPath.lineTo(e3, t3);
      }, quadraticCurveTo: function(e3, t3, n3, r3) {
        this.currentPath.quadraticCurveTo(e3, t3, n3, r3);
      }, bezierCurveTo: function(e3, t3, n3, r3, i3, a2) {
        this.currentPath.bezierCurveTo(e3, t3, n3, r3, i3, a2);
      }, splineThru: function(e3) {
        this.currentPath.splineThru(e3);
      }, toShapes: function(e3, t3) {
        function n3(e4) {
          for (var t4 = [], n4 = 0, r4 = e4.length; n4 < r4; n4++) {
            var i4 = e4[n4], a3 = new Co();
            a3.curves = i4.curves, t4.push(a3);
          }
          return t4;
        }
        function r3(e4, t4) {
          for (var n4 = t4.length, r4 = false, i4 = n4 - 1, a3 = 0; a3 < n4; i4 = a3++) {
            var o3 = t4[i4], s3 = t4[a3], c4 = s3.x - o3.x, u4 = s3.y - o3.y;
            if (Math.abs(u4) > Number.EPSILON) {
              if (u4 < 0 && (o3 = t4[a3], c4 = -c4, s3 = t4[i4], u4 = -u4), e4.y < o3.y || e4.y > s3.y)
                continue;
              if (e4.y === o3.y) {
                if (e4.x === o3.x)
                  return true;
              } else {
                var l4 = u4 * (e4.x - o3.x) - c4 * (e4.y - o3.y);
                if (0 === l4)
                  return true;
                if (l4 < 0)
                  continue;
                r4 = !r4;
              }
            } else {
              if (e4.y !== o3.y)
                continue;
              if (s3.x <= e4.x && e4.x <= o3.x || o3.x <= e4.x && e4.x <= s3.x)
                return true;
            }
          }
          return r4;
        }
        var i3 = ma2.isClockWise, a2 = this.subPaths;
        if (0 === a2.length)
          return [];
        if (true === t3)
          return n3(a2);
        var o2, s2, c3, u3 = [];
        if (1 === a2.length)
          return s2 = a2[0], (c3 = new Co()).curves = s2.curves, u3.push(c3), u3;
        var l3 = !i3(a2[0].getPoints());
        l3 = e3 ? !l3 : l3;
        var h3, d3, p3 = [], f3 = [], m3 = [], g3 = 0;
        f3[g3] = void 0, m3[g3] = [];
        for (var v3 = 0, y3 = a2.length; v3 < y3; v3++)
          o2 = i3(h3 = (s2 = a2[v3]).getPoints()), (o2 = e3 ? !o2 : o2) ? (!l3 && f3[g3] && g3++, f3[g3] = { s: new Co(), p: h3 }, f3[g3].s.curves = s2.curves, l3 && g3++, m3[g3] = []) : m3[g3].push({ h: s2, p: h3[0] });
        if (!f3[0])
          return n3(a2);
        if (f3.length > 1) {
          for (var x3 = false, b3 = [], w3 = 0, _3 = f3.length; w3 < _3; w3++)
            p3[w3] = [];
          for (w3 = 0, _3 = f3.length; w3 < _3; w3++)
            for (var M3 = m3[w3], E3 = 0; E3 < M3.length; E3++) {
              for (var T3 = M3[E3], S3 = true, A3 = 0; A3 < f3.length; A3++)
                r3(T3.p, f3[A3].p) && (w3 !== A3 && b3.push({ froms: w3, tos: A3, hole: E3 }), S3 ? (S3 = false, p3[A3].push(T3)) : x3 = true);
              S3 && p3[w3].push(T3);
            }
          b3.length > 0 && (x3 || (m3 = p3));
        }
        v3 = 0;
        for (var L3 = f3.length; v3 < L3; v3++) {
          c3 = f3[v3].s, u3.push(c3);
          for (var R3 = 0, C3 = (d3 = m3[v3]).length; R3 < C3; R3++)
            c3.holes.push(d3[R3].h);
        }
        return u3;
      } }), Object.assign(ms.prototype, { isFont: true, generateShapes: function(e3, t3) {
        void 0 === t3 && (t3 = 100);
        for (var n3 = [], r3 = function(e4, t4, n4) {
          for (var r4 = Array.from ? Array.from(e4) : String(e4).split(""), i4 = t4 / n4.resolution, a3 = (n4.boundingBox.yMax - n4.boundingBox.yMin + n4.underlineThickness) * i4, o2 = [], s2 = 0, c3 = 0, u3 = 0; u3 < r4.length; u3++) {
            var l3 = r4[u3];
            if ("\n" === l3)
              s2 = 0, c3 -= a3;
            else {
              var h3 = gs(l3, i4, s2, c3, n4);
              s2 += h3.offsetX, o2.push(h3.path);
            }
          }
          return o2;
        }(e3, t3, this.data), i3 = 0, a2 = r3.length; i3 < a2; i3++)
          Array.prototype.push.apply(n3, r3[i3].toShapes());
        return n3;
      } }), Object.assign(vs.prototype, { load: function(e3, t3, n3, r3) {
        var i3 = this, a2 = new to(this.manager);
        a2.setPath(this.path), a2.load(e3, function(e4) {
          var n4;
          try {
            n4 = JSON.parse(e4);
          } catch (t4) {
            console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n4 = JSON.parse(e4.substring(65, e4.length - 2));
          }
          var r4 = i3.parse(n4);
          t3 && t3(r4);
        }, n3, r3);
      }, parse: function(e3) {
        return new ms(e3);
      }, setPath: function(e3) {
        return this.path = e3, this;
      } });
      var ys = { getContext: function() {
        return void 0 === us && (us = new (window.AudioContext || window.webkitAudioContext)()), us;
      }, setContext: function(e3) {
        us = e3;
      } };
      function xs(e3) {
        this.manager = void 0 !== e3 ? e3 : $a;
      }
      function bs() {
        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new ri2(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = false, this.cameraR = new ri2(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = false;
      }
      function ws(e3, t3, n3) {
        dn.call(this), this.type = "CubeCamera";
        var r3 = new ri2(90, 1, e3, t3);
        r3.up.set(0, -1, 0), r3.lookAt(new Ht(1, 0, 0)), this.add(r3);
        var i3 = new ri2(90, 1, e3, t3);
        i3.up.set(0, -1, 0), i3.lookAt(new Ht(-1, 0, 0)), this.add(i3);
        var a2 = new ri2(90, 1, e3, t3);
        a2.up.set(0, 0, 1), a2.lookAt(new Ht(0, 1, 0)), this.add(a2);
        var o2 = new ri2(90, 1, e3, t3);
        o2.up.set(0, 0, -1), o2.lookAt(new Ht(0, -1, 0)), this.add(o2);
        var s2 = new ri2(90, 1, e3, t3);
        s2.up.set(0, -1, 0), s2.lookAt(new Ht(0, 0, 1)), this.add(s2);
        var c3 = new ri2(90, 1, e3, t3);
        c3.up.set(0, -1, 0), c3.lookAt(new Ht(0, 0, -1)), this.add(c3);
        var u3 = { format: Be2, magFilter: we2, minFilter: we2 };
        this.renderTarget = new Yt(n3, n3, u3), this.renderTarget.texture.name = "CubeCamera", this.update = function(e4, t4) {
          null === this.parent && this.updateMatrixWorld();
          var n4 = this.renderTarget, u4 = n4.texture.generateMipmaps;
          n4.texture.generateMipmaps = false, n4.activeCubeFace = 0, e4.render(t4, r3, n4), n4.activeCubeFace = 1, e4.render(t4, i3, n4), n4.activeCubeFace = 2, e4.render(t4, a2, n4), n4.activeCubeFace = 3, e4.render(t4, o2, n4), n4.activeCubeFace = 4, e4.render(t4, s2, n4), n4.texture.generateMipmaps = u4, n4.activeCubeFace = 5, e4.render(t4, c3, n4), e4.setRenderTarget(null);
        }, this.clear = function(e4, t4, n4, r4) {
          for (var i4 = this.renderTarget, a3 = 0; a3 < 6; a3++)
            i4.activeCubeFace = a3, e4.setRenderTarget(i4), e4.clear(t4, n4, r4);
          e4.setRenderTarget(null);
        };
      }
      function _s() {
        dn.call(this), this.type = "AudioListener", this.context = ys.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null;
      }
      function Ms(e3) {
        dn.call(this), this.type = "Audio", this.context = e3.context, this.gain = this.context.createGain(), this.gain.connect(e3.getInput()), this.autoplay = false, this.buffer = null, this.loop = false, this.startTime = 0, this.offset = 0, this.playbackRate = 1, this.isPlaying = false, this.hasPlaybackControl = true, this.sourceType = "empty", this.filters = [];
      }
      function Es(e3) {
        Ms.call(this, e3), this.panner = this.context.createPanner(), this.panner.connect(this.gain);
      }
      function Ts(e3, t3) {
        this.analyser = e3.context.createAnalyser(), this.analyser.fftSize = void 0 !== t3 ? t3 : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), e3.getOutput().connect(this.analyser);
      }
      function Ss(e3, t3, n3) {
        this.binding = e3, this.valueSize = n3;
        var r3, i3 = Float64Array;
        switch (t3) {
          case "quaternion":
            r3 = this._slerp;
            break;
          case "string":
          case "bool":
            i3 = Array, r3 = this._select;
            break;
          default:
            r3 = this._lerp;
        }
        this.buffer = new i3(4 * n3), this._mixBufferRegion = r3, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0;
      }
      Object.assign(xs.prototype, { load: function(e3, t3, n3, r3) {
        var i3 = new to(this.manager);
        i3.setResponseType("arraybuffer"), i3.load(e3, function(e4) {
          var n4 = e4.slice(0);
          ys.getContext().decodeAudioData(n4, function(e5) {
            t3(e5);
          });
        }, n3, r3);
      } }), Object.assign(bs.prototype, { update: function() {
        var e3, t3, n3, r3, i3, a2, o2, s2, c3 = new Gt(), u3 = new Gt();
        return function(l3) {
          if (e3 !== this || t3 !== l3.focus || n3 !== l3.fov || r3 !== l3.aspect * this.aspect || i3 !== l3.near || a2 !== l3.far || o2 !== l3.zoom || s2 !== this.eyeSep) {
            e3 = this, t3 = l3.focus, n3 = l3.fov, r3 = l3.aspect * this.aspect, i3 = l3.near, a2 = l3.far, o2 = l3.zoom;
            var h3, d3, p3 = l3.projectionMatrix.clone(), f3 = (s2 = this.eyeSep / 2) * i3 / t3, m3 = i3 * Math.tan(Bt.DEG2RAD * n3 * 0.5) / o2;
            u3.elements[12] = -s2, c3.elements[12] = s2, h3 = -m3 * r3 + f3, d3 = m3 * r3 + f3, p3.elements[0] = 2 * i3 / (d3 - h3), p3.elements[8] = (d3 + h3) / (d3 - h3), this.cameraL.projectionMatrix.copy(p3), h3 = -m3 * r3 - f3, d3 = m3 * r3 - f3, p3.elements[0] = 2 * i3 / (d3 - h3), p3.elements[8] = (d3 + h3) / (d3 - h3), this.cameraR.projectionMatrix.copy(p3);
          }
          this.cameraL.matrixWorld.copy(l3.matrixWorld).multiply(u3), this.cameraR.matrixWorld.copy(l3.matrixWorld).multiply(c3);
        };
      }() }), ws.prototype = Object.create(dn.prototype), ws.prototype.constructor = ws, _s.prototype = Object.assign(Object.create(dn.prototype), { constructor: _s, getInput: function() {
        return this.gain;
      }, removeFilter: function() {
        return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
      }, getFilter: function() {
        return this.filter;
      }, setFilter: function(e3) {
        return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e3, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
      }, getMasterVolume: function() {
        return this.gain.gain.value;
      }, setMasterVolume: function(e3) {
        return this.gain.gain.setTargetAtTime(e3, this.context.currentTime, 0.01), this;
      }, updateMatrixWorld: function() {
        var e3 = new Ht(), t3 = new zt(), n3 = new Ht(), r3 = new Ht();
        return function(i3) {
          dn.prototype.updateMatrixWorld.call(this, i3);
          var a2 = this.context.listener, o2 = this.up;
          this.matrixWorld.decompose(e3, t3, n3), r3.set(0, 0, -1).applyQuaternion(t3), a2.positionX ? (a2.positionX.setValueAtTime(e3.x, this.context.currentTime), a2.positionY.setValueAtTime(e3.y, this.context.currentTime), a2.positionZ.setValueAtTime(e3.z, this.context.currentTime), a2.forwardX.setValueAtTime(r3.x, this.context.currentTime), a2.forwardY.setValueAtTime(r3.y, this.context.currentTime), a2.forwardZ.setValueAtTime(r3.z, this.context.currentTime), a2.upX.setValueAtTime(o2.x, this.context.currentTime), a2.upY.setValueAtTime(o2.y, this.context.currentTime), a2.upZ.setValueAtTime(o2.z, this.context.currentTime)) : (a2.setPosition(e3.x, e3.y, e3.z), a2.setOrientation(r3.x, r3.y, r3.z, o2.x, o2.y, o2.z));
        };
      }() }), Ms.prototype = Object.assign(Object.create(dn.prototype), { constructor: Ms, getOutput: function() {
        return this.gain;
      }, setNodeSource: function(e3) {
        return this.hasPlaybackControl = false, this.sourceType = "audioNode", this.source = e3, this.connect(), this;
      }, setMediaElementSource: function(e3) {
        return this.hasPlaybackControl = false, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e3), this.connect(), this;
      }, setBuffer: function(e3) {
        return this.buffer = e3, this.sourceType = "buffer", this.autoplay && this.play(), this;
      }, play: function() {
        if (true !== this.isPlaying) {
          if (false !== this.hasPlaybackControl) {
            var e3 = this.context.createBufferSource();
            return e3.buffer = this.buffer, e3.loop = this.loop, e3.onended = this.onEnded.bind(this), e3.playbackRate.setValueAtTime(this.playbackRate, this.startTime), this.startTime = this.context.currentTime, e3.start(this.startTime, this.offset), this.isPlaying = true, this.source = e3, this.connect();
          }
          console.warn("THREE.Audio: this Audio has no playback control.");
        } else
          console.warn("THREE.Audio: Audio is already playing.");
      }, pause: function() {
        if (false !== this.hasPlaybackControl)
          return true === this.isPlaying && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = false), this;
        console.warn("THREE.Audio: this Audio has no playback control.");
      }, stop: function() {
        if (false !== this.hasPlaybackControl)
          return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = false, this;
        console.warn("THREE.Audio: this Audio has no playback control.");
      }, connect: function() {
        if (this.filters.length > 0) {
          this.source.connect(this.filters[0]);
          for (var e3 = 1, t3 = this.filters.length; e3 < t3; e3++)
            this.filters[e3 - 1].connect(this.filters[e3]);
          this.filters[this.filters.length - 1].connect(this.getOutput());
        } else
          this.source.connect(this.getOutput());
        return this;
      }, disconnect: function() {
        if (this.filters.length > 0) {
          this.source.disconnect(this.filters[0]);
          for (var e3 = 1, t3 = this.filters.length; e3 < t3; e3++)
            this.filters[e3 - 1].disconnect(this.filters[e3]);
          this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else
          this.source.disconnect(this.getOutput());
        return this;
      }, getFilters: function() {
        return this.filters;
      }, setFilters: function(e3) {
        return e3 || (e3 = []), true === this.isPlaying ? (this.disconnect(), this.filters = e3, this.connect()) : this.filters = e3, this;
      }, getFilter: function() {
        return this.getFilters()[0];
      }, setFilter: function(e3) {
        return this.setFilters(e3 ? [e3] : []);
      }, setPlaybackRate: function(e3) {
        if (false !== this.hasPlaybackControl)
          return this.playbackRate = e3, true === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), this;
        console.warn("THREE.Audio: this Audio has no playback control.");
      }, getPlaybackRate: function() {
        return this.playbackRate;
      }, onEnded: function() {
        this.isPlaying = false;
      }, getLoop: function() {
        return false === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), false) : this.loop;
      }, setLoop: function(e3) {
        if (false !== this.hasPlaybackControl)
          return this.loop = e3, true === this.isPlaying && (this.source.loop = this.loop), this;
        console.warn("THREE.Audio: this Audio has no playback control.");
      }, getVolume: function() {
        return this.gain.gain.value;
      }, setVolume: function(e3) {
        return this.gain.gain.setTargetAtTime(e3, this.context.currentTime, 0.01), this;
      } }), Es.prototype = Object.assign(Object.create(Ms.prototype), { constructor: Es, getOutput: function() {
        return this.panner;
      }, getRefDistance: function() {
        return this.panner.refDistance;
      }, setRefDistance: function(e3) {
        return this.panner.refDistance = e3, this;
      }, getRolloffFactor: function() {
        return this.panner.rolloffFactor;
      }, setRolloffFactor: function(e3) {
        return this.panner.rolloffFactor = e3, this;
      }, getDistanceModel: function() {
        return this.panner.distanceModel;
      }, setDistanceModel: function(e3) {
        return this.panner.distanceModel = e3, this;
      }, getMaxDistance: function() {
        return this.panner.maxDistance;
      }, setMaxDistance: function(e3) {
        return this.panner.maxDistance = e3, this;
      }, setDirectionalCone: function(e3, t3, n3) {
        return this.panner.coneInnerAngle = e3, this.panner.coneOuterAngle = t3, this.panner.coneOuterGain = n3, this;
      }, updateMatrixWorld: function() {
        var e3 = new Ht(), t3 = new zt(), n3 = new Ht(), r3 = new Ht();
        return function(i3) {
          dn.prototype.updateMatrixWorld.call(this, i3);
          var a2 = this.panner;
          this.matrixWorld.decompose(e3, t3, n3), r3.set(0, 0, 1).applyQuaternion(t3), a2.setPosition(e3.x, e3.y, e3.z), a2.setOrientation(r3.x, r3.y, r3.z);
        };
      }() }), Object.assign(Ts.prototype, { getFrequencyData: function() {
        return this.analyser.getByteFrequencyData(this.data), this.data;
      }, getAverageFrequency: function() {
        for (var e3 = 0, t3 = this.getFrequencyData(), n3 = 0; n3 < t3.length; n3++)
          e3 += t3[n3];
        return e3 / t3.length;
      } }), Object.assign(Ss.prototype, { accumulate: function(e3, t3) {
        var n3 = this.buffer, r3 = this.valueSize, i3 = e3 * r3 + r3, a2 = this.cumulativeWeight;
        if (0 === a2) {
          for (var o2 = 0; o2 !== r3; ++o2)
            n3[i3 + o2] = n3[o2];
          a2 = t3;
        } else {
          var s2 = t3 / (a2 += t3);
          this._mixBufferRegion(n3, i3, 0, s2, r3);
        }
        this.cumulativeWeight = a2;
      }, apply: function(e3) {
        var t3 = this.valueSize, n3 = this.buffer, r3 = e3 * t3 + t3, i3 = this.cumulativeWeight, a2 = this.binding;
        if (this.cumulativeWeight = 0, i3 < 1) {
          var o2 = 3 * t3;
          this._mixBufferRegion(n3, r3, o2, 1 - i3, t3);
        }
        for (var s2 = t3, c3 = t3 + t3; s2 !== c3; ++s2)
          if (n3[s2] !== n3[s2 + t3]) {
            a2.setValue(n3, r3);
            break;
          }
      }, saveOriginalState: function() {
        var e3 = this.binding, t3 = this.buffer, n3 = this.valueSize, r3 = 3 * n3;
        e3.getValue(t3, r3);
        for (var i3 = n3, a2 = r3; i3 !== a2; ++i3)
          t3[i3] = t3[r3 + i3 % n3];
        this.cumulativeWeight = 0;
      }, restoreOriginalState: function() {
        var e3 = 3 * this.valueSize;
        this.binding.setValue(this.buffer, e3);
      }, _select: function(e3, t3, n3, r3, i3) {
        if (r3 >= 0.5)
          for (var a2 = 0; a2 !== i3; ++a2)
            e3[t3 + a2] = e3[n3 + a2];
      }, _slerp: function(e3, t3, n3, r3) {
        zt.slerpFlat(e3, t3, e3, t3, e3, n3, r3);
      }, _lerp: function(e3, t3, n3, r3, i3) {
        for (var a2 = 1 - r3, o2 = 0; o2 !== i3; ++o2) {
          var s2 = t3 + o2;
          e3[s2] = e3[s2] * a2 + e3[n3 + o2] * r3;
        }
      } });
      var As, Ls;
      function Rs(e3, t3, n3) {
        var r3 = n3 || Cs.parseTrackName(t3);
        this._targetGroup = e3, this._bindings = e3.subscribe_(t3, r3);
      }
      function Cs(e3, t3, n3) {
        this.path = t3, this.parsedPath = n3 || Cs.parseTrackName(t3), this.node = Cs.findNode(e3, this.parsedPath.nodeName) || e3, this.rootNode = e3;
      }
      function Ps() {
        this.uuid = Bt.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
        var e3 = {};
        this._indicesByUUID = e3;
        for (var t3 = 0, n3 = arguments.length; t3 !== n3; ++t3)
          e3[arguments[t3].uuid] = t3;
        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
        var r3 = this;
        this.stats = { objects: { get total() {
          return r3._objects.length;
        }, get inUse() {
          return this.total - r3.nCachedObjects_;
        } }, get bindingsPerObject() {
          return r3._bindings.length;
        } };
      }
      function Os(e3, t3, n3) {
        this._mixer = e3, this._clip = t3, this._localRoot = n3 || null;
        for (var r3 = t3.tracks, i3 = r3.length, a2 = new Array(i3), o2 = { endingStart: xt, endingEnd: xt }, s2 = 0; s2 !== i3; ++s2) {
          var c3 = r3[s2].createInterpolant(null);
          a2[s2] = c3, c3.settings = o2;
        }
        this._interpolantSettings = o2, this._interpolants = a2, this._propertyBindings = new Array(i3), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = ft, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = false, this.enabled = true, this.clampWhenFinished = false, this.zeroSlopeAtStart = true, this.zeroSlopeAtEnd = true;
      }
      function Ns(e3) {
        this._root = e3, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
      }
      function Is(e3) {
        "string" == typeof e3 && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e3 = arguments[1]), this.value = e3;
      }
      function Ds() {
        Pn.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0;
      }
      function Us(e3, t3, n3) {
        li2.call(this, e3, t3), this.meshPerAttribute = n3 || 1;
      }
      function Bs(e3, t3, n3) {
        yn.call(this, e3, t3), this.meshPerAttribute = n3 || 1;
      }
      function Fs(e3, t3, n3, r3) {
        this.ray = new zn(e3, t3), this.near = n3 || 0, this.far = r3 || 1 / 0, this.params = { Mesh: {}, Line: {}, LOD: {}, Points: { threshold: 1 }, Sprite: {} }, Object.defineProperties(this.params, { PointCloud: { get: function() {
          return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points;
        } } });
      }
      function Gs(e3, t3) {
        return e3.distance - t3.distance;
      }
      function zs(e3, t3, n3, r3) {
        if (false !== e3.visible && (e3.raycast(t3, n3), true === r3))
          for (var i3 = e3.children, a2 = 0, o2 = i3.length; a2 < o2; a2++)
            zs(i3[a2], t3, n3, true);
      }
      function Hs(e3) {
        this.autoStart = void 0 === e3 || e3, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = false;
      }
      function ks(e3, t3, n3) {
        return this.radius = void 0 !== e3 ? e3 : 1, this.phi = void 0 !== t3 ? t3 : 0, this.theta = void 0 !== n3 ? n3 : 0, this;
      }
      function js(e3, t3, n3) {
        return this.radius = void 0 !== e3 ? e3 : 1, this.theta = void 0 !== t3 ? t3 : 0, this.y = void 0 !== n3 ? n3 : 0, this;
      }
      function Vs(e3, t3) {
        this.min = void 0 !== e3 ? e3 : new Ft(1 / 0, 1 / 0), this.max = void 0 !== t3 ? t3 : new Ft(-1 / 0, -1 / 0);
      }
      function Ws(e3, t3) {
        this.start = void 0 !== e3 ? e3 : new Ht(), this.end = void 0 !== t3 ? t3 : new Ht();
      }
      function Xs(e3) {
        dn.call(this), this.material = e3, this.render = function() {
        };
      }
      function qs(e3, t3, n3, r3) {
        this.object = e3, this.size = void 0 !== t3 ? t3 : 1;
        var i3 = void 0 !== n3 ? n3 : 16711680, a2 = void 0 !== r3 ? r3 : 1, o2 = 0, s2 = this.object.geometry;
        s2 && s2.isGeometry ? o2 = 3 * s2.faces.length : s2 && s2.isBufferGeometry && (o2 = s2.attributes.normal.count);
        var c3 = new Pn(), u3 = new Sn(2 * o2 * 3, 3);
        c3.addAttribute("position", u3), bi2.call(this, c3, new yi2({ color: i3, linewidth: a2 })), this.matrixAutoUpdate = false, this.update();
      }
      function Ys(e3, t3) {
        dn.call(this), this.light = e3, this.light.updateMatrixWorld(), this.matrix = e3.matrixWorld, this.matrixAutoUpdate = false, this.color = t3;
        for (var n3 = new Pn(), r3 = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], i3 = 0, a2 = 1; i3 < 32; i3++, a2++) {
          var o2 = i3 / 32 * Math.PI * 2, s2 = a2 / 32 * Math.PI * 2;
          r3.push(Math.cos(o2), Math.sin(o2), 1, Math.cos(s2), Math.sin(s2), 1);
        }
        n3.addAttribute("position", new Sn(r3, 3));
        var c3 = new yi2({ fog: false });
        this.cone = new bi2(n3, c3), this.add(this.cone), this.update();
      }
      function Zs(e3) {
        for (var t3 = function e4(t4) {
          var n4 = [];
          t4 && t4.isBone && n4.push(t4);
          for (var r4 = 0; r4 < t4.children.length; r4++)
            n4.push.apply(n4, e4(t4.children[r4]));
          return n4;
        }(e3), n3 = new Pn(), r3 = [], i3 = [], a2 = new rn(0, 0, 1), o2 = new rn(0, 1, 0), s2 = 0; s2 < t3.length; s2++) {
          var c3 = t3[s2];
          c3.parent && c3.parent.isBone && (r3.push(0, 0, 0), r3.push(0, 0, 0), i3.push(a2.r, a2.g, a2.b), i3.push(o2.r, o2.g, o2.b));
        }
        n3.addAttribute("position", new Sn(r3, 3)), n3.addAttribute("color", new Sn(i3, 3));
        var u3 = new yi2({ vertexColors: _2, depthTest: false, depthWrite: false, transparent: true });
        bi2.call(this, n3, u3), this.root = e3, this.bones = t3, this.matrix = e3.matrixWorld, this.matrixAutoUpdate = false;
      }
      function Js(e3, t3, n3) {
        this.light = e3, this.light.updateMatrixWorld(), this.color = n3;
        var r3 = new Ta2(t3, 4, 2), i3 = new Fn({ wireframe: true, fog: false });
        kn.call(this, r3, i3), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = false, this.update();
      }
      function Ks(e3, t3) {
        dn.call(this), this.light = e3, this.light.updateMatrixWorld(), this.matrix = e3.matrixWorld, this.matrixAutoUpdate = false, this.color = t3;
        var n3 = new yi2({ fog: false }), r3 = new Pn();
        r3.addAttribute("position", new yn(new Float32Array(15), 3)), this.line = new xi2(r3, n3), this.add(this.line), this.update();
      }
      function Qs(e3, t3, n3) {
        dn.call(this), this.light = e3, this.light.updateMatrixWorld(), this.matrix = e3.matrixWorld, this.matrixAutoUpdate = false, this.color = n3;
        var r3 = new Ui2(t3);
        r3.rotateY(0.5 * Math.PI), this.material = new Fn({ wireframe: true, fog: false }), void 0 === this.color && (this.material.vertexColors = _2);
        var i3 = r3.getAttribute("position"), a2 = new Float32Array(3 * i3.count);
        r3.addAttribute("color", new yn(a2, 3)), this.add(new kn(r3, this.material)), this.update();
      }
      function $s(e3, t3, n3, r3) {
        e3 = e3 || 10, t3 = t3 || 10, n3 = new rn(void 0 !== n3 ? n3 : 4473924), r3 = new rn(void 0 !== r3 ? r3 : 8947848);
        for (var i3 = t3 / 2, a2 = e3 / t3, o2 = e3 / 2, s2 = [], c3 = [], u3 = 0, l3 = 0, h3 = -o2; u3 <= t3; u3++, h3 += a2) {
          s2.push(-o2, 0, h3, o2, 0, h3), s2.push(h3, 0, -o2, h3, 0, o2);
          var d3 = u3 === i3 ? n3 : r3;
          d3.toArray(c3, l3), l3 += 3, d3.toArray(c3, l3), l3 += 3, d3.toArray(c3, l3), l3 += 3, d3.toArray(c3, l3), l3 += 3;
        }
        var p3 = new Pn();
        p3.addAttribute("position", new Sn(s2, 3)), p3.addAttribute("color", new Sn(c3, 3));
        var f3 = new yi2({ vertexColors: _2 });
        bi2.call(this, p3, f3);
      }
      function ec2(e3, t3, n3, r3, i3, a2) {
        e3 = e3 || 10, t3 = t3 || 16, n3 = n3 || 8, r3 = r3 || 64, i3 = new rn(void 0 !== i3 ? i3 : 4473924), a2 = new rn(void 0 !== a2 ? a2 : 8947848);
        var o2, s2, c3, u3, l3, h3, d3, p3 = [], f3 = [];
        for (u3 = 0; u3 <= t3; u3++)
          c3 = u3 / t3 * (2 * Math.PI), o2 = Math.sin(c3) * e3, s2 = Math.cos(c3) * e3, p3.push(0, 0, 0), p3.push(o2, 0, s2), d3 = 1 & u3 ? i3 : a2, f3.push(d3.r, d3.g, d3.b), f3.push(d3.r, d3.g, d3.b);
        for (u3 = 0; u3 <= n3; u3++)
          for (d3 = 1 & u3 ? i3 : a2, h3 = e3 - e3 / n3 * u3, l3 = 0; l3 < r3; l3++)
            c3 = l3 / r3 * (2 * Math.PI), o2 = Math.sin(c3) * h3, s2 = Math.cos(c3) * h3, p3.push(o2, 0, s2), f3.push(d3.r, d3.g, d3.b), c3 = (l3 + 1) / r3 * (2 * Math.PI), o2 = Math.sin(c3) * h3, s2 = Math.cos(c3) * h3, p3.push(o2, 0, s2), f3.push(d3.r, d3.g, d3.b);
        var m3 = new Pn();
        m3.addAttribute("position", new Sn(p3, 3)), m3.addAttribute("color", new Sn(f3, 3));
        var g3 = new yi2({ vertexColors: _2 });
        bi2.call(this, m3, g3);
      }
      function tc2(e3, t3, n3, r3) {
        this.object = e3, this.size = void 0 !== t3 ? t3 : 1;
        var i3 = void 0 !== n3 ? n3 : 16776960, a2 = void 0 !== r3 ? r3 : 1, o2 = 0, s2 = this.object.geometry;
        s2 && s2.isGeometry ? o2 = s2.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
        var c3 = new Pn(), u3 = new Sn(2 * o2 * 3, 3);
        c3.addAttribute("position", u3), bi2.call(this, c3, new yi2({ color: i3, linewidth: a2 })), this.matrixAutoUpdate = false, this.update();
      }
      function nc2(e3, t3, n3) {
        dn.call(this), this.light = e3, this.light.updateMatrixWorld(), this.matrix = e3.matrixWorld, this.matrixAutoUpdate = false, this.color = n3, void 0 === t3 && (t3 = 1);
        var r3 = new Pn();
        r3.addAttribute("position", new Sn([-t3, t3, 0, t3, t3, 0, t3, -t3, 0, -t3, -t3, 0, -t3, t3, 0], 3));
        var i3 = new yi2({ fog: false });
        this.lightPlane = new xi2(r3, i3), this.add(this.lightPlane), (r3 = new Pn()).addAttribute("position", new Sn([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new xi2(r3, i3), this.add(this.targetLine), this.update();
      }
      function rc2(e3) {
        var t3 = new Pn(), n3 = new yi2({ color: 16777215, vertexColors: w2 }), r3 = [], i3 = [], a2 = {}, o2 = new rn(16755200), s2 = new rn(16711680), c3 = new rn(43775), u3 = new rn(16777215), l3 = new rn(3355443);
        function h3(e4, t4, n4) {
          d3(e4, n4), d3(t4, n4);
        }
        function d3(e4, t4) {
          r3.push(0, 0, 0), i3.push(t4.r, t4.g, t4.b), void 0 === a2[e4] && (a2[e4] = []), a2[e4].push(r3.length / 3 - 1);
        }
        h3("n1", "n2", o2), h3("n2", "n4", o2), h3("n4", "n3", o2), h3("n3", "n1", o2), h3("f1", "f2", o2), h3("f2", "f4", o2), h3("f4", "f3", o2), h3("f3", "f1", o2), h3("n1", "f1", o2), h3("n2", "f2", o2), h3("n3", "f3", o2), h3("n4", "f4", o2), h3("p", "n1", s2), h3("p", "n2", s2), h3("p", "n3", s2), h3("p", "n4", s2), h3("u1", "u2", c3), h3("u2", "u3", c3), h3("u3", "u1", c3), h3("c", "t", u3), h3("p", "c", l3), h3("cn1", "cn2", l3), h3("cn3", "cn4", l3), h3("cf1", "cf2", l3), h3("cf3", "cf4", l3), t3.addAttribute("position", new Sn(r3, 3)), t3.addAttribute("color", new Sn(i3, 3)), bi2.call(this, t3, n3), this.camera = e3, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e3.matrixWorld, this.matrixAutoUpdate = false, this.pointMap = a2, this.update();
      }
      function ic2(e3, t3) {
        this.object = e3, void 0 === t3 && (t3 = 16776960);
        var n3 = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r3 = new Float32Array(24), i3 = new Pn();
        i3.setIndex(new yn(n3, 1)), i3.addAttribute("position", new yn(r3, 3)), bi2.call(this, i3, new yi2({ color: t3 })), this.matrixAutoUpdate = false, this.update();
      }
      function ac2(e3, t3) {
        this.type = "Box3Helper", this.box = e3;
        var n3 = void 0 !== t3 ? t3 : 16776960, r3 = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i3 = new Pn();
        i3.setIndex(new yn(r3, 1)), i3.addAttribute("position", new Sn([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), bi2.call(this, i3, new yi2({ color: n3 })), this.geometry.computeBoundingSphere();
      }
      function oc2(e3, t3, n3) {
        this.type = "PlaneHelper", this.plane = e3, this.size = void 0 === t3 ? 1 : t3;
        var r3 = void 0 !== n3 ? n3 : 16776960, i3 = new Pn();
        i3.addAttribute("position", new Sn([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), i3.computeBoundingSphere(), xi2.call(this, i3, new yi2({ color: r3 }));
        var a2 = new Pn();
        a2.addAttribute("position", new Sn([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), a2.computeBoundingSphere(), this.add(new kn(a2, new Fn({ color: r3, opacity: 0.2, transparent: true, depthWrite: false })));
      }
      function sc2(e3, t3, n3, r3, i3, a2) {
        dn.call(this), void 0 === r3 && (r3 = 16776960), void 0 === n3 && (n3 = 1), void 0 === i3 && (i3 = 0.2 * n3), void 0 === a2 && (a2 = 0.2 * i3), void 0 === As && ((As = new Pn()).addAttribute("position", new Sn([0, 0, 0, 0, 1, 0], 3)), (Ls = new Da2(0, 0.5, 1, 5, 1)).translate(0, -0.5, 0)), this.position.copy(t3), this.line = new xi2(As, new yi2({ color: r3 })), this.line.matrixAutoUpdate = false, this.add(this.line), this.cone = new kn(Ls, new Fn({ color: r3 })), this.cone.matrixAutoUpdate = false, this.add(this.cone), this.setDirection(e3), this.setLength(n3, i3, a2);
      }
      function cc2(e3) {
        var t3 = [0, 0, 0, e3 = e3 || 1, 0, 0, 0, 0, 0, 0, e3, 0, 0, 0, 0, 0, 0, e3], n3 = new Pn();
        n3.addAttribute("position", new Sn(t3, 3)), n3.addAttribute("color", new Sn([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], 3));
        var r3 = new yi2({ vertexColors: _2 });
        bi2.call(this, n3, r3);
      }
      function uc2(e3, t3, n3, r3, i3, a2, o2) {
        return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new mn(e3, t3, n3, i3, a2, o2);
      }
      Object.assign(Rs.prototype, { getValue: function(e3, t3) {
        this.bind();
        var n3 = this._targetGroup.nCachedObjects_, r3 = this._bindings[n3];
        void 0 !== r3 && r3.getValue(e3, t3);
      }, setValue: function(e3, t3) {
        for (var n3 = this._bindings, r3 = this._targetGroup.nCachedObjects_, i3 = n3.length; r3 !== i3; ++r3)
          n3[r3].setValue(e3, t3);
      }, bind: function() {
        for (var e3 = this._bindings, t3 = this._targetGroup.nCachedObjects_, n3 = e3.length; t3 !== n3; ++t3)
          e3[t3].bind();
      }, unbind: function() {
        for (var e3 = this._bindings, t3 = this._targetGroup.nCachedObjects_, n3 = e3.length; t3 !== n3; ++t3)
          e3[t3].unbind();
      } }), Object.assign(Cs, { Composite: Rs, create: function(e3, t3, n3) {
        return e3 && e3.isAnimationObjectGroup ? new Cs.Composite(e3, t3, n3) : new Cs(e3, t3, n3);
      }, sanitizeNodeName: function() {
        var e3 = new RegExp("[\\[\\]\\.:\\/]", "g");
        return function(t3) {
          return t3.replace(/\s/g, "_").replace(e3, "");
        };
      }(), parseTrackName: function() {
        var e3 = "[^\\[\\]\\.:\\/]", t3 = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", n3 = /((?:WC+[\/:])*)/.source.replace("WC", e3), r3 = /(WCOD+)?/.source.replace("WCOD", t3), i3 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", e3), a2 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", e3), o2 = new RegExp("^" + n3 + r3 + i3 + a2 + "$"), s2 = ["material", "materials", "bones"];
        return function(e4) {
          var t4 = o2.exec(e4);
          if (!t4)
            throw new Error("PropertyBinding: Cannot parse trackName: " + e4);
          var n4 = { nodeName: t4[2], objectName: t4[3], objectIndex: t4[4], propertyName: t4[5], propertyIndex: t4[6] }, r4 = n4.nodeName && n4.nodeName.lastIndexOf(".");
          if (void 0 !== r4 && -1 !== r4) {
            var i4 = n4.nodeName.substring(r4 + 1);
            -1 !== s2.indexOf(i4) && (n4.nodeName = n4.nodeName.substring(0, r4), n4.objectName = i4);
          }
          if (null === n4.propertyName || 0 === n4.propertyName.length)
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e4);
          return n4;
        };
      }(), findNode: function(e3, t3) {
        if (!t3 || "" === t3 || "root" === t3 || "." === t3 || -1 === t3 || t3 === e3.name || t3 === e3.uuid)
          return e3;
        if (e3.skeleton) {
          var n3 = e3.skeleton.getBoneByName(t3);
          if (void 0 !== n3)
            return n3;
        }
        if (e3.children) {
          var r3 = function(e4) {
            for (var n4 = 0; n4 < e4.length; n4++) {
              var i4 = e4[n4];
              if (i4.name === t3 || i4.uuid === t3)
                return i4;
              var a2 = r3(i4.children);
              if (a2)
                return a2;
            }
            return null;
          }, i3 = r3(e3.children);
          if (i3)
            return i3;
        }
        return null;
      } }), Object.assign(Cs.prototype, { _getValue_unavailable: function() {
      }, _setValue_unavailable: function() {
      }, BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, GetterByBindingType: [function(e3, t3) {
        e3[t3] = this.node[this.propertyName];
      }, function(e3, t3) {
        for (var n3 = this.resolvedProperty, r3 = 0, i3 = n3.length; r3 !== i3; ++r3)
          e3[t3++] = n3[r3];
      }, function(e3, t3) {
        e3[t3] = this.resolvedProperty[this.propertyIndex];
      }, function(e3, t3) {
        this.resolvedProperty.toArray(e3, t3);
      }], SetterByBindingTypeAndVersioning: [[function(e3, t3) {
        this.targetObject[this.propertyName] = e3[t3];
      }, function(e3, t3) {
        this.targetObject[this.propertyName] = e3[t3], this.targetObject.needsUpdate = true;
      }, function(e3, t3) {
        this.targetObject[this.propertyName] = e3[t3], this.targetObject.matrixWorldNeedsUpdate = true;
      }], [function(e3, t3) {
        for (var n3 = this.resolvedProperty, r3 = 0, i3 = n3.length; r3 !== i3; ++r3)
          n3[r3] = e3[t3++];
      }, function(e3, t3) {
        for (var n3 = this.resolvedProperty, r3 = 0, i3 = n3.length; r3 !== i3; ++r3)
          n3[r3] = e3[t3++];
        this.targetObject.needsUpdate = true;
      }, function(e3, t3) {
        for (var n3 = this.resolvedProperty, r3 = 0, i3 = n3.length; r3 !== i3; ++r3)
          n3[r3] = e3[t3++];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }], [function(e3, t3) {
        this.resolvedProperty[this.propertyIndex] = e3[t3];
      }, function(e3, t3) {
        this.resolvedProperty[this.propertyIndex] = e3[t3], this.targetObject.needsUpdate = true;
      }, function(e3, t3) {
        this.resolvedProperty[this.propertyIndex] = e3[t3], this.targetObject.matrixWorldNeedsUpdate = true;
      }], [function(e3, t3) {
        this.resolvedProperty.fromArray(e3, t3);
      }, function(e3, t3) {
        this.resolvedProperty.fromArray(e3, t3), this.targetObject.needsUpdate = true;
      }, function(e3, t3) {
        this.resolvedProperty.fromArray(e3, t3), this.targetObject.matrixWorldNeedsUpdate = true;
      }]], getValue: function(e3, t3) {
        this.bind(), this.getValue(e3, t3);
      }, setValue: function(e3, t3) {
        this.bind(), this.setValue(e3, t3);
      }, bind: function() {
        var e3 = this.node, t3 = this.parsedPath, n3 = t3.objectName, r3 = t3.propertyName, i3 = t3.propertyIndex;
        if (e3 || (e3 = Cs.findNode(this.rootNode, t3.nodeName) || this.rootNode, this.node = e3), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, e3) {
          if (n3) {
            var a2 = t3.objectIndex;
            switch (n3) {
              case "materials":
                if (!e3.material)
                  return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                if (!e3.material.materials)
                  return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                e3 = e3.material.materials;
                break;
              case "bones":
                if (!e3.skeleton)
                  return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                e3 = e3.skeleton.bones;
                for (var o2 = 0; o2 < e3.length; o2++)
                  if (e3[o2].name === a2) {
                    a2 = o2;
                    break;
                  }
                break;
              default:
                if (void 0 === e3[n3])
                  return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                e3 = e3[n3];
            }
            if (void 0 !== a2) {
              if (void 0 === e3[a2])
                return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e3);
              e3 = e3[a2];
            }
          }
          var s2 = e3[r3];
          if (void 0 !== s2) {
            var c3 = this.Versioning.None;
            void 0 !== e3.needsUpdate ? (c3 = this.Versioning.NeedsUpdate, this.targetObject = e3) : void 0 !== e3.matrixWorldNeedsUpdate && (c3 = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = e3);
            var u3 = this.BindingType.Direct;
            if (void 0 !== i3) {
              if ("morphTargetInfluences" === r3) {
                if (!e3.geometry)
                  return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                if (e3.geometry.isBufferGeometry) {
                  if (!e3.geometry.morphAttributes)
                    return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                  for (o2 = 0; o2 < this.node.geometry.morphAttributes.position.length; o2++)
                    if (e3.geometry.morphAttributes.position[o2].name === i3) {
                      i3 = o2;
                      break;
                    }
                } else {
                  if (!e3.geometry.morphTargets)
                    return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                  for (o2 = 0; o2 < this.node.geometry.morphTargets.length; o2++)
                    if (e3.geometry.morphTargets[o2].name === i3) {
                      i3 = o2;
                      break;
                    }
                }
              }
              u3 = this.BindingType.ArrayElement, this.resolvedProperty = s2, this.propertyIndex = i3;
            } else
              void 0 !== s2.fromArray && void 0 !== s2.toArray ? (u3 = this.BindingType.HasFromToArray, this.resolvedProperty = s2) : Array.isArray(s2) ? (u3 = this.BindingType.EntireArray, this.resolvedProperty = s2) : this.propertyName = r3;
            this.getValue = this.GetterByBindingType[u3], this.setValue = this.SetterByBindingTypeAndVersioning[u3][c3];
          } else {
            var l3 = t3.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + l3 + "." + r3 + " but it wasn't found.", e3);
          }
        } else
          console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      }, unbind: function() {
        this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
      } }), Object.assign(Cs.prototype, { _getValue_unbound: Cs.prototype.getValue, _setValue_unbound: Cs.prototype.setValue }), Object.assign(Ps.prototype, { isAnimationObjectGroup: true, add: function() {
        for (var e3 = this._objects, t3 = e3.length, n3 = this.nCachedObjects_, r3 = this._indicesByUUID, i3 = this._paths, a2 = this._parsedPaths, o2 = this._bindings, s2 = o2.length, c3 = void 0, u3 = 0, l3 = arguments.length; u3 !== l3; ++u3) {
          var h3 = arguments[u3], d3 = h3.uuid, p3 = r3[d3];
          if (void 0 === p3) {
            p3 = t3++, r3[d3] = p3, e3.push(h3);
            for (var f3 = 0, m3 = s2; f3 !== m3; ++f3)
              o2[f3].push(new Cs(h3, i3[f3], a2[f3]));
          } else if (p3 < n3) {
            c3 = e3[p3];
            var g3 = --n3, v3 = e3[g3];
            r3[v3.uuid] = p3, e3[p3] = v3, r3[d3] = g3, e3[g3] = h3;
            for (f3 = 0, m3 = s2; f3 !== m3; ++f3) {
              var y3 = o2[f3], x3 = y3[g3], b3 = y3[p3];
              y3[p3] = x3, void 0 === b3 && (b3 = new Cs(h3, i3[f3], a2[f3])), y3[g3] = b3;
            }
          } else
            e3[p3] !== c3 && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
        }
        this.nCachedObjects_ = n3;
      }, remove: function() {
        for (var e3 = this._objects, t3 = this.nCachedObjects_, n3 = this._indicesByUUID, r3 = this._bindings, i3 = r3.length, a2 = 0, o2 = arguments.length; a2 !== o2; ++a2) {
          var s2 = arguments[a2], c3 = s2.uuid, u3 = n3[c3];
          if (void 0 !== u3 && u3 >= t3) {
            var l3 = t3++, h3 = e3[l3];
            n3[h3.uuid] = u3, e3[u3] = h3, n3[c3] = l3, e3[l3] = s2;
            for (var d3 = 0, p3 = i3; d3 !== p3; ++d3) {
              var f3 = r3[d3], m3 = f3[l3], g3 = f3[u3];
              f3[u3] = m3, f3[l3] = g3;
            }
          }
        }
        this.nCachedObjects_ = t3;
      }, uncache: function() {
        for (var e3 = this._objects, t3 = e3.length, n3 = this.nCachedObjects_, r3 = this._indicesByUUID, i3 = this._bindings, a2 = i3.length, o2 = 0, s2 = arguments.length; o2 !== s2; ++o2) {
          var c3 = arguments[o2].uuid, u3 = r3[c3];
          if (void 0 !== u3)
            if (delete r3[c3], u3 < n3) {
              var l3 = --n3, h3 = e3[l3], d3 = e3[v3 = --t3];
              r3[h3.uuid] = u3, e3[u3] = h3, r3[d3.uuid] = l3, e3[l3] = d3, e3.pop();
              for (var p3 = 0, f3 = a2; p3 !== f3; ++p3) {
                var m3 = (y3 = i3[p3])[l3], g3 = y3[v3];
                y3[u3] = m3, y3[l3] = g3, y3.pop();
              }
            } else {
              var v3;
              r3[(d3 = e3[v3 = --t3]).uuid] = u3, e3[u3] = d3, e3.pop();
              for (p3 = 0, f3 = a2; p3 !== f3; ++p3) {
                var y3;
                (y3 = i3[p3])[u3] = y3[v3], y3.pop();
              }
            }
        }
        this.nCachedObjects_ = n3;
      }, subscribe_: function(e3, t3) {
        var n3 = this._bindingsIndicesByPath, r3 = n3[e3], i3 = this._bindings;
        if (void 0 !== r3)
          return i3[r3];
        var a2 = this._paths, o2 = this._parsedPaths, s2 = this._objects, c3 = s2.length, u3 = this.nCachedObjects_, l3 = new Array(c3);
        r3 = i3.length, n3[e3] = r3, a2.push(e3), o2.push(t3), i3.push(l3);
        for (var h3 = u3, d3 = s2.length; h3 !== d3; ++h3) {
          var p3 = s2[h3];
          l3[h3] = new Cs(p3, e3, t3);
        }
        return l3;
      }, unsubscribe_: function(e3) {
        var t3 = this._bindingsIndicesByPath, n3 = t3[e3];
        if (void 0 !== n3) {
          var r3 = this._paths, i3 = this._parsedPaths, a2 = this._bindings, o2 = a2.length - 1, s2 = a2[o2];
          t3[e3[o2]] = n3, a2[n3] = s2, a2.pop(), i3[n3] = i3[o2], i3.pop(), r3[n3] = r3[o2], r3.pop();
        }
      } }), Object.assign(Os.prototype, { play: function() {
        return this._mixer._activateAction(this), this;
      }, stop: function() {
        return this._mixer._deactivateAction(this), this.reset();
      }, reset: function() {
        return this.paused = false, this.enabled = true, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
      }, isRunning: function() {
        return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
      }, isScheduled: function() {
        return this._mixer._isActiveAction(this);
      }, startAt: function(e3) {
        return this._startTime = e3, this;
      }, setLoop: function(e3, t3) {
        return this.loop = e3, this.repetitions = t3, this;
      }, setEffectiveWeight: function(e3) {
        return this.weight = e3, this._effectiveWeight = this.enabled ? e3 : 0, this.stopFading();
      }, getEffectiveWeight: function() {
        return this._effectiveWeight;
      }, fadeIn: function(e3) {
        return this._scheduleFading(e3, 0, 1);
      }, fadeOut: function(e3) {
        return this._scheduleFading(e3, 1, 0);
      }, crossFadeFrom: function(e3, t3, n3) {
        if (e3.fadeOut(t3), this.fadeIn(t3), n3) {
          var r3 = this._clip.duration, i3 = e3._clip.duration, a2 = i3 / r3, o2 = r3 / i3;
          e3.warp(1, a2, t3), this.warp(o2, 1, t3);
        }
        return this;
      }, crossFadeTo: function(e3, t3, n3) {
        return e3.crossFadeFrom(this, t3, n3);
      }, stopFading: function() {
        var e3 = this._weightInterpolant;
        return null !== e3 && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e3)), this;
      }, setEffectiveTimeScale: function(e3) {
        return this.timeScale = e3, this._effectiveTimeScale = this.paused ? 0 : e3, this.stopWarping();
      }, getEffectiveTimeScale: function() {
        return this._effectiveTimeScale;
      }, setDuration: function(e3) {
        return this.timeScale = this._clip.duration / e3, this.stopWarping();
      }, syncWith: function(e3) {
        return this.time = e3.time, this.timeScale = e3.timeScale, this.stopWarping();
      }, halt: function(e3) {
        return this.warp(this._effectiveTimeScale, 0, e3);
      }, warp: function(e3, t3, n3) {
        var r3 = this._mixer, i3 = r3.time, a2 = this._timeScaleInterpolant, o2 = this.timeScale;
        null === a2 && (a2 = r3._lendControlInterpolant(), this._timeScaleInterpolant = a2);
        var s2 = a2.parameterPositions, c3 = a2.sampleValues;
        return s2[0] = i3, s2[1] = i3 + n3, c3[0] = e3 / o2, c3[1] = t3 / o2, this;
      }, stopWarping: function() {
        var e3 = this._timeScaleInterpolant;
        return null !== e3 && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e3)), this;
      }, getMixer: function() {
        return this._mixer;
      }, getClip: function() {
        return this._clip;
      }, getRoot: function() {
        return this._localRoot || this._mixer._root;
      }, _update: function(e3, t3, n3, r3) {
        if (this.enabled) {
          var i3 = this._startTime;
          if (null !== i3) {
            var a2 = (e3 - i3) * n3;
            if (a2 < 0 || 0 === n3)
              return;
            this._startTime = null, t3 = n3 * a2;
          }
          t3 *= this._updateTimeScale(e3);
          var o2 = this._updateTime(t3), s2 = this._updateWeight(e3);
          if (s2 > 0)
            for (var c3 = this._interpolants, u3 = this._propertyBindings, l3 = 0, h3 = c3.length; l3 !== h3; ++l3)
              c3[l3].evaluate(o2), u3[l3].accumulate(r3, s2);
        } else
          this._updateWeight(e3);
      }, _updateWeight: function(e3) {
        var t3 = 0;
        if (this.enabled) {
          t3 = this.weight;
          var n3 = this._weightInterpolant;
          if (null !== n3) {
            var r3 = n3.evaluate(e3)[0];
            t3 *= r3, e3 > n3.parameterPositions[1] && (this.stopFading(), 0 === r3 && (this.enabled = false));
          }
        }
        return this._effectiveWeight = t3, t3;
      }, _updateTimeScale: function(e3) {
        var t3 = 0;
        if (!this.paused) {
          t3 = this.timeScale;
          var n3 = this._timeScaleInterpolant;
          if (null !== n3)
            t3 *= n3.evaluate(e3)[0], e3 > n3.parameterPositions[1] && (this.stopWarping(), 0 === t3 ? this.paused = true : this.timeScale = t3);
        }
        return this._effectiveTimeScale = t3, t3;
      }, _updateTime: function(e3) {
        var t3 = this.time + e3, n3 = this._clip.duration, r3 = this.loop, i3 = this._loopCount, a2 = r3 === mt;
        if (0 === e3)
          return -1 === i3 ? t3 : a2 && 1 == (1 & i3) ? n3 - t3 : t3;
        if (r3 === pt) {
          -1 === i3 && (this._loopCount = 0, this._setEndings(true, true, false));
          e: {
            if (t3 >= n3)
              t3 = n3;
            else {
              if (!(t3 < 0))
                break e;
              t3 = 0;
            }
            this.clampWhenFinished ? this.paused = true : this.enabled = false, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e3 < 0 ? -1 : 1 });
          }
        } else {
          if (-1 === i3 && (e3 >= 0 ? (i3 = 0, this._setEndings(true, 0 === this.repetitions, a2)) : this._setEndings(0 === this.repetitions, true, a2)), t3 >= n3 || t3 < 0) {
            var o2 = Math.floor(t3 / n3);
            t3 -= n3 * o2, i3 += Math.abs(o2);
            var s2 = this.repetitions - i3;
            if (s2 <= 0)
              this.clampWhenFinished ? this.paused = true : this.enabled = false, t3 = e3 > 0 ? n3 : 0, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e3 > 0 ? 1 : -1 });
            else {
              if (1 === s2) {
                var c3 = e3 < 0;
                this._setEndings(c3, !c3, a2);
              } else
                this._setEndings(false, false, a2);
              this._loopCount = i3, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: o2 });
            }
          }
          if (a2 && 1 == (1 & i3))
            return this.time = t3, n3 - t3;
        }
        return this.time = t3, t3;
      }, _setEndings: function(e3, t3, n3) {
        var r3 = this._interpolantSettings;
        n3 ? (r3.endingStart = bt, r3.endingEnd = bt) : (r3.endingStart = e3 ? this.zeroSlopeAtStart ? bt : xt : wt, r3.endingEnd = t3 ? this.zeroSlopeAtEnd ? bt : xt : wt);
      }, _scheduleFading: function(e3, t3, n3) {
        var r3 = this._mixer, i3 = r3.time, a2 = this._weightInterpolant;
        null === a2 && (a2 = r3._lendControlInterpolant(), this._weightInterpolant = a2);
        var o2 = a2.parameterPositions, s2 = a2.sampleValues;
        return o2[0] = i3, s2[0] = t3, o2[1] = i3 + e3, s2[1] = n3, this;
      } }), Ns.prototype = Object.assign(Object.create(r2.prototype), { constructor: Ns, _bindAction: function(e3, t3) {
        var n3 = e3._localRoot || this._root, r3 = e3._clip.tracks, i3 = r3.length, a2 = e3._propertyBindings, o2 = e3._interpolants, s2 = n3.uuid, c3 = this._bindingsByRootAndName, u3 = c3[s2];
        void 0 === u3 && (u3 = {}, c3[s2] = u3);
        for (var l3 = 0; l3 !== i3; ++l3) {
          var h3 = r3[l3], d3 = h3.name, p3 = u3[d3];
          if (void 0 !== p3)
            a2[l3] = p3;
          else {
            if (void 0 !== (p3 = a2[l3])) {
              null === p3._cacheIndex && (++p3.referenceCount, this._addInactiveBinding(p3, s2, d3));
              continue;
            }
            var f3 = t3 && t3._propertyBindings[l3].binding.parsedPath;
            ++(p3 = new Ss(Cs.create(n3, d3, f3), h3.ValueTypeName, h3.getValueSize())).referenceCount, this._addInactiveBinding(p3, s2, d3), a2[l3] = p3;
          }
          o2[l3].resultBuffer = p3.buffer;
        }
      }, _activateAction: function(e3) {
        if (!this._isActiveAction(e3)) {
          if (null === e3._cacheIndex) {
            var t3 = (e3._localRoot || this._root).uuid, n3 = e3._clip.uuid, r3 = this._actionsByClip[n3];
            this._bindAction(e3, r3 && r3.knownActions[0]), this._addInactiveAction(e3, n3, t3);
          }
          for (var i3 = e3._propertyBindings, a2 = 0, o2 = i3.length; a2 !== o2; ++a2) {
            var s2 = i3[a2];
            0 == s2.useCount++ && (this._lendBinding(s2), s2.saveOriginalState());
          }
          this._lendAction(e3);
        }
      }, _deactivateAction: function(e3) {
        if (this._isActiveAction(e3)) {
          for (var t3 = e3._propertyBindings, n3 = 0, r3 = t3.length; n3 !== r3; ++n3) {
            var i3 = t3[n3];
            0 == --i3.useCount && (i3.restoreOriginalState(), this._takeBackBinding(i3));
          }
          this._takeBackAction(e3);
        }
      }, _initMemoryManager: function() {
        this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
        var e3 = this;
        this.stats = { actions: { get total() {
          return e3._actions.length;
        }, get inUse() {
          return e3._nActiveActions;
        } }, bindings: { get total() {
          return e3._bindings.length;
        }, get inUse() {
          return e3._nActiveBindings;
        } }, controlInterpolants: { get total() {
          return e3._controlInterpolants.length;
        }, get inUse() {
          return e3._nActiveControlInterpolants;
        } } };
      }, _isActiveAction: function(e3) {
        var t3 = e3._cacheIndex;
        return null !== t3 && t3 < this._nActiveActions;
      }, _addInactiveAction: function(e3, t3, n3) {
        var r3 = this._actions, i3 = this._actionsByClip, a2 = i3[t3];
        if (void 0 === a2)
          a2 = { knownActions: [e3], actionByRoot: {} }, e3._byClipCacheIndex = 0, i3[t3] = a2;
        else {
          var o2 = a2.knownActions;
          e3._byClipCacheIndex = o2.length, o2.push(e3);
        }
        e3._cacheIndex = r3.length, r3.push(e3), a2.actionByRoot[n3] = e3;
      }, _removeInactiveAction: function(e3) {
        var t3 = this._actions, n3 = t3[t3.length - 1], r3 = e3._cacheIndex;
        n3._cacheIndex = r3, t3[r3] = n3, t3.pop(), e3._cacheIndex = null;
        var i3 = e3._clip.uuid, a2 = this._actionsByClip, o2 = a2[i3], s2 = o2.knownActions, c3 = s2[s2.length - 1], u3 = e3._byClipCacheIndex;
        c3._byClipCacheIndex = u3, s2[u3] = c3, s2.pop(), e3._byClipCacheIndex = null, delete o2.actionByRoot[(e3._localRoot || this._root).uuid], 0 === s2.length && delete a2[i3], this._removeInactiveBindingsForAction(e3);
      }, _removeInactiveBindingsForAction: function(e3) {
        for (var t3 = e3._propertyBindings, n3 = 0, r3 = t3.length; n3 !== r3; ++n3) {
          var i3 = t3[n3];
          0 == --i3.referenceCount && this._removeInactiveBinding(i3);
        }
      }, _lendAction: function(e3) {
        var t3 = this._actions, n3 = e3._cacheIndex, r3 = this._nActiveActions++, i3 = t3[r3];
        e3._cacheIndex = r3, t3[r3] = e3, i3._cacheIndex = n3, t3[n3] = i3;
      }, _takeBackAction: function(e3) {
        var t3 = this._actions, n3 = e3._cacheIndex, r3 = --this._nActiveActions, i3 = t3[r3];
        e3._cacheIndex = r3, t3[r3] = e3, i3._cacheIndex = n3, t3[n3] = i3;
      }, _addInactiveBinding: function(e3, t3, n3) {
        var r3 = this._bindingsByRootAndName, i3 = r3[t3], a2 = this._bindings;
        void 0 === i3 && (i3 = {}, r3[t3] = i3), i3[n3] = e3, e3._cacheIndex = a2.length, a2.push(e3);
      }, _removeInactiveBinding: function(e3) {
        var t3 = this._bindings, n3 = e3.binding, r3 = n3.rootNode.uuid, i3 = n3.path, a2 = this._bindingsByRootAndName, o2 = a2[r3], s2 = t3[t3.length - 1], c3 = e3._cacheIndex;
        s2._cacheIndex = c3, t3[c3] = s2, t3.pop(), delete o2[i3];
        e: {
          for (var u3 in o2)
            break e;
          delete a2[r3];
        }
      }, _lendBinding: function(e3) {
        var t3 = this._bindings, n3 = e3._cacheIndex, r3 = this._nActiveBindings++, i3 = t3[r3];
        e3._cacheIndex = r3, t3[r3] = e3, i3._cacheIndex = n3, t3[n3] = i3;
      }, _takeBackBinding: function(e3) {
        var t3 = this._bindings, n3 = e3._cacheIndex, r3 = --this._nActiveBindings, i3 = t3[r3];
        e3._cacheIndex = r3, t3[r3] = e3, i3._cacheIndex = n3, t3[n3] = i3;
      }, _lendControlInterpolant: function() {
        var e3 = this._controlInterpolants, t3 = this._nActiveControlInterpolants++, n3 = e3[t3];
        return void 0 === n3 && ((n3 = new Vo(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = t3, e3[t3] = n3), n3;
      }, _takeBackControlInterpolant: function(e3) {
        var t3 = this._controlInterpolants, n3 = e3.__cacheIndex, r3 = --this._nActiveControlInterpolants, i3 = t3[r3];
        e3.__cacheIndex = r3, t3[r3] = e3, i3.__cacheIndex = n3, t3[n3] = i3;
      }, _controlInterpolantsResultBuffer: new Float32Array(1), clipAction: function(e3, t3) {
        var n3 = t3 || this._root, r3 = n3.uuid, i3 = "string" == typeof e3 ? es.findByName(n3, e3) : e3, a2 = null !== i3 ? i3.uuid : e3, o2 = this._actionsByClip[a2], s2 = null;
        if (void 0 !== o2) {
          var c3 = o2.actionByRoot[r3];
          if (void 0 !== c3)
            return c3;
          s2 = o2.knownActions[0], null === i3 && (i3 = s2._clip);
        }
        if (null === i3)
          return null;
        var u3 = new Os(this, i3, t3);
        return this._bindAction(u3, s2), this._addInactiveAction(u3, a2, r3), u3;
      }, existingAction: function(e3, t3) {
        var n3 = t3 || this._root, r3 = n3.uuid, i3 = "string" == typeof e3 ? es.findByName(n3, e3) : e3, a2 = i3 ? i3.uuid : e3, o2 = this._actionsByClip[a2];
        return void 0 !== o2 && o2.actionByRoot[r3] || null;
      }, stopAllAction: function() {
        var e3 = this._actions, t3 = this._nActiveActions, n3 = this._bindings, r3 = this._nActiveBindings;
        this._nActiveActions = 0, this._nActiveBindings = 0;
        for (var i3 = 0; i3 !== t3; ++i3)
          e3[i3].reset();
        for (i3 = 0; i3 !== r3; ++i3)
          n3[i3].useCount = 0;
        return this;
      }, update: function(e3) {
        e3 *= this.timeScale;
        for (var t3 = this._actions, n3 = this._nActiveActions, r3 = this.time += e3, i3 = Math.sign(e3), a2 = this._accuIndex ^= 1, o2 = 0; o2 !== n3; ++o2) {
          t3[o2]._update(r3, e3, i3, a2);
        }
        var s2 = this._bindings, c3 = this._nActiveBindings;
        for (o2 = 0; o2 !== c3; ++o2)
          s2[o2].apply(a2);
        return this;
      }, getRoot: function() {
        return this._root;
      }, uncacheClip: function(e3) {
        var t3 = this._actions, n3 = e3.uuid, r3 = this._actionsByClip, i3 = r3[n3];
        if (void 0 !== i3) {
          for (var a2 = i3.knownActions, o2 = 0, s2 = a2.length; o2 !== s2; ++o2) {
            var c3 = a2[o2];
            this._deactivateAction(c3);
            var u3 = c3._cacheIndex, l3 = t3[t3.length - 1];
            c3._cacheIndex = null, c3._byClipCacheIndex = null, l3._cacheIndex = u3, t3[u3] = l3, t3.pop(), this._removeInactiveBindingsForAction(c3);
          }
          delete r3[n3];
        }
      }, uncacheRoot: function(e3) {
        var t3 = e3.uuid, n3 = this._actionsByClip;
        for (var r3 in n3) {
          var i3 = n3[r3].actionByRoot[t3];
          void 0 !== i3 && (this._deactivateAction(i3), this._removeInactiveAction(i3));
        }
        var a2 = this._bindingsByRootAndName[t3];
        if (void 0 !== a2)
          for (var o2 in a2) {
            var s2 = a2[o2];
            s2.restoreOriginalState(), this._removeInactiveBinding(s2);
          }
      }, uncacheAction: function(e3, t3) {
        var n3 = this.existingAction(e3, t3);
        null !== n3 && (this._deactivateAction(n3), this._removeInactiveAction(n3));
      } }), Is.prototype.clone = function() {
        return new Is(void 0 === this.value.clone ? this.value : this.value.clone());
      }, Ds.prototype = Object.assign(Object.create(Pn.prototype), { constructor: Ds, isInstancedBufferGeometry: true, copy: function(e3) {
        return Pn.prototype.copy.call(this, e3), this.maxInstancedCount = e3.maxInstancedCount, this;
      }, clone: function() {
        return new this.constructor().copy(this);
      } }), Us.prototype = Object.assign(Object.create(li2.prototype), { constructor: Us, isInstancedInterleavedBuffer: true, copy: function(e3) {
        return li2.prototype.copy.call(this, e3), this.meshPerAttribute = e3.meshPerAttribute, this;
      } }), Bs.prototype = Object.assign(Object.create(yn.prototype), { constructor: Bs, isInstancedBufferAttribute: true, copy: function(e3) {
        return yn.prototype.copy.call(this, e3), this.meshPerAttribute = e3.meshPerAttribute, this;
      } }), Object.assign(Fs.prototype, { linePrecision: 1, set: function(e3, t3) {
        this.ray.set(e3, t3);
      }, setFromCamera: function(e3, t3) {
        t3 && t3.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t3.matrixWorld), this.ray.direction.set(e3.x, e3.y, 0.5).unproject(t3).sub(this.ray.origin).normalize()) : t3 && t3.isOrthographicCamera ? (this.ray.origin.set(e3.x, e3.y, (t3.near + t3.far) / (t3.near - t3.far)).unproject(t3), this.ray.direction.set(0, 0, -1).transformDirection(t3.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.");
      }, intersectObject: function(e3, t3, n3) {
        var r3 = n3 || [];
        return zs(e3, this, r3, t3), r3.sort(Gs), r3;
      }, intersectObjects: function(e3, t3, n3) {
        var r3 = n3 || [];
        if (false === Array.isArray(e3))
          return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), r3;
        for (var i3 = 0, a2 = e3.length; i3 < a2; i3++)
          zs(e3[i3], this, r3, t3);
        return r3.sort(Gs), r3;
      } }), Object.assign(Hs.prototype, { start: function() {
        this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = true;
      }, stop: function() {
        this.getElapsedTime(), this.running = false, this.autoStart = false;
      }, getElapsedTime: function() {
        return this.getDelta(), this.elapsedTime;
      }, getDelta: function() {
        var e3 = 0;
        if (this.autoStart && !this.running)
          return this.start(), 0;
        if (this.running) {
          var t3 = ("undefined" == typeof performance ? Date : performance).now();
          e3 = (t3 - this.oldTime) / 1e3, this.oldTime = t3, this.elapsedTime += e3;
        }
        return e3;
      } }), Object.assign(ks.prototype, { set: function(e3, t3, n3) {
        return this.radius = e3, this.phi = t3, this.theta = n3, this;
      }, clone: function() {
        return new this.constructor().copy(this);
      }, copy: function(e3) {
        return this.radius = e3.radius, this.phi = e3.phi, this.theta = e3.theta, this;
      }, makeSafe: function() {
        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
      }, setFromVector3: function(e3) {
        return this.radius = e3.length(), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e3.x, e3.z), this.phi = Math.acos(Bt.clamp(e3.y / this.radius, -1, 1))), this;
      } }), Object.assign(js.prototype, { set: function(e3, t3, n3) {
        return this.radius = e3, this.theta = t3, this.y = n3, this;
      }, clone: function() {
        return new this.constructor().copy(this);
      }, copy: function(e3) {
        return this.radius = e3.radius, this.theta = e3.theta, this.y = e3.y, this;
      }, setFromVector3: function(e3) {
        return this.radius = Math.sqrt(e3.x * e3.x + e3.z * e3.z), this.theta = Math.atan2(e3.x, e3.z), this.y = e3.y, this;
      } }), Object.assign(Vs.prototype, { set: function(e3, t3) {
        return this.min.copy(e3), this.max.copy(t3), this;
      }, setFromPoints: function(e3) {
        this.makeEmpty();
        for (var t3 = 0, n3 = e3.length; t3 < n3; t3++)
          this.expandByPoint(e3[t3]);
        return this;
      }, setFromCenterAndSize: function() {
        var e3 = new Ft();
        return function(t3, n3) {
          var r3 = e3.copy(n3).multiplyScalar(0.5);
          return this.min.copy(t3).sub(r3), this.max.copy(t3).add(r3), this;
        };
      }(), clone: function() {
        return new this.constructor().copy(this);
      }, copy: function(e3) {
        return this.min.copy(e3.min), this.max.copy(e3.max), this;
      }, makeEmpty: function() {
        return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
      }, isEmpty: function() {
        return this.max.x < this.min.x || this.max.y < this.min.y;
      }, getCenter: function(e3) {
        return void 0 === e3 && (console.warn("THREE.Box2: .getCenter() target is now required"), e3 = new Ft()), this.isEmpty() ? e3.set(0, 0) : e3.addVectors(this.min, this.max).multiplyScalar(0.5);
      }, getSize: function(e3) {
        return void 0 === e3 && (console.warn("THREE.Box2: .getSize() target is now required"), e3 = new Ft()), this.isEmpty() ? e3.set(0, 0) : e3.subVectors(this.max, this.min);
      }, expandByPoint: function(e3) {
        return this.min.min(e3), this.max.max(e3), this;
      }, expandByVector: function(e3) {
        return this.min.sub(e3), this.max.add(e3), this;
      }, expandByScalar: function(e3) {
        return this.min.addScalar(-e3), this.max.addScalar(e3), this;
      }, containsPoint: function(e3) {
        return !(e3.x < this.min.x || e3.x > this.max.x || e3.y < this.min.y || e3.y > this.max.y);
      }, containsBox: function(e3) {
        return this.min.x <= e3.min.x && e3.max.x <= this.max.x && this.min.y <= e3.min.y && e3.max.y <= this.max.y;
      }, getParameter: function(e3, t3) {
        return void 0 === t3 && (console.warn("THREE.Box2: .getParameter() target is now required"), t3 = new Ft()), t3.set((e3.x - this.min.x) / (this.max.x - this.min.x), (e3.y - this.min.y) / (this.max.y - this.min.y));
      }, intersectsBox: function(e3) {
        return !(e3.max.x < this.min.x || e3.min.x > this.max.x || e3.max.y < this.min.y || e3.min.y > this.max.y);
      }, clampPoint: function(e3, t3) {
        return void 0 === t3 && (console.warn("THREE.Box2: .clampPoint() target is now required"), t3 = new Ft()), t3.copy(e3).clamp(this.min, this.max);
      }, distanceToPoint: function() {
        var e3 = new Ft();
        return function(t3) {
          return e3.copy(t3).clamp(this.min, this.max).sub(t3).length();
        };
      }(), intersect: function(e3) {
        return this.min.max(e3.min), this.max.min(e3.max), this;
      }, union: function(e3) {
        return this.min.min(e3.min), this.max.max(e3.max), this;
      }, translate: function(e3) {
        return this.min.add(e3), this.max.add(e3), this;
      }, equals: function(e3) {
        return e3.min.equals(this.min) && e3.max.equals(this.max);
      } }), Object.assign(Ws.prototype, { set: function(e3, t3) {
        return this.start.copy(e3), this.end.copy(t3), this;
      }, clone: function() {
        return new this.constructor().copy(this);
      }, copy: function(e3) {
        return this.start.copy(e3.start), this.end.copy(e3.end), this;
      }, getCenter: function(e3) {
        return void 0 === e3 && (console.warn("THREE.Line3: .getCenter() target is now required"), e3 = new Ht()), e3.addVectors(this.start, this.end).multiplyScalar(0.5);
      }, delta: function(e3) {
        return void 0 === e3 && (console.warn("THREE.Line3: .delta() target is now required"), e3 = new Ht()), e3.subVectors(this.end, this.start);
      }, distanceSq: function() {
        return this.start.distanceToSquared(this.end);
      }, distance: function() {
        return this.start.distanceTo(this.end);
      }, at: function(e3, t3) {
        return void 0 === t3 && (console.warn("THREE.Line3: .at() target is now required"), t3 = new Ht()), this.delta(t3).multiplyScalar(e3).add(this.start);
      }, closestPointToPointParameter: function() {
        var e3 = new Ht(), t3 = new Ht();
        return function(n3, r3) {
          e3.subVectors(n3, this.start), t3.subVectors(this.end, this.start);
          var i3 = t3.dot(t3), a2 = t3.dot(e3) / i3;
          return r3 && (a2 = Bt.clamp(a2, 0, 1)), a2;
        };
      }(), closestPointToPoint: function(e3, t3, n3) {
        var r3 = this.closestPointToPointParameter(e3, t3);
        return void 0 === n3 && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), n3 = new Ht()), this.delta(n3).multiplyScalar(r3).add(this.start);
      }, applyMatrix4: function(e3) {
        return this.start.applyMatrix4(e3), this.end.applyMatrix4(e3), this;
      }, equals: function(e3) {
        return e3.start.equals(this.start) && e3.end.equals(this.end);
      } }), Xs.prototype = Object.create(dn.prototype), Xs.prototype.constructor = Xs, Xs.prototype.isImmediateRenderObject = true, qs.prototype = Object.create(bi2.prototype), qs.prototype.constructor = qs, qs.prototype.update = function() {
        var e3 = new Ht(), t3 = new Ht(), n3 = new kt();
        return function() {
          var r3 = ["a", "b", "c"];
          this.object.updateMatrixWorld(true), n3.getNormalMatrix(this.object.matrixWorld);
          var i3 = this.object.matrixWorld, a2 = this.geometry.attributes.position, o2 = this.object.geometry;
          if (o2 && o2.isGeometry)
            for (var s2 = o2.vertices, c3 = o2.faces, u3 = 0, l3 = 0, h3 = c3.length; l3 < h3; l3++)
              for (var d3 = c3[l3], p3 = 0, f3 = d3.vertexNormals.length; p3 < f3; p3++) {
                var m3 = s2[d3[r3[p3]]], g3 = d3.vertexNormals[p3];
                e3.copy(m3).applyMatrix4(i3), t3.copy(g3).applyMatrix3(n3).normalize().multiplyScalar(this.size).add(e3), a2.setXYZ(u3, e3.x, e3.y, e3.z), u3 += 1, a2.setXYZ(u3, t3.x, t3.y, t3.z), u3 += 1;
              }
          else if (o2 && o2.isBufferGeometry) {
            var v3 = o2.attributes.position, y3 = o2.attributes.normal;
            for (u3 = 0, p3 = 0, f3 = v3.count; p3 < f3; p3++)
              e3.set(v3.getX(p3), v3.getY(p3), v3.getZ(p3)).applyMatrix4(i3), t3.set(y3.getX(p3), y3.getY(p3), y3.getZ(p3)), t3.applyMatrix3(n3).normalize().multiplyScalar(this.size).add(e3), a2.setXYZ(u3, e3.x, e3.y, e3.z), u3 += 1, a2.setXYZ(u3, t3.x, t3.y, t3.z), u3 += 1;
          }
          a2.needsUpdate = true;
        };
      }(), Ys.prototype = Object.create(dn.prototype), Ys.prototype.constructor = Ys, Ys.prototype.dispose = function() {
        this.cone.geometry.dispose(), this.cone.material.dispose();
      }, Ys.prototype.update = function() {
        var e3 = new Ht(), t3 = new Ht();
        return function() {
          this.light.updateMatrixWorld();
          var n3 = this.light.distance ? this.light.distance : 1e3, r3 = n3 * Math.tan(this.light.angle);
          this.cone.scale.set(r3, r3, n3), e3.setFromMatrixPosition(this.light.matrixWorld), t3.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(t3.sub(e3)), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
        };
      }(), Zs.prototype = Object.create(bi2.prototype), Zs.prototype.constructor = Zs, Zs.prototype.updateMatrixWorld = function() {
        var e3 = new Ht(), t3 = new Gt(), n3 = new Gt();
        return function(r3) {
          var i3 = this.bones, a2 = this.geometry, o2 = a2.getAttribute("position");
          n3.getInverse(this.root.matrixWorld);
          for (var s2 = 0, c3 = 0; s2 < i3.length; s2++) {
            var u3 = i3[s2];
            u3.parent && u3.parent.isBone && (t3.multiplyMatrices(n3, u3.matrixWorld), e3.setFromMatrixPosition(t3), o2.setXYZ(c3, e3.x, e3.y, e3.z), t3.multiplyMatrices(n3, u3.parent.matrixWorld), e3.setFromMatrixPosition(t3), o2.setXYZ(c3 + 1, e3.x, e3.y, e3.z), c3 += 2);
          }
          a2.getAttribute("position").needsUpdate = true, dn.prototype.updateMatrixWorld.call(this, r3);
        };
      }(), Js.prototype = Object.create(kn.prototype), Js.prototype.constructor = Js, Js.prototype.dispose = function() {
        this.geometry.dispose(), this.material.dispose();
      }, Js.prototype.update = function() {
        void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
      }, Ks.prototype = Object.create(dn.prototype), Ks.prototype.constructor = Ks, Ks.prototype.dispose = function() {
        this.children[0].geometry.dispose(), this.children[0].material.dispose();
      }, Ks.prototype.update = function() {
        var e3 = 0.5 * this.light.width, t3 = 0.5 * this.light.height, n3 = this.line.geometry.attributes.position, r3 = n3.array;
        r3[0] = e3, r3[1] = -t3, r3[2] = 0, r3[3] = e3, r3[4] = t3, r3[5] = 0, r3[6] = -e3, r3[7] = t3, r3[8] = 0, r3[9] = -e3, r3[10] = -t3, r3[11] = 0, r3[12] = e3, r3[13] = -t3, r3[14] = 0, n3.needsUpdate = true, void 0 !== this.color ? this.line.material.color.set(this.color) : this.line.material.color.copy(this.light.color);
      }, Qs.prototype = Object.create(dn.prototype), Qs.prototype.constructor = Qs, Qs.prototype.dispose = function() {
        this.children[0].geometry.dispose(), this.children[0].material.dispose();
      }, Qs.prototype.update = function() {
        var e3 = new Ht(), t3 = new rn(), n3 = new rn();
        return function() {
          var r3 = this.children[0];
          if (void 0 !== this.color)
            this.material.color.set(this.color);
          else {
            var i3 = r3.geometry.getAttribute("color");
            t3.copy(this.light.color), n3.copy(this.light.groundColor);
            for (var a2 = 0, o2 = i3.count; a2 < o2; a2++) {
              var s2 = a2 < o2 / 2 ? t3 : n3;
              i3.setXYZ(a2, s2.r, s2.g, s2.b);
            }
            i3.needsUpdate = true;
          }
          r3.lookAt(e3.setFromMatrixPosition(this.light.matrixWorld).negate());
        };
      }(), $s.prototype = Object.create(bi2.prototype), $s.prototype.constructor = $s, ec2.prototype = Object.create(bi2.prototype), ec2.prototype.constructor = ec2, tc2.prototype = Object.create(bi2.prototype), tc2.prototype.constructor = tc2, tc2.prototype.update = function() {
        var e3 = new Ht(), t3 = new Ht(), n3 = new kt();
        return function() {
          this.object.updateMatrixWorld(true), n3.getNormalMatrix(this.object.matrixWorld);
          for (var r3 = this.object.matrixWorld, i3 = this.geometry.attributes.position, a2 = this.object.geometry, o2 = a2.vertices, s2 = a2.faces, c3 = 0, u3 = 0, l3 = s2.length; u3 < l3; u3++) {
            var h3 = s2[u3], d3 = h3.normal;
            e3.copy(o2[h3.a]).add(o2[h3.b]).add(o2[h3.c]).divideScalar(3).applyMatrix4(r3), t3.copy(d3).applyMatrix3(n3).normalize().multiplyScalar(this.size).add(e3), i3.setXYZ(c3, e3.x, e3.y, e3.z), c3 += 1, i3.setXYZ(c3, t3.x, t3.y, t3.z), c3 += 1;
          }
          i3.needsUpdate = true;
        };
      }(), nc2.prototype = Object.create(dn.prototype), nc2.prototype.constructor = nc2, nc2.prototype.dispose = function() {
        this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
      }, nc2.prototype.update = function() {
        var e3 = new Ht(), t3 = new Ht(), n3 = new Ht();
        return function() {
          e3.setFromMatrixPosition(this.light.matrixWorld), t3.setFromMatrixPosition(this.light.target.matrixWorld), n3.subVectors(t3, e3), this.lightPlane.lookAt(n3), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(n3), this.targetLine.scale.z = n3.length();
        };
      }(), rc2.prototype = Object.create(bi2.prototype), rc2.prototype.constructor = rc2, rc2.prototype.update = function() {
        var e3, t3, n3 = new Ht(), r3 = new pn();
        function i3(i4, a2, o2, s2) {
          n3.set(a2, o2, s2).unproject(r3);
          var c3 = t3[i4];
          if (void 0 !== c3)
            for (var u3 = e3.getAttribute("position"), l3 = 0, h3 = c3.length; l3 < h3; l3++)
              u3.setXYZ(c3[l3], n3.x, n3.y, n3.z);
        }
        return function() {
          e3 = this.geometry, t3 = this.pointMap;
          r3.projectionMatrix.copy(this.camera.projectionMatrix), i3("c", 0, 0, -1), i3("t", 0, 0, 1), i3("n1", -1, -1, -1), i3("n2", 1, -1, -1), i3("n3", -1, 1, -1), i3("n4", 1, 1, -1), i3("f1", -1, -1, 1), i3("f2", 1, -1, 1), i3("f3", -1, 1, 1), i3("f4", 1, 1, 1), i3("u1", 0.7, 1.1, -1), i3("u2", -0.7, 1.1, -1), i3("u3", 0, 2, -1), i3("cf1", -1, 0, 1), i3("cf2", 1, 0, 1), i3("cf3", 0, -1, 1), i3("cf4", 0, 1, 1), i3("cn1", -1, 0, -1), i3("cn2", 1, 0, -1), i3("cn3", 0, -1, -1), i3("cn4", 0, 1, -1), e3.getAttribute("position").needsUpdate = true;
        };
      }(), ic2.prototype = Object.create(bi2.prototype), ic2.prototype.constructor = ic2, ic2.prototype.update = function() {
        var e3 = new Jt();
        return function(t3) {
          if (void 0 !== t3 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && e3.setFromObject(this.object), !e3.isEmpty()) {
            var n3 = e3.min, r3 = e3.max, i3 = this.geometry.attributes.position, a2 = i3.array;
            a2[0] = r3.x, a2[1] = r3.y, a2[2] = r3.z, a2[3] = n3.x, a2[4] = r3.y, a2[5] = r3.z, a2[6] = n3.x, a2[7] = n3.y, a2[8] = r3.z, a2[9] = r3.x, a2[10] = n3.y, a2[11] = r3.z, a2[12] = r3.x, a2[13] = r3.y, a2[14] = n3.z, a2[15] = n3.x, a2[16] = r3.y, a2[17] = n3.z, a2[18] = n3.x, a2[19] = n3.y, a2[20] = n3.z, a2[21] = r3.x, a2[22] = n3.y, a2[23] = n3.z, i3.needsUpdate = true, this.geometry.computeBoundingSphere();
          }
        };
      }(), ic2.prototype.setFromObject = function(e3) {
        return this.object = e3, this.update(), this;
      }, ac2.prototype = Object.create(bi2.prototype), ac2.prototype.constructor = ac2, ac2.prototype.updateMatrixWorld = function(e3) {
        var t3 = this.box;
        t3.isEmpty() || (t3.getCenter(this.position), t3.getSize(this.scale), this.scale.multiplyScalar(0.5), dn.prototype.updateMatrixWorld.call(this, e3));
      }, oc2.prototype = Object.create(xi2.prototype), oc2.prototype.constructor = oc2, oc2.prototype.updateMatrixWorld = function(e3) {
        var t3 = -this.plane.constant;
        Math.abs(t3) < 1e-8 && (t3 = 1e-8), this.scale.set(0.5 * this.size, 0.5 * this.size, t3), this.children[0].material.side = t3 < 0 ? g2 : m2, this.lookAt(this.plane.normal), dn.prototype.updateMatrixWorld.call(this, e3);
      }, sc2.prototype = Object.create(dn.prototype), sc2.prototype.constructor = sc2, sc2.prototype.setDirection = function() {
        var e3, t3 = new Ht();
        return function(n3) {
          n3.y > 0.99999 ? this.quaternion.set(0, 0, 0, 1) : n3.y < -0.99999 ? this.quaternion.set(1, 0, 0, 0) : (t3.set(n3.z, 0, -n3.x).normalize(), e3 = Math.acos(n3.y), this.quaternion.setFromAxisAngle(t3, e3));
        };
      }(), sc2.prototype.setLength = function(e3, t3, n3) {
        void 0 === t3 && (t3 = 0.2 * e3), void 0 === n3 && (n3 = 0.2 * t3), this.line.scale.set(1, Math.max(0, e3 - t3), 1), this.line.updateMatrix(), this.cone.scale.set(n3, t3, n3), this.cone.position.y = e3, this.cone.updateMatrix();
      }, sc2.prototype.setColor = function(e3) {
        this.line.material.color.copy(e3), this.cone.material.color.copy(e3);
      }, cc2.prototype = Object.create(bi2.prototype), cc2.prototype.constructor = cc2;
      var lc2 = 0, hc2 = 1;
      function dc2(e3) {
        return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), e3;
      }
      function pc2(e3) {
        return void 0 === e3 && (e3 = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), e3.isMultiMaterial = true, e3.materials = e3, e3.clone = function() {
          return e3.slice();
        }, e3;
      }
      function fc2(e3, t3) {
        return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Mi2(e3, t3);
      }
      function mc2(e3) {
        return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new pi2(e3);
      }
      function gc2(e3, t3) {
        return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Mi2(e3, t3);
      }
      function vc2(e3) {
        return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new _i(e3);
      }
      function yc2(e3) {
        return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new _i(e3);
      }
      function xc2(e3) {
        return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new _i(e3);
      }
      function bc2(e3, t3, n3) {
        return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new Ht(e3, t3, n3);
      }
      function wc2(e3, t3) {
        return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new yn(e3, t3).setDynamic(true);
      }
      function _c(e3, t3) {
        return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new xn(e3, t3);
      }
      function Mc2(e3, t3) {
        return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new bn(e3, t3);
      }
      function Ec2(e3, t3) {
        return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new wn(e3, t3);
      }
      function Tc2(e3, t3) {
        return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new _n(e3, t3);
      }
      function Sc2(e3, t3) {
        return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new Mn(e3, t3);
      }
      function Ac2(e3, t3) {
        return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new En(e3, t3);
      }
      function Lc2(e3, t3) {
        return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new Tn(e3, t3);
      }
      function Rc2(e3, t3) {
        return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new Sn(e3, t3);
      }
      function Cc2(e3, t3) {
        return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new An(e3, t3);
      }
      function Pc2(e3) {
        console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), go.call(this, e3), this.type = "catmullrom", this.closed = true;
      }
      function Oc2(e3) {
        console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), go.call(this, e3), this.type = "catmullrom";
      }
      function Nc2(e3) {
        console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), go.call(this, e3), this.type = "catmullrom";
      }
      function Ic2(e3) {
        return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new cc2(e3);
      }
      function Dc2(e3, t3) {
        return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new ic2(e3, t3);
      }
      function Uc2(e3, t3) {
        return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new bi2(new Na2(e3.geometry), new yi2({ color: void 0 !== t3 ? t3 : 16777215 }));
      }
      function Bc2(e3, t3) {
        return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new bi2(new Li2(e3.geometry), new yi2({ color: void 0 !== t3 ? t3 : 16777215 }));
      }
      function Fc2(e3) {
        return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new to(e3);
      }
      function Gc2(e3) {
        return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new ro(e3);
      }
      so.create = function(e3, t3) {
        return console.log("THREE.Curve.create() has been deprecated"), e3.prototype = Object.create(so.prototype), e3.prototype.constructor = e3, e3.prototype.getPoint = t3, e3;
      }, Object.assign(Lo.prototype, { createPointsGeometry: function(e3) {
        console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
        var t3 = this.getPoints(e3);
        return this.createGeometry(t3);
      }, createSpacedPointsGeometry: function(e3) {
        console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
        var t3 = this.getSpacedPoints(e3);
        return this.createGeometry(t3);
      }, createGeometry: function(e3) {
        console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
        for (var t3 = new vn(), n3 = 0, r3 = e3.length; n3 < r3; n3++) {
          var i3 = e3[n3];
          t3.vertices.push(new Ht(i3.x, i3.y, i3.z || 0));
        }
        return t3;
      } }), Object.assign(Ro.prototype, { fromPoints: function(e3) {
        console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e3);
      } }), Pc2.prototype = Object.create(go.prototype), Oc2.prototype = Object.create(go.prototype), Nc2.prototype = Object.create(go.prototype), Object.assign(Nc2.prototype, { initFromArray: function() {
        console.error("THREE.Spline: .initFromArray() has been removed.");
      }, getControlPointsArray: function() {
        console.error("THREE.Spline: .getControlPointsArray() has been removed.");
      }, reparametrizeByArcLength: function() {
        console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.");
      } }), $s.prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
      }, Zs.prototype.update = function() {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
      }, Object.assign(as.prototype, { extractUrlBase: function(e3) {
        return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), os.extractUrlBase(e3);
      } }), Object.assign(Vs.prototype, { center: function(e3) {
        return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e3);
      }, empty: function() {
        return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
      }, isIntersectionBox: function(e3) {
        return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e3);
      }, size: function(e3) {
        return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e3);
      } }), Object.assign(Jt.prototype, { center: function(e3) {
        return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e3);
      }, empty: function() {
        return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
      }, isIntersectionBox: function(e3) {
        return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e3);
      }, isIntersectionSphere: function(e3) {
        return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e3);
      }, size: function(e3) {
        return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e3);
      } }), Ws.prototype.center = function(e3) {
        return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e3);
      }, Object.assign(Bt, { random16: function() {
        return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random();
      }, nearestPowerOfTwo: function(e3) {
        return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), Bt.floorPowerOfTwo(e3);
      }, nextPowerOfTwo: function(e3) {
        return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), Bt.ceilPowerOfTwo(e3);
      } }), Object.assign(kt.prototype, { flattenToArrayOffset: function(e3, t3) {
        return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e3, t3);
      }, multiplyVector3: function(e3) {
        return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e3.applyMatrix3(this);
      }, multiplyVector3Array: function() {
        console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
      }, applyToBuffer: function(e3) {
        return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e3);
      }, applyToVector3Array: function() {
        console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
      } }), Object.assign(Gt.prototype, { extractPosition: function(e3) {
        return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e3);
      }, flattenToArrayOffset: function(e3, t3) {
        return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e3, t3);
      }, getPosition: function() {
        var e3;
        return function() {
          return void 0 === e3 && (e3 = new Ht()), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), e3.setFromMatrixColumn(this, 3);
        };
      }(), setRotationFromQuaternion: function(e3) {
        return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e3);
      }, multiplyToArray: function() {
        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
      }, multiplyVector3: function(e3) {
        return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e3.applyMatrix4(this);
      }, multiplyVector4: function(e3) {
        return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e3.applyMatrix4(this);
      }, multiplyVector3Array: function() {
        console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
      }, rotateAxis: function(e3) {
        console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e3.transformDirection(this);
      }, crossVector: function(e3) {
        return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e3.applyMatrix4(this);
      }, translate: function() {
        console.error("THREE.Matrix4: .translate() has been removed.");
      }, rotateX: function() {
        console.error("THREE.Matrix4: .rotateX() has been removed.");
      }, rotateY: function() {
        console.error("THREE.Matrix4: .rotateY() has been removed.");
      }, rotateZ: function() {
        console.error("THREE.Matrix4: .rotateZ() has been removed.");
      }, rotateByAxis: function() {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
      }, applyToBuffer: function(e3) {
        return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e3);
      }, applyToVector3Array: function() {
        console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
      }, makeFrustum: function(e3, t3, n3, r3, i3, a2) {
        return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e3, t3, r3, n3, i3, a2);
      } }), Qt.prototype.isIntersectionLine = function(e3) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e3);
      }, zt.prototype.multiplyVector3 = function(e3) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e3.applyQuaternion(this);
      }, Object.assign(zn.prototype, { isIntersectionBox: function(e3) {
        return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e3);
      }, isIntersectionPlane: function(e3) {
        return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e3);
      }, isIntersectionSphere: function(e3) {
        return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e3);
      } }), Object.assign(Hn.prototype, { area: function() {
        return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
      }, barycoordFromPoint: function(e3, t3) {
        return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e3, t3);
      }, midpoint: function(e3) {
        return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e3);
      }, normal: function(e3) {
        return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e3);
      }, plane: function(e3) {
        return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e3);
      } }), Object.assign(Hn, { barycoordFromPoint: function(e3, t3, n3, r3, i3) {
        return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Hn.getBarycoord(e3, t3, n3, r3, i3);
      }, normal: function(e3, t3, n3, r3) {
        return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Hn.getNormal(e3, t3, n3, r3);
      } }), Object.assign(Co.prototype, { extractAllPoints: function(e3) {
        return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e3);
      }, extrude: function(e3) {
        return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new ya2(this, e3);
      }, makeGeometry: function(e3) {
        return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Ca2(this, e3);
      } }), Object.assign(Ft.prototype, { fromAttribute: function(e3, t3, n3) {
        return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e3, t3, n3);
      }, distanceToManhattan: function(e3) {
        return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e3);
      }, lengthManhattan: function() {
        return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
      } }), Object.assign(Ht.prototype, { setEulerFromRotationMatrix: function() {
        console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
      }, setEulerFromQuaternion: function() {
        console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
      }, getPositionFromMatrix: function(e3) {
        return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e3);
      }, getScaleFromMatrix: function(e3) {
        return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e3);
      }, getColumnFromMatrix: function(e3, t3) {
        return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t3, e3);
      }, applyProjection: function(e3) {
        return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e3);
      }, fromAttribute: function(e3, t3, n3) {
        return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e3, t3, n3);
      }, distanceToManhattan: function(e3) {
        return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e3);
      }, lengthManhattan: function() {
        return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
      } }), Object.assign(Xt.prototype, { fromAttribute: function(e3, t3, n3) {
        return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e3, t3, n3);
      }, lengthManhattan: function() {
        return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
      } }), Object.assign(vn.prototype, { computeTangents: function() {
        console.error("THREE.Geometry: .computeTangents() has been removed.");
      }, computeLineDistances: function() {
        console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
      } }), Object.assign(dn.prototype, { getChildByName: function(e3) {
        return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e3);
      }, renderDepth: function() {
        console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
      }, translate: function(e3, t3) {
        return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t3, e3);
      }, getWorldRotation: function() {
        console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
      } }), Object.defineProperties(dn.prototype, { eulerOrder: { get: function() {
        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
      }, set: function(e3) {
        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e3;
      } }, useQuaternion: { get: function() {
        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
      }, set: function() {
        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
      } } }), Object.defineProperties(fi2.prototype, { objects: { get: function() {
        return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels;
      } } }), Object.defineProperty(mi2.prototype, "useVertexTexture", { get: function() {
        console.warn("THREE.Skeleton: useVertexTexture has been removed.");
      }, set: function() {
        console.warn("THREE.Skeleton: useVertexTexture has been removed.");
      } }), Object.defineProperty(so.prototype, "__arcLengthDivisions", { get: function() {
        return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions;
      }, set: function(e3) {
        console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = e3;
      } }), ri2.prototype.setLens = function(e3, t3) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t3 && (this.filmGauge = t3), this.setFocalLength(e3);
      }, Object.defineProperties(Po.prototype, { onlyShadow: { set: function() {
        console.warn("THREE.Light: .onlyShadow has been removed.");
      } }, shadowCameraFov: { set: function(e3) {
        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e3;
      } }, shadowCameraLeft: { set: function(e3) {
        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e3;
      } }, shadowCameraRight: { set: function(e3) {
        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e3;
      } }, shadowCameraTop: { set: function(e3) {
        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e3;
      } }, shadowCameraBottom: { set: function(e3) {
        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e3;
      } }, shadowCameraNear: { set: function(e3) {
        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e3;
      } }, shadowCameraFar: { set: function(e3) {
        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e3;
      } }, shadowCameraVisible: { set: function() {
        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
      } }, shadowBias: { set: function(e3) {
        console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e3;
      } }, shadowDarkness: { set: function() {
        console.warn("THREE.Light: .shadowDarkness has been removed.");
      } }, shadowMapWidth: { set: function(e3) {
        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e3;
      } }, shadowMapHeight: { set: function(e3) {
        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e3;
      } } }), Object.defineProperties(yn.prototype, { length: { get: function() {
        return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length;
      } }, copyIndicesArray: function() {
        console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
      } }), Object.assign(Pn.prototype, { addIndex: function(e3) {
        console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e3);
      }, addDrawCall: function(e3, t3, n3) {
        void 0 !== n3 && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e3, t3);
      }, clearDrawCalls: function() {
        console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups();
      }, computeTangents: function() {
        console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
      }, computeOffsets: function() {
        console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
      } }), Object.defineProperties(Pn.prototype, { drawcalls: { get: function() {
        return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups;
      } }, offsets: { get: function() {
        return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups;
      } } }), Object.assign(xa.prototype, { getArrays: function() {
        console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.");
      }, addShapeList: function() {
        console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.");
      }, addShape: function() {
        console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.");
      } }), Object.defineProperties(Is.prototype, { dynamic: { set: function() {
        console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
      } }, onUpdate: { value: function() {
        return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this;
      } } }), Object.defineProperties(Bn.prototype, { wrapAround: { get: function() {
        console.warn("THREE.Material: .wrapAround has been removed.");
      }, set: function() {
        console.warn("THREE.Material: .wrapAround has been removed.");
      } }, wrapRGB: { get: function() {
        return console.warn("THREE.Material: .wrapRGB has been removed."), new rn();
      } }, shading: { get: function() {
        console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
      }, set: function(e3) {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = e3 === y2;
      } } }), Object.defineProperties(Wa2.prototype, { metal: { get: function() {
        return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), false;
      }, set: function() {
        console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
      } } }), Object.defineProperties(Gn.prototype, { derivatives: { get: function() {
        return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives;
      }, set: function(e3) {
        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e3;
      } } }), Object.assign(oi2.prototype, { animate: function(e3) {
        console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e3);
      }, getCurrentRenderTarget: function() {
        return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget();
      }, getMaxAnisotropy: function() {
        return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy();
      }, getPrecision: function() {
        return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision;
      }, resetGLState: function() {
        return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset();
      }, supportsFloatTextures: function() {
        return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float");
      }, supportsHalfFloatTextures: function() {
        return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float");
      }, supportsStandardDerivatives: function() {
        return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives");
      }, supportsCompressedTextureS3TC: function() {
        return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc");
      }, supportsCompressedTexturePVRTC: function() {
        return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc");
      }, supportsBlendMinMax: function() {
        return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax");
      }, supportsVertexTextures: function() {
        return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures;
      }, supportsInstancedArrays: function() {
        return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays");
      }, enableScissorTest: function(e3) {
        console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e3);
      }, initMaterial: function() {
        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
      }, addPrePlugin: function() {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
      }, addPostPlugin: function() {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
      }, updateShadowMap: function() {
        console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
      }, setFaceCulling: function() {
        console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
      } }), Object.defineProperties(oi2.prototype, { shadowMapEnabled: { get: function() {
        return this.shadowMap.enabled;
      }, set: function(e3) {
        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e3;
      } }, shadowMapType: { get: function() {
        return this.shadowMap.type;
      }, set: function(e3) {
        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e3;
      } }, shadowMapCullFace: { get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
      }, set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
      } } }), Object.defineProperties($r.prototype, { cullFace: { get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
      }, set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
      } }, renderReverseSided: { get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
      }, set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
      } }, renderSingleSided: { get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
      }, set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
      } } }), Object.defineProperties(qt.prototype, { wrapS: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
      }, set: function(e3) {
        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e3;
      } }, wrapT: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
      }, set: function(e3) {
        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e3;
      } }, magFilter: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter;
      }, set: function(e3) {
        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e3;
      } }, minFilter: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter;
      }, set: function(e3) {
        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e3;
      } }, anisotropy: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy;
      }, set: function(e3) {
        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e3;
      } }, offset: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset;
      }, set: function(e3) {
        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e3;
      } }, repeat: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat;
      }, set: function(e3) {
        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e3;
      } }, format: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format;
      }, set: function(e3) {
        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e3;
      } }, type: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
      }, set: function(e3) {
        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e3;
      } }, generateMipmaps: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps;
      }, set: function(e3) {
        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e3;
      } } }), Object.defineProperties(ai2.prototype, { standing: { set: function() {
        console.warn("THREE.WebVRManager: .standing has been removed.");
      } } }), Ms.prototype.load = function(e3) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        var t3 = this;
        return new xs().load(e3, function(e4) {
          t3.setBuffer(e4);
        }), this;
      }, Ts.prototype.getData = function() {
        return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData();
      }, ws.prototype.updateCubeMap = function(e3, t3) {
        return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e3, t3);
      };
      var zc2 = { merge: function(e3, t3, n3) {
        var r3;
        console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), t3.isMesh && (t3.matrixAutoUpdate && t3.updateMatrix(), r3 = t3.matrix, t3 = t3.geometry), e3.merge(t3, r3, n3);
      }, center: function(e3) {
        return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), e3.center();
      } };
      function Hc2() {
        console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function(e3, t3) {
          console.warn("THREE.Projector: .projectVector() is now vector.project()."), e3.project(t3);
        }, this.unprojectVector = function(e3, t3) {
          console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), e3.unproject(t3);
        }, this.pickingRay = function() {
          console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().");
        };
      }
      function kc2() {
        console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), this.clear = function() {
        }, this.render = function() {
        }, this.setClearColor = function() {
        }, this.setSize = function() {
        };
      }
      jt.crossOrigin = void 0, jt.loadTexture = function(e3, t3, n3, r3) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        var i3 = new oo();
        i3.setCrossOrigin(this.crossOrigin);
        var a2 = i3.load(e3, n3, void 0, r3);
        return t3 && (a2.mapping = t3), a2;
      }, jt.loadTextureCube = function(e3, t3, n3, r3) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        var i3 = new ao();
        i3.setCrossOrigin(this.crossOrigin);
        var a2 = i3.load(e3, n3, void 0, r3);
        return t3 && (a2.mapping = t3), a2;
      }, jt.loadCompressedTexture = function() {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
      }, jt.loadCompressedTextureCube = function() {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
      };
      var jc2 = { createMultiMaterialObject: function() {
        console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js");
      }, detach: function() {
        console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js");
      }, attach: function() {
        console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js");
      } };
      function Vc2() {
        console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js");
      }
    }, function(e2, t2, n2) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var r2, i2, a = function() {
        function e3(e4, t3) {
          for (var n3 = 0; n3 < t3.length; n3++) {
            var r3 = t3[n3];
            r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(e4, r3.key, r3);
          }
        }
        return function(t3, n3, r3) {
          return n3 && e3(t3.prototype, n3), r3 && e3(t3, r3), t3;
        };
      }(), o = l2(n2(5)), s = function(e3) {
        if (e3 && e3.__esModule)
          return e3;
        var t3 = {};
        if (null != e3)
          for (var n3 in e3)
            Object.prototype.hasOwnProperty.call(e3, n3) && (t3[n3] = e3[n3]);
        return t3.default = e3, t3;
      }(n2(0)), c2 = n2(4), u2 = l2(n2(3));
      function l2(e3) {
        return e3 && e3.__esModule ? e3 : { default: e3 };
      }
      var h2 = { directionligth: { create: function() {
        var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = e3.color, n3 = e3.position, r3 = e3.castShadow, i3 = new s.DirectionalLight(new s.Color(t3), 0.95);
        return i3.position.set(n3.x, n3.y, n3.z), i3.castShadow = r3, i3;
      } }, ambientlight: { create: function() {
        var e3 = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).color;
        return new s.AmbientLight(new s.Color(e3));
      } }, spotlight: { create: function() {
      } } }, d2 = function e3(t3) {
        if (t3 instanceof s.Mesh) {
          var n3 = t3.geometry;
          if (n3) {
            n3.boundingBox || n3.computeBoundingBox();
            var r3 = n3.boundingBox;
            return t3.updateMatrix(), r3.applyMatrix4(t3.matrix), r3;
          }
          return new s.Box3(new s.Vector3(), new s.Vector3());
        }
        var i3, a2 = t3.children.length, o2 = new s.Box3(new s.Vector3(), new s.Vector3());
        for (i3 = 0; i3 < a2; i3++) {
          var c3 = e3(t3.children[i3]);
          c3.min.x < o2.min.x && (o2.min.x = c3.min.x), c3.max.x > o2.max.x && (o2.max.x = c3.max.x), c3.min.y < o2.min.y && (o2.min.y = c3.min.y), c3.max.y > o2.max.y && (o2.max.y = c3.max.y), c3.min.z < o2.min.z && (o2.min.z = c3.min.z), c3.max.z > o2.max.z && (o2.max.z = c3.max.z);
        }
        return t3.updateMatrix(), o2.applyMatrix4(t3.matrix), o2;
      }, p2 = (i2 = r2 = function(e3) {
        function t3(e4) {
          !function(e5, t4) {
            if (!(e5 instanceof t4))
              throw new TypeError("Cannot call a class as a function");
          }(this, t3);
          var n3 = function(e5, t4) {
            if (!e5)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t4 || "object" != typeof t4 && "function" != typeof t4 ? e5 : t4;
          }(this, (t3.__proto__ || Object.getPrototypeOf(t3)).call(this, e4));
          return n3.obj3d, n3.src, n3.state = { lights: [] }, n3.lights = [], n3.group = new s.Group(), n3;
        }
        return function(e4, t4) {
          if ("function" != typeof t4 && null !== t4)
            throw new TypeError("Super expression must either be null or a function, not " + typeof t4);
          e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, enumerable: false, writable: true, configurable: true } }), t4 && (Object.setPrototypeOf ? Object.setPrototypeOf(e4, t4) : e4.__proto__ = t4);
        }(t3, o.default.Component), a(t3, [{ key: "render", value: function() {
          var e4 = this;
          this.state.lights;
          return o.default.createElement("div", { ref: function(t4) {
            return e4.$container = t4;
          }, "data-loader": this.props.loader, style: this.style() });
        } }, { key: "componentDidUpdate", value: function() {
          var e4 = this;
          if (!this.obj3d)
            return false;
          var t4 = this.props, n3 = t4.src, r3 = (t4.background, t4.width), i3 = t4.height;
          this.camera.aspect = r3 / i3, this.camera.updateProjectionMatrix(), this.renderer.setSize(r3, i3);
          var a2 = this.props, o2 = a2.enableKeys, s2 = a2.enableRotate, u3 = a2.enableZoom, l3 = a2.enabled;
          Object.assign(this.orbit_controls, { enableKeys: o2, enablePan: true, enableRotate: s2, enableZoom: u3, enabled: l3 }), void 0 !== this.src && this.src != n3 && (this.src = n3, this.remove3dModel(), this.load3dModel()), this.lights.forEach(function(t5) {
            return e4.scene.remove(t5);
          }), this.lights = [], this.addLight("ambientlight", c2.AmbientLight.defaultProps), this.need_children_lights ? this.addChildrenLights() : this.addLight("directionligth", c2.DirectionLight.defaultProps);
        } }, { key: "componentWillUnmount", value: function() {
          this.tick.animate = false;
        } }, { key: "componentDidMount", value: function() {
          var e4 = this, t4 = this.props, n3 = t4.width, r3 = t4.height, i3 = t4.antialias, a2 = t4.background;
          this.scene = new s.Scene(), this.camera = new s.PerspectiveCamera(45, n3 / r3, 0.1, 8888), this.renderer = new s.WebGLRenderer({ antialias: i3 }), this.renderer.setClearColor(new s.Color(a2)), this.renderer.setSize(n3, r3), this.$container.appendChild(this.renderer.domElement), this.scene.add(this.group), this.camera.position.set(0, 0, 0.1), this.createDefaultLight();
          var o2 = this.props, c3 = o2.position, l3 = o2.rotation, h3 = o2.scale;
          this.group.position.copy(new s.Vector3(c3.x, c3.y, c3.z)), this.group.rotation.set(l3.x, l3.y, l3.z), this.group.scale.set(h3.x, h3.y, h3.z), this.load3dModel(), this.tick = (0, u2.default)(function() {
            if (e4.renderer.render(e4.scene, e4.camera), e4.obj3d) {
              e4.group.children.length || e4.group.add(e4.obj3d);
              var t5 = e4.props, n4 = t5.position, r4 = t5.rotation, i4 = t5.scale;
              e4.group.position.copy(new s.Vector3(n4.x, n4.y, n4.z)), e4.group.rotation.set(r4.x, r4.y, r4.z), e4.group.scale.set(i4.x, i4.y, i4.z);
            }
          });
        } }, { key: "initControl", value: function() {
          var e4 = this.props, t4 = e4.enableKeys, n3 = e4.enableRotate, r3 = e4.enableZoom, i3 = e4.enabled;
          this.orbit_controls = new s.OrbitControls(this.camera, this.renderer.domElement), Object.assign(this.orbit_controls, { enableKeys: t4, enablePan: true, enableRotate: n3, enableZoom: r3, enabled: i3 }), this.orbit_controls.update();
        } }, { key: "remove3dModel", value: function() {
          this.obj3d && this.scene.remove(this.obj3d);
        } }, { key: "load3dModel", value: function() {
        } }, { key: "style", value: function() {
          var e4 = this.props, t4 = e4.width, n3 = e4.height;
          return Object.assign({}, { width: t4 + "px", height: n3 + "px" });
        } }, { key: "computeBoundingBox", value: function(e4) {
          if (e4 instanceof s.Mesh) {
            var t4 = e4.geometry;
            if (t4) {
              t4.boundingBox || t4.computeBoundingBox();
              var n3 = t4.boundingBox;
              return e4.updateMatrix(), n3.applyMatrix4(e4.matrix), n3;
            }
            return new s.Box3(new s.Vector3(), new s.Vector3());
          }
          var r3, i3 = e4.children.length, a2 = new s.Box3(new s.Vector3(), new s.Vector3());
          for (r3 = 0; r3 < i3; r3++) {
            var o2 = d2(e4.children[r3]);
            o2.min.x < a2.min.x && (a2.min.x = o2.min.x), o2.max.x > a2.max.x && (a2.max.x = o2.max.x), o2.min.y < a2.min.y && (a2.min.y = o2.min.y), o2.max.y > a2.max.y && (a2.max.y = o2.max.y), o2.min.z < a2.min.z && (a2.min.z = o2.min.z), o2.max.z > a2.max.z && (a2.max.z = o2.max.z);
          }
          return e4.updateMatrix(), a2.applyMatrix4(e4.matrix), a2;
        } }, { key: "traverseScene", value: function() {
        } }, { key: "createEnvironment", value: function() {
        } }, { key: "addLight", value: function(e4, t4) {
          if (/directionligth|ambientlight|spotlight/.test(e4)) {
            var n3 = h2[e4].create(t4);
            return this.scene.add(n3), this.lights.push(n3), n3;
          }
        } }, { key: "addChildrenLights", value: function() {
          var e4 = this;
          this.lights.forEach(function(t4) {
            e4.scene.remove(t4);
          }), this.lights = [], this.array_children.map(function(t4) {
            var n3 = t4.props, r3 = n3.__constructor;
            e4.addLight(r3, n3);
          });
        } }, { key: "createDefaultLight", value: function() {
          this.addLight("ambientlight", c2.AmbientLight.defaultProps), this.need_children_lights ? this.addChildrenLights() : this.addLight("directionligth", c2.DirectionLight.defaultProps);
        } }, { key: "array_children", get: function() {
          return this.props.children ? this.props.children instanceof Array ? this.props.children : [this.props.children] : [];
        } }, { key: "need_children_lights", get: function() {
          return !!this.array_children.filter(function(e4) {
            return /directionligth|ambientlight|spotlight/.test(e4.props.__constructor);
          }).length;
        } }]), t3;
      }(), r2.defaultProps = { width: 500, height: 500, antialias: true, loader: "", baseUrl: "", texPath: "", position: { x: 0, y: 0, z: 0 }, scale: { x: 1, y: 1, z: 1 }, rotation: { x: 0, y: 0, z: 0 }, background: "rgb(255,255,255)", enableKeys: true, enableRotate: true, enableZoom: true, enabled: true }, i2);
      t2.default = p2;
    }, function(e2, t2, n2) {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.GLTFLoader = t2.ColladaLoader = t2.OBJLoader = t2.MTLLoader = t2.OrbitControls = void 0;
      var r2 = function(e3) {
        if (e3 && e3.__esModule)
          return e3;
        var t3 = {};
        if (null != e3)
          for (var n3 in e3)
            Object.prototype.hasOwnProperty.call(e3, n3) && (t3[n3] = e3[n3]);
        return t3.default = e3, t3;
      }(n2(0));
      r2.OrbitControls = function(e3, t3) {
        this.object = e3, this.domElement = void 0 !== t3 ? t3 : document, this.enabled = true, this.target = new r2.Vector3(), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = false, this.dampingFactor = 0.25, this.enableZoom = true, this.zoomSpeed = 1, this.enableRotate = true, this.rotateSpeed = 1, this.enablePan = true, this.keyPanSpeed = 7, this.autoRotate = false, this.autoRotateSpeed = 2, this.enableKeys = true, this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 }, this.mouseButtons = { ORBIT: r2.MOUSE.LEFT, ZOOM: r2.MOUSE.MIDDLE, PAN: r2.MOUSE.RIGHT }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = function() {
          return l2.phi;
        }, this.getAzimuthalAngle = function() {
          return l2.theta;
        }, this.reset = function() {
          n3.target.copy(n3.target0), n3.object.position.copy(n3.position0), n3.object.zoom = n3.zoom0, n3.object.updateProjectionMatrix(), n3.dispatchEvent(i3), n3.update(), c3 = s2.NONE;
        }, this.update = function() {
          var t4 = new r2.Vector3(), a3 = new r2.Quaternion().setFromUnitVectors(e3.up, new r2.Vector3(0, 1, 0)), o3 = a3.clone().inverse(), m3 = new r2.Vector3(), g3 = new r2.Quaternion();
          return function() {
            var e4 = n3.object.position;
            return t4.copy(e4).sub(n3.target), t4.applyQuaternion(a3), l2.setFromVector3(t4), n3.autoRotate && c3 === s2.NONE && T2(2 * Math.PI / 60 / 60 * n3.autoRotateSpeed), l2.theta += h2.theta, l2.phi += h2.phi, l2.theta = Math.max(n3.minAzimuthAngle, Math.min(n3.maxAzimuthAngle, l2.theta)), l2.phi = Math.max(n3.minPolarAngle, Math.min(n3.maxPolarAngle, l2.phi)), l2.makeSafe(), l2.radius *= d2, l2.radius = Math.max(n3.minDistance, Math.min(n3.maxDistance, l2.radius)), n3.target.add(p2), t4.setFromSpherical(l2), t4.applyQuaternion(o3), e4.copy(n3.target).add(t4), n3.object.lookAt(n3.target), true === n3.enableDamping ? (h2.theta *= 1 - n3.dampingFactor, h2.phi *= 1 - n3.dampingFactor) : h2.set(0, 0, 0), d2 = 1, p2.set(0, 0, 0), !!(f2 || m3.distanceToSquared(n3.object.position) > u2 || 8 * (1 - g3.dot(n3.object.quaternion)) > u2) && (n3.dispatchEvent(i3), m3.copy(n3.object.position), g3.copy(n3.object.quaternion), f2 = false, true);
          };
        }(), this.dispose = function() {
          n3.domElement.removeEventListener("contextmenu", z2, false), n3.domElement.removeEventListener("mousedown", O2, false), n3.domElement.removeEventListener("wheel", D2, false), n3.domElement.removeEventListener("touchstart", B2, false), n3.domElement.removeEventListener("touchend", G2, false), n3.domElement.removeEventListener("touchmove", F2, false), document.removeEventListener("mousemove", N2, false), document.removeEventListener("mouseup", I2, false), window.removeEventListener("keydown", U2, false);
        };
        var n3 = this, i3 = { type: "change" }, a2 = { type: "start" }, o2 = { type: "end" }, s2 = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 }, c3 = s2.NONE, u2 = 1e-6, l2 = new r2.Spherical(), h2 = new r2.Spherical(), d2 = 1, p2 = new r2.Vector3(), f2 = false, m2 = new r2.Vector2(), g2 = new r2.Vector2(), v2 = new r2.Vector2(), y2 = new r2.Vector2(), x2 = new r2.Vector2(), b2 = new r2.Vector2(), w2 = new r2.Vector2(), _2 = new r2.Vector2(), M2 = new r2.Vector2();
        function E2() {
          return Math.pow(0.95, n3.zoomSpeed);
        }
        function T2(e4) {
          h2.theta -= e4;
        }
        function S2(e4) {
          h2.phi -= e4;
        }
        var A2 = function() {
          var e4 = new r2.Vector3();
          return function(t4, n4) {
            e4.setFromMatrixColumn(n4, 0), e4.multiplyScalar(-t4), p2.add(e4);
          };
        }(), L2 = function() {
          var e4 = new r2.Vector3();
          return function(t4, n4) {
            e4.setFromMatrixColumn(n4, 1), e4.multiplyScalar(t4), p2.add(e4);
          };
        }(), R2 = function() {
          var e4 = new r2.Vector3();
          return function(t4, i4) {
            var a3 = n3.domElement === document ? n3.domElement.body : n3.domElement;
            if (n3.object instanceof r2.PerspectiveCamera) {
              var o3 = n3.object.position;
              e4.copy(o3).sub(n3.target);
              var s3 = e4.length();
              s3 *= Math.tan(n3.object.fov / 2 * Math.PI / 180), A2(2 * t4 * s3 / a3.clientHeight, n3.object.matrix), L2(2 * i4 * s3 / a3.clientHeight, n3.object.matrix);
            } else
              n3.object instanceof r2.OrthographicCamera ? (A2(t4 * (n3.object.right - n3.object.left) / n3.object.zoom / a3.clientWidth, n3.object.matrix), L2(i4 * (n3.object.top - n3.object.bottom) / n3.object.zoom / a3.clientHeight, n3.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n3.enablePan = false);
          };
        }();
        function C2(e4) {
          n3.object instanceof r2.PerspectiveCamera ? d2 /= e4 : n3.object instanceof r2.OrthographicCamera ? (n3.object.zoom = Math.max(n3.minZoom, Math.min(n3.maxZoom, n3.object.zoom * e4)), n3.object.updateProjectionMatrix(), f2 = true) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n3.enableZoom = false);
        }
        function P2(e4) {
          n3.object instanceof r2.PerspectiveCamera ? d2 *= e4 : n3.object instanceof r2.OrthographicCamera ? (n3.object.zoom = Math.max(n3.minZoom, Math.min(n3.maxZoom, n3.object.zoom / e4)), n3.object.updateProjectionMatrix(), f2 = true) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n3.enableZoom = false);
        }
        function O2(e4) {
          if (false !== n3.enabled) {
            if (e4.preventDefault(), e4.button === n3.mouseButtons.ORBIT) {
              if (false === n3.enableRotate)
                return;
              !function(e5) {
                m2.set(e5.clientX, e5.clientY);
              }(e4), c3 = s2.ROTATE;
            } else if (e4.button === n3.mouseButtons.ZOOM) {
              if (false === n3.enableZoom)
                return;
              !function(e5) {
                w2.set(e5.clientX, e5.clientY);
              }(e4), c3 = s2.DOLLY;
            } else if (e4.button === n3.mouseButtons.PAN) {
              if (false === n3.enablePan)
                return;
              !function(e5) {
                y2.set(e5.clientX, e5.clientY);
              }(e4), c3 = s2.PAN;
            }
            c3 !== s2.NONE && (document.addEventListener("mousemove", N2, false), document.addEventListener("mouseup", I2, false), n3.dispatchEvent(a2));
          }
        }
        function N2(e4) {
          if (false !== n3.enabled) {
            if (e4.preventDefault(), c3 === s2.ROTATE) {
              if (false === n3.enableRotate)
                return;
              !function(e5) {
                g2.set(e5.clientX, e5.clientY), v2.subVectors(g2, m2);
                var t4 = n3.domElement === document ? n3.domElement.body : n3.domElement;
                T2(2 * Math.PI * v2.x / t4.clientWidth * n3.rotateSpeed), S2(2 * Math.PI * v2.y / t4.clientHeight * n3.rotateSpeed), m2.copy(g2), n3.update();
              }(e4);
            } else if (c3 === s2.DOLLY) {
              if (false === n3.enableZoom)
                return;
              !function(e5) {
                _2.set(e5.clientX, e5.clientY), M2.subVectors(_2, w2), M2.y > 0 ? C2(E2()) : M2.y < 0 && P2(E2()), w2.copy(_2), n3.update();
              }(e4);
            } else if (c3 === s2.PAN) {
              if (false === n3.enablePan)
                return;
              !function(e5) {
                x2.set(e5.clientX, e5.clientY), b2.subVectors(x2, y2), R2(b2.x, b2.y), y2.copy(x2), n3.update();
              }(e4);
            }
          }
        }
        function I2(e4) {
          false !== n3.enabled && (document.removeEventListener("mousemove", N2, false), document.removeEventListener("mouseup", I2, false), n3.dispatchEvent(o2), c3 = s2.NONE);
        }
        function D2(e4) {
          false === n3.enabled || false === n3.enableZoom || c3 !== s2.NONE && c3 !== s2.ROTATE || (e4.preventDefault(), e4.stopPropagation(), function(e5) {
            e5.deltaY < 0 ? P2(E2()) : e5.deltaY > 0 && C2(E2()), n3.update();
          }(e4), n3.dispatchEvent(a2), n3.dispatchEvent(o2));
        }
        function U2(e4) {
          false !== n3.enabled && false !== n3.enableKeys && false !== n3.enablePan && function(e5) {
            switch (e5.keyCode) {
              case n3.keys.UP:
                R2(0, n3.keyPanSpeed), n3.update();
                break;
              case n3.keys.BOTTOM:
                R2(0, -n3.keyPanSpeed), n3.update();
                break;
              case n3.keys.LEFT:
                R2(n3.keyPanSpeed, 0), n3.update();
                break;
              case n3.keys.RIGHT:
                R2(-n3.keyPanSpeed, 0), n3.update();
            }
          }(e4);
        }
        function B2(e4) {
          if (false !== n3.enabled) {
            switch (e4.touches.length) {
              case 1:
                if (false === n3.enableRotate)
                  return;
                !function(e5) {
                  m2.set(e5.touches[0].pageX, e5.touches[0].pageY);
                }(e4), c3 = s2.TOUCH_ROTATE;
                break;
              case 2:
                if (false === n3.enableZoom)
                  return;
                !function(e5) {
                  var t4 = e5.touches[0].pageX - e5.touches[1].pageX, n4 = e5.touches[0].pageY - e5.touches[1].pageY, r3 = Math.sqrt(t4 * t4 + n4 * n4);
                  w2.set(0, r3);
                }(e4), c3 = s2.TOUCH_DOLLY;
                break;
              case 3:
                if (false === n3.enablePan)
                  return;
                !function(e5) {
                  y2.set(e5.touches[0].pageX, e5.touches[0].pageY);
                }(e4), c3 = s2.TOUCH_PAN;
                break;
              default:
                c3 = s2.NONE;
            }
            c3 !== s2.NONE && n3.dispatchEvent(a2);
          }
        }
        function F2(e4) {
          if (false !== n3.enabled)
            switch (e4.preventDefault(), e4.stopPropagation(), e4.touches.length) {
              case 1:
                if (false === n3.enableRotate)
                  return;
                if (c3 !== s2.TOUCH_ROTATE)
                  return;
                !function(e5) {
                  g2.set(e5.touches[0].pageX, e5.touches[0].pageY), v2.subVectors(g2, m2);
                  var t4 = n3.domElement === document ? n3.domElement.body : n3.domElement;
                  T2(2 * Math.PI * v2.x / t4.clientWidth * n3.rotateSpeed), S2(2 * Math.PI * v2.y / t4.clientHeight * n3.rotateSpeed), m2.copy(g2), n3.update();
                }(e4);
                break;
              case 2:
                if (false === n3.enableZoom)
                  return;
                if (c3 !== s2.TOUCH_DOLLY)
                  return;
                !function(e5) {
                  var t4 = e5.touches[0].pageX - e5.touches[1].pageX, r3 = e5.touches[0].pageY - e5.touches[1].pageY, i4 = Math.sqrt(t4 * t4 + r3 * r3);
                  _2.set(0, i4), M2.subVectors(_2, w2), M2.y > 0 ? P2(E2()) : M2.y < 0 && C2(E2()), w2.copy(_2), n3.update();
                }(e4);
                break;
              case 3:
                if (false === n3.enablePan)
                  return;
                if (c3 !== s2.TOUCH_PAN)
                  return;
                !function(e5) {
                  x2.set(e5.touches[0].pageX, e5.touches[0].pageY), b2.subVectors(x2, y2), R2(b2.x, b2.y), y2.copy(x2), n3.update();
                }(e4);
                break;
              default:
                c3 = s2.NONE;
            }
        }
        function G2(e4) {
          false !== n3.enabled && (n3.dispatchEvent(o2), c3 = s2.NONE);
        }
        function z2(e4) {
          e4.preventDefault();
        }
        n3.domElement.addEventListener("contextmenu", z2, false), n3.domElement.addEventListener("mousedown", O2, false), n3.domElement.addEventListener("wheel", D2, false), n3.domElement.addEventListener("touchstart", B2, false), n3.domElement.addEventListener("touchend", G2, false), n3.domElement.addEventListener("touchmove", F2, false), window.addEventListener("keydown", U2, false), this.update();
      }, r2.OrbitControls.prototype = Object.create(r2.EventDispatcher.prototype), r2.OrbitControls.prototype.constructor = r2.OrbitControls, Object.defineProperties(r2.OrbitControls.prototype, { center: { get: function() {
        return console.warn("THREE.OrbitControls: .center has been renamed to .target"), this.target;
      } }, noZoom: { get: function() {
        return console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), !this.enableZoom;
      }, set: function(e3) {
        console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), this.enableZoom = !e3;
      } }, noRotate: { get: function() {
        return console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), !this.enableRotate;
      }, set: function(e3) {
        console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), this.enableRotate = !e3;
      } }, noPan: { get: function() {
        return console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), !this.enablePan;
      }, set: function(e3) {
        console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), this.enablePan = !e3;
      } }, noKeys: { get: function() {
        return console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), !this.enableKeys;
      }, set: function(e3) {
        console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), this.enableKeys = !e3;
      } }, staticMoving: { get: function() {
        return console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), !this.enableDamping;
      }, set: function(e3) {
        console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), this.enableDamping = !e3;
      } }, dynamicDampingFactor: { get: function() {
        return console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."), this.dampingFactor;
      }, set: function(e3) {
        console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."), this.dampingFactor = e3;
      } } }), r2.MTLLoader = function(e3) {
        this.manager = void 0 !== e3 ? e3 : r2.DefaultLoadingManager;
      }, r2.MTLLoader.prototype = { constructor: r2.MTLLoader, load: function(e3, t3, n3, i3) {
        var a2 = this, o2 = new r2.FileLoader(this.manager);
        o2.setPath(this.path), o2.load(e3, function(e4) {
          t3(a2.parse(e4));
        }, n3, i3);
      }, setPath: function(e3) {
        this.path = e3;
      }, setTexturePath: function(e3) {
        this.texturePath = e3;
      }, setBaseUrl: function(e3) {
        console.warn("THREE.MTLLoader: .setBaseUrl() is deprecated. Use .setTexturePath( path ) for texture path or .setPath( path ) for general base path instead."), this.setTexturePath(e3);
      }, setCrossOrigin: function(e3) {
        this.crossOrigin = e3;
      }, setMaterialOptions: function(e3) {
        this.materialOptions = e3;
      }, parse: function(e3) {
        for (var t3 = e3.split("\n"), n3 = {}, i3 = /\s+/, a2 = {}, o2 = 0; o2 < t3.length; o2++) {
          var s2 = t3[o2];
          if (0 !== (s2 = s2.trim()).length && "#" !== s2.charAt(0)) {
            var c3 = s2.indexOf(" "), u2 = c3 >= 0 ? s2.substring(0, c3) : s2;
            u2 = u2.toLowerCase();
            var l2 = c3 >= 0 ? s2.substring(c3 + 1) : "";
            if (l2 = l2.trim(), "newmtl" === u2)
              n3 = { name: l2 }, a2[l2] = n3;
            else if (n3)
              if ("ka" === u2 || "kd" === u2 || "ks" === u2) {
                var h2 = l2.split(i3, 3);
                n3[u2] = [parseFloat(h2[0]), parseFloat(h2[1]), parseFloat(h2[2])];
              } else
                n3[u2] = l2;
          }
        }
        var d2 = new r2.MTLLoader.MaterialCreator(this.texturePath || this.path, this.materialOptions);
        return d2.setCrossOrigin(this.crossOrigin), d2.setManager(this.manager), d2.setMaterials(a2), d2;
      } }, r2.MTLLoader.MaterialCreator = function(e3, t3) {
        this.baseUrl = e3 || "", this.options = t3, this.materialsInfo = {}, this.materials = {}, this.materialsArray = [], this.nameLookup = {}, this.side = this.options && this.options.side ? this.options.side : r2.FrontSide, this.wrap = this.options && this.options.wrap ? this.options.wrap : r2.RepeatWrapping;
      }, r2.MTLLoader.MaterialCreator.prototype = { constructor: r2.MTLLoader.MaterialCreator, crossOrigin: "Anonymous", setCrossOrigin: function(e3) {
        this.crossOrigin = e3;
      }, setManager: function(e3) {
        this.manager = e3;
      }, setMaterials: function(e3) {
        this.materialsInfo = this.convert(e3), this.materials = {}, this.materialsArray = [], this.nameLookup = {};
      }, convert: function(e3) {
        if (!this.options)
          return e3;
        var t3 = {};
        for (var n3 in e3) {
          var r3 = e3[n3], i3 = {};
          for (var a2 in t3[n3] = i3, r3) {
            var o2 = true, s2 = r3[a2], c3 = a2.toLowerCase();
            switch (c3) {
              case "kd":
              case "ka":
              case "ks":
                this.options && this.options.normalizeRGB && (s2 = [s2[0] / 255, s2[1] / 255, s2[2] / 255]), this.options && this.options.ignoreZeroRGBs && 0 === s2[0] && 0 === s2[1] && 0 === s2[2] && (o2 = false);
            }
            o2 && (i3[c3] = s2);
          }
        }
        return t3;
      }, preload: function() {
        for (var e3 in this.materialsInfo)
          this.create(e3);
      }, getIndex: function(e3) {
        return this.nameLookup[e3];
      }, getAsArray: function() {
        var e3 = 0;
        for (var t3 in this.materialsInfo)
          this.materialsArray[e3] = this.create(t3), this.nameLookup[t3] = e3, e3++;
        return this.materialsArray;
      }, create: function(e3) {
        return void 0 === this.materials[e3] && this.createMaterial_(e3), this.materials[e3];
      }, createMaterial_: function(e3) {
        var t3 = this, n3 = this.materialsInfo[e3], i3 = { name: e3, side: this.side };
        function a2(e4, n4) {
          if (!i3[e4]) {
            var r3 = t3.getTextureParams(n4, i3), a3 = t3.loadTexture(function(e5, t4) {
              return "string" != typeof t4 || "" === t4 ? "" : /^https?:\/\//i.test(t4) ? t4 : e5 + t4;
            }(t3.baseUrl, r3.url));
            a3.repeat.copy(r3.scale), a3.offset.copy(r3.offset), a3.wrapS = t3.wrap, a3.wrapT = t3.wrap, i3[e4] = a3;
          }
        }
        for (var o2 in n3) {
          var s2, c3 = n3[o2];
          if ("" !== c3)
            switch (o2.toLowerCase()) {
              case "kd":
                i3.color = new r2.Color().fromArray(c3);
                break;
              case "ks":
                i3.specular = new r2.Color().fromArray(c3);
                break;
              case "map_kd":
                a2("map", c3);
                break;
              case "map_ks":
                a2("specularMap", c3);
                break;
              case "norm":
                a2("normalMap", c3);
                break;
              case "map_bump":
              case "bump":
                a2("bumpMap", c3);
                break;
              case "ns":
                i3.shininess = parseFloat(c3);
                break;
              case "d":
                (s2 = parseFloat(c3)) < 1 && (i3.opacity = s2, i3.transparent = true);
                break;
              case "tr":
                (s2 = parseFloat(c3)) > 0 && (i3.opacity = 1 - s2, i3.transparent = true);
            }
        }
        return this.materials[e3] = new r2.MeshPhongMaterial(i3), this.materials[e3];
      }, getTextureParams: function(e3, t3) {
        var n3, i3 = { scale: new r2.Vector2(1, 1), offset: new r2.Vector2(0, 0) }, a2 = e3.split(/\s+/);
        return (n3 = a2.indexOf("-bm")) >= 0 && (t3.bumpScale = parseFloat(a2[n3 + 1]), a2.splice(n3, 2)), (n3 = a2.indexOf("-s")) >= 0 && (i3.scale.set(parseFloat(a2[n3 + 1]), parseFloat(a2[n3 + 2])), a2.splice(n3, 4)), (n3 = a2.indexOf("-o")) >= 0 && (i3.offset.set(parseFloat(a2[n3 + 1]), parseFloat(a2[n3 + 2])), a2.splice(n3, 4)), i3.url = a2.join(" ").trim(), i3;
      }, loadTexture: function(e3, t3, n3, i3, a2) {
        var o2, s2 = r2.Loader.Handlers.get(e3), c3 = void 0 !== this.manager ? this.manager : r2.DefaultLoadingManager;
        return null === s2 && (s2 = new r2.TextureLoader(c3)), s2.setCrossOrigin && s2.setCrossOrigin(this.crossOrigin), o2 = s2.load(e3, n3, i3, a2), void 0 !== t3 && (o2.mapping = t3), o2;
      } }, r2.OBJLoader = function() {
        var e3 = /^[og]\s*(.+)?/, t3 = /^mtllib /, n3 = /^usemtl /;
        function i3(e4) {
          this.manager = void 0 !== e4 ? e4 : r2.DefaultLoadingManager, this.materials = null;
        }
        return i3.prototype = { constructor: i3, load: function(e4, t4, n4, i4) {
          var a2 = this, o2 = new r2.FileLoader(a2.manager);
          o2.setPath(this.path), o2.load(e4, function(e5) {
            t4(a2.parse(e5));
          }, n4, i4);
        }, setPath: function(e4) {
          this.path = e4;
        }, setMaterials: function(e4) {
          return this.materials = e4, this;
        }, parse: function(i4) {
          console.time("OBJLoader");
          var a2 = new function() {
            var e4 = { objects: [], object: {}, vertices: [], normals: [], colors: [], uvs: [], materialLibraries: [], startObject: function(e5, t4) {
              if (this.object && false === this.object.fromDeclaration)
                return this.object.name = e5, void (this.object.fromDeclaration = false !== t4);
              var n4 = this.object && "function" == typeof this.object.currentMaterial ? this.object.currentMaterial() : void 0;
              if (this.object && "function" == typeof this.object._finalize && this.object._finalize(true), this.object = { name: e5 || "", fromDeclaration: false !== t4, geometry: { vertices: [], normals: [], colors: [], uvs: [] }, materials: [], smooth: true, startMaterial: function(e6, t5) {
                var n5 = this._finalize(false);
                n5 && (n5.inherited || n5.groupCount <= 0) && this.materials.splice(n5.index, 1);
                var r4 = { index: this.materials.length, name: e6 || "", mtllib: Array.isArray(t5) && t5.length > 0 ? t5[t5.length - 1] : "", smooth: void 0 !== n5 ? n5.smooth : this.smooth, groupStart: void 0 !== n5 ? n5.groupEnd : 0, groupEnd: -1, groupCount: -1, inherited: false, clone: function(e7) {
                  var t6 = { index: "number" == typeof e7 ? e7 : this.index, name: this.name, mtllib: this.mtllib, smooth: this.smooth, groupStart: 0, groupEnd: -1, groupCount: -1, inherited: false };
                  return t6.clone = this.clone.bind(t6), t6;
                } };
                return this.materials.push(r4), r4;
              }, currentMaterial: function() {
                if (this.materials.length > 0)
                  return this.materials[this.materials.length - 1];
              }, _finalize: function(e6) {
                var t5 = this.currentMaterial();
                if (t5 && -1 === t5.groupEnd && (t5.groupEnd = this.geometry.vertices.length / 3, t5.groupCount = t5.groupEnd - t5.groupStart, t5.inherited = false), e6 && this.materials.length > 1)
                  for (var n5 = this.materials.length - 1; n5 >= 0; n5--)
                    this.materials[n5].groupCount <= 0 && this.materials.splice(n5, 1);
                return e6 && 0 === this.materials.length && this.materials.push({ name: "", smooth: this.smooth }), t5;
              } }, n4 && n4.name && "function" == typeof n4.clone) {
                var r3 = n4.clone(0);
                r3.inherited = true, this.object.materials.push(r3);
              }
              this.objects.push(this.object);
            }, finalize: function() {
              this.object && "function" == typeof this.object._finalize && this.object._finalize(true);
            }, parseVertexIndex: function(e5, t4) {
              var n4 = parseInt(e5, 10);
              return 3 * (n4 >= 0 ? n4 - 1 : n4 + t4 / 3);
            }, parseNormalIndex: function(e5, t4) {
              var n4 = parseInt(e5, 10);
              return 3 * (n4 >= 0 ? n4 - 1 : n4 + t4 / 3);
            }, parseUVIndex: function(e5, t4) {
              var n4 = parseInt(e5, 10);
              return 2 * (n4 >= 0 ? n4 - 1 : n4 + t4 / 2);
            }, addVertex: function(e5, t4, n4) {
              var r3 = this.vertices, i5 = this.object.geometry.vertices;
              i5.push(r3[e5 + 0], r3[e5 + 1], r3[e5 + 2]), i5.push(r3[t4 + 0], r3[t4 + 1], r3[t4 + 2]), i5.push(r3[n4 + 0], r3[n4 + 1], r3[n4 + 2]);
            }, addVertexLine: function(e5) {
              var t4 = this.vertices;
              this.object.geometry.vertices.push(t4[e5 + 0], t4[e5 + 1], t4[e5 + 2]);
            }, addNormal: function(e5, t4, n4) {
              var r3 = this.normals, i5 = this.object.geometry.normals;
              i5.push(r3[e5 + 0], r3[e5 + 1], r3[e5 + 2]), i5.push(r3[t4 + 0], r3[t4 + 1], r3[t4 + 2]), i5.push(r3[n4 + 0], r3[n4 + 1], r3[n4 + 2]);
            }, addColor: function(e5, t4, n4) {
              var r3 = this.colors, i5 = this.object.geometry.colors;
              i5.push(r3[e5 + 0], r3[e5 + 1], r3[e5 + 2]), i5.push(r3[t4 + 0], r3[t4 + 1], r3[t4 + 2]), i5.push(r3[n4 + 0], r3[n4 + 1], r3[n4 + 2]);
            }, addUV: function(e5, t4, n4) {
              var r3 = this.uvs, i5 = this.object.geometry.uvs;
              i5.push(r3[e5 + 0], r3[e5 + 1]), i5.push(r3[t4 + 0], r3[t4 + 1]), i5.push(r3[n4 + 0], r3[n4 + 1]);
            }, addUVLine: function(e5) {
              var t4 = this.uvs;
              this.object.geometry.uvs.push(t4[e5 + 0], t4[e5 + 1]);
            }, addFace: function(e5, t4, n4, r3, i5, a3, o3, s3, c4) {
              var u3 = this.vertices.length, l3 = this.parseVertexIndex(e5, u3), h3 = this.parseVertexIndex(t4, u3), d3 = this.parseVertexIndex(n4, u3);
              if (this.addVertex(l3, h3, d3), void 0 !== r3) {
                var p3 = this.uvs.length;
                l3 = this.parseUVIndex(r3, p3), h3 = this.parseUVIndex(i5, p3), d3 = this.parseUVIndex(a3, p3), this.addUV(l3, h3, d3);
              }
              if (void 0 !== o3) {
                var f3 = this.normals.length;
                l3 = this.parseNormalIndex(o3, f3), h3 = o3 === s3 ? l3 : this.parseNormalIndex(s3, f3), d3 = o3 === c4 ? l3 : this.parseNormalIndex(c4, f3), this.addNormal(l3, h3, d3);
              }
              this.colors.length > 0 && this.addColor(l3, h3, d3);
            }, addLineGeometry: function(e5, t4) {
              this.object.geometry.type = "Line";
              for (var n4 = this.vertices.length, r3 = this.uvs.length, i5 = 0, a3 = e5.length; i5 < a3; i5++)
                this.addVertexLine(this.parseVertexIndex(e5[i5], n4));
              var o3 = 0;
              for (a3 = t4.length; o3 < a3; o3++)
                this.addUVLine(this.parseUVIndex(t4[o3], r3));
            } };
            return e4.startObject("", false), e4;
          }();
          -1 !== i4.indexOf("\r\n") && (i4 = i4.replace(/\r\n/g, "\n")), -1 !== i4.indexOf("\\\n") && (i4 = i4.replace(/\\\n/g, ""));
          for (var o2 = i4.split("\n"), s2 = "", c3 = "", u2 = [], l2 = "function" == typeof "".trimLeft, h2 = 0, d2 = o2.length; h2 < d2; h2++)
            if (s2 = o2[h2], 0 !== (s2 = l2 ? s2.trimLeft() : s2.trim()).length && "#" !== (c3 = s2.charAt(0)))
              if ("v" === c3) {
                var p2 = s2.split(/\s+/);
                switch (p2[0]) {
                  case "v":
                    a2.vertices.push(parseFloat(p2[1]), parseFloat(p2[2]), parseFloat(p2[3])), 8 === p2.length && a2.colors.push(parseFloat(p2[4]), parseFloat(p2[5]), parseFloat(p2[6]));
                    break;
                  case "vn":
                    a2.normals.push(parseFloat(p2[1]), parseFloat(p2[2]), parseFloat(p2[3]));
                    break;
                  case "vt":
                    a2.uvs.push(parseFloat(p2[1]), parseFloat(p2[2]));
                }
              } else if ("f" === c3) {
                for (var f2 = s2.substr(1).trim().split(/\s+/), m2 = [], g2 = 0, v2 = f2.length; g2 < v2; g2++) {
                  var y2 = f2[g2];
                  if (y2.length > 0) {
                    var x2 = y2.split("/");
                    m2.push(x2);
                  }
                }
                var b2 = m2[0];
                for (g2 = 1, v2 = m2.length - 1; g2 < v2; g2++) {
                  var w2 = m2[g2], _2 = m2[g2 + 1];
                  a2.addFace(b2[0], w2[0], _2[0], b2[1], w2[1], _2[1], b2[2], w2[2], _2[2]);
                }
              } else if ("l" === c3) {
                var M2 = s2.substring(1).trim().split(" "), E2 = [], T2 = [];
                if (-1 === s2.indexOf("/"))
                  E2 = M2;
                else
                  for (var S2 = 0, A2 = M2.length; S2 < A2; S2++) {
                    var L2 = M2[S2].split("/");
                    "" !== L2[0] && E2.push(L2[0]), "" !== L2[1] && T2.push(L2[1]);
                  }
                a2.addLineGeometry(E2, T2);
              } else if (null !== (u2 = e3.exec(s2))) {
                var R2 = (" " + u2[0].substr(1).trim()).substr(1);
                a2.startObject(R2);
              } else if (n3.test(s2))
                a2.object.startMaterial(s2.substring(7).trim(), a2.materialLibraries);
              else if (t3.test(s2))
                a2.materialLibraries.push(s2.substring(7).trim());
              else {
                if ("s" !== c3) {
                  if ("\0" === s2)
                    continue;
                  throw new Error('THREE.OBJLoader: Unexpected line: "' + s2 + '"');
                }
                if ((u2 = s2.split(" ")).length > 1) {
                  var C2 = u2[1].trim().toLowerCase();
                  a2.object.smooth = "0" !== C2 && "off" !== C2;
                } else
                  a2.object.smooth = true;
                (k2 = a2.object.currentMaterial()) && (k2.smooth = a2.object.smooth);
              }
          a2.finalize();
          var P2 = new r2.Group();
          P2.materialLibraries = [].concat(a2.materialLibraries);
          for (h2 = 0, d2 = a2.objects.length; h2 < d2; h2++) {
            var O2 = a2.objects[h2], N2 = O2.geometry, I2 = O2.materials, D2 = "Line" === N2.type;
            if (0 !== N2.vertices.length) {
              var U2 = new r2.BufferGeometry();
              U2.addAttribute("position", new r2.Float32BufferAttribute(N2.vertices, 3)), N2.normals.length > 0 ? U2.addAttribute("normal", new r2.Float32BufferAttribute(N2.normals, 3)) : U2.computeVertexNormals(), N2.colors.length > 0 && U2.addAttribute("color", new r2.Float32BufferAttribute(N2.colors, 3)), N2.uvs.length > 0 && U2.addAttribute("uv", new r2.Float32BufferAttribute(N2.uvs, 2));
              for (var B2, F2 = [], G2 = 0, z2 = I2.length; G2 < z2; G2++) {
                var H2 = I2[G2], k2 = void 0;
                if (null !== this.materials && (k2 = this.materials.create(H2.name), D2 && k2 && !(k2 instanceof r2.LineBasicMaterial))) {
                  var j = new r2.LineBasicMaterial();
                  j.copy(k2), k2 = j;
                }
                k2 || ((k2 = D2 ? new r2.LineBasicMaterial() : new r2.MeshPhongMaterial()).name = H2.name), k2.flatShading = !H2.smooth, F2.push(k2);
              }
              if (F2.length > 1) {
                for (G2 = 0, z2 = I2.length; G2 < z2; G2++) {
                  H2 = I2[G2];
                  U2.addGroup(H2.groupStart, H2.groupCount, G2);
                }
                B2 = D2 ? new r2.LineSegments(U2, F2) : new r2.Mesh(U2, F2);
              } else
                B2 = D2 ? new r2.LineSegments(U2, F2[0]) : new r2.Mesh(U2, F2[0]);
              B2.name = O2.name, P2.add(B2);
            }
          }
          return console.timeEnd("OBJLoader"), P2;
        } }, i3;
      }(), r2.ColladaLoader = function(e3) {
        this.manager = void 0 !== e3 ? e3 : r2.DefaultLoadingManager;
      }, r2.ColladaLoader.prototype = { constructor: r2.ColladaLoader, crossOrigin: "anonymous", load: function(e3, t3, n3, i3) {
        var a2 = this, o2 = void 0 === a2.path ? r2.LoaderUtils.extractUrlBase(e3) : a2.path;
        new r2.FileLoader(a2.manager).load(e3, function(e4) {
          t3(a2.parse(e4, o2));
        }, n3, i3);
      }, setPath: function(e3) {
        return this.path = e3, this;
      }, options: { set convertUpAxis(e3) {
        console.warn("THREE.ColladaLoader: options.convertUpAxis() has been removed. Up axis is converted automatically.");
      } }, setCrossOrigin: function(e3) {
        return this.crossOrigin = e3, this;
      }, parse: function(e3, t3) {
        function n3(e4, t4) {
          for (var n4 = [], r3 = e4.childNodes, i4 = 0, a3 = r3.length; i4 < a3; i4++) {
            var o3 = r3[i4];
            o3.nodeName === t4 && n4.push(o3);
          }
          return n4;
        }
        function i3(e4) {
          if (0 === e4.length)
            return [];
          for (var t4 = e4.trim().split(/\s+/), n4 = new Array(t4.length), r3 = 0, i4 = t4.length; r3 < i4; r3++)
            n4[r3] = t4[r3];
          return n4;
        }
        function a2(e4) {
          if (0 === e4.length)
            return [];
          for (var t4 = e4.trim().split(/\s+/), n4 = new Array(t4.length), r3 = 0, i4 = t4.length; r3 < i4; r3++)
            n4[r3] = parseFloat(t4[r3]);
          return n4;
        }
        function o2(e4) {
          if (0 === e4.length)
            return [];
          for (var t4 = e4.trim().split(/\s+/), n4 = new Array(t4.length), r3 = 0, i4 = t4.length; r3 < i4; r3++)
            n4[r3] = parseInt(t4[r3]);
          return n4;
        }
        function s2(e4) {
          return e4.substring(1);
        }
        function c3(e4) {
          return 0 === Object.keys(e4).length;
        }
        function u2(e4, t4, r3, i4) {
          var a3 = n3(e4, t4)[0];
          if (void 0 !== a3)
            for (var o3 = n3(a3, r3), s3 = 0; s3 < o3.length; s3++)
              i4(o3[s3]);
        }
        function l2(e4, t4) {
          for (var n4 in e4) {
            e4[n4].build = t4(e4[n4]);
          }
        }
        function h2(e4, t4) {
          return void 0 !== e4.build ? e4.build : (e4.build = t4(e4), e4.build);
        }
        function d2(e4) {
          for (var t4 = { inputs: {} }, n4 = 0, r3 = e4.childNodes.length; n4 < r3; n4++) {
            var i4 = e4.childNodes[n4];
            if (1 === i4.nodeType)
              switch (i4.nodeName) {
                case "input":
                  var a3 = s2(i4.getAttribute("source")), o3 = i4.getAttribute("semantic");
                  t4.inputs[o3] = a3;
              }
          }
          return t4;
        }
        function p2(e4) {
          var t4 = {}, n4 = e4.getAttribute("target").split("/"), r3 = n4.shift(), i4 = n4.shift(), a3 = -1 !== i4.indexOf("("), o3 = -1 !== i4.indexOf(".");
          if (o3)
            i4 = (n4 = i4.split(".")).shift(), t4.member = n4.shift();
          else if (a3) {
            var c4 = i4.split("(");
            i4 = c4.shift();
            for (var u3 = 0; u3 < c4.length; u3++)
              c4[u3] = parseInt(c4[u3].replace(/\)/, ""));
            t4.indices = c4;
          }
          return t4.id = r3, t4.sid = i4, t4.arraySyntax = a3, t4.memberSyntax = o3, t4.sampler = s2(e4.getAttribute("source")), t4;
        }
        function f2(e4) {
          var t4 = [], n4 = e4.channels, r3 = e4.samplers, i4 = e4.sources;
          for (var a3 in n4)
            if (n4.hasOwnProperty(a3)) {
              var o3 = n4[a3], s3 = r3[o3.sampler], c4 = s3.inputs.INPUT, u3 = s3.inputs.OUTPUT;
              b2(g2(o3, i4[c4], i4[u3]), t4);
            }
          return t4;
        }
        function m2(e4) {
          return h2(Ve2.animations[e4], f2);
        }
        function g2(e4, t4, n4) {
          var r3, i4, a3, o3, s3, c4, u3 = Ve2.nodes[e4.id], l3 = Ne2(u3.id), h3 = u3.transforms[e4.sid], d3 = u3.matrix.clone().transpose(), p3 = {};
          switch (h3) {
            case "matrix":
              for (a3 = 0, o3 = t4.array.length; a3 < o3; a3++)
                if (r3 = t4.array[a3], i4 = a3 * n4.stride, void 0 === p3[r3] && (p3[r3] = {}), true === e4.arraySyntax) {
                  var f3 = n4.array[i4], m3 = e4.indices[0] + 4 * e4.indices[1];
                  p3[r3][m3] = f3;
                } else
                  for (s3 = 0, c4 = n4.stride; s3 < c4; s3++)
                    p3[r3][s3] = n4.array[i4 + s3];
              break;
            case "translate":
            case "rotate":
            case "scale":
              console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', h3);
          }
          var g3 = function(e5, t5) {
            var n5 = [];
            for (var r4 in e5)
              n5.push({ time: parseFloat(r4), value: e5[r4] });
            n5.sort(function(e6, t6) {
              return e6.time - t6.time;
            });
            for (var i5 = 0; i5 < 16; i5++)
              w2(n5, i5, t5.elements[i5]);
            return n5;
          }(p3, d3);
          return { name: l3.uuid, keyframes: g3 };
        }
        var v2 = new r2.Vector3(), y2 = new r2.Vector3(), x2 = new r2.Quaternion();
        function b2(e4, t4) {
          for (var n4 = e4.keyframes, i4 = e4.name, a3 = [], o3 = [], s3 = [], c4 = [], u3 = 0, l3 = n4.length; u3 < l3; u3++) {
            var h3 = n4[u3], d3 = h3.time, p3 = h3.value;
            Me2.fromArray(p3).transpose(), Me2.decompose(v2, x2, y2), a3.push(d3), o3.push(v2.x, v2.y, v2.z), s3.push(x2.x, x2.y, x2.z, x2.w), c4.push(y2.x, y2.y, y2.z);
          }
          return o3.length > 0 && t4.push(new r2.VectorKeyframeTrack(i4 + ".position", a3, o3)), s3.length > 0 && t4.push(new r2.QuaternionKeyframeTrack(i4 + ".quaternion", a3, s3)), c4.length > 0 && t4.push(new r2.VectorKeyframeTrack(i4 + ".scale", a3, c4)), t4;
        }
        function w2(e4, t4, n4) {
          var r3, i4, a3, o3 = true;
          for (i4 = 0, a3 = e4.length; i4 < a3; i4++)
            void 0 === (r3 = e4[i4]).value[t4] ? r3.value[t4] = null : o3 = false;
          if (true === o3)
            for (i4 = 0, a3 = e4.length; i4 < a3; i4++)
              (r3 = e4[i4]).value[t4] = n4;
          else
            !function(e5, t5) {
              for (var n5, r4, i5 = 0, a4 = e5.length; i5 < a4; i5++) {
                var o4 = e5[i5];
                if (null === o4.value[t5]) {
                  if (n5 = _2(e5, i5, t5), r4 = M2(e5, i5, t5), null === n5) {
                    o4.value[t5] = r4.value[t5];
                    continue;
                  }
                  if (null === r4) {
                    o4.value[t5] = n5.value[t5];
                    continue;
                  }
                  E2(o4, n5, r4, t5);
                }
              }
            }(e4, t4);
        }
        function _2(e4, t4, n4) {
          for (; t4 >= 0; ) {
            var r3 = e4[t4];
            if (null !== r3.value[n4])
              return r3;
            t4--;
          }
          return null;
        }
        function M2(e4, t4, n4) {
          for (; t4 < e4.length; ) {
            var r3 = e4[t4];
            if (null !== r3.value[n4])
              return r3;
            t4++;
          }
          return null;
        }
        function E2(e4, t4, n4, r3) {
          n4.time - t4.time != 0 ? e4.value[r3] = (e4.time - t4.time) * (n4.value[r3] - t4.value[r3]) / (n4.time - t4.time) + t4.value[r3] : e4.value[r3] = t4.value[r3];
        }
        function T2(e4) {
          for (var t4 = [], n4 = e4.name, i4 = e4.end - e4.start || -1, a3 = e4.animations, o3 = 0, s3 = a3.length; o3 < s3; o3++)
            for (var c4 = m2(a3[o3]), u3 = 0, l3 = c4.length; u3 < l3; u3++)
              t4.push(c4[u3]);
          return new r2.AnimationClip(n4, i4, t4);
        }
        function S2(e4) {
          return h2(Ve2.clips[e4], T2);
        }
        function A2(e4) {
          for (var t4 = { sources: {} }, n4 = 0, r3 = e4.childNodes.length; n4 < r3; n4++) {
            var i4 = e4.childNodes[n4];
            if (1 === i4.nodeType)
              switch (i4.nodeName) {
                case "bind_shape_matrix":
                  t4.bindShapeMatrix = a2(i4.textContent);
                  break;
                case "source":
                  var o3 = i4.getAttribute("id");
                  t4.sources[o3] = ie2(i4);
                  break;
                case "joints":
                  t4.joints = L2(i4);
                  break;
                case "vertex_weights":
                  t4.vertexWeights = R2(i4);
              }
          }
          return t4;
        }
        function L2(e4) {
          for (var t4 = { inputs: {} }, n4 = 0, r3 = e4.childNodes.length; n4 < r3; n4++) {
            var i4 = e4.childNodes[n4];
            if (1 === i4.nodeType)
              switch (i4.nodeName) {
                case "input":
                  var a3 = i4.getAttribute("semantic"), o3 = s2(i4.getAttribute("source"));
                  t4.inputs[a3] = o3;
              }
          }
          return t4;
        }
        function R2(e4) {
          for (var t4 = { inputs: {} }, n4 = 0, r3 = e4.childNodes.length; n4 < r3; n4++) {
            var i4 = e4.childNodes[n4];
            if (1 === i4.nodeType)
              switch (i4.nodeName) {
                case "input":
                  var a3 = i4.getAttribute("semantic"), c4 = s2(i4.getAttribute("source")), u3 = parseInt(i4.getAttribute("offset"));
                  t4.inputs[a3] = { id: c4, offset: u3 };
                  break;
                case "vcount":
                  t4.vcount = o2(i4.textContent);
                  break;
                case "v":
                  t4.v = o2(i4.textContent);
              }
          }
          return t4;
        }
        function C2(e4) {
          var t4 = { id: e4.id }, n4 = Ve2.geometries[t4.id];
          return void 0 !== e4.skin && (t4.skin = function(e5) {
            var t5, n5, i4, a3 = { joints: [], indices: { array: [], stride: 4 }, weights: { array: [], stride: 4 } }, o3 = e5.sources, s3 = e5.vertexWeights, c4 = s3.vcount, u3 = s3.v, l3 = s3.inputs.JOINT.offset, h3 = s3.inputs.WEIGHT.offset, d3 = e5.sources[e5.joints.inputs.JOINT], p3 = e5.sources[e5.joints.inputs.INV_BIND_MATRIX], f3 = o3[s3.inputs.WEIGHT.id].array, m3 = 0;
            for (t5 = 0, i4 = c4.length; t5 < i4; t5++) {
              var g3 = c4[t5], v3 = [];
              for (n5 = 0; n5 < g3; n5++) {
                var y3 = u3[m3 + l3], x3 = u3[m3 + h3], b3 = f3[x3];
                v3.push({ index: y3, weight: b3 }), m3 += 2;
              }
              for (v3.sort(E3), n5 = 0; n5 < 4; n5++) {
                var w3 = v3[n5];
                void 0 !== w3 ? (a3.indices.array.push(w3.index), a3.weights.array.push(w3.weight)) : (a3.indices.array.push(0), a3.weights.array.push(0));
              }
            }
            e5.bindShapeMatrix ? a3.bindMatrix = new r2.Matrix4().fromArray(e5.bindShapeMatrix).transpose() : a3.bindMatrix = new r2.Matrix4().transpose();
            for (t5 = 0, i4 = d3.array.length; t5 < i4; t5++) {
              var _3 = d3.array[t5], M3 = new r2.Matrix4().fromArray(p3.array, t5 * p3.stride).transpose();
              a3.joints.push({ name: _3, boneInverse: M3 });
            }
            return a3;
            function E3(e6, t6) {
              return t6.weight - e6.weight;
            }
          }(e4.skin), n4.sources.skinIndices = t4.skin.indices, n4.sources.skinWeights = t4.skin.weights), t4;
        }
        function P2(e4) {
          return h2(Ve2.controllers[e4], C2);
        }
        function O2(e4) {
          return void 0 !== e4.build ? e4.build : e4.init_from;
        }
        function N2(e4) {
          var t4 = Ve2.images[e4];
          return void 0 !== t4 ? h2(t4, O2) : (console.warn("THREE.ColladaLoader: Couldn't find image with ID:", e4), null);
        }
        function I2(e4) {
          for (var t4 = { surfaces: {}, samplers: {} }, n4 = 0, r3 = e4.childNodes.length; n4 < r3; n4++) {
            var i4 = e4.childNodes[n4];
            if (1 === i4.nodeType)
              switch (i4.nodeName) {
                case "newparam":
                  D2(i4, t4);
                  break;
                case "technique":
                  t4.technique = F2(i4);
                  break;
                case "extra":
                  t4.extra = V2(i4);
              }
          }
          return t4;
        }
        function D2(e4, t4) {
          for (var n4 = e4.getAttribute("sid"), r3 = 0, i4 = e4.childNodes.length; r3 < i4; r3++) {
            var a3 = e4.childNodes[r3];
            if (1 === a3.nodeType)
              switch (a3.nodeName) {
                case "surface":
                  t4.surfaces[n4] = U2(a3);
                  break;
                case "sampler2D":
                  t4.samplers[n4] = B2(a3);
              }
          }
        }
        function U2(e4) {
          for (var t4 = {}, n4 = 0, r3 = e4.childNodes.length; n4 < r3; n4++) {
            var i4 = e4.childNodes[n4];
            if (1 === i4.nodeType)
              switch (i4.nodeName) {
                case "init_from":
                  t4.init_from = i4.textContent;
              }
          }
          return t4;
        }
        function B2(e4) {
          for (var t4 = {}, n4 = 0, r3 = e4.childNodes.length; n4 < r3; n4++) {
            var i4 = e4.childNodes[n4];
            if (1 === i4.nodeType)
              switch (i4.nodeName) {
                case "source":
                  t4.source = i4.textContent;
              }
          }
          return t4;
        }
        function F2(e4) {
          for (var t4 = {}, n4 = 0, r3 = e4.childNodes.length; n4 < r3; n4++) {
            var i4 = e4.childNodes[n4];
            if (1 === i4.nodeType)
              switch (i4.nodeName) {
                case "constant":
                case "lambert":
                case "blinn":
                case "phong":
                  t4.type = i4.nodeName, t4.parameters = G2(i4);
              }
          }
          return t4;
        }
        function G2(e4) {
          for (var t4 = {}, n4 = 0, r3 = e4.childNodes.length; n4 < r3; n4++) {
            var i4 = e4.childNodes[n4];
            if (1 === i4.nodeType)
              switch (i4.nodeName) {
                case "emission":
                case "diffuse":
                case "specular":
                case "shininess":
                case "transparency":
                  t4[i4.nodeName] = z2(i4);
                  break;
                case "transparent":
                  t4[i4.nodeName] = { opaque: i4.getAttribute("opaque"), data: z2(i4) };
              }
          }
          return t4;
        }
        function z2(e4) {
          for (var t4 = {}, n4 = 0, r3 = e4.childNodes.length; n4 < r3; n4++) {
            var i4 = e4.childNodes[n4];
            if (1 === i4.nodeType)
              switch (i4.nodeName) {
                case "color":
                  t4[i4.nodeName] = a2(i4.textContent);
                  break;
                case "float":
                  t4[i4.nodeName] = parseFloat(i4.textContent);
                  break;
                case "texture":
                  t4[i4.nodeName] = { id: i4.getAttribute("texture"), extra: H2(i4) };
              }
          }
          return t4;
        }
        function H2(e4) {
          for (var t4 = { technique: {} }, n4 = 0, r3 = e4.childNodes.length; n4 < r3; n4++) {
            var i4 = e4.childNodes[n4];
            if (1 === i4.nodeType)
              switch (i4.nodeName) {
                case "extra":
                  k2(i4, t4);
              }
          }
          return t4;
        }
        function k2(e4, t4) {
          for (var n4 = 0, r3 = e4.childNodes.length; n4 < r3; n4++) {
            var i4 = e4.childNodes[n4];
            if (1 === i4.nodeType)
              switch (i4.nodeName) {
                case "technique":
                  j(i4, t4);
              }
          }
        }
        function j(e4, t4) {
          for (var n4 = 0, r3 = e4.childNodes.length; n4 < r3; n4++) {
            var i4 = e4.childNodes[n4];
            if (1 === i4.nodeType)
              switch (i4.nodeName) {
                case "repeatU":
                case "repeatV":
                case "offsetU":
                case "offsetV":
                  t4.technique[i4.nodeName] = parseFloat(i4.textContent);
                  break;
                case "wrapU":
                case "wrapV":
                  "TRUE" === i4.textContent.toUpperCase() ? t4.technique[i4.nodeName] = 1 : "FALSE" === i4.textContent.toUpperCase() ? t4.technique[i4.nodeName] = 0 : t4.technique[i4.nodeName] = parseInt(i4.textContent);
              }
          }
        }
        function V2(e4) {
          for (var t4 = {}, n4 = 0, r3 = e4.childNodes.length; n4 < r3; n4++) {
            var i4 = e4.childNodes[n4];
            if (1 === i4.nodeType)
              switch (i4.nodeName) {
                case "technique":
                  t4.technique = W2(i4);
              }
          }
          return t4;
        }
        function W2(e4) {
          for (var t4 = {}, n4 = 0, r3 = e4.childNodes.length; n4 < r3; n4++) {
            var i4 = e4.childNodes[n4];
            if (1 === i4.nodeType)
              switch (i4.nodeName) {
                case "double_sided":
                  t4[i4.nodeName] = parseInt(i4.textContent);
              }
          }
          return t4;
        }
        function X2(e4) {
          return e4;
        }
        function q2(e4) {
          var t4, n4 = function(e5) {
            return h2(Ve2.effects[e5], X2);
          }(e4.url), i4 = n4.profile.technique, a3 = n4.profile.extra;
          switch (i4.type) {
            case "phong":
            case "blinn":
              t4 = new r2.MeshPhongMaterial();
              break;
            case "lambert":
              t4 = new r2.MeshLambertMaterial();
              break;
            default:
              t4 = new r2.MeshBasicMaterial();
          }
          function o3(e5) {
            var t5 = n4.profile.samplers[e5.id], i5 = null;
            void 0 !== t5 ? i5 = N2(n4.profile.surfaces[t5.source].init_from) : (console.warn("THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530)."), i5 = N2(e5.id));
            if (null !== i5) {
              var a4 = ze2.load(i5), o4 = e5.extra;
              if (void 0 !== o4 && void 0 !== o4.technique && false === c3(o4.technique)) {
                var s4 = o4.technique;
                a4.wrapS = s4.wrapU ? r2.RepeatWrapping : r2.ClampToEdgeWrapping, a4.wrapT = s4.wrapV ? r2.RepeatWrapping : r2.ClampToEdgeWrapping, a4.offset.set(s4.offsetU || 0, s4.offsetV || 0), a4.repeat.set(s4.repeatU || 1, s4.repeatV || 1);
              } else
                a4.wrapS = r2.RepeatWrapping, a4.wrapT = r2.RepeatWrapping;
              return a4;
            }
            return console.warn("THREE.ColladaLoader: Couldn't create texture with ID:", e5.id), null;
          }
          t4.name = e4.name;
          var s3 = i4.parameters;
          for (var u3 in s3) {
            var l3 = s3[u3];
            switch (u3) {
              case "diffuse":
                l3.color && t4.color.fromArray(l3.color), l3.texture && (t4.map = o3(l3.texture));
                break;
              case "specular":
                l3.color && t4.specular && t4.specular.fromArray(l3.color), l3.texture && (t4.specularMap = o3(l3.texture));
                break;
              case "shininess":
                l3.float && t4.shininess && (t4.shininess = l3.float);
                break;
              case "emission":
                l3.color && t4.emissive && t4.emissive.fromArray(l3.color), l3.texture && (t4.emissiveMap = o3(l3.texture));
            }
          }
          var d3 = s3.transparent, p3 = s3.transparency;
          if (void 0 === p3 && d3 && (p3 = { float: 1 }), void 0 === d3 && p3 && (d3 = { opaque: "A_ONE", data: { color: [1, 1, 1, 1] } }), d3 && p3)
            if (d3.data.texture)
              t4.transparent = true;
            else {
              var f3 = d3.data.color;
              switch (d3.opaque) {
                case "A_ONE":
                  t4.opacity = f3[3] * p3.float;
                  break;
                case "RGB_ZERO":
                  t4.opacity = 1 - f3[0] * p3.float;
                  break;
                case "A_ZERO":
                  t4.opacity = 1 - f3[3] * p3.float;
                  break;
                case "RGB_ONE":
                  t4.opacity = f3[0] * p3.float;
                  break;
                default:
                  console.warn('THREE.ColladaLoader: Invalid opaque type "%s" of transparent tag.', d3.opaque);
              }
              t4.opacity < 1 && (t4.transparent = true);
            }
          return void 0 !== a3 && void 0 !== a3.technique && 1 === a3.technique.double_sided && (t4.side = r2.DoubleSide), t4;
        }
        function Y2(e4) {
          return h2(Ve2.materials[e4], q2);
        }
        function Z2(e4) {
          for (var t4 = 0; t4 < e4.childNodes.length; t4++) {
            var n4 = e4.childNodes[t4];
            switch (n4.nodeName) {
              case "technique_common":
                return J2(n4);
            }
          }
          return {};
        }
        function J2(e4) {
          for (var t4 = {}, n4 = 0; n4 < e4.childNodes.length; n4++) {
            var r3 = e4.childNodes[n4];
            switch (r3.nodeName) {
              case "perspective":
              case "orthographic":
                t4.technique = r3.nodeName, t4.parameters = K2(r3);
            }
          }
          return t4;
        }
        function K2(e4) {
          for (var t4 = {}, n4 = 0; n4 < e4.childNodes.length; n4++) {
            var r3 = e4.childNodes[n4];
            switch (r3.nodeName) {
              case "xfov":
              case "yfov":
              case "xmag":
              case "ymag":
              case "znear":
              case "zfar":
              case "aspect_ratio":
                t4[r3.nodeName] = parseFloat(r3.textContent);
            }
          }
          return t4;
        }
        function Q2(e4) {
          var t4;
          switch (e4.optics.technique) {
            case "perspective":
              t4 = new r2.PerspectiveCamera(e4.optics.parameters.yfov, e4.optics.parameters.aspect_ratio, e4.optics.parameters.znear, e4.optics.parameters.zfar);
              break;
            case "orthographic":
              var n4 = e4.optics.parameters.ymag, i4 = e4.optics.parameters.xmag, a3 = e4.optics.parameters.aspect_ratio;
              i4 = void 0 === i4 ? n4 * a3 : i4, n4 = void 0 === n4 ? i4 / a3 : n4, i4 *= 0.5, n4 *= 0.5, t4 = new r2.OrthographicCamera(-i4, i4, n4, -n4, e4.optics.parameters.znear, e4.optics.parameters.zfar);
              break;
            default:
              t4 = new r2.PerspectiveCamera();
          }
          return t4.name = e4.name, t4;
        }
        function $(e4) {
          var t4 = Ve2.cameras[e4];
          return void 0 !== t4 ? h2(t4, Q2) : (console.warn("THREE.ColladaLoader: Couldn't find camera with ID:", e4), null);
        }
        function ee2(e4) {
          for (var t4 = {}, n4 = 0, r3 = e4.childNodes.length; n4 < r3; n4++) {
            var i4 = e4.childNodes[n4];
            if (1 === i4.nodeType)
              switch (i4.nodeName) {
                case "directional":
                case "point":
                case "spot":
                case "ambient":
                  t4.technique = i4.nodeName, t4.parameters = te2(i4);
              }
          }
          return t4;
        }
        function te2(e4) {
          for (var t4 = {}, n4 = 0, i4 = e4.childNodes.length; n4 < i4; n4++) {
            var o3 = e4.childNodes[n4];
            if (1 === o3.nodeType)
              switch (o3.nodeName) {
                case "color":
                  var s3 = a2(o3.textContent);
                  t4.color = new r2.Color().fromArray(s3);
                  break;
                case "falloff_angle":
                  t4.falloffAngle = parseFloat(o3.textContent);
                  break;
                case "quadratic_attenuation":
                  var c4 = parseFloat(o3.textContent);
                  t4.distance = c4 ? Math.sqrt(1 / c4) : 0;
              }
          }
          return t4;
        }
        function ne2(e4) {
          var t4;
          switch (e4.technique) {
            case "directional":
              t4 = new r2.DirectionalLight();
              break;
            case "point":
              t4 = new r2.PointLight();
              break;
            case "spot":
              t4 = new r2.SpotLight();
              break;
            case "ambient":
              t4 = new r2.AmbientLight();
          }
          return e4.parameters.color && t4.color.copy(e4.parameters.color), e4.parameters.distance && (t4.distance = e4.parameters.distance), t4;
        }
        function re2(e4) {
          var t4 = Ve2.lights[e4];
          return void 0 !== t4 ? h2(t4, ne2) : (console.warn("THREE.ColladaLoader: Couldn't find light with ID:", e4), null);
        }
        function ie2(e4) {
          for (var t4 = { array: [], stride: 3 }, r3 = 0; r3 < e4.childNodes.length; r3++) {
            var o3 = e4.childNodes[r3];
            if (1 === o3.nodeType)
              switch (o3.nodeName) {
                case "float_array":
                  t4.array = a2(o3.textContent);
                  break;
                case "Name_array":
                  t4.array = i3(o3.textContent);
                  break;
                case "technique_common":
                  var s3 = n3(o3, "accessor")[0];
                  void 0 !== s3 && (t4.stride = parseInt(s3.getAttribute("stride")));
              }
          }
          return t4;
        }
        function ae2(e4) {
          for (var t4 = {}, n4 = 0; n4 < e4.childNodes.length; n4++) {
            var r3 = e4.childNodes[n4];
            1 === r3.nodeType && (t4[r3.getAttribute("semantic")] = s2(r3.getAttribute("source")));
          }
          return t4;
        }
        function oe2(e4) {
          for (var t4 = { type: e4.nodeName, material: e4.getAttribute("material"), count: parseInt(e4.getAttribute("count")), inputs: {}, stride: 0, hasUV: false }, n4 = 0, r3 = e4.childNodes.length; n4 < r3; n4++) {
            var i4 = e4.childNodes[n4];
            if (1 === i4.nodeType)
              switch (i4.nodeName) {
                case "input":
                  var a3 = s2(i4.getAttribute("source")), c4 = i4.getAttribute("semantic"), u3 = parseInt(i4.getAttribute("offset"));
                  t4.inputs[c4] = { id: a3, offset: u3 }, t4.stride = Math.max(t4.stride, u3 + 1), "TEXCOORD" === c4 && (t4.hasUV = true);
                  break;
                case "vcount":
                  t4.vcount = o2(i4.textContent);
                  break;
                case "p":
                  t4.p = o2(i4.textContent);
              }
          }
          return t4;
        }
        function se2(e4) {
          for (var t4 = 0, n4 = 0, r3 = e4.length; n4 < r3; n4++) {
            true === e4[n4].hasUV && t4++;
          }
          t4 > 0 && t4 < e4.length && (e4.uvsNeedsFix = true);
        }
        function ce2(e4) {
          var t4 = {}, n4 = e4.sources, r3 = e4.vertices, i4 = e4.primitives;
          if (0 === i4.length)
            return {};
          var a3 = function(e5) {
            for (var t5 = {}, n5 = 0; n5 < e5.length; n5++) {
              var r4 = e5[n5];
              void 0 === t5[r4.type] && (t5[r4.type] = []), t5[r4.type].push(r4);
            }
            return t5;
          }(i4);
          for (var o3 in a3) {
            var s3 = a3[o3];
            se2(s3), t4[o3] = ue2(s3, n4, r3);
          }
          return t4;
        }
        function ue2(e4, t4, n4) {
          for (var i4 = {}, a3 = { array: [], stride: 0 }, o3 = { array: [], stride: 0 }, s3 = { array: [], stride: 0 }, c4 = { array: [], stride: 0 }, u3 = [], l3 = 4, h3 = [], d3 = 4, p3 = new r2.BufferGeometry(), f3 = [], m3 = 0, g3 = 0; g3 < e4.length; g3++) {
            var v3 = e4[g3], y3 = v3.inputs, x3 = 0;
            switch (v3.type) {
              case "lines":
              case "linestrips":
                x3 = 2 * v3.count;
                break;
              case "triangles":
                x3 = 3 * v3.count;
                break;
              case "polylist":
                for (var b3 = 0; b3 < v3.count; b3++) {
                  var w3 = v3.vcount[b3];
                  switch (w3) {
                    case 3:
                      x3 += 3;
                      break;
                    case 4:
                      x3 += 6;
                      break;
                    default:
                      x3 += 3 * (w3 - 2);
                  }
                }
                break;
              default:
                console.warn("THREE.ColladaLoader: Unknow primitive type:", v3.type);
            }
            for (var _3 in p3.addGroup(m3, x3, g3), m3 += x3, v3.material && f3.push(v3.material), y3) {
              var M3 = y3[_3];
              switch (_3) {
                case "VERTEX":
                  for (var E3 in n4) {
                    var T3 = n4[E3];
                    switch (E3) {
                      case "POSITION":
                        var S3 = a3.array.length;
                        if (le2(v3, t4[T3], M3.offset, a3.array), a3.stride = t4[T3].stride, t4.skinWeights && t4.skinIndices && (le2(v3, t4.skinIndices, M3.offset, u3), le2(v3, t4.skinWeights, M3.offset, h3)), false === v3.hasUV && true === e4.uvsNeedsFix) {
                          x3 = (a3.array.length - S3) / a3.stride;
                          for (var A3 = 0; A3 < x3; A3++)
                            s3.array.push(0, 0);
                        }
                        break;
                      case "NORMAL":
                        le2(v3, t4[T3], M3.offset, o3.array), o3.stride = t4[T3].stride;
                        break;
                      case "COLOR":
                        le2(v3, t4[T3], M3.offset, c4.array), c4.stride = t4[T3].stride;
                        break;
                      case "TEXCOORD":
                        le2(v3, t4[T3], M3.offset, s3.array), s3.stride = t4[T3].stride;
                        break;
                      default:
                        console.warn('THREE.ColladaLoader: Semantic "%s" not handled in geometry build process.', E3);
                    }
                  }
                  break;
                case "NORMAL":
                  le2(v3, t4[M3.id], M3.offset, o3.array), o3.stride = t4[M3.id].stride;
                  break;
                case "COLOR":
                  le2(v3, t4[M3.id], M3.offset, c4.array), c4.stride = t4[M3.id].stride;
                  break;
                case "TEXCOORD":
                  le2(v3, t4[M3.id], M3.offset, s3.array), s3.stride = t4[M3.id].stride;
              }
            }
          }
          return a3.array.length > 0 && p3.addAttribute("position", new r2.Float32BufferAttribute(a3.array, a3.stride)), o3.array.length > 0 && p3.addAttribute("normal", new r2.Float32BufferAttribute(o3.array, o3.stride)), c4.array.length > 0 && p3.addAttribute("color", new r2.Float32BufferAttribute(c4.array, c4.stride)), s3.array.length > 0 && p3.addAttribute("uv", new r2.Float32BufferAttribute(s3.array, s3.stride)), u3.length > 0 && p3.addAttribute("skinIndex", new r2.Float32BufferAttribute(u3, l3)), h3.length > 0 && p3.addAttribute("skinWeight", new r2.Float32BufferAttribute(h3, d3)), i4.data = p3, i4.type = e4[0].type, i4.materialKeys = f3, i4;
        }
        function le2(e4, t4, n4, r3) {
          var i4 = e4.p, a3 = e4.stride, o3 = e4.vcount;
          function s3(e5) {
            for (var t5 = i4[e5 + n4] * u3, a4 = t5 + u3; t5 < a4; t5++)
              r3.push(c4[t5]);
          }
          var c4 = t4.array, u3 = t4.stride;
          if (void 0 !== e4.vcount)
            for (var l3 = 0, h3 = 0, d3 = o3.length; h3 < d3; h3++) {
              var p3 = o3[h3];
              if (4 === p3) {
                var f3 = l3 + 1 * a3, m3 = l3 + 2 * a3, g3 = l3 + 3 * a3;
                s3(l3 + 0 * a3), s3(f3), s3(g3), s3(f3), s3(m3), s3(g3);
              } else if (3 === p3) {
                f3 = l3 + 1 * a3, m3 = l3 + 2 * a3;
                s3(l3 + 0 * a3), s3(f3), s3(m3);
              } else if (p3 > 4)
                for (var v3 = 1, y3 = p3 - 2; v3 <= y3; v3++) {
                  f3 = l3 + a3 * v3, m3 = l3 + a3 * (v3 + 1);
                  s3(l3 + 0 * a3), s3(f3), s3(m3);
                }
              l3 += a3 * p3;
            }
          else
            for (h3 = 0, d3 = i4.length; h3 < d3; h3 += a3)
              s3(h3);
        }
        function he2(e4) {
          return h2(Ve2.geometries[e4], ce2);
        }
        function de2(e4) {
          return void 0 !== e4.build ? e4.build : e4;
        }
        function pe2(e4, t4) {
          for (var n4 = 0; n4 < e4.childNodes.length; n4++) {
            var r3 = e4.childNodes[n4];
            if (1 === r3.nodeType)
              switch (r3.nodeName) {
                case "joint":
                  t4.joints[r3.getAttribute("sid")] = fe2(r3);
                  break;
                case "link":
                  t4.links.push(ge2(r3));
              }
          }
        }
        function fe2(e4) {
          for (var t4, n4 = 0; n4 < e4.childNodes.length; n4++) {
            var r3 = e4.childNodes[n4];
            if (1 === r3.nodeType)
              switch (r3.nodeName) {
                case "prismatic":
                case "revolute":
                  t4 = me2(r3);
              }
          }
          return t4;
        }
        function me2(e4, t4) {
          t4 = { sid: e4.getAttribute("sid"), name: e4.getAttribute("name") || "", axis: new r2.Vector3(), limits: { min: 0, max: 0 }, type: e4.nodeName, static: false, zeroPosition: 0, middlePosition: 0 };
          for (var n4 = 0; n4 < e4.childNodes.length; n4++) {
            var i4 = e4.childNodes[n4];
            if (1 === i4.nodeType)
              switch (i4.nodeName) {
                case "axis":
                  var o3 = a2(i4.textContent);
                  t4.axis.fromArray(o3);
                  break;
                case "limits":
                  var s3 = i4.getElementsByTagName("max")[0], c4 = i4.getElementsByTagName("min")[0];
                  t4.limits.max = parseFloat(s3.textContent), t4.limits.min = parseFloat(c4.textContent);
              }
          }
          return t4.limits.min >= t4.limits.max && (t4.static = true), t4.middlePosition = (t4.limits.min + t4.limits.max) / 2, t4;
        }
        function ge2(e4) {
          for (var t4 = { sid: e4.getAttribute("sid"), name: e4.getAttribute("name") || "", attachments: [], transforms: [] }, n4 = 0; n4 < e4.childNodes.length; n4++) {
            var r3 = e4.childNodes[n4];
            if (1 === r3.nodeType)
              switch (r3.nodeName) {
                case "attachment_full":
                  t4.attachments.push(ve2(r3));
                  break;
                case "matrix":
                case "translate":
                case "rotate":
                  t4.transforms.push(ye2(r3));
              }
          }
          return t4;
        }
        function ve2(e4) {
          for (var t4 = { joint: e4.getAttribute("joint").split("/").pop(), transforms: [], links: [] }, n4 = 0; n4 < e4.childNodes.length; n4++) {
            var r3 = e4.childNodes[n4];
            if (1 === r3.nodeType)
              switch (r3.nodeName) {
                case "link":
                  t4.links.push(ge2(r3));
                  break;
                case "matrix":
                case "translate":
                case "rotate":
                  t4.transforms.push(ye2(r3));
              }
          }
          return t4;
        }
        function ye2(e4) {
          var t4 = { type: e4.nodeName }, n4 = a2(e4.textContent);
          switch (t4.type) {
            case "matrix":
              t4.obj = new r2.Matrix4(), t4.obj.fromArray(n4).transpose();
              break;
            case "translate":
              t4.obj = new r2.Vector3(), t4.obj.fromArray(n4);
              break;
            case "rotate":
              t4.obj = new r2.Vector3(), t4.obj.fromArray(n4), t4.angle = r2.Math.degToRad(n4[3]);
          }
          return t4;
        }
        function xe2(e4, t4) {
          for (var n4 = 0; n4 < e4.childNodes.length; n4++) {
            var r3 = e4.childNodes[n4];
            if (1 === r3.nodeType)
              switch (r3.nodeName) {
                case "technique_common":
                  be2(r3, t4);
              }
          }
        }
        function be2(e4, t4) {
          for (var n4 = 0; n4 < e4.childNodes.length; n4++) {
            var r3 = e4.childNodes[n4];
            if (1 === r3.nodeType)
              switch (r3.nodeName) {
                case "inertia":
                  t4.inertia = a2(r3.textContent);
                  break;
                case "mass":
                  t4.mass = a2(r3.textContent)[0];
              }
          }
        }
        function we2(e4) {
          for (var t4 = { target: e4.getAttribute("target").split("/").pop() }, n4 = 0; n4 < e4.childNodes.length; n4++) {
            var r3 = e4.childNodes[n4];
            if (1 === r3.nodeType)
              switch (r3.nodeName) {
                case "axis":
                  var i4 = r3.getElementsByTagName("param")[0];
                  t4.axis = i4.textContent;
                  var a3 = t4.axis.split("inst_").pop().split("axis")[0];
                  t4.jointIndex = a3.substr(0, a3.length - 1);
              }
          }
          return t4;
        }
        function _e(e4) {
          return void 0 !== e4.build ? e4.build : e4;
        }
        var Me2 = new r2.Matrix4(), Ee2 = new r2.Vector3();
        function Te2(e4) {
          for (var t4 = { name: e4.getAttribute("name") || "", type: e4.getAttribute("type"), id: e4.getAttribute("id"), sid: e4.getAttribute("sid"), matrix: new r2.Matrix4(), nodes: [], instanceCameras: [], instanceControllers: [], instanceLights: [], instanceGeometries: [], instanceNodes: [], transforms: {} }, n4 = 0; n4 < e4.childNodes.length; n4++) {
            var i4 = e4.childNodes[n4];
            if (1 === i4.nodeType)
              switch (i4.nodeName) {
                case "node":
                  t4.nodes.push(i4.getAttribute("id")), Te2(i4);
                  break;
                case "instance_camera":
                  t4.instanceCameras.push(s2(i4.getAttribute("url")));
                  break;
                case "instance_controller":
                  t4.instanceControllers.push(Se2(i4));
                  break;
                case "instance_light":
                  t4.instanceLights.push(s2(i4.getAttribute("url")));
                  break;
                case "instance_geometry":
                  t4.instanceGeometries.push(Se2(i4));
                  break;
                case "instance_node":
                  t4.instanceNodes.push(s2(i4.getAttribute("url")));
                  break;
                case "matrix":
                  var o3 = a2(i4.textContent);
                  t4.matrix.multiply(Me2.fromArray(o3).transpose()), t4.transforms[i4.getAttribute("sid")] = i4.nodeName;
                  break;
                case "translate":
                  o3 = a2(i4.textContent);
                  Ee2.fromArray(o3), t4.matrix.multiply(Me2.makeTranslation(Ee2.x, Ee2.y, Ee2.z)), t4.transforms[i4.getAttribute("sid")] = i4.nodeName;
                  break;
                case "rotate":
                  o3 = a2(i4.textContent);
                  var c4 = r2.Math.degToRad(o3[3]);
                  t4.matrix.multiply(Me2.makeRotationAxis(Ee2.fromArray(o3), c4)), t4.transforms[i4.getAttribute("sid")] = i4.nodeName;
                  break;
                case "scale":
                  o3 = a2(i4.textContent);
                  t4.matrix.scale(Ee2.fromArray(o3)), t4.transforms[i4.getAttribute("sid")] = i4.nodeName;
                  break;
                case "extra":
                  break;
                default:
                  console.log(i4);
              }
          }
          return Ve2.nodes[t4.id] = t4, t4;
        }
        function Se2(e4) {
          for (var t4 = { id: s2(e4.getAttribute("url")), materials: {}, skeletons: [] }, n4 = 0; n4 < e4.childNodes.length; n4++) {
            var r3 = e4.childNodes[n4];
            switch (r3.nodeName) {
              case "bind_material":
                for (var i4 = r3.getElementsByTagName("instance_material"), a3 = 0; a3 < i4.length; a3++) {
                  var o3 = i4[a3], c4 = o3.getAttribute("symbol"), u3 = o3.getAttribute("target");
                  t4.materials[c4] = s2(u3);
                }
                break;
              case "skeleton":
                t4.skeletons.push(s2(r3.textContent));
            }
          }
          return t4;
        }
        function Ae2(e4, t4) {
          var n4, i4, a3 = [], o3 = [];
          for (n4 = 0; n4 < e4.length; n4++) {
            var s3 = e4[n4];
            if (Oe2(s3))
              Le2(Ne2(s3), t4, a3);
            else if (De2(s3))
              for (var c4 = Ve2.visualScenes[s3].children, u3 = 0; u3 < c4.length; u3++) {
                var l3 = c4[u3];
                if ("JOINT" === l3.type)
                  Le2(Ne2(l3.id), t4, a3);
              }
            else
              console.error("THREE.ColladaLoader: Unable to find root bone of skeleton with ID:", s3);
          }
          for (n4 = 0; n4 < t4.length; n4++)
            for (u3 = 0; u3 < a3.length; u3++)
              if ((i4 = a3[u3]).bone.name === t4[n4].name) {
                o3[n4] = i4, i4.processed = true;
                break;
              }
          for (n4 = 0; n4 < a3.length; n4++)
            false === (i4 = a3[n4]).processed && (o3.push(i4), i4.processed = true);
          var h3 = [], d3 = [];
          for (n4 = 0; n4 < o3.length; n4++)
            i4 = o3[n4], h3.push(i4.bone), d3.push(i4.boneInverse);
          return new r2.Skeleton(h3, d3);
        }
        function Le2(e4, t4, n4) {
          e4.traverse(function(e5) {
            if (true === e5.isBone) {
              for (var i4, a3 = 0; a3 < t4.length; a3++) {
                var o3 = t4[a3];
                if (o3.name === e5.name) {
                  i4 = o3.boneInverse;
                  break;
                }
              }
              void 0 === i4 && (i4 = new r2.Matrix4()), n4.push({ bone: e5, boneInverse: i4, processed: false });
            }
          });
        }
        function Re2(e4) {
          for (var t4 = [], n4 = e4.matrix, i4 = e4.nodes, a3 = e4.type, o3 = e4.instanceCameras, s3 = e4.instanceControllers, c4 = e4.instanceLights, u3 = e4.instanceGeometries, l3 = e4.instanceNodes, h3 = 0, d3 = i4.length; h3 < d3; h3++)
            t4.push(Ne2(i4[h3]));
          for (h3 = 0, d3 = o3.length; h3 < d3; h3++) {
            var p3 = $(o3[h3]);
            null !== p3 && t4.push(p3.clone());
          }
          for (h3 = 0, d3 = s3.length; h3 < d3; h3++)
            for (var f3 = P2((w3 = s3[h3]).id), m3 = Pe2(he2(f3.id), w3.materials), g3 = Ae2(w3.skeletons, f3.skin.joints), v3 = 0, y3 = m3.length; v3 < y3; v3++) {
              var x3;
              (x3 = m3[v3]).isSkinnedMesh && (x3.bind(g3, f3.skin.bindMatrix), x3.normalizeSkinWeights()), t4.push(x3);
            }
          for (h3 = 0, d3 = c4.length; h3 < d3; h3++) {
            var b3 = re2(c4[h3]);
            null !== b3 && t4.push(b3.clone());
          }
          for (h3 = 0, d3 = u3.length; h3 < d3; h3++) {
            var w3;
            for (v3 = 0, y3 = (m3 = Pe2(he2((w3 = u3[h3]).id), w3.materials)).length; v3 < y3; v3++)
              t4.push(m3[v3]);
          }
          for (h3 = 0, d3 = l3.length; h3 < d3; h3++)
            t4.push(Ne2(l3[h3]).clone());
          if (0 === i4.length && 1 === t4.length)
            x3 = t4[0];
          else {
            x3 = "JOINT" === a3 ? new r2.Bone() : new r2.Group();
            for (h3 = 0; h3 < t4.length; h3++)
              x3.add(t4[h3]);
          }
          return "" === x3.name && (x3.name = "JOINT" === a3 ? e4.sid : e4.name), x3.matrix.copy(n4), x3.matrix.decompose(x3.position, x3.quaternion, x3.scale), x3;
        }
        function Ce2(e4, t4) {
          for (var n4 = [], r3 = 0, i4 = e4.length; r3 < i4; r3++) {
            var a3 = t4[e4[r3]];
            n4.push(Y2(a3));
          }
          return n4;
        }
        function Pe2(e4, t4) {
          var n4 = [];
          for (var i4 in e4) {
            var a3 = e4[i4], o3 = Ce2(a3.materialKeys, t4);
            0 === o3.length && ("lines" === i4 || "linestrips" === i4 ? o3.push(new r2.LineBasicMaterial()) : o3.push(new r2.MeshPhongMaterial()));
            var s3 = void 0 !== a3.data.attributes.skinIndex;
            if (s3)
              for (var c4 = 0, u3 = o3.length; c4 < u3; c4++)
                o3[c4].skinning = true;
            var l3, h3 = 1 === o3.length ? o3[0] : o3;
            switch (i4) {
              case "lines":
                l3 = new r2.LineSegments(a3.data, h3);
                break;
              case "linestrips":
                l3 = new r2.Line(a3.data, h3);
                break;
              case "triangles":
              case "polylist":
                l3 = s3 ? new r2.SkinnedMesh(a3.data, h3) : new r2.Mesh(a3.data, h3);
            }
            n4.push(l3);
          }
          return n4;
        }
        function Oe2(e4) {
          return void 0 !== Ve2.nodes[e4];
        }
        function Ne2(e4) {
          return h2(Ve2.nodes[e4], Re2);
        }
        function Ie2(e4) {
          var t4 = new r2.Group();
          t4.name = e4.name;
          for (var n4 = e4.children, i4 = 0; i4 < n4.length; i4++) {
            var a3 = n4[i4];
            t4.add(Ne2(a3.id));
          }
          return t4;
        }
        function De2(e4) {
          return void 0 !== Ve2.visualScenes[e4];
        }
        function Ue2(e4) {
          return h2(Ve2.visualScenes[e4], Ie2);
        }
        if (0 === e3.length)
          return { scene: new r2.Scene() };
        var Be2 = n3(new DOMParser().parseFromString(e3, "application/xml"), "COLLADA")[0], Fe2 = Be2.getAttribute("version");
        console.log("THREE.ColladaLoader: File version", Fe2);
        var Ge2 = function(e4) {
          return { unit: function(e5) {
            return void 0 !== e5 && true === e5.hasAttribute("meter") ? parseFloat(e5.getAttribute("meter")) : 1;
          }(n3(e4, "unit")[0]), upAxis: function(e5) {
            return void 0 !== e5 ? e5.textContent : "Y_UP";
          }(n3(e4, "up_axis")[0]) };
        }(n3(Be2, "asset")[0]), ze2 = new r2.TextureLoader(this.manager);
        ze2.setPath(t3).setCrossOrigin(this.crossOrigin);
        var He2 = [], ke2 = {}, je2 = 0, Ve2 = { animations: {}, clips: {}, controllers: {}, images: {}, effects: {}, materials: {}, cameras: {}, lights: {}, geometries: {}, nodes: {}, visualScenes: {}, kinematicsModels: {}, physicsModels: {}, kinematicsScenes: {} };
        u2(Be2, "library_animations", "animation", function(e4) {
          for (var t4 = { sources: {}, samplers: {}, channels: {} }, n4 = 0, r3 = e4.childNodes.length; n4 < r3; n4++) {
            var i4, a3 = e4.childNodes[n4];
            if (1 === a3.nodeType)
              switch (a3.nodeName) {
                case "source":
                  i4 = a3.getAttribute("id"), t4.sources[i4] = ie2(a3);
                  break;
                case "sampler":
                  i4 = a3.getAttribute("id"), t4.samplers[i4] = d2(a3);
                  break;
                case "channel":
                  i4 = a3.getAttribute("target"), t4.channels[i4] = p2(a3);
                  break;
                default:
                  console.log(a3);
              }
          }
          Ve2.animations[e4.getAttribute("id")] = t4;
        }), u2(Be2, "library_animation_clips", "animation_clip", function(e4) {
          for (var t4 = { name: e4.getAttribute("id") || "default", start: parseFloat(e4.getAttribute("start") || 0), end: parseFloat(e4.getAttribute("end") || 0), animations: [] }, n4 = 0, r3 = e4.childNodes.length; n4 < r3; n4++) {
            var i4 = e4.childNodes[n4];
            if (1 === i4.nodeType)
              switch (i4.nodeName) {
                case "instance_animation":
                  t4.animations.push(s2(i4.getAttribute("url")));
              }
          }
          Ve2.clips[e4.getAttribute("id")] = t4;
        }), u2(Be2, "library_controllers", "controller", function(e4) {
          for (var t4 = {}, n4 = 0, r3 = e4.childNodes.length; n4 < r3; n4++) {
            var i4 = e4.childNodes[n4];
            if (1 === i4.nodeType)
              switch (i4.nodeName) {
                case "skin":
                  t4.id = s2(i4.getAttribute("source")), t4.skin = A2(i4);
                  break;
                case "morph":
                  t4.id = s2(i4.getAttribute("source")), console.warn("THREE.ColladaLoader: Morph target animation not supported yet.");
              }
          }
          Ve2.controllers[e4.getAttribute("id")] = t4;
        }), u2(Be2, "library_images", "image", function(e4) {
          var t4 = { init_from: n3(e4, "init_from")[0].textContent };
          Ve2.images[e4.getAttribute("id")] = t4;
        }), u2(Be2, "library_effects", "effect", function(e4) {
          for (var t4 = {}, n4 = 0, r3 = e4.childNodes.length; n4 < r3; n4++) {
            var i4 = e4.childNodes[n4];
            if (1 === i4.nodeType)
              switch (i4.nodeName) {
                case "profile_COMMON":
                  t4.profile = I2(i4);
              }
          }
          Ve2.effects[e4.getAttribute("id")] = t4;
        }), u2(Be2, "library_materials", "material", function(e4) {
          for (var t4 = { name: e4.getAttribute("name") }, n4 = 0, r3 = e4.childNodes.length; n4 < r3; n4++) {
            var i4 = e4.childNodes[n4];
            if (1 === i4.nodeType)
              switch (i4.nodeName) {
                case "instance_effect":
                  t4.url = s2(i4.getAttribute("url"));
              }
          }
          Ve2.materials[e4.getAttribute("id")] = t4;
        }), u2(Be2, "library_cameras", "camera", function(e4) {
          for (var t4 = { name: e4.getAttribute("name") }, n4 = 0, r3 = e4.childNodes.length; n4 < r3; n4++) {
            var i4 = e4.childNodes[n4];
            if (1 === i4.nodeType)
              switch (i4.nodeName) {
                case "optics":
                  t4.optics = Z2(i4);
              }
          }
          Ve2.cameras[e4.getAttribute("id")] = t4;
        }), u2(Be2, "library_lights", "light", function(e4) {
          for (var t4 = {}, n4 = 0, r3 = e4.childNodes.length; n4 < r3; n4++) {
            var i4 = e4.childNodes[n4];
            if (1 === i4.nodeType)
              switch (i4.nodeName) {
                case "technique_common":
                  t4 = ee2(i4);
              }
          }
          Ve2.lights[e4.getAttribute("id")] = t4;
        }), u2(Be2, "library_geometries", "geometry", function(e4) {
          var t4 = { name: e4.getAttribute("name"), sources: {}, vertices: {}, primitives: [] }, r3 = n3(e4, "mesh")[0];
          if (void 0 !== r3) {
            for (var i4 = 0; i4 < r3.childNodes.length; i4++) {
              var a3 = r3.childNodes[i4];
              if (1 === a3.nodeType) {
                var o3 = a3.getAttribute("id");
                switch (a3.nodeName) {
                  case "source":
                    t4.sources[o3] = ie2(a3);
                    break;
                  case "vertices":
                    t4.vertices = ae2(a3);
                    break;
                  case "polygons":
                    console.warn("THREE.ColladaLoader: Unsupported primitive type: ", a3.nodeName);
                    break;
                  case "lines":
                  case "linestrips":
                  case "polylist":
                  case "triangles":
                    t4.primitives.push(oe2(a3));
                    break;
                  default:
                    console.log(a3);
                }
              }
            }
            Ve2.geometries[e4.getAttribute("id")] = t4;
          }
        }), u2(Be2, "library_nodes", "node", Te2), u2(Be2, "library_visual_scenes", "visual_scene", function(e4) {
          var t4 = { name: e4.getAttribute("name"), children: [] };
          !function(e5) {
            for (var t5 = e5.getElementsByTagName("node"), n4 = 0; n4 < t5.length; n4++) {
              var r4 = t5[n4];
              false === r4.hasAttribute("id") && r4.setAttribute("id", "three_default_" + je2++);
            }
          }(e4);
          for (var r3 = n3(e4, "node"), i4 = 0; i4 < r3.length; i4++)
            t4.children.push(Te2(r3[i4]));
          Ve2.visualScenes[e4.getAttribute("id")] = t4;
        }), u2(Be2, "library_kinematics_models", "kinematics_model", function(e4) {
          for (var t4 = { name: e4.getAttribute("name") || "", joints: {}, links: [] }, n4 = 0; n4 < e4.childNodes.length; n4++) {
            var r3 = e4.childNodes[n4];
            if (1 === r3.nodeType)
              switch (r3.nodeName) {
                case "technique_common":
                  pe2(r3, t4);
              }
          }
          Ve2.kinematicsModels[e4.getAttribute("id")] = t4;
        }), u2(Be2, "library_physics_models", "physics_model", function(e4) {
          for (var t4 = { name: e4.getAttribute("name") || "", rigidBodies: {} }, n4 = 0; n4 < e4.childNodes.length; n4++) {
            var r3 = e4.childNodes[n4];
            if (1 === r3.nodeType)
              switch (r3.nodeName) {
                case "rigid_body":
                  t4.rigidBodies[r3.getAttribute("name")] = {}, xe2(r3, t4.rigidBodies[r3.getAttribute("name")]);
              }
          }
          Ve2.physicsModels[e4.getAttribute("id")] = t4;
        }), u2(Be2, "scene", "instance_kinematics_scene", function(e4) {
          for (var t4 = { bindJointAxis: [] }, n4 = 0; n4 < e4.childNodes.length; n4++) {
            var r3 = e4.childNodes[n4];
            if (1 === r3.nodeType)
              switch (r3.nodeName) {
                case "bind_joint_axis":
                  t4.bindJointAxis.push(we2(r3));
              }
          }
          Ve2.kinematicsScenes[s2(e4.getAttribute("url"))] = t4;
        }), l2(Ve2.animations, f2), l2(Ve2.clips, T2), l2(Ve2.controllers, C2), l2(Ve2.images, O2), l2(Ve2.effects, X2), l2(Ve2.materials, q2), l2(Ve2.cameras, Q2), l2(Ve2.lights, ne2), l2(Ve2.geometries, ce2), l2(Ve2.visualScenes, Ie2), function() {
          var e4 = Ve2.clips;
          if (true === c3(e4)) {
            if (false === c3(Ve2.animations)) {
              var t4 = [];
              for (var n4 in Ve2.animations)
                for (var i4 = m2(n4), a3 = 0, o3 = i4.length; a3 < o3; a3++)
                  t4.push(i4[a3]);
              He2.push(new r2.AnimationClip("default", -1, t4));
            }
          } else
            for (var n4 in e4)
              He2.push(S2(n4));
        }(), function() {
          var e4 = Object.keys(Ve2.kinematicsModels)[0], t4 = Object.keys(Ve2.kinematicsScenes)[0], n4 = Object.keys(Ve2.visualScenes)[0];
          if (void 0 !== e4 && void 0 !== t4) {
            for (var i4 = function(e5) {
              return h2(Ve2.kinematicsModels[e5], de2);
            }(e4), o3 = function(e5) {
              return h2(Ve2.kinematicsScenes[e5], _e);
            }(t4), s3 = Ue2(n4), c4 = o3.bindJointAxis, u3 = {}, l3 = 0, d3 = c4.length; l3 < d3; l3++) {
              var p3 = c4[l3], f3 = Be2.querySelector('[sid="' + p3.target + '"]');
              if (f3) {
                var m3 = f3.parentElement;
                v3(p3.jointIndex, m3);
              }
            }
            var g3 = new r2.Matrix4();
            ke2 = { joints: i4 && i4.joints, getJointValue: function(e5) {
              var t5 = u3[e5];
              if (t5)
                return t5.position;
              console.warn("THREE.ColladaLoader: Joint " + e5 + " doesn't exist.");
            }, setJointValue: function(e5, t5) {
              var n5 = u3[e5];
              if (n5) {
                var i5 = n5.joint;
                if (t5 > i5.limits.max || t5 < i5.limits.min)
                  console.warn("THREE.ColladaLoader: Joint " + e5 + " value " + t5 + " outside of limits (min: " + i5.limits.min + ", max: " + i5.limits.max + ").");
                else if (i5.static)
                  console.warn("THREE.ColladaLoader: Joint " + e5 + " is static.");
                else {
                  var a3 = n5.object, o4 = i5.axis, s4 = n5.transforms;
                  Me2.identity();
                  for (var c5 = 0; c5 < s4.length; c5++) {
                    var l4 = s4[c5];
                    if (l4.sid && -1 !== l4.sid.indexOf(e5))
                      switch (i5.type) {
                        case "revolute":
                          Me2.multiply(g3.makeRotationAxis(o4, r2.Math.degToRad(t5)));
                          break;
                        case "prismatic":
                          Me2.multiply(g3.makeTranslation(o4.x * t5, o4.y * t5, o4.z * t5));
                          break;
                        default:
                          console.warn("THREE.ColladaLoader: Unknown joint type: " + i5.type);
                      }
                    else
                      switch (l4.type) {
                        case "matrix":
                          Me2.multiply(l4.obj);
                          break;
                        case "translate":
                          Me2.multiply(g3.makeTranslation(l4.obj.x, l4.obj.y, l4.obj.z));
                          break;
                        case "scale":
                          Me2.scale(l4.obj);
                          break;
                        case "rotate":
                          Me2.multiply(g3.makeRotationAxis(l4.obj, l4.angle));
                      }
                  }
                  a3.matrix.copy(Me2), a3.matrix.decompose(a3.position, a3.quaternion, a3.scale), u3[e5].position = t5;
                }
              } else
                console.log("THREE.ColladaLoader: " + e5 + " does not exist.");
            } };
          }
          function v3(e5, t5) {
            var n5 = t5.getAttribute("name"), o4 = i4.joints[e5];
            s3.traverse(function(i5) {
              i5.name === n5 && (u3[e5] = { object: i5, transforms: function(e6) {
                for (var t6 = [], n6 = Be2.querySelector('[id="' + e6.id + '"]'), i6 = 0; i6 < n6.childNodes.length; i6++) {
                  var o5 = n6.childNodes[i6];
                  if (1 === o5.nodeType)
                    switch (o5.nodeName) {
                      case "matrix":
                        var s4 = a2(o5.textContent), c5 = new r2.Matrix4().fromArray(s4).transpose();
                        t6.push({ sid: o5.getAttribute("sid"), type: o5.nodeName, obj: c5 });
                        break;
                      case "translate":
                      case "scale":
                        var s4 = a2(o5.textContent), u4 = new r2.Vector3().fromArray(s4);
                        t6.push({ sid: o5.getAttribute("sid"), type: o5.nodeName, obj: u4 });
                        break;
                      case "rotate":
                        var s4 = a2(o5.textContent), u4 = new r2.Vector3().fromArray(s4), l4 = r2.Math.degToRad(s4[3]);
                        t6.push({ sid: o5.getAttribute("sid"), type: o5.nodeName, obj: u4, angle: l4 });
                    }
                }
                return t6;
              }(t5), joint: o4, position: o4.zeroPosition });
            });
          }
        }();
        var We2 = function(e4) {
          return Ue2(s2(n3(e4, "instance_visual_scene")[0].getAttribute("url")));
        }(n3(Be2, "scene")[0]);
        return "Z_UP" === Ge2.upAxis && We2.quaternion.setFromEuler(new r2.Euler(-Math.PI / 2, 0, 0)), We2.scale.multiplyScalar(Ge2.unit), { animations: He2, kinematics: ke2, library: Ve2, scene: We2 };
      } }, r2.GLTFLoader = function() {
        function e3(e4) {
          this.manager = void 0 !== e4 ? e4 : r2.DefaultLoadingManager, this.dracoLoader = null;
        }
        e3.prototype = { constructor: e3, crossOrigin: "anonymous", load: function(e4, t4, n4, i4) {
          var a3 = this, o3 = void 0 !== this.path ? this.path : r2.LoaderUtils.extractUrlBase(e4), s3 = new r2.FileLoader(a3.manager);
          s3.setResponseType("arraybuffer"), s3.load(e4, function(e5) {
            try {
              a3.parse(e5, o3, t4, i4);
            } catch (e6) {
              if (void 0 === i4)
                throw e6;
              i4(e6);
            }
          }, n4, i4);
        }, setCrossOrigin: function(e4) {
          return this.crossOrigin = e4, this;
        }, setPath: function(e4) {
          return this.path = e4, this;
        }, setDRACOLoader: function(e4) {
          return this.dracoLoader = e4, this;
        }, parse: function(e4, h3, d3, p3) {
          var f3, m3 = {};
          if ("string" == typeof e4)
            f3 = e4;
          else if (r2.LoaderUtils.decodeText(new Uint8Array(e4, 0, 4)) === o2) {
            try {
              m3[t3.KHR_BINARY_GLTF] = new function(e5) {
                this.name = t3.KHR_BINARY_GLTF, this.content = null, this.body = null;
                var n4 = new DataView(e5, 0, s2);
                if (this.header = { magic: r2.LoaderUtils.decodeText(new Uint8Array(e5.slice(0, 4))), version: n4.getUint32(4, true), length: n4.getUint32(8, true) }, this.header.magic !== o2)
                  throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                if (this.header.version < 2)
                  throw new Error("THREE.GLTFLoader: Legacy binary file detected. Use LegacyGLTFLoader instead.");
                var i4 = new DataView(e5, s2), a3 = 0;
                for (; a3 < i4.byteLength; ) {
                  var u3 = i4.getUint32(a3, true);
                  a3 += 4;
                  var l3 = i4.getUint32(a3, true);
                  if (a3 += 4, l3 === c3.JSON) {
                    var h4 = new Uint8Array(e5, s2 + a3, u3);
                    this.content = r2.LoaderUtils.decodeText(h4);
                  } else if (l3 === c3.BIN) {
                    var d4 = s2 + a3;
                    this.body = e5.slice(d4, d4 + u3);
                  }
                  a3 += u3;
                }
                if (null === this.content)
                  throw new Error("THREE.GLTFLoader: JSON content not found.");
              }(e4);
            } catch (e5) {
              return void (p3 && p3(e5));
            }
            f3 = m3[t3.KHR_BINARY_GLTF].content;
          } else
            f3 = r2.LoaderUtils.decodeText(new Uint8Array(e4));
          var g3 = JSON.parse(f3);
          if (void 0 === g3.asset || g3.asset.version[0] < 2)
            p3 && p3(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported. Use LegacyGLTFLoader instead."));
          else {
            if (g3.extensionsUsed)
              for (var v3 = 0; v3 < g3.extensionsUsed.length; ++v3) {
                var y3 = g3.extensionsUsed[v3], x3 = g3.extensionsRequired || [];
                switch (y3) {
                  case t3.KHR_LIGHTS:
                    m3[y3] = new i3(g3);
                    break;
                  case t3.KHR_MATERIALS_UNLIT:
                    m3[y3] = new a2();
                    break;
                  case t3.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                    m3[y3] = new l2();
                    break;
                  case t3.KHR_DRACO_MESH_COMPRESSION:
                    m3[y3] = new u2(g3, this.dracoLoader);
                    break;
                  case t3.MSFT_TEXTURE_DDS:
                    m3[t3.MSFT_TEXTURE_DDS] = new n3();
                    break;
                  default:
                    x3.indexOf(y3) >= 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + y3 + '".');
                }
              }
            var b3 = new G2(g3, m3, { path: h3 || this.path || "", crossOrigin: this.crossOrigin, manager: this.manager });
            b3.parse(function(e5, t4, n4, r3, i4) {
              var a3 = { scene: e5, scenes: t4, cameras: n4, animations: r3, asset: i4.asset, parser: b3, userData: {} };
              O2(m3, a3, i4), d3(a3);
            }, p3);
          }
        } };
        var t3 = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS: "KHR_lights", KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", MSFT_TEXTURE_DDS: "MSFT_texture_dds" };
        function n3() {
          if (!r2.DDSLoader)
            throw new Error("THREE.GLTFLoader: Attempting to load .dds texture without importing THREE.DDSLoader");
          this.name = t3.MSFT_TEXTURE_DDS, this.ddsLoader = new r2.DDSLoader();
        }
        function i3(e4) {
          this.name = t3.KHR_LIGHTS, this.lights = {};
          var n4 = (e4.extensions && e4.extensions[t3.KHR_LIGHTS] || {}).lights || {};
          for (var i4 in n4) {
            var a3, o3 = n4[i4], s3 = new r2.Color().fromArray(o3.color);
            switch (o3.type) {
              case "directional":
                (a3 = new r2.DirectionalLight(s3)).target.position.set(0, 0, 1), a3.add(a3.target);
                break;
              case "point":
                a3 = new r2.PointLight(s3);
                break;
              case "spot":
                a3 = new r2.SpotLight(s3), o3.spot = o3.spot || {}, o3.spot.innerConeAngle = void 0 !== o3.spot.innerConeAngle ? o3.spot.innerConeAngle : 0, o3.spot.outerConeAngle = void 0 !== o3.spot.outerConeAngle ? o3.spot.outerConeAngle : Math.PI / 4, a3.angle = o3.spot.outerConeAngle, a3.penumbra = 1 - o3.spot.innerConeAngle / o3.spot.outerConeAngle, a3.target.position.set(0, 0, 1), a3.add(a3.target);
                break;
              case "ambient":
                a3 = new r2.AmbientLight(s3);
            }
            a3 && (a3.decay = 2, void 0 !== o3.intensity && (a3.intensity = o3.intensity), a3.name = o3.name || "light_" + i4, this.lights[i4] = a3);
          }
        }
        function a2(e4) {
          this.name = t3.KHR_MATERIALS_UNLIT;
        }
        a2.prototype.getMaterialType = function(e4) {
          return r2.MeshBasicMaterial;
        }, a2.prototype.extendParams = function(e4, t4, n4) {
          var i4 = [];
          e4.color = new r2.Color(1, 1, 1), e4.opacity = 1;
          var a3 = t4.pbrMetallicRoughness;
          if (a3) {
            if (Array.isArray(a3.baseColorFactor)) {
              var o3 = a3.baseColorFactor;
              e4.color.fromArray(o3), e4.opacity = o3[3];
            }
            void 0 !== a3.baseColorTexture && i4.push(n4.assignTexture(e4, "map", a3.baseColorTexture.index));
          }
          return Promise.all(i4);
        };
        var o2 = "glTF", s2 = 12, c3 = { JSON: 1313821514, BIN: 5130562 };
        function u2(e4, n4) {
          if (!n4)
            throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
          this.name = t3.KHR_DRACO_MESH_COMPRESSION, this.json = e4, this.dracoLoader = n4;
        }
        function l2() {
          return { name: t3.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, specularGlossinessParams: ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"], getMaterialType: function() {
            return r2.ShaderMaterial;
          }, extendParams: function(e4, t4, n4) {
            var i4 = t4.extensions[this.name], a3 = r2.ShaderLib.standard, o3 = r2.UniformsUtils.clone(a3.uniforms), s3 = ["#ifdef USE_SPECULARMAP", "	uniform sampler2D specularMap;", "#endif"].join("\n"), c4 = ["#ifdef USE_GLOSSINESSMAP", "	uniform sampler2D glossinessMap;", "#endif"].join("\n"), u3 = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "	vec4 texelSpecular = texture2D( specularMap, vUv );", "	texelSpecular = sRGBToLinear( texelSpecular );", "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "	specularFactor *= texelSpecular.rgb;", "#endif"].join("\n"), l3 = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );", "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "	glossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"), h3 = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb;", "material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );", "material.specularColor = specularFactor.rgb;"].join("\n"), d3 = a3.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", s3).replace("#include <metalnessmap_pars_fragment>", c4).replace("#include <roughnessmap_fragment>", u3).replace("#include <metalnessmap_fragment>", l3).replace("#include <lights_physical_fragment>", h3);
            delete o3.roughness, delete o3.metalness, delete o3.roughnessMap, delete o3.metalnessMap, o3.specular = { value: new r2.Color().setHex(1118481) }, o3.glossiness = { value: 0.5 }, o3.specularMap = { value: null }, o3.glossinessMap = { value: null }, e4.vertexShader = a3.vertexShader, e4.fragmentShader = d3, e4.uniforms = o3, e4.defines = { STANDARD: "" }, e4.color = new r2.Color(1, 1, 1), e4.opacity = 1;
            var p3 = [];
            if (Array.isArray(i4.diffuseFactor)) {
              var f3 = i4.diffuseFactor;
              e4.color.fromArray(f3), e4.opacity = f3[3];
            }
            if (void 0 !== i4.diffuseTexture && p3.push(n4.assignTexture(e4, "map", i4.diffuseTexture.index)), e4.emissive = new r2.Color(0, 0, 0), e4.glossiness = void 0 !== i4.glossinessFactor ? i4.glossinessFactor : 1, e4.specular = new r2.Color(1, 1, 1), Array.isArray(i4.specularFactor) && e4.specular.fromArray(i4.specularFactor), void 0 !== i4.specularGlossinessTexture) {
              var m3 = i4.specularGlossinessTexture.index;
              p3.push(n4.assignTexture(e4, "glossinessMap", m3)), p3.push(n4.assignTexture(e4, "specularMap", m3));
            }
            return Promise.all(p3);
          }, createMaterial: function(e4) {
            var t4 = new r2.ShaderMaterial({ defines: e4.defines, vertexShader: e4.vertexShader, fragmentShader: e4.fragmentShader, uniforms: e4.uniforms, fog: true, lights: true, opacity: e4.opacity, transparent: e4.transparent });
            return t4.isGLTFSpecularGlossinessMaterial = true, t4.color = e4.color, t4.map = void 0 === e4.map ? null : e4.map, t4.lightMap = null, t4.lightMapIntensity = 1, t4.aoMap = void 0 === e4.aoMap ? null : e4.aoMap, t4.aoMapIntensity = 1, t4.emissive = e4.emissive, t4.emissiveIntensity = 1, t4.emissiveMap = void 0 === e4.emissiveMap ? null : e4.emissiveMap, t4.bumpMap = void 0 === e4.bumpMap ? null : e4.bumpMap, t4.bumpScale = 1, t4.normalMap = void 0 === e4.normalMap ? null : e4.normalMap, e4.normalScale && (t4.normalScale = e4.normalScale), t4.displacementMap = null, t4.displacementScale = 1, t4.displacementBias = 0, t4.specularMap = void 0 === e4.specularMap ? null : e4.specularMap, t4.specular = e4.specular, t4.glossinessMap = void 0 === e4.glossinessMap ? null : e4.glossinessMap, t4.glossiness = e4.glossiness, t4.alphaMap = null, t4.envMap = void 0 === e4.envMap ? null : e4.envMap, t4.envMapIntensity = 1, t4.refractionRatio = 0.98, t4.extensions.derivatives = true, t4;
          }, cloneMaterial: function(e4) {
            var t4 = e4.clone();
            t4.isGLTFSpecularGlossinessMaterial = true;
            for (var n4 = this.specularGlossinessParams, r3 = 0, i4 = n4.length; r3 < i4; r3++)
              t4[n4[r3]] = e4[n4[r3]];
            return t4;
          }, refreshUniforms: function(e4, t4, n4, r3, i4, a3) {
            if (true === i4.isGLTFSpecularGlossinessMaterial) {
              var o3, s3 = i4.uniforms, c4 = i4.defines;
              s3.opacity.value = i4.opacity, s3.diffuse.value.copy(i4.color), s3.emissive.value.copy(i4.emissive).multiplyScalar(i4.emissiveIntensity), s3.map.value = i4.map, s3.specularMap.value = i4.specularMap, s3.alphaMap.value = i4.alphaMap, s3.lightMap.value = i4.lightMap, s3.lightMapIntensity.value = i4.lightMapIntensity, s3.aoMap.value = i4.aoMap, s3.aoMapIntensity.value = i4.aoMapIntensity, i4.map ? o3 = i4.map : i4.specularMap ? o3 = i4.specularMap : i4.displacementMap ? o3 = i4.displacementMap : i4.normalMap ? o3 = i4.normalMap : i4.bumpMap ? o3 = i4.bumpMap : i4.glossinessMap ? o3 = i4.glossinessMap : i4.alphaMap ? o3 = i4.alphaMap : i4.emissiveMap && (o3 = i4.emissiveMap), void 0 !== o3 && (o3.isWebGLRenderTarget && (o3 = o3.texture), true === o3.matrixAutoUpdate && o3.updateMatrix(), s3.uvTransform.value.copy(o3.matrix)), s3.envMap.value = i4.envMap, s3.envMapIntensity.value = i4.envMapIntensity, s3.flipEnvMap.value = i4.envMap && i4.envMap.isCubeTexture ? -1 : 1, s3.refractionRatio.value = i4.refractionRatio, s3.specular.value.copy(i4.specular), s3.glossiness.value = i4.glossiness, s3.glossinessMap.value = i4.glossinessMap, s3.emissiveMap.value = i4.emissiveMap, s3.bumpMap.value = i4.bumpMap, s3.normalMap.value = i4.normalMap, s3.displacementMap.value = i4.displacementMap, s3.displacementScale.value = i4.displacementScale, s3.displacementBias.value = i4.displacementBias, null !== s3.glossinessMap.value && void 0 === c4.USE_GLOSSINESSMAP && (c4.USE_GLOSSINESSMAP = "", c4.USE_ROUGHNESSMAP = ""), null === s3.glossinessMap.value && void 0 !== c4.USE_GLOSSINESSMAP && (delete c4.USE_GLOSSINESSMAP, delete c4.USE_ROUGHNESSMAP);
            }
          } };
        }
        function h2(e4, t4, n4, i4) {
          r2.Interpolant.call(this, e4, t4, n4, i4);
        }
        u2.prototype.decodePrimitive = function(e4, t4) {
          var n4 = this.json, r3 = this.dracoLoader, i4 = e4.extensions[this.name].bufferView, a3 = e4.extensions[this.name].attributes, o3 = {}, s3 = {}, c4 = {};
          for (var u3 in a3)
            u3 in T2 && (o3[T2[u3]] = a3[u3]);
          for (u3 in e4.attributes)
            if (void 0 !== T2[u3] && void 0 !== a3[u3]) {
              var l3 = n4.accessors[e4.attributes[u3]], h3 = x2[l3.componentType];
              c4[T2[u3]] = h3, s3[T2[u3]] = true === l3.normalized;
            }
          return t4.getDependency("bufferView", i4).then(function(e5) {
            return new Promise(function(t5) {
              r3.decodeDracoFile(e5, function(e6) {
                for (var n5 in e6.attributes) {
                  var r4 = e6.attributes[n5], i5 = s3[n5];
                  void 0 !== i5 && (r4.normalized = i5);
                }
                t5(e6);
              }, o3, c4);
            });
          });
        }, h2.prototype = Object.create(r2.Interpolant.prototype), h2.prototype.constructor = h2, h2.prototype.interpolate_ = function(e4, t4, n4, r3) {
          for (var i4 = this.resultBuffer, a3 = this.sampleValues, o3 = this.valueSize, s3 = 2 * o3, c4 = 3 * o3, u3 = r3 - t4, l3 = (n4 - t4) / u3, h3 = l3 * l3, d3 = h3 * l3, p3 = e4 * c4, f3 = p3 - c4, m3 = 2 * d3 - 3 * h3 + 1, g3 = d3 - 2 * h3 + l3, v3 = -2 * d3 + 3 * h3, y3 = d3 - h3, x3 = 0; x3 !== o3; x3++) {
            var b3 = a3[f3 + x3 + o3], w3 = a3[f3 + x3 + s3] * u3, _3 = a3[p3 + x3 + o3], M3 = a3[p3 + x3] * u3;
            i4[x3] = m3 * b3 + g3 * w3 + v3 * _3 + y3 * M3;
          }
          return i4;
        };
        var d2 = 0, p2 = 1, f2 = 2, m2 = 3, g2 = 4, v2 = 5, y2 = 6, x2 = (r2.Matrix3, r2.Matrix4, r2.Vector2, r2.Vector3, r2.Vector4, r2.Texture, { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }), b2 = { 9728: r2.NearestFilter, 9729: r2.LinearFilter, 9984: r2.NearestMipMapNearestFilter, 9985: r2.LinearMipMapNearestFilter, 9986: r2.NearestMipMapLinearFilter, 9987: r2.LinearMipMapLinearFilter }, w2 = { 33071: r2.ClampToEdgeWrapping, 33648: r2.MirroredRepeatWrapping, 10497: r2.RepeatWrapping }, _2 = { 6406: r2.AlphaFormat, 6407: r2.RGBFormat, 6408: r2.RGBAFormat, 6409: r2.LuminanceFormat, 6410: r2.LuminanceAlphaFormat }, M2 = { 5121: r2.UnsignedByteType, 32819: r2.UnsignedShort4444Type, 32820: r2.UnsignedShort5551Type, 33635: r2.UnsignedShort565Type }, E2 = (r2.BackSide, r2.FrontSide, r2.NeverDepth, r2.LessDepth, r2.EqualDepth, r2.LessEqualDepth, r2.GreaterEqualDepth, r2.NotEqualDepth, r2.GreaterEqualDepth, r2.AlwaysDepth, r2.AddEquation, r2.SubtractEquation, r2.ReverseSubtractEquation, r2.ZeroFactor, r2.OneFactor, r2.SrcColorFactor, r2.OneMinusSrcColorFactor, r2.SrcAlphaFactor, r2.OneMinusSrcAlphaFactor, r2.DstAlphaFactor, r2.OneMinusDstAlphaFactor, r2.DstColorFactor, r2.OneMinusDstColorFactor, r2.SrcAlphaSaturateFactor, { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }), T2 = { POSITION: "position", NORMAL: "normal", TEXCOORD_0: "uv", TEXCOORD0: "uv", TEXCOORD: "uv", TEXCOORD_1: "uv2", COLOR_0: "color", COLOR0: "color", COLOR: "color", WEIGHTS_0: "skinWeight", WEIGHT: "skinWeight", JOINTS_0: "skinIndex", JOINT: "skinIndex" }, S2 = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, A2 = { CUBICSPLINE: r2.InterpolateSmooth, LINEAR: r2.InterpolateLinear, STEP: r2.InterpolateDiscrete }, L2 = "OPAQUE", R2 = "MASK", C2 = "BLEND";
        function P2(e4, t4) {
          return "string" != typeof e4 || "" === e4 ? "" : /^(https?:)?\/\//i.test(e4) ? e4 : /^data:.*,.*$/i.test(e4) ? e4 : /^blob:.*$/i.test(e4) ? e4 : t4 + e4;
        }
        function O2(e4, t4, n4) {
          for (var r3 in n4.extensions)
            void 0 === e4[r3] && (t4.userData.gltfExtensions = t4.userData.gltfExtensions || {}, t4.userData.gltfExtensions[r3] = n4.extensions[r3]);
        }
        function N2(e4, t4) {
          if (e4.updateMorphTargets(), void 0 !== t4.weights)
            for (var n4 = 0, r3 = t4.weights.length; n4 < r3; n4++)
              e4.morphTargetInfluences[n4] = t4.weights[n4];
          if (t4.extras && Array.isArray(t4.extras.targetNames)) {
            var i4 = t4.extras.targetNames;
            if (e4.morphTargetInfluences.length === i4.length) {
              e4.morphTargetDictionary = {};
              for (n4 = 0, r3 = i4.length; n4 < r3; n4++)
                e4.morphTargetDictionary[i4[n4]] = n4;
            } else
              console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
          }
        }
        function I2(e4, t4) {
          return e4.indices === t4.indices && D2(e4.attributes, t4.attributes);
        }
        function D2(e4, t4) {
          if (Object.keys(e4).length !== Object.keys(t4).length)
            return false;
          for (var n4 in e4)
            if (e4[n4] !== t4[n4])
              return false;
          return true;
        }
        function U2(e4, t4) {
          if (e4.length !== t4.length)
            return false;
          for (var n4 = 0, r3 = e4.length; n4 < r3; n4++)
            if (e4[n4] !== t4[n4])
              return false;
          return true;
        }
        function B2(e4, t4) {
          for (var n4 = 0, r3 = e4.length; n4 < r3; n4++) {
            var i4 = e4[n4];
            if (I2(i4.primitive, t4))
              return i4.promise;
          }
          return null;
        }
        function F2(e4) {
          if (e4.isInterleavedBufferAttribute) {
            for (var t4 = e4.count, n4 = e4.itemSize, i4 = e4.array.slice(0, t4 * n4), a3 = 0; a3 < t4; ++a3)
              i4[a3] = e4.getX(a3), n4 >= 2 && (i4[a3 + 1] = e4.getY(a3)), n4 >= 3 && (i4[a3 + 2] = e4.getZ(a3)), n4 >= 4 && (i4[a3 + 3] = e4.getW(a3));
            return new r2.BufferAttribute(i4, n4, e4.normalized);
          }
          return e4.clone();
        }
        function G2(e4, t4, n4) {
          this.json = e4 || {}, this.extensions = t4 || {}, this.options = n4 || {}, this.cache = new function() {
            var e5 = {};
            return { get: function(t5) {
              return e5[t5];
            }, add: function(t5, n5) {
              e5[t5] = n5;
            }, remove: function(t5) {
              delete e5[t5];
            }, removeAll: function() {
              e5 = {};
            } };
          }(), this.primitiveCache = [], this.multiplePrimitivesCache = [], this.multiPassGeometryCache = [], this.textureLoader = new r2.TextureLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.fileLoader = new r2.FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer");
        }
        function z2(e4, t4, n4) {
          var r3 = t4.attributes;
          for (var i4 in r3) {
            var a3 = T2[i4], o3 = n4[r3[i4]];
            a3 && (a3 in e4.attributes || e4.addAttribute(a3, o3));
          }
          void 0 === t4.indices || e4.index || e4.setIndex(n4[t4.indices]), void 0 !== t4.targets && function(e5, t5, n5) {
            for (var r4 = false, i5 = false, a4 = 0, o4 = t5.length; a4 < o4 && (void 0 !== (u3 = t5[a4]).POSITION && (r4 = true), void 0 !== u3.NORMAL && (i5 = true), !r4 || !i5); a4++)
              ;
            if (r4 || i5) {
              var s3 = [], c4 = [];
              for (a4 = 0, o4 = t5.length; a4 < o4; a4++) {
                var u3 = t5[a4], l3 = "morphTarget" + a4;
                if (r4) {
                  if (void 0 !== u3.POSITION) {
                    var h3 = F2(n5[u3.POSITION]);
                    h3.name = l3;
                    for (var d3 = e5.attributes.position, p3 = 0, f3 = h3.count; p3 < f3; p3++)
                      h3.setXYZ(p3, h3.getX(p3) + d3.getX(p3), h3.getY(p3) + d3.getY(p3), h3.getZ(p3) + d3.getZ(p3));
                  } else
                    h3 = e5.attributes.position;
                  s3.push(h3);
                }
                if (i5) {
                  if (void 0 !== u3.NORMAL) {
                    var m3;
                    (m3 = F2(n5[u3.NORMAL])).name = l3;
                    var g3 = e5.attributes.normal;
                    for (p3 = 0, f3 = m3.count; p3 < f3; p3++)
                      m3.setXYZ(p3, m3.getX(p3) + g3.getX(p3), m3.getY(p3) + g3.getY(p3), m3.getZ(p3) + g3.getZ(p3));
                  } else
                    m3 = e5.attributes.normal;
                  c4.push(m3);
                }
              }
              r4 && (e5.morphAttributes.position = s3), i5 && (e5.morphAttributes.normal = c4);
            }
          }(e4, t4.targets, n4), void 0 !== t4.extras && (e4.userData = t4.extras);
        }
        return G2.prototype.parse = function(e4, t4) {
          var n4 = this.json;
          this.cache.removeAll(), this.markDefs(), this.getMultiDependencies(["scene", "animation", "camera"]).then(function(t5) {
            var r3 = t5.scenes || [], i4 = r3[n4.scene || 0], a3 = t5.animations || [], o3 = t5.cameras || [];
            e4(i4, r3, o3, a3, n4);
          }).catch(t4);
        }, G2.prototype.markDefs = function() {
          for (var e4 = this.json.nodes || [], t4 = this.json.skins || [], n4 = this.json.meshes || [], r3 = {}, i4 = {}, a3 = 0, o3 = t4.length; a3 < o3; a3++)
            for (var s3 = t4[a3].joints, c4 = 0, u3 = s3.length; c4 < u3; c4++)
              e4[s3[c4]].isBone = true;
          for (var l3 = 0, h3 = e4.length; l3 < h3; l3++) {
            var d3 = e4[l3];
            void 0 !== d3.mesh && (void 0 === r3[d3.mesh] && (r3[d3.mesh] = i4[d3.mesh] = 0), r3[d3.mesh]++, void 0 !== d3.skin && (n4[d3.mesh].isSkinnedMesh = true));
          }
          this.json.meshReferences = r3, this.json.meshUses = i4;
        }, G2.prototype.getDependency = function(e4, t4) {
          var n4 = e4 + ":" + t4, r3 = this.cache.get(n4);
          if (!r3) {
            switch (e4) {
              case "scene":
                r3 = this.loadScene(t4);
                break;
              case "node":
                r3 = this.loadNode(t4);
                break;
              case "mesh":
                r3 = this.loadMesh(t4);
                break;
              case "accessor":
                r3 = this.loadAccessor(t4);
                break;
              case "bufferView":
                r3 = this.loadBufferView(t4);
                break;
              case "buffer":
                r3 = this.loadBuffer(t4);
                break;
              case "material":
                r3 = this.loadMaterial(t4);
                break;
              case "texture":
                r3 = this.loadTexture(t4);
                break;
              case "skin":
                r3 = this.loadSkin(t4);
                break;
              case "animation":
                r3 = this.loadAnimation(t4);
                break;
              case "camera":
                r3 = this.loadCamera(t4);
                break;
              default:
                throw new Error("Unknown type: " + e4);
            }
            this.cache.add(n4, r3);
          }
          return r3;
        }, G2.prototype.getDependencies = function(e4) {
          var t4 = this.cache.get(e4);
          if (!t4) {
            var n4 = this, r3 = this.json[e4 + ("mesh" === e4 ? "es" : "s")] || [];
            t4 = Promise.all(r3.map(function(t5, r4) {
              return n4.getDependency(e4, r4);
            })), this.cache.add(e4, t4);
          }
          return t4;
        }, G2.prototype.getMultiDependencies = function(e4) {
          for (var t4 = {}, n4 = [], r3 = 0, i4 = e4.length; r3 < i4; r3++) {
            var a3 = e4[r3], o3 = this.getDependencies(a3);
            o3 = o3.then(function(e5, n5) {
              t4[e5] = n5;
            }.bind(this, a3 + ("mesh" === a3 ? "es" : "s"))), n4.push(o3);
          }
          return Promise.all(n4).then(function() {
            return t4;
          });
        }, G2.prototype.loadBuffer = function(e4) {
          var n4 = this.json.buffers[e4], r3 = this.fileLoader;
          if (n4.type && "arraybuffer" !== n4.type)
            throw new Error("THREE.GLTFLoader: " + n4.type + " buffer type is not supported.");
          if (void 0 === n4.uri && 0 === e4)
            return Promise.resolve(this.extensions[t3.KHR_BINARY_GLTF].body);
          var i4 = this.options;
          return new Promise(function(e5, t4) {
            r3.load(P2(n4.uri, i4.path), e5, void 0, function() {
              t4(new Error('THREE.GLTFLoader: Failed to load buffer "' + n4.uri + '".'));
            });
          });
        }, G2.prototype.loadBufferView = function(e4) {
          var t4 = this.json.bufferViews[e4];
          return this.getDependency("buffer", t4.buffer).then(function(e5) {
            var n4 = t4.byteLength || 0, r3 = t4.byteOffset || 0;
            return e5.slice(r3, r3 + n4);
          });
        }, G2.prototype.loadAccessor = function(e4) {
          var t4 = this, n4 = this.json, i4 = this.json.accessors[e4];
          if (void 0 === i4.bufferView && void 0 === i4.sparse)
            return null;
          var a3 = [];
          return void 0 !== i4.bufferView ? a3.push(this.getDependency("bufferView", i4.bufferView)) : a3.push(null), void 0 !== i4.sparse && (a3.push(this.getDependency("bufferView", i4.sparse.indices.bufferView)), a3.push(this.getDependency("bufferView", i4.sparse.values.bufferView))), Promise.all(a3).then(function(e5) {
            var a4, o3, s3 = e5[0], c4 = E2[i4.type], u3 = x2[i4.componentType], l3 = u3.BYTES_PER_ELEMENT, h3 = l3 * c4, d3 = i4.byteOffset || 0, p3 = n4.bufferViews[i4.bufferView].byteStride, f3 = true === i4.normalized;
            if (p3 && p3 !== h3) {
              var m3 = "InterleavedBuffer:" + i4.bufferView + ":" + i4.componentType, g3 = t4.cache.get(m3);
              g3 || (a4 = new u3(s3), g3 = new r2.InterleavedBuffer(a4, p3 / l3), t4.cache.add(m3, g3)), o3 = new r2.InterleavedBufferAttribute(g3, c4, d3 / l3, f3);
            } else
              a4 = null === s3 ? new u3(i4.count * c4) : new u3(s3, d3, i4.count * c4), o3 = new r2.BufferAttribute(a4, c4, f3);
            if (void 0 !== i4.sparse) {
              var v3 = E2.SCALAR, y3 = x2[i4.sparse.indices.componentType], b3 = i4.sparse.indices.byteOffset || 0, w3 = i4.sparse.values.byteOffset || 0, _3 = new y3(e5[1], b3, i4.sparse.count * v3), M3 = new u3(e5[2], w3, i4.sparse.count * c4);
              null !== s3 && o3.setArray(o3.array.slice());
              for (var T3 = 0, S3 = _3.length; T3 < S3; T3++) {
                var A3 = _3[T3];
                if (o3.setX(A3, M3[T3 * c4]), c4 >= 2 && o3.setY(A3, M3[T3 * c4 + 1]), c4 >= 3 && o3.setZ(A3, M3[T3 * c4 + 2]), c4 >= 4 && o3.setW(A3, M3[T3 * c4 + 3]), c4 >= 5)
                  throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
              }
            }
            return o3;
          });
        }, G2.prototype.loadTexture = function(e4) {
          var n4, i4 = this, a3 = this.json, o3 = this.options, s3 = this.textureLoader, c4 = window.URL || window.webkitURL, u3 = a3.textures[e4], l3 = u3.extensions || {}, h3 = (n4 = l3[t3.MSFT_TEXTURE_DDS] ? a3.images[l3[t3.MSFT_TEXTURE_DDS].source] : a3.images[u3.source]).uri, d3 = false;
          return void 0 !== n4.bufferView && (h3 = i4.getDependency("bufferView", n4.bufferView).then(function(e5) {
            d3 = true;
            var t4 = new Blob([e5], { type: n4.mimeType });
            return h3 = c4.createObjectURL(t4);
          })), Promise.resolve(h3).then(function(e5) {
            var n5 = r2.Loader.Handlers.get(e5);
            return n5 || (n5 = l3[t3.MSFT_TEXTURE_DDS] ? i4.extensions[t3.MSFT_TEXTURE_DDS].ddsLoader : s3), new Promise(function(t4, r3) {
              n5.load(P2(e5, o3.path), t4, void 0, r3);
            });
          }).then(function(e5) {
            true === d3 && c4.revokeObjectURL(h3), e5.flipY = false, void 0 !== u3.name && (e5.name = u3.name), l3[t3.MSFT_TEXTURE_DDS] || (e5.format = void 0 !== u3.format ? _2[u3.format] : r2.RGBAFormat), void 0 !== u3.internalFormat && e5.format !== _2[u3.internalFormat] && console.warn("THREE.GLTFLoader: Three.js does not support texture internalFormat which is different from texture format. internalFormat will be forced to be the same value as format."), e5.type = void 0 !== u3.type ? M2[u3.type] : r2.UnsignedByteType;
            var n5 = (a3.samplers || {})[u3.sampler] || {};
            return e5.magFilter = b2[n5.magFilter] || r2.LinearFilter, e5.minFilter = b2[n5.minFilter] || r2.LinearMipMapLinearFilter, e5.wrapS = w2[n5.wrapS] || r2.RepeatWrapping, e5.wrapT = w2[n5.wrapT] || r2.RepeatWrapping, e5;
          });
        }, G2.prototype.assignTexture = function(e4, t4, n4) {
          return this.getDependency("texture", n4).then(function(n5) {
            e4[t4] = n5;
          });
        }, G2.prototype.loadMaterial = function(e4) {
          this.json;
          var n4, i4 = this.extensions, a3 = this.json.materials[e4], o3 = {}, s3 = a3.extensions || {}, c4 = [];
          if (s3[t3.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
            var u3 = i4[t3.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
            n4 = u3.getMaterialType(a3), c4.push(u3.extendParams(o3, a3, this));
          } else if (s3[t3.KHR_MATERIALS_UNLIT]) {
            var l3 = i4[t3.KHR_MATERIALS_UNLIT];
            n4 = l3.getMaterialType(a3), c4.push(l3.extendParams(o3, a3, this));
          } else {
            n4 = r2.MeshStandardMaterial;
            var h3 = a3.pbrMetallicRoughness || {};
            if (o3.color = new r2.Color(1, 1, 1), o3.opacity = 1, Array.isArray(h3.baseColorFactor)) {
              var d3 = h3.baseColorFactor;
              o3.color.fromArray(d3), o3.opacity = d3[3];
            }
            if (void 0 !== h3.baseColorTexture && c4.push(this.assignTexture(o3, "map", h3.baseColorTexture.index)), o3.metalness = void 0 !== h3.metallicFactor ? h3.metallicFactor : 1, o3.roughness = void 0 !== h3.roughnessFactor ? h3.roughnessFactor : 1, void 0 !== h3.metallicRoughnessTexture) {
              var p3 = h3.metallicRoughnessTexture.index;
              c4.push(this.assignTexture(o3, "metalnessMap", p3)), c4.push(this.assignTexture(o3, "roughnessMap", p3));
            }
          }
          true === a3.doubleSided && (o3.side = r2.DoubleSide);
          var f3 = a3.alphaMode || L2;
          return f3 === C2 ? o3.transparent = true : (o3.transparent = false, f3 === R2 && (o3.alphaTest = void 0 !== a3.alphaCutoff ? a3.alphaCutoff : 0.5)), void 0 !== a3.normalTexture && n4 !== r2.MeshBasicMaterial && (c4.push(this.assignTexture(o3, "normalMap", a3.normalTexture.index)), o3.normalScale = new r2.Vector2(1, 1), void 0 !== a3.normalTexture.scale && o3.normalScale.set(a3.normalTexture.scale, a3.normalTexture.scale)), void 0 !== a3.occlusionTexture && n4 !== r2.MeshBasicMaterial && (c4.push(this.assignTexture(o3, "aoMap", a3.occlusionTexture.index)), void 0 !== a3.occlusionTexture.strength && (o3.aoMapIntensity = a3.occlusionTexture.strength)), void 0 !== a3.emissiveFactor && n4 !== r2.MeshBasicMaterial && (o3.emissive = new r2.Color().fromArray(a3.emissiveFactor)), void 0 !== a3.emissiveTexture && n4 !== r2.MeshBasicMaterial && c4.push(this.assignTexture(o3, "emissiveMap", a3.emissiveTexture.index)), Promise.all(c4).then(function() {
            var e5;
            return e5 = n4 === r2.ShaderMaterial ? i4[t3.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(o3) : new n4(o3), void 0 !== a3.name && (e5.name = a3.name), e5.normalScale && (e5.normalScale.y = -e5.normalScale.y), e5.map && (e5.map.encoding = r2.sRGBEncoding), e5.emissiveMap && (e5.emissiveMap.encoding = r2.sRGBEncoding), e5.specularMap && (e5.specularMap.encoding = r2.sRGBEncoding), a3.extras && (e5.userData = a3.extras), a3.extensions && O2(i4, e5, a3), e5;
          });
        }, G2.prototype.loadGeometries = function(e4) {
          var n4, i4 = this, a3 = this.extensions, o3 = this.primitiveCache, s3 = function(e5) {
            if (e5.length < 2)
              return false;
            var t4 = e5[0], n5 = t4.targets || [];
            if (void 0 === t4.indices)
              return false;
            for (var r3 = 1, i5 = e5.length; r3 < i5; r3++) {
              var a4 = e5[r3];
              if (t4.mode !== a4.mode)
                return false;
              if (void 0 === a4.indices)
                return false;
              if (!D2(t4.attributes, a4.attributes))
                return false;
              var o4 = a4.targets || [];
              if (n5.length !== o4.length)
                return false;
              for (var s4 = 0, c4 = n5.length; s4 < c4; s4++)
                if (!D2(n5[s4], o4[s4]))
                  return false;
            }
            return true;
          }(e4);
          return s3 && (n4 = e4, e4 = [e4[0]]), this.getDependencies("accessor").then(function(c4) {
            for (var u3 = [], l3 = 0, h3 = e4.length; l3 < h3; l3++) {
              var d3 = e4[l3], p3 = B2(o3, d3);
              if (p3)
                u3.push(p3);
              else if (d3.extensions && d3.extensions[t3.KHR_DRACO_MESH_COMPRESSION]) {
                var f3 = a3[t3.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(d3, i4).then(function(e5) {
                  return z2(e5, d3, c4), e5;
                });
                o3.push({ primitive: d3, promise: f3 }), u3.push(f3);
              } else {
                var m3 = new r2.BufferGeometry();
                z2(m3, d3, c4);
                f3 = Promise.resolve(m3);
                o3.push({ primitive: d3, promise: f3 }), u3.push(f3);
              }
            }
            return Promise.all(u3).then(function(t4) {
              if (s3) {
                var a4 = t4[0];
                if (null !== (y3 = function(e5, t5, n5) {
                  for (var r3 = 0, i5 = e5.length; r3 < i5; r3++) {
                    var a5 = e5[r3];
                    if (t5 === a5.baseGeometry && U2(n5, a5.primitives))
                      return a5.geometry;
                  }
                  return null;
                }(v3 = i4.multiPassGeometryCache, a4, n4)))
                  return [y3.geometry];
                var o4 = new r2.BufferGeometry();
                for (var u4 in o4.name = a4.name, o4.userData = a4.userData, a4.attributes)
                  o4.addAttribute(u4, a4.attributes[u4]);
                for (var u4 in a4.morphAttributes)
                  o4.morphAttributes[u4] = a4.morphAttributes[u4];
                for (var l4 = [], h4 = 0, d4 = 0, p4 = n4.length; d4 < p4; d4++) {
                  for (var f4 = c4[n4[d4].indices], m4 = 0, g3 = f4.count; m4 < g3; m4++)
                    l4.push(f4.array[m4]);
                  o4.addGroup(h4, f4.count, d4), h4 += f4.count;
                }
                return o4.setIndex(l4), v3.push({ geometry: o4, baseGeometry: a4, primitives: n4 }), [o4];
              }
              if (t4.length > 1 && void 0 !== r2.BufferGeometryUtils) {
                for (d4 = 1, p4 = e4.length; d4 < p4; d4++)
                  if (e4[0].mode !== e4[d4].mode)
                    return t4;
                var v3, y3;
                if (y3 = function(e5, t5) {
                  for (var n5 = 0, r3 = e5.length; n5 < r3; n5++) {
                    var i5 = e5[n5];
                    if (U2(t5, i5.baseGeometries))
                      return i5.geometry;
                  }
                  return null;
                }(v3 = i4.multiplePrimitivesCache, t4)) {
                  if (null !== y3.geometry)
                    return [y3.geometry];
                } else {
                  o4 = r2.BufferGeometryUtils.mergeBufferGeometries(t4, true);
                  if (v3.push({ geometry: o4, baseGeometries: t4 }), null !== o4)
                    return [o4];
                }
              }
              return t4;
            });
          });
        }, G2.prototype.loadMesh = function(e4) {
          var n4 = this, i4 = (this.json, this.extensions), a3 = this.json.meshes[e4];
          return this.getMultiDependencies(["accessor", "material"]).then(function(o3) {
            for (var s3 = a3.primitives, c4 = [], u3 = 0, l3 = s3.length; u3 < l3; u3++)
              c4[u3] = void 0 === s3[u3].material ? new r2.MeshStandardMaterial({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: false, depthTest: true, side: r2.FrontSide }) : o3.materials[s3[u3].material];
            return n4.loadGeometries(s3).then(function(o4) {
              for (var u4 = 1 === o4.length && o4[0].groups.length > 0, l4 = [], h3 = 0, x3 = o4.length; h3 < x3; h3++) {
                var b3, w3 = o4[h3], _3 = s3[h3], M3 = u4 ? c4 : c4[h3];
                if (_3.mode === g2 || _3.mode === v2 || _3.mode === y2 || void 0 === _3.mode)
                  b3 = true === a3.isSkinnedMesh ? new r2.SkinnedMesh(w3, M3) : new r2.Mesh(w3, M3), _3.mode === v2 ? b3.drawMode = r2.TriangleStripDrawMode : _3.mode === y2 && (b3.drawMode = r2.TriangleFanDrawMode);
                else if (_3.mode === p2)
                  b3 = new r2.LineSegments(w3, M3);
                else if (_3.mode === m2)
                  b3 = new r2.Line(w3, M3);
                else if (_3.mode === f2)
                  b3 = new r2.LineLoop(w3, M3);
                else {
                  if (_3.mode !== d2)
                    throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + _3.mode);
                  b3 = new r2.Points(w3, M3);
                }
                Object.keys(b3.geometry.morphAttributes).length > 0 && N2(b3, a3), b3.name = a3.name || "mesh_" + e4, o4.length > 1 && (b3.name += "_" + h3), void 0 !== a3.extras && (b3.userData = a3.extras), l4.push(b3);
                for (var E3 = u4 ? b3.material : [b3.material], T3 = void 0 !== w3.attributes.color, S3 = void 0 === w3.attributes.normal, A3 = true === b3.isSkinnedMesh, L3 = Object.keys(w3.morphAttributes).length > 0, R3 = L3 && void 0 !== w3.morphAttributes.normal, C3 = 0, P3 = E3.length; C3 < P3; C3++) {
                  M3 = E3[C3];
                  if (b3.isPoints) {
                    var O3 = "PointsMaterial:" + M3.uuid, I3 = n4.cache.get(O3);
                    I3 || (I3 = new r2.PointsMaterial(), r2.Material.prototype.copy.call(I3, M3), I3.color.copy(M3.color), I3.map = M3.map, I3.lights = false, n4.cache.add(O3, I3)), M3 = I3;
                  } else if (b3.isLine) {
                    O3 = "LineBasicMaterial:" + M3.uuid;
                    var D3 = n4.cache.get(O3);
                    D3 || (D3 = new r2.LineBasicMaterial(), r2.Material.prototype.copy.call(D3, M3), D3.color.copy(M3.color), D3.lights = false, n4.cache.add(O3, D3)), M3 = D3;
                  }
                  if (T3 || S3 || A3 || L3) {
                    O3 = "ClonedMaterial:" + M3.uuid + ":";
                    M3.isGLTFSpecularGlossinessMaterial && (O3 += "specular-glossiness:"), A3 && (O3 += "skinning:"), T3 && (O3 += "vertex-colors:"), S3 && (O3 += "flat-shading:"), L3 && (O3 += "morph-targets:"), R3 && (O3 += "morph-normals:");
                    var U3 = n4.cache.get(O3);
                    U3 || (U3 = M3.isGLTFSpecularGlossinessMaterial ? i4[t3.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].cloneMaterial(M3) : M3.clone(), A3 && (U3.skinning = true), T3 && (U3.vertexColors = r2.VertexColors), S3 && (U3.flatShading = true), L3 && (U3.morphTargets = true), R3 && (U3.morphNormals = true), n4.cache.add(O3, U3)), M3 = U3;
                  }
                  E3[C3] = M3, M3.aoMap && void 0 === w3.attributes.uv2 && void 0 !== w3.attributes.uv && (console.log("THREE.GLTFLoader: Duplicating UVs to support aoMap."), w3.addAttribute("uv2", new r2.BufferAttribute(w3.attributes.uv.array, 2))), M3.isGLTFSpecularGlossinessMaterial && (b3.onBeforeRender = i4[t3.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].refreshUniforms);
                }
                b3.material = u4 ? E3 : E3[0];
              }
              if (1 === l4.length)
                return l4[0];
              var B3 = new r2.Group();
              for (h3 = 0, x3 = l4.length; h3 < x3; h3++)
                B3.add(l4[h3]);
              return B3;
            });
          });
        }, G2.prototype.loadCamera = function(e4) {
          var t4, n4 = this.json.cameras[e4], i4 = n4[n4.type];
          if (i4)
            return "perspective" === n4.type ? t4 = new r2.PerspectiveCamera(r2.Math.radToDeg(i4.yfov), i4.aspectRatio || 1, i4.znear || 1, i4.zfar || 2e6) : "orthographic" === n4.type && (t4 = new r2.OrthographicCamera(i4.xmag / -2, i4.xmag / 2, i4.ymag / 2, i4.ymag / -2, i4.znear, i4.zfar)), void 0 !== n4.name && (t4.name = n4.name), n4.extras && (t4.userData = n4.extras), Promise.resolve(t4);
          console.warn("THREE.GLTFLoader: Missing camera parameters.");
        }, G2.prototype.loadSkin = function(e4) {
          var t4 = this.json.skins[e4], n4 = { joints: t4.joints };
          return void 0 === t4.inverseBindMatrices ? Promise.resolve(n4) : this.getDependency("accessor", t4.inverseBindMatrices).then(function(e5) {
            return n4.inverseBindMatrices = e5, n4;
          });
        }, G2.prototype.loadAnimation = function(e4) {
          this.json;
          var t4 = this.json.animations[e4];
          return this.getMultiDependencies(["accessor", "node"]).then(function(n4) {
            for (var i4 = [], a3 = 0, o3 = t4.channels.length; a3 < o3; a3++) {
              var s3 = t4.channels[a3], c4 = t4.samplers[s3.sampler];
              if (c4) {
                var u3 = s3.target, l3 = void 0 !== u3.node ? u3.node : u3.id, d3 = void 0 !== t4.parameters ? t4.parameters[c4.input] : c4.input, p3 = void 0 !== t4.parameters ? t4.parameters[c4.output] : c4.output, f3 = n4.accessors[d3], m3 = n4.accessors[p3], g3 = n4.nodes[l3];
                if (g3) {
                  var v3;
                  switch (g3.updateMatrix(), g3.matrixAutoUpdate = true, S2[u3.path]) {
                    case S2.weights:
                      v3 = r2.NumberKeyframeTrack;
                      break;
                    case S2.rotation:
                      v3 = r2.QuaternionKeyframeTrack;
                      break;
                    case S2.position:
                    case S2.scale:
                    default:
                      v3 = r2.VectorKeyframeTrack;
                  }
                  var y3 = g3.name ? g3.name : g3.uuid, x3 = void 0 !== c4.interpolation ? A2[c4.interpolation] : r2.InterpolateLinear, b3 = [];
                  S2[u3.path] === S2.weights ? g3.traverse(function(e5) {
                    true === e5.isMesh && e5.morphTargetInfluences && b3.push(e5.name ? e5.name : e5.uuid);
                  }) : b3.push(y3);
                  for (var w3 = 0, _3 = b3.length; w3 < _3; w3++) {
                    var M3 = new v3(b3[w3] + "." + S2[u3.path], r2.AnimationUtils.arraySlice(f3.array, 0), r2.AnimationUtils.arraySlice(m3.array, 0), x3);
                    "CUBICSPLINE" === c4.interpolation && (M3.createInterpolant = function(e5) {
                      return new h2(this.times, this.values, this.getValueSize() / 3, e5);
                    }, M3.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true), i4.push(M3);
                  }
                }
              }
            }
            l3 = void 0 !== t4.name ? t4.name : "animation_" + e4;
            return new r2.AnimationClip(l3, void 0, i4);
          });
        }, G2.prototype.loadNode = function(e4) {
          this.json;
          var n4 = this.extensions, i4 = this.json.meshReferences, a3 = this.json.meshUses, o3 = this.json.nodes[e4];
          return this.getMultiDependencies(["mesh", "skin", "camera", "light"]).then(function(e5) {
            var s3;
            if (true === o3.isBone)
              s3 = new r2.Bone();
            else if (void 0 !== o3.mesh) {
              var c4 = e5.meshes[o3.mesh];
              if (s3 = c4.clone(), true === c4.isGroup)
                for (var u3 = 0, l3 = c4.children.length; u3 < l3; u3++) {
                  var h3 = c4.children[u3];
                  h3.material && true === h3.material.isGLTFSpecularGlossinessMaterial && (s3.children[u3].onBeforeRender = h3.onBeforeRender);
                }
              else
                c4.material && true === c4.material.isGLTFSpecularGlossinessMaterial && (s3.onBeforeRender = c4.onBeforeRender);
              i4[o3.mesh] > 1 && (s3.name += "_instance_" + a3[o3.mesh]++);
            } else if (void 0 !== o3.camera)
              s3 = e5.cameras[o3.camera];
            else if (o3.extensions && o3.extensions[t3.KHR_LIGHTS] && void 0 !== o3.extensions[t3.KHR_LIGHTS].light) {
              s3 = n4[t3.KHR_LIGHTS].lights[o3.extensions[t3.KHR_LIGHTS].light];
            } else
              s3 = new r2.Object3D();
            if (void 0 !== o3.name && (s3.name = r2.PropertyBinding.sanitizeNodeName(o3.name)), o3.extras && (s3.userData = o3.extras), o3.extensions && O2(n4, s3, o3), void 0 !== o3.matrix) {
              var d3 = new r2.Matrix4();
              d3.fromArray(o3.matrix), s3.applyMatrix(d3);
            } else
              void 0 !== o3.translation && s3.position.fromArray(o3.translation), void 0 !== o3.rotation && s3.quaternion.fromArray(o3.rotation), void 0 !== o3.scale && s3.scale.fromArray(o3.scale);
            return s3;
          });
        }, G2.prototype.loadScene = function() {
          function e4(t4, n4, i4, a3, o3) {
            var s3 = a3[t4], c4 = i4.nodes[t4];
            if (void 0 !== c4.skin)
              for (var u3 = true === s3.isGroup ? s3.children : [s3], l3 = 0, h3 = u3.length; l3 < h3; l3++) {
                for (var d3 = u3[l3], p3 = o3[c4.skin], f3 = [], m3 = [], g3 = 0, v3 = p3.joints.length; g3 < v3; g3++) {
                  var y3 = p3.joints[g3], x3 = a3[y3];
                  if (x3) {
                    f3.push(x3);
                    var b3 = new r2.Matrix4();
                    void 0 !== p3.inverseBindMatrices && b3.fromArray(p3.inverseBindMatrices.array, 16 * g3), m3.push(b3);
                  } else
                    console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', y3);
                }
                d3.bind(new r2.Skeleton(f3, m3), d3.matrixWorld);
              }
            if (n4.add(s3), c4.children) {
              var w3 = c4.children;
              for (l3 = 0, h3 = w3.length; l3 < h3; l3++) {
                e4(w3[l3], s3, i4, a3, o3);
              }
            }
          }
          return function(n4) {
            var i4 = this.json, a3 = this.extensions, o3 = this.json.scenes[n4];
            return this.getMultiDependencies(["node", "skin"]).then(function(n5) {
              var s3 = new r2.Scene();
              void 0 !== o3.name && (s3.name = o3.name), o3.extras && (s3.userData = o3.extras), o3.extensions && O2(a3, s3, o3);
              for (var c4 = o3.nodes || [], u3 = 0, l3 = c4.length; u3 < l3; u3++)
                e4(c4[u3], s3, i4, n5.nodes, n5.skins);
              if (o3.extensions && o3.extensions[t3.KHR_LIGHTS] && void 0 !== o3.extensions[t3.KHR_LIGHTS].light) {
                var h3 = a3[t3.KHR_LIGHTS].lights;
                s3.add(h3[o3.extensions[t3.KHR_LIGHTS].light]);
              }
              return s3;
            });
          };
        }(), e3;
      }();
      var i2 = r2.MTLLoader, a = r2.OBJLoader, o = r2.OrbitControls, s = r2.ColladaLoader, c2 = r2.GLTFLoader;
      t2.OrbitControls = o, t2.MTLLoader = i2, t2.OBJLoader = a, t2.ColladaLoader = s, t2.GLTFLoader = c2;
    }, function(e2, t2, n2) {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, n3) {
        var r2 = { animate: true, name: "" };
        var i2 = [Object.assign(Object.create(r2), { fuc: e3, name: n3 })];
        !function e4() {
          requestAnimationFrame(e4), i2.forEach(function(e5) {
            var t3 = e5.fuc, n4 = e5.animate;
            n4 && t3.call(e5, Date.now());
          });
        }();
        t2.default = function(e4, t3) {
          var n4 = Object.assign(Object.create(r2), { fuc: e4, name: t3 });
          return i2.push(n4), n4;
        };
        return i2[0];
      };
    }, function(e2, t2, n2) {
      var r2, i2, a, o, s = function() {
        function e3(e4, t3) {
          for (var n3 = 0; n3 < t3.length; n3++) {
            var r3 = t3[n3];
            r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(e4, r3.key, r3);
          }
        }
        return function(t3, n3, r3) {
          return n3 && e3(t3.prototype, n3), r3 && e3(t3, r3), t3;
        };
      }(), c2 = n2(5), u2 = function(e3) {
        return e3 && e3.__esModule ? e3 : { default: e3 };
      }(c2), l2 = function(e3) {
        if (e3 && e3.__esModule)
          return e3;
        var t3 = {};
        if (null != e3)
          for (var n3 in e3)
            Object.prototype.hasOwnProperty.call(e3, n3) && (t3[n3] = e3[n3]);
        return t3.default = e3, t3;
      }(n2(0));
      function h2(e3, t3) {
        if (!(e3 instanceof t3))
          throw new TypeError("Cannot call a class as a function");
      }
      function d2(e3, t3) {
        if (!e3)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t3 || "object" != typeof t3 && "function" != typeof t3 ? e3 : t3;
      }
      function p2(e3, t3) {
        if ("function" != typeof t3 && null !== t3)
          throw new TypeError("Super expression must either be null or a function, not " + typeof t3);
        e3.prototype = Object.create(t3 && t3.prototype, { constructor: { value: e3, enumerable: false, writable: true, configurable: true } }), t3 && (Object.setPrototypeOf ? Object.setPrototypeOf(e3, t3) : e3.__proto__ = t3);
      }
      var f2 = (i2 = r2 = function(e3) {
        function t3() {
          return h2(this, t3), d2(this, (t3.__proto__ || Object.getPrototypeOf(t3)).apply(this, arguments));
        }
        return p2(t3, c2.Component), s(t3, [{ key: "render", value: function() {
          return u2.default.createElement(u2.default.Fragment, null, " ");
        } }]), t3;
      }(), r2.defaultProps = { color: "rgb(30,30,30)", __constructor: "ambientlight" }, i2), m2 = (o = a = function(e3) {
        function t3() {
          return h2(this, t3), d2(this, (t3.__proto__ || Object.getPrototypeOf(t3)).apply(this, arguments));
        }
        return p2(t3, c2.Component), s(t3, [{ key: "render", value: function() {
          return u2.default.createElement(u2.default.Fragment, null, " ");
        } }]), t3;
      }(), a.defaultProps = { color: 16777215, __constructor: "directionligth", position: new l2.Vector3(-30, 30, 30), castShadow: true }, o);
      e2.exports = { AmbientLight: f2, DirectionLight: m2 };
    }, function(e2, t2, n2) {
      e2.exports = n2(12);
    }, function(e2, t2, n2) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var r2, i2, a = function() {
        function e3(e4, t3) {
          for (var n3 = 0; n3 < t3.length; n3++) {
            var r3 = t3[n3];
            r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(e4, r3.key, r3);
          }
        }
        return function(t3, n3, r3) {
          return n3 && e3(t3.prototype, n3), r3 && e3(t3, r3), t3;
        };
      }(), o = function(e3) {
        if (e3 && e3.__esModule)
          return e3;
        var t3 = {};
        if (null != e3)
          for (var n3 in e3)
            Object.prototype.hasOwnProperty.call(e3, n3) && (t3[n3] = e3[n3]);
        return t3.default = e3, t3;
      }(n2(0)), s = (n2(2), function(e3) {
        return e3 && e3.__esModule ? e3 : { default: e3 };
      }(n2(1)));
      var c2 = (i2 = r2 = function(e3) {
        function t3(e4) {
          return function(e5, t4) {
            if (!(e5 instanceof t4))
              throw new TypeError("Cannot call a class as a function");
          }(this, t3), function(e5, t4) {
            if (!e5)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t4 || "object" != typeof t4 && "function" != typeof t4 ? e5 : t4;
          }(this, (t3.__proto__ || Object.getPrototypeOf(t3)).call(this, e4));
        }
        return function(e4, t4) {
          if ("function" != typeof t4 && null !== t4)
            throw new TypeError("Super expression must either be null or a function, not " + typeof t4);
          e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, enumerable: false, writable: true, configurable: true } }), t4 && (Object.setPrototypeOf ? Object.setPrototypeOf(e4, t4) : e4.__proto__ = t4);
        }(t3, s.default), a(t3, [{ key: "load3dModel", value: function() {
          var e4 = this, t4 = this.props, n3 = t4.src;
          t4.texPath;
          if (!n3)
            return false;
          new o.GLTFLoader().load(n3, function(t5) {
            e4.obj3d = t5.scene;
            var n4 = {};
            if (t5.scene.traverse(function(e5) {
              e5 instanceof o.Camera && (n4.cameras || (n4.cameras = []), n4.cameras.push(e5)), e5 instanceof o.Light && (n4.lights || (n4.lights = []), n4.lights.push(e5));
            }), n4.cameras && n4.cameras.length)
              e4.camera = n4.cameras[0], e4.camera.position.copy(e4.camera.position.clone().add(new o.Vector3(0, 0, 0.01)));
            else {
              var r3 = e4.computeBoundingBox(t5.scene), i3 = r3.max, a2 = r3.max.z - r3.min.z;
              e4.camera.position.set(i3.x, i3.y, i3.z + 0.6 * a2);
            }
            n4.lights && n4.lights.length, e4.initControl(), e4.props.onLoad && e4.props.onLoad();
          }, function(t5) {
            e4.props.onProgress && e4.props.onProgress(t5);
          }, function() {
            console.log("An error happened");
          });
        } }]), t3;
      }(), r2.defaultProps = Object.assign({}, s.default.defaultProps, { loader: "gltf" }), i2);
      t2.default = c2;
    }, function(e2, t2, n2) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var r2, i2, a = function() {
        function e3(e4, t3) {
          for (var n3 = 0; n3 < t3.length; n3++) {
            var r3 = t3[n3];
            r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(e4, r3.key, r3);
          }
        }
        return function(t3, n3, r3) {
          return n3 && e3(t3.prototype, n3), r3 && e3(t3, r3), t3;
        };
      }(), o = function(e3) {
        if (e3 && e3.__esModule)
          return e3;
        var t3 = {};
        if (null != e3)
          for (var n3 in e3)
            Object.prototype.hasOwnProperty.call(e3, n3) && (t3[n3] = e3[n3]);
        return t3.default = e3, t3;
      }(n2(0)), s = (n2(2), function(e3) {
        return e3 && e3.__esModule ? e3 : { default: e3 };
      }(n2(1)));
      var c2 = (i2 = r2 = function(e3) {
        function t3(e4) {
          return function(e5, t4) {
            if (!(e5 instanceof t4))
              throw new TypeError("Cannot call a class as a function");
          }(this, t3), function(e5, t4) {
            if (!e5)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t4 || "object" != typeof t4 && "function" != typeof t4 ? e5 : t4;
          }(this, (t3.__proto__ || Object.getPrototypeOf(t3)).call(this, e4));
        }
        return function(e4, t4) {
          if ("function" != typeof t4 && null !== t4)
            throw new TypeError("Super expression must either be null or a function, not " + typeof t4);
          e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, enumerable: false, writable: true, configurable: true } }), t4 && (Object.setPrototypeOf ? Object.setPrototypeOf(e4, t4) : e4.__proto__ = t4);
        }(t3, s.default), a(t3, [{ key: "load3dModel", value: function() {
          var e4 = this, t4 = this.props, n3 = t4.src;
          t4.texPath;
          if (!n3)
            return false;
          new o.ColladaLoader().load(n3, function(t5) {
            e4.obj3d = t5.scene;
            var n4 = {};
            if (t5.scene.traverse(function(e5) {
              e5 instanceof o.Camera && (n4.cameras || (n4.cameras = []), n4.cameras.push(e5)), e5 instanceof o.Light && (n4.lights || (n4.lights = []), n4.lights.push(e5));
            }), n4.cameras && n4.cameras.length)
              e4.camera = n4.cameras[0], e4.camera.position.copy(e4.camera.position.clone().add(new o.Vector3(0, 0, 0.01)));
            else {
              var r3 = e4.computeBoundingBox(t5.scene), i3 = r3.max;
              r3.max.z, r3.min.z;
              e4.camera.position.set(i3.x, i3.y, i3.z);
            }
            n4.lights && n4.lights.length, e4.initControl(), e4.props.onLoad && e4.props.onLoad();
          }, function(t5) {
            e4.props.onProgress && e4.props.onProgress(t5);
          }, function() {
            console.log("An error happened");
          });
        } }]), t3;
      }(), r2.defaultProps = Object.assign({}, s.default.defaultProps, { loader: "collada" }), i2);
      t2.default = c2;
    }, function(e2, t2, n2) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var r2, i2, a = function() {
        function e3(e4, t3) {
          for (var n3 = 0; n3 < t3.length; n3++) {
            var r3 = t3[n3];
            r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(e4, r3.key, r3);
          }
        }
        return function(t3, n3, r3) {
          return n3 && e3(t3.prototype, n3), r3 && e3(t3, r3), t3;
        };
      }(), o = function(e3) {
        if (e3 && e3.__esModule)
          return e3;
        var t3 = {};
        if (null != e3)
          for (var n3 in e3)
            Object.prototype.hasOwnProperty.call(e3, n3) && (t3[n3] = e3[n3]);
        return t3.default = e3, t3;
      }(n2(0)), s = (n2(2), function(e3) {
        return e3 && e3.__esModule ? e3 : { default: e3 };
      }(n2(1)));
      var c2 = (i2 = r2 = function(e3) {
        function t3(e4) {
          return function(e5, t4) {
            if (!(e5 instanceof t4))
              throw new TypeError("Cannot call a class as a function");
          }(this, t3), function(e5, t4) {
            if (!e5)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t4 || "object" != typeof t4 && "function" != typeof t4 ? e5 : t4;
          }(this, (t3.__proto__ || Object.getPrototypeOf(t3)).call(this, e4));
        }
        return function(e4, t4) {
          if ("function" != typeof t4 && null !== t4)
            throw new TypeError("Super expression must either be null or a function, not " + typeof t4);
          e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, enumerable: false, writable: true, configurable: true } }), t4 && (Object.setPrototypeOf ? Object.setPrototypeOf(e4, t4) : e4.__proto__ = t4);
        }(t3, s.default), a(t3, [{ key: "load3dModel", value: function() {
          var e4 = this, t4 = this.props, n3 = t4.src, r3 = t4.mtl, i3 = t4.texPath;
          if (!n3 || !r3)
            return false;
          var a2 = new o.MTLLoader(), s2 = new o.OBJLoader();
          a2.setTexturePath(i3), a2.load(r3, function(t5) {
            t5.preload(), s2.setMaterials(t5).load(n3, function(t6) {
              var n4 = e4.computeBoundingBox(t6), r4 = n4.max, i4 = n4.max.z - n4.min.z;
              e4.camera.position.set(0, 0, r4.z + 1.5 * i4), e4.initControl(), e4.obj3d = t6, e4.props.onLoad && e4.props.onLoad();
            }, function(t6) {
              e4.props.onProgress && e4.props.onProgress(t6);
            });
          });
        } }]), t3;
      }(), r2.defaultProps = Object.assign({}, s.default.defaultProps, { loader: "objmtl" }), i2);
      t2.default = c2;
    }, function(e2, t2, n2) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var r2, i2, a = function() {
        function e3(e4, t3) {
          for (var n3 = 0; n3 < t3.length; n3++) {
            var r3 = t3[n3];
            r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(e4, r3.key, r3);
          }
        }
        return function(t3, n3, r3) {
          return n3 && e3(t3.prototype, n3), r3 && e3(t3, r3), t3;
        };
      }(), o = function(e3) {
        if (e3 && e3.__esModule)
          return e3;
        var t3 = {};
        if (null != e3)
          for (var n3 in e3)
            Object.prototype.hasOwnProperty.call(e3, n3) && (t3[n3] = e3[n3]);
        return t3.default = e3, t3;
      }(n2(0)), s = (n2(2), function(e3) {
        return e3 && e3.__esModule ? e3 : { default: e3 };
      }(n2(1)));
      var c2 = (i2 = r2 = function(e3) {
        function t3(e4) {
          return function(e5, t4) {
            if (!(e5 instanceof t4))
              throw new TypeError("Cannot call a class as a function");
          }(this, t3), function(e5, t4) {
            if (!e5)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t4 || "object" != typeof t4 && "function" != typeof t4 ? e5 : t4;
          }(this, (t3.__proto__ || Object.getPrototypeOf(t3)).call(this, e4));
        }
        return function(e4, t4) {
          if ("function" != typeof t4 && null !== t4)
            throw new TypeError("Super expression must either be null or a function, not " + typeof t4);
          e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, enumerable: false, writable: true, configurable: true } }), t4 && (Object.setPrototypeOf ? Object.setPrototypeOf(e4, t4) : e4.__proto__ = t4);
        }(t3, s.default), a(t3, [{ key: "load3dModel", value: function() {
          var e4 = this, t4 = this.props, n3 = t4.src;
          t4.texPath;
          if (!n3)
            return false;
          new o.OBJLoader().load(n3, function(t5) {
            var n4 = e4.computeBoundingBox(t5), r3 = n4.max, i3 = n4.max.z - n4.min.z;
            e4.camera.position.set(0, 0, r3.z + 1.5 * i3), e4.initControl(), e4.obj3d = t5, e4.props.onLoad && e4.props.onLoad();
          }, function(t5) {
            e4.props.onProgress && e4.props.onProgress(t5);
          });
        } }]), t3;
      }(), r2.defaultProps = Object.assign({}, s.default.defaultProps, { loader: "obj" }), i2);
      t2.default = c2;
    }, function(e2, t2, n2) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var r2, i2, a = function() {
        function e3(e4, t3) {
          for (var n3 = 0; n3 < t3.length; n3++) {
            var r3 = t3[n3];
            r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(e4, r3.key, r3);
          }
        }
        return function(t3, n3, r3) {
          return n3 && e3(t3.prototype, n3), r3 && e3(t3, r3), t3;
        };
      }(), o = function(e3) {
        if (e3 && e3.__esModule)
          return e3;
        var t3 = {};
        if (null != e3)
          for (var n3 in e3)
            Object.prototype.hasOwnProperty.call(e3, n3) && (t3[n3] = e3[n3]);
        return t3.default = e3, t3;
      }(n2(0)), s = (n2(2), function(e3) {
        return e3 && e3.__esModule ? e3 : { default: e3 };
      }(n2(1)));
      var c2 = (i2 = r2 = function(e3) {
        function t3(e4) {
          return function(e5, t4) {
            if (!(e5 instanceof t4))
              throw new TypeError("Cannot call a class as a function");
          }(this, t3), function(e5, t4) {
            if (!e5)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t4 || "object" != typeof t4 && "function" != typeof t4 ? e5 : t4;
          }(this, (t3.__proto__ || Object.getPrototypeOf(t3)).call(this, e4));
        }
        return function(e4, t4) {
          if ("function" != typeof t4 && null !== t4)
            throw new TypeError("Super expression must either be null or a function, not " + typeof t4);
          e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, enumerable: false, writable: true, configurable: true } }), t4 && (Object.setPrototypeOf ? Object.setPrototypeOf(e4, t4) : e4.__proto__ = t4);
        }(t3, s.default), a(t3, [{ key: "load3dModel", value: function() {
          var e4 = this, t4 = this.props, n3 = t4.src, r3 = t4.onProgress, i3 = t4.onLoad, a2 = t4.texPath, s2 = new o.JSONLoader();
          s2.setTexturePath(a2), s2.load(n3, function(t5, n4) {
            var r4 = new o.Mesh(t5, n4);
            t5.computeBoundingBox();
            var a3 = t5.boundingSphere, s3 = a3.center, c3 = a3.radius, u2 = s3.clone().multiplyScalar(-1);
            r4.geometry.applyMatrix(new o.Matrix4().makeTranslation(u2.x, u2.y, u2.z));
            var l2 = e4.computeBoundingBox(r4).max;
            e4.camera.position.set(l2.x, l2.y, l2.z), e4.camera.position.copy(u2.clone().add(new o.Vector3(0, 0, 1.666 * c3))), e4.initControl(), e4.obj3d = r4, i3 && i3();
          }, function(e5) {
            r3 && r3(e5);
          });
        } }]), t3;
      }(), r2.defaultProps = Object.assign({}, s.default.defaultProps, { loader: "json" }), i2);
      t2.default = c2;
    }, function(e2, t2, n2) {
      /*
      object-assign
      (c) Sindre Sorhus
      @license MIT
      */
      var r2 = Object.getOwnPropertySymbols, i2 = Object.prototype.hasOwnProperty, a = Object.prototype.propertyIsEnumerable;
      e2.exports = function() {
        try {
          if (!Object.assign)
            return false;
          var e3 = new String("abc");
          if (e3[5] = "de", "5" === Object.getOwnPropertyNames(e3)[0])
            return false;
          for (var t3 = {}, n3 = 0; n3 < 10; n3++)
            t3["_" + String.fromCharCode(n3)] = n3;
          if ("0123456789" !== Object.getOwnPropertyNames(t3).map(function(e4) {
            return t3[e4];
          }).join(""))
            return false;
          var r3 = {};
          return "abcdefghijklmnopqrst".split("").forEach(function(e4) {
            r3[e4] = e4;
          }), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, r3)).join("");
        } catch (e4) {
          return false;
        }
      }() ? Object.assign : function(e3, t3) {
        for (var n3, o, s = function(e4) {
          if (null === e4 || void 0 === e4)
            throw new TypeError("Object.assign cannot be called with null or undefined");
          return Object(e4);
        }(e3), c2 = 1; c2 < arguments.length; c2++) {
          for (var u2 in n3 = Object(arguments[c2]))
            i2.call(n3, u2) && (s[u2] = n3[u2]);
          if (r2) {
            o = r2(n3);
            for (var l2 = 0; l2 < o.length; l2++)
              a.call(n3, o[l2]) && (s[o[l2]] = n3[o[l2]]);
          }
        }
        return s;
      };
    }, function(e2, t2, n2) {
      /** @license React v16.7.0
      * react.production.min.js
      *
      * Copyright (c) Facebook, Inc. and its affiliates.
      *
      * This source code is licensed under the MIT license found in the
      * LICENSE file in the root directory of this source tree.
      */
      var r2 = n2(11), i2 = "function" == typeof Symbol && Symbol.for, a = i2 ? Symbol.for("react.element") : 60103, o = i2 ? Symbol.for("react.portal") : 60106, s = i2 ? Symbol.for("react.fragment") : 60107, c2 = i2 ? Symbol.for("react.strict_mode") : 60108, u2 = i2 ? Symbol.for("react.profiler") : 60114, l2 = i2 ? Symbol.for("react.provider") : 60109, h2 = i2 ? Symbol.for("react.context") : 60110, d2 = i2 ? Symbol.for("react.concurrent_mode") : 60111, p2 = i2 ? Symbol.for("react.forward_ref") : 60112, f2 = i2 ? Symbol.for("react.suspense") : 60113, m2 = i2 ? Symbol.for("react.memo") : 60115, g2 = i2 ? Symbol.for("react.lazy") : 60116, v2 = "function" == typeof Symbol && Symbol.iterator;
      function y2(e3) {
        for (var t3 = arguments.length - 1, n3 = "https://reactjs.org/docs/error-decoder.html?invariant=" + e3, r3 = 0; r3 < t3; r3++)
          n3 += "&args[]=" + encodeURIComponent(arguments[r3 + 1]);
        !function(e4, t4, n4, r4, i3, a2, o2, s2) {
          if (!e4) {
            if (e4 = void 0, void 0 === t4)
              e4 = Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
            else {
              var c3 = [n4, r4, i3, a2, o2, s2], u3 = 0;
              (e4 = Error(t4.replace(/%s/g, function() {
                return c3[u3++];
              }))).name = "Invariant Violation";
            }
            throw e4.framesToPop = 1, e4;
          }
        }(false, "Minified React error #" + e3 + "; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ", n3);
      }
      var x2 = { isMounted: function() {
        return false;
      }, enqueueForceUpdate: function() {
      }, enqueueReplaceState: function() {
      }, enqueueSetState: function() {
      } }, b2 = {};
      function w2(e3, t3, n3) {
        this.props = e3, this.context = t3, this.refs = b2, this.updater = n3 || x2;
      }
      function _2() {
      }
      function M2(e3, t3, n3) {
        this.props = e3, this.context = t3, this.refs = b2, this.updater = n3 || x2;
      }
      w2.prototype.isReactComponent = {}, w2.prototype.setState = function(e3, t3) {
        "object" != typeof e3 && "function" != typeof e3 && null != e3 && y2("85"), this.updater.enqueueSetState(this, e3, t3, "setState");
      }, w2.prototype.forceUpdate = function(e3) {
        this.updater.enqueueForceUpdate(this, e3, "forceUpdate");
      }, _2.prototype = w2.prototype;
      var E2 = M2.prototype = new _2();
      E2.constructor = M2, r2(E2, w2.prototype), E2.isPureReactComponent = true;
      var T2 = { current: null, currentDispatcher: null }, S2 = Object.prototype.hasOwnProperty, A2 = { key: true, ref: true, __self: true, __source: true };
      function L2(e3, t3, n3) {
        var r3 = void 0, i3 = {}, o2 = null, s2 = null;
        if (null != t3)
          for (r3 in void 0 !== t3.ref && (s2 = t3.ref), void 0 !== t3.key && (o2 = "" + t3.key), t3)
            S2.call(t3, r3) && !A2.hasOwnProperty(r3) && (i3[r3] = t3[r3]);
        var c3 = arguments.length - 2;
        if (1 === c3)
          i3.children = n3;
        else if (1 < c3) {
          for (var u3 = Array(c3), l3 = 0; l3 < c3; l3++)
            u3[l3] = arguments[l3 + 2];
          i3.children = u3;
        }
        if (e3 && e3.defaultProps)
          for (r3 in c3 = e3.defaultProps)
            void 0 === i3[r3] && (i3[r3] = c3[r3]);
        return { $$typeof: a, type: e3, key: o2, ref: s2, props: i3, _owner: T2.current };
      }
      function R2(e3) {
        return "object" == typeof e3 && null !== e3 && e3.$$typeof === a;
      }
      var C2 = /\/+/g, P2 = [];
      function O2(e3, t3, n3, r3) {
        if (P2.length) {
          var i3 = P2.pop();
          return i3.result = e3, i3.keyPrefix = t3, i3.func = n3, i3.context = r3, i3.count = 0, i3;
        }
        return { result: e3, keyPrefix: t3, func: n3, context: r3, count: 0 };
      }
      function N2(e3) {
        e3.result = null, e3.keyPrefix = null, e3.func = null, e3.context = null, e3.count = 0, 10 > P2.length && P2.push(e3);
      }
      function I2(e3, t3, n3) {
        return null == e3 ? 0 : function e4(t4, n4, r3, i3) {
          var s2 = typeof t4;
          "undefined" !== s2 && "boolean" !== s2 || (t4 = null);
          var c3 = false;
          if (null === t4)
            c3 = true;
          else
            switch (s2) {
              case "string":
              case "number":
                c3 = true;
                break;
              case "object":
                switch (t4.$$typeof) {
                  case a:
                  case o:
                    c3 = true;
                }
            }
          if (c3)
            return r3(i3, t4, "" === n4 ? "." + D2(t4, 0) : n4), 1;
          if (c3 = 0, n4 = "" === n4 ? "." : n4 + ":", Array.isArray(t4))
            for (var u3 = 0; u3 < t4.length; u3++) {
              var l3 = n4 + D2(s2 = t4[u3], u3);
              c3 += e4(s2, l3, r3, i3);
            }
          else if (l3 = null === t4 || "object" != typeof t4 ? null : "function" == typeof (l3 = v2 && t4[v2] || t4["@@iterator"]) ? l3 : null, "function" == typeof l3)
            for (t4 = l3.call(t4), u3 = 0; !(s2 = t4.next()).done; )
              c3 += e4(s2 = s2.value, l3 = n4 + D2(s2, u3++), r3, i3);
          else
            "object" === s2 && y2("31", "[object Object]" == (r3 = "" + t4) ? "object with keys {" + Object.keys(t4).join(", ") + "}" : r3, "");
          return c3;
        }(e3, "", t3, n3);
      }
      function D2(e3, t3) {
        return "object" == typeof e3 && null !== e3 && null != e3.key ? function(e4) {
          var t4 = { "=": "=0", ":": "=2" };
          return "$" + ("" + e4).replace(/[=:]/g, function(e5) {
            return t4[e5];
          });
        }(e3.key) : t3.toString(36);
      }
      function U2(e3, t3) {
        e3.func.call(e3.context, t3, e3.count++);
      }
      function B2(e3, t3, n3) {
        var r3 = e3.result, i3 = e3.keyPrefix;
        e3 = e3.func.call(e3.context, t3, e3.count++), Array.isArray(e3) ? F2(e3, r3, n3, function(e4) {
          return e4;
        }) : null != e3 && (R2(e3) && (e3 = function(e4, t4) {
          return { $$typeof: a, type: e4.type, key: t4, ref: e4.ref, props: e4.props, _owner: e4._owner };
        }(e3, i3 + (!e3.key || t3 && t3.key === e3.key ? "" : ("" + e3.key).replace(C2, "$&/") + "/") + n3)), r3.push(e3));
      }
      function F2(e3, t3, n3, r3, i3) {
        var a2 = "";
        null != n3 && (a2 = ("" + n3).replace(C2, "$&/") + "/"), I2(e3, B2, t3 = O2(t3, a2, r3, i3)), N2(t3);
      }
      var G2 = { Children: { map: function(e3, t3, n3) {
        if (null == e3)
          return e3;
        var r3 = [];
        return F2(e3, r3, null, t3, n3), r3;
      }, forEach: function(e3, t3, n3) {
        if (null == e3)
          return e3;
        I2(e3, U2, t3 = O2(null, null, t3, n3)), N2(t3);
      }, count: function(e3) {
        return I2(e3, function() {
          return null;
        }, null);
      }, toArray: function(e3) {
        var t3 = [];
        return F2(e3, t3, null, function(e4) {
          return e4;
        }), t3;
      }, only: function(e3) {
        return R2(e3) || y2("143"), e3;
      } }, createRef: function() {
        return { current: null };
      }, Component: w2, PureComponent: M2, createContext: function(e3, t3) {
        return void 0 === t3 && (t3 = null), (e3 = { $$typeof: h2, _calculateChangedBits: t3, _currentValue: e3, _currentValue2: e3, _threadCount: 0, Provider: null, Consumer: null }).Provider = { $$typeof: l2, _context: e3 }, e3.Consumer = e3;
      }, forwardRef: function(e3) {
        return { $$typeof: p2, render: e3 };
      }, lazy: function(e3) {
        return { $$typeof: g2, _ctor: e3, _status: -1, _result: null };
      }, memo: function(e3, t3) {
        return { $$typeof: m2, type: e3, compare: void 0 === t3 ? null : t3 };
      }, Fragment: s, StrictMode: c2, Suspense: f2, createElement: L2, cloneElement: function(e3, t3, n3) {
        (null === e3 || void 0 === e3) && y2("267", e3);
        var i3 = void 0, o2 = r2({}, e3.props), s2 = e3.key, c3 = e3.ref, u3 = e3._owner;
        if (null != t3) {
          void 0 !== t3.ref && (c3 = t3.ref, u3 = T2.current), void 0 !== t3.key && (s2 = "" + t3.key);
          var l3 = void 0;
          for (i3 in e3.type && e3.type.defaultProps && (l3 = e3.type.defaultProps), t3)
            S2.call(t3, i3) && !A2.hasOwnProperty(i3) && (o2[i3] = void 0 === t3[i3] && void 0 !== l3 ? l3[i3] : t3[i3]);
        }
        if (1 === (i3 = arguments.length - 2))
          o2.children = n3;
        else if (1 < i3) {
          l3 = Array(i3);
          for (var h3 = 0; h3 < i3; h3++)
            l3[h3] = arguments[h3 + 2];
          o2.children = l3;
        }
        return { $$typeof: a, type: e3.type, key: s2, ref: c3, props: o2, _owner: u3 };
      }, createFactory: function(e3) {
        var t3 = L2.bind(null, e3);
        return t3.type = e3, t3;
      }, isValidElement: R2, version: "16.7.0", unstable_ConcurrentMode: d2, unstable_Profiler: u2, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: { ReactCurrentOwner: T2, assign: r2 } }, z2 = { default: G2 }, H2 = z2 && G2 || z2;
      e2.exports = H2.default || H2;
    }, function(e2, t2, n2) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var r2 = n2(1);
      Object.defineProperty(t2, "Model", { enumerable: true, get: function() {
        return h2(r2).default;
      } });
      var i2 = n2(10);
      Object.defineProperty(t2, "JSONModel", { enumerable: true, get: function() {
        return h2(i2).default;
      } });
      var a = n2(9);
      Object.defineProperty(t2, "OBJModel", { enumerable: true, get: function() {
        return h2(a).default;
      } });
      var o = n2(8);
      Object.defineProperty(t2, "MTLModel", { enumerable: true, get: function() {
        return h2(o).default;
      } });
      var s = n2(7);
      Object.defineProperty(t2, "DAEModel", { enumerable: true, get: function() {
        return h2(s).default;
      } });
      var c2 = n2(6);
      Object.defineProperty(t2, "GLTFModel", { enumerable: true, get: function() {
        return h2(c2).default;
      } });
      var u2 = n2(3);
      Object.defineProperty(t2, "Tick", { enumerable: true, get: function() {
        return h2(u2).default;
      } });
      var l2 = n2(4);
      function h2(e3) {
        return e3 && e3.__esModule ? e3 : { default: e3 };
      }
      Object.defineProperty(t2, "DirectionLight", { enumerable: true, get: function() {
        return l2.DirectionLight;
      } }), Object.defineProperty(t2, "AmbientLight", { enumerable: true, get: function() {
        return l2.AmbientLight;
      } });
    }]);
  });
})(react3dViewer);
const StyledBagItem = styled$1.div`
  ${(props) => {
  const {
    isDragging
  } = props;
  return css`
      width: 6em;
      height: 6em;
      border: 0 !important;
      opacity: ${isDragging ? 0 : 1};
      cursor: grab;
      img,
      video {
        max-width: 100%;
      }
    `;
}}
`;
StyledBagItem.displayName = "StyledBagItem";
const PresentationalBagItem = ({
  drag,
  isDragging,
  item
}) => {
  const {
    setSelItem
  } = useStore();
  const modelRef = React.useRef(null);
  const handleClick = (event) => {
    switch (event.detail) {
      case 1:
        console.log("handling click");
        if (window && window.openInWebaverse) {
          console.log("webaverse click!");
          window.openInWebaverse(item);
          setSelItem(item);
        } else {
          console.log("single click for item select");
          setSelItem(item);
        }
        break;
      case 2:
        console.log("handling double click");
        break;
      case 3:
        console.log("handling triple click");
        break;
      default:
        console.log("handling default click");
        break;
    }
  };
  React.useEffect(() => {
    const interval = setInterval(() => {
      const refContainer = modelRef && modelRef.current && modelRef.current.$container;
      if (refContainer && refContainer.children && refContainer.children.length > 1) {
        refContainer.removeChild(refContainer.firstChild);
      }
    }, 1);
    return () => {
      clearInterval(interval);
    };
  }, []);
  return item && /* @__PURE__ */ jsxs(StyledBagItem, {
    className: "flex items-center justify-center class_model",
    ref: drag,
    isDragging,
    onClick: handleClick,
    children: [(isImage(item && item.url) || !isImage(item && item.url) && !isMedia(item && item.url) && !isModel(item && item.url)) && /* @__PURE__ */ jsx("span", {
      onClick: handleClick,
      children: /* @__PURE__ */ jsx("img", {
        crossOrigin: "anonymous",
        referrerPolicy: "no-referer-on-downgrade",
        className: "w-full h-full",
        src: item.url,
        onClick: handleClick
      })
    }), isMedia(item && item.url) && /* @__PURE__ */ jsx("span", {
      onClick: handleClick,
      children: /* @__PURE__ */ jsx("video", {
        crossOrigin: "anonymous",
        referrerPolicy: "no-referer-on-downgrade",
        className: "w-full h-full",
        src: item.url,
        autoPlay: true,
        loop: true,
        muted: true
      })
    }), isModel(item && item.url) && /* @__PURE__ */ jsx(react3dViewer.exports.GLTFModel, {
      ref: modelRef,
      width: 96,
      height: 96,
      src: item.url,
      enabled: false,
      position: {
        x: -0.15,
        y: -0.3,
        z: -0.3
      },
      onClick: handleClick
    })]
  });
};
const BagItem = ({
  item,
  isForTrade,
  index: index2,
  tradeBoxes,
  updateTradeBoxes,
  tradeLayer
}) => {
  const ref = React.useRef(null);
  const {
    plugActor,
    tradeData,
    localUser
  } = useStore();
  if (!item)
    item = {};
  item.isForTrade = isForTrade;
  const [{
    handlerId
  }, drop] = useDrop({
    accept: itemTypes.LAYER1,
    canDrop(dragItem, monitor) {
      const flag = tradeLayer !== "remote";
      return flag;
    },
    collect(monitor) {
      return {
        handlerId: monitor.getHandlerId()
      };
    },
    drop(dragEl, monitor) {
      if (!ref.current || item.canister_id || !tradeData)
        return;
      const dragIndex = dragEl.index;
      const hoverIndex = index2;
      const cloneDragTradeItem = clone(dragEl.item);
      cloneDragTradeItem.slot = hoverIndex;
      const cloneDragTradeBoxes = clone(dragEl.tradeBoxes);
      const cloneHoverTradeItem = clone(item);
      cloneHoverTradeItem.slot = dragIndex;
      const cloneHoverTradeBoxes = clone(tradeBoxes);
      console.log("cloneDragTradeItem: ", cloneDragTradeItem);
      if (dragEl.tradeLayer === "inventory" && tradeLayer === "local") {
        (async () => {
          const res = await plugActor.add_item_to_trade(localUser, tradeData.id, cloneDragTradeItem);
          console.log("add_item_to_trade res: ", res);
        })();
      }
      if (dragEl.tradeLayer === "local" && tradeLayer === "inventory") {
        (async () => {
          const res = await plugActor.remove_item_from_trade(localUser, tradeData.id, cloneDragTradeItem.id);
          console.log("remove_item_from_trade res: ", res);
        })();
      }
      if (tradeLayer === dragEl.tradeLayer) {
        cloneDragTradeBoxes[dragIndex].item = cloneHoverTradeItem;
        cloneDragTradeBoxes[hoverIndex].item = cloneDragTradeItem;
        updateTradeBoxes(cloneDragTradeBoxes);
      } else {
        cloneDragTradeBoxes[dragIndex].item = cloneHoverTradeItem;
        cloneHoverTradeBoxes[hoverIndex].item = cloneDragTradeItem;
        dragEl.updateTradeBoxes(cloneDragTradeBoxes);
        updateTradeBoxes(cloneHoverTradeBoxes);
      }
    }
  });
  const [{
    isDragging
  }, drag] = useDrag({
    type: itemTypes.LAYER1,
    canDrag: !!item.canister_id,
    item: () => {
      return {
        index: index2,
        tradeBoxes,
        updateTradeBoxes,
        item,
        tradeLayer
      };
    },
    collect: (monitor) => ({
      isDragging: monitor.isDragging()
    })
  });
  const opacity = isDragging ? 0 : 1;
  drag(drop(ref));
  return /* @__PURE__ */ jsx("div", {
    className: classnames({
      opacity
    }),
    ref,
    "data-handler-id": handlerId,
    children: /* @__PURE__ */ jsx(PresentationalBagItem, {
      drag,
      isDragging,
      item
    })
  });
};
const Loading = () => {
  const {
    loading
  } = useStore();
  return !loading ? null : /* @__PURE__ */ jsx("div", {
    className: classnames("absolute top-0 bottom-0 left-0 right-0 z-10 flex justify-center items-center opacity-30 bg-white", {
      hidden: !loading
    }),
    children: /* @__PURE__ */ jsx("div", {
      className: "w-32 h-32 border-8 rounded-full border-t-green-900 animate-spin"
    })
  });
};
const ItemDetails = () => {
  const {
    selItem
  } = useStore();
  const modelRef = React.useRef(null);
  React.useEffect(() => {
    const interval = setInterval(() => {
      var _a, _b;
      const refContainer = (_a = modelRef == null ? void 0 : modelRef.current) == null ? void 0 : _a.$container;
      if (((_b = refContainer == null ? void 0 : refContainer.children) == null ? void 0 : _b.length) > 1) {
        refContainer.removeChild(refContainer.firstChild);
      }
    }, 1);
    return () => {
      clearInterval(interval);
    };
  }, []);
  return selItem ? /* @__PURE__ */ jsxs("div", {
    className: "absolute bottom-0 right-0 z-10 flex flex-col w-1/4 gap-1 p-4 bg-black-100",
    children: [/* @__PURE__ */ jsxs("div", {
      className: "flex flex-col gap-1 font-bold text-red-900",
      children: [/* @__PURE__ */ jsx("div", {
        children: selItem == null ? void 0 : selItem.collection
      }), /* @__PURE__ */ jsx("div", {
        children: "#7849"
      })]
    }), /* @__PURE__ */ jsxs("div", {
      className: "flex items-center justify-center w-full p-4 bg-black",
      children: [isImage(selItem == null ? void 0 : selItem.url) && !isImage(selItem && selItem.url) && !isMedia(selItem && selItem.url) && !isModel(selItem && selItem.url) && /* @__PURE__ */ jsx("img", {
        className: "w-4/5",
        src: selItem.url
      }), false, false]
    })]
  }) : /* @__PURE__ */ jsx(Fragment, {});
};
const {
  ic
} = window;
const plug = ic == null ? void 0 : ic.plug;
const canister_id = "lj532-6iaaa-aaaah-qcc7a-cai";
const whitelist = [canister_id, "vlhm2-4iaaa-aaaam-qaatq-cai", "ryjl3-tyaaa-aaaaa-aaaba-cai"];
const url = new URL(window.location.href);
const tradeId = url.searchParams.get("tradeId");
tradeId && console.log("I'm joiner. tradeId: ", tradeId);
let inventoryTokens = [];
let partner;
const updatePartner = (val) => {
  partner = val;
};
const host = "https://mainnet.dfinity.network";
const timeout = 12e4;
const Trade = () => {
  const {
    isCreator,
    setIsCreator,
    tradeData,
    setTradeData,
    remoteBoxes,
    setRemoteBoxes,
    localBoxes,
    setLocalBoxes,
    inventoryBoxes,
    setInventoryBoxes,
    plugActor,
    setPlugActor,
    tradeStarted,
    setTradeStarted,
    accepted,
    setAccepted,
    curPage,
    setCurPage,
    setLoading,
    localUser,
    setLocalUser,
    curTradeId,
    setCurTradeId,
    principal,
    setPrincipal,
    authenticated,
    setAuthenticated
  } = useStore();
  const login = async () => {
    try {
      if (plug) {
        const publicKey = await plug.requestConnect({
          whitelist,
          host,
          timeout
        });
        if (publicKey) {
          const principal2 = await plug.agent.getPrincipal();
          setPrincipal(principal2);
          setAuthenticated(true);
        }
      }
    } catch (e2) {
      console.log("Error", e2);
    }
  };
  const principalString = principal ? window.ic.plug.principalId : "<none>";
  React.useEffect(() => {
    (async () => {
      if (!principal)
        return;
      setLoading(true);
      const user = window.ic.plug.principalId;
      console.log("local user: ", user);
      setLocalUser(user);
      const newTokens = Object.values(await getUserTokens({
        agent: plug.agent,
        user
      }));
      inventoryTokens = clone(newTokens);
      setInventoryBoxes(getInventoryBoxes(inventoryTokens));
      if (tradeId) {
        startTrade();
      }
      setLoading(false);
    })();
  }, [principal]);
  React.useEffect(() => {
    (async () => {
      if (!plugActor || !localUser)
        return;
      setLoading(true);
      console.log("plugActor: ", plugActor);
      let trade;
      if (tradeId) {
        console.log("***** TRADE DETECTED *****");
        trade = await plugActor.get_trade_by_id(tradeId);
        setIsCreator(false);
      } else {
        trade = await plugActor.create_trade();
        setIsCreator(true);
      }
      console.log("trade: ", trade);
      setCurTradeId(trade.id);
      setTradeData(trade);
      setTradeStarted(true);
      setLoading(false);
    })();
  }, [plugActor]);
  React.useEffect(() => {
    var _a, _b;
    const user = (_b = (_a = window == null ? void 0 : window.ic) == null ? void 0 : _a.plug) == null ? void 0 : _b.principalId;
    if (!user)
      return;
    const host2 = Principal$3.fromUint8Array(tradeData.host._arr).toText();
    const guest = Principal$3.fromUint8Array(tradeData.guest._arr).toText();
    const userIsHost = user === host2;
    const userIsGuest = user === guest;
    let data2 = [];
    if (userIsHost) {
      data2 = tradeData.host_data;
    } else if (userIsGuest) {
      data2 = tradeData.guest_data;
    } else {
      throw new Error("User is not host or guest");
    }
    if (localBoxes.length === data2.length) {
      return;
    }
    let added = false;
    for (let i2 = 0; i2 < localBoxes.length; i2++) {
      const localBox = localBoxes[i2];
      const index2 = data2.findIndex((element) => element.id === localBox.id);
      if (index2 === -1 && localBox.item) {
        const item = localBox.item;
        console.log("***** ADDING ITEM", item);
        console.log("***** tradeData", tradeData);
        const token_id = Number(item.index);
        console.log("tradeData.id, {name: item.collection, canister: Principal.fromText(item.canister), token_id");
        console.log(tradeData.id, {
          name: item.metadata.name,
          canister_id: item.canister,
          token_id
        });
        plugActor.add_item_to_trade(tradeData.id, {
          name: item.collection,
          canister_id: Principal$3.fromText(item.canister),
          token_id
        }).then((tradeResponse) => {
          console.log("tradeResponse", tradeResponse);
          updateTradeData(tradeResponse[0]);
        });
        added = true;
      }
    }
    if (!added) {
      let removed = false;
      for (let i2 = 0; i2 < data2.length; i2++) {
        const item = data2[i2];
        const index2 = localBoxes.findIndex((element) => element.id === item.id);
        if (index2 === -1) {
          plugActor.remove_item_from_trade(tradeId, item.id);
          return removed = true;
        }
      }
      if (!removed) {
        throw new Error("something went wrong");
      }
    }
  }, [localBoxes]);
  React.useEffect(() => {
    if (!plugActor || !tradeData || partner)
      return;
    const interval = setInterval(async () => {
      const rtTrade = await plugActor.get_trade_by_id(tradeData.id);
      console.log("rtTrade: ", rtTrade);
      const guest = Principal$3.fromUint8Array(rtTrade[0].guest._arr).toText();
      if (guest !== null && guest !== "" && guest !== nullPrincipal && guest !== nullPartner) {
        updatePartner(guest);
        clearInterval(interval);
        console.log("Trade partner found! guest: ", guest);
      }
    }, 1e3);
  }, [plugActor, tradeData]);
  React.useEffect(() => {
    (async () => {
      if (!plugActor && !curTradeId && !tradeData)
        return;
      setLoading(true);
      const host2 = tradeData.host;
      const guest = tradeData.guest;
      if (!isCreator && guest !== nullPrincipalId && guest !== localUser) {
        return console.error("Trade already initialized to another wallet: ", guest);
      }
      if (isCreator && guest !== nullPrincipalId && guest !== localUser && guest !== host2 && guest !== partner) {
        console.log("trade partner found(guest): ", guest);
        updatePartner(guest);
      }
      if (!isCreator && host2 !== nullPrincipalId && host2 !== localUser && host2 !== partner) {
        console.log("trade partner found(host): ", host2);
        await plugActor.join_trade(curTradeId);
        updatePartner(host2);
      }
      if (isCreator) {
        const rb2 = getRemoteBoxes(tradeData.guest_data);
        console.log("guest_data: ", tradeData.guest_data);
        console.log("remoteBoxes: ", rb2);
        setRemoteBoxes(rb2);
      } else {
        const rb2 = getRemoteBoxes(tradeData.host_data);
        console.log("host_data: ", tradeData.host_data);
        console.log("remoteBoxes: ", rb2);
        setRemoteBoxes(rb2);
      }
      setLoading(false);
    })();
  }, [tradeData]);
  React.useEffect(() => {
    if (!plugActor)
      return;
    const interval = setInterval(async () => {
      const trade = await plugActor.get_trade_by_id(curTradeId);
      setTradeData(trade);
    }, 10);
    return () => {
      clearInterval(interval);
    };
  }, [curTradeId]);
  React.useEffect(() => {
    if (!plugActor || !tradeData || !partner)
      return;
    const interval = setInterval(async () => {
      const rtTrade = await plugActor.get_trade_by_id(tradeData.id);
      if (JSON.stringify(rtTrade[0]) === JSON.stringify(tradeData))
        return;
      console.log("updated!");
      updateTradeData(rtTrade[0]);
      const user = window.ic.plug.principalId.toText();
      const rtHost = Principal$3.fromUint8Array(rtTrade[0].host._arr).toText();
      const rtGuest = Principal$3.fromUint8Array(rtTrade[0].guest._arr).toText();
      const userIsHost = user === rtHost;
      const userIsGuest = user === rtGuest;
      if (!userIsHost && !userIsGuest) {
        throw new Error("User is not in this trade!");
      }
      if (rtHost !== tradeData.host) {
        throw new Error("host changed!");
      }
      if (rtGuest !== tradeData.guest) {
        throw new Error("guest changed!");
      }
    }, 1e3);
    return () => clearInterval(interval);
  }, [plugActor, tradeData, partner]);
  const connect = async () => {
    console.log("connecting...");
    login();
  };
  const startTrade = async () => {
    setPlugActor(trade_canister);
  };
  const onAccept = () => {
    if (!plugActor)
      return;
    plugActor.accept(tradeData.id);
    setAccepted(true);
    console.log("Trade accepted!");
  };
  const onCancel = () => {
    if (!plugActor)
      return;
    plugActor.cancel(tradeData.id);
    setAccepted(false);
    console.log("Trade canceled!");
  };
  const onPrevPage = () => {
    if (curPage <= 1)
      return;
    setCurPage(curPage - 1);
  };
  const onNextPage = () => {
    const pageNum = Math.ceil(inventoryBoxNum / pageBoxNum);
    if (curPage >= pageNum)
      return;
    setCurPage(curPage + 1);
  };
  return /* @__PURE__ */ jsx("div", {
    className: "w-full h-full",
    children: /* @__PURE__ */ jsxs(DndProvider, {
      backend: HTML5Backend,
      children: [/* @__PURE__ */ jsx(ItemDetails, {}), /* @__PURE__ */ jsxs("div", {
        className: "absolute top-0 left-0 w-3/4 h-full",
        children: [/* @__PURE__ */ jsx(Loading, {}), !authenticated && /* @__PURE__ */ jsx(Frame, {
          className: "absolute w-full h-full",
          children: /* @__PURE__ */ jsx("div", {
            className: "flex items-center justify-center w-full h-full",
            children: /* @__PURE__ */ jsx(Button$1, {
              variant: "contained",
              onClick: connect,
              children: "Connect"
            })
          })
        }), authenticated && !tradeData && /* @__PURE__ */ jsxs(React.Fragment, {
          children: [/* @__PURE__ */ jsx(Frame, {
            className: "absolute w-full",
            children: /* @__PURE__ */ jsxs("div", {
              className: "flex items-center justify-center w-full h-full",
              children: [!tradeStarted && /* @__PURE__ */ jsx(Button$1, {
                variant: "contained",
                onClick: startTrade,
                children: "Start Trade"
              }), tradeStarted && !tradeData && /* @__PURE__ */ jsx(Button$1, {
                variant: "disabled",
                children: "Starting..."
              })]
            })
          }), /* @__PURE__ */ jsxs("div", {
            className: "absolute w-full h-full overflow-auto",
            children: [authenticated && tradeData && /* @__PURE__ */ jsxs(React.Fragment, {
              children: [/* @__PURE__ */ jsx(Frame, {
                children: /* @__PURE__ */ jsxs("div", {
                  className: "flex flex-col gap-2",
                  children: [/* @__PURE__ */ jsxs("div", {
                    className: "flex items-center justify-between",
                    children: [/* @__PURE__ */ jsx("div", {
                      className: "text-2xl",
                      children: "Their Trade"
                    }), /* @__PURE__ */ jsx("div", {
                      className: "text-xl text-blue-900",
                      children: isCreator && tradeData.guest_accept || !isCreator && tradeData.host_accept ? "TRADE ACCEPTED" : ""
                    })]
                  }), /* @__PURE__ */ jsx("div", {
                    className: "flex flex-wrap gap-3",
                    children: remoteBoxes.map((box, index2) => {
                      return /* @__PURE__ */ jsx(RemoteBox$1, {
                        children: /* @__PURE__ */ jsx(BagItem, {
                          item: clone(box.item),
                          index: index2,
                          tradeBoxes: clone(remoteBoxes),
                          updateTradeBoxes: setRemoteBoxes,
                          tradeLayer: "remote"
                        }, `remote_${box.id}`)
                      }, box.id);
                    })
                  })]
                })
              }), /* @__PURE__ */ jsx(Frame, {
                children: /* @__PURE__ */ jsxs("div", {
                  className: "flex flex-col gap-2",
                  children: [/* @__PURE__ */ jsx("div", {
                    className: "text-2xl",
                    children: "Your Trade"
                  }), /* @__PURE__ */ jsx("div", {
                    className: "flex flex-wrap gap-3",
                    children: localBoxes.map((box, index2) => {
                      return /* @__PURE__ */ jsx(BagBox$1, {
                        children: /* @__PURE__ */ jsx(BagItem, {
                          isForTrade: true,
                          item: clone(box.item),
                          index: index2,
                          tradeBoxes: clone(localBoxes),
                          updateTradeBoxes: setLocalBoxes,
                          tradeLayer: "local"
                        }, `local_${box.id}`)
                      }, box.id);
                    })
                  })]
                })
              }), /* @__PURE__ */ jsx(Frame, {
                children: /* @__PURE__ */ jsxs("div", {
                  className: "flex flex-wrap items-center justify-center w-full h-full gap-8",
                  children: [/* @__PURE__ */ jsx(Button$1, {
                    variant: "contained",
                    onClick: onAccept,
                    disabled: accepted || !existItems(localBoxes),
                    color: "success",
                    children: "Accept"
                  }), /* @__PURE__ */ jsxs("div", {
                    className: "flex items-center justify-center gap-2",
                    children: [/* @__PURE__ */ jsx("label", {
                      htmlFor: "icp",
                      children: "ICP: "
                    }), /* @__PURE__ */ jsx("input", {
                      className: "w-32 p-0.5 text-xl border rounded opacity-30 bg-amber-900",
                      id: "icp",
                      type: "number"
                    })]
                  }), /* @__PURE__ */ jsx(Button$1, {
                    variant: "contained",
                    onClick: onCancel,
                    disabled: !accepted && existItems(localBoxes),
                    color: "error",
                    children: "Cancel"
                  })]
                })
              })]
            }), principal && /* @__PURE__ */ jsx(Frame, {
              children: /* @__PURE__ */ jsxs("div", {
                className: "flex flex-col gap-2",
                children: [/* @__PURE__ */ jsxs("div", {
                  className: "flex items-center justify-between",
                  children: [/* @__PURE__ */ jsx("div", {
                    className: "text-2xl",
                    children: "Inventory"
                  }), /* @__PURE__ */ jsxs("div", {
                    className: "flex items-center gap-2 text-xl",
                    children: [/* @__PURE__ */ jsx("div", {
                      className: "cursor-pointer",
                      onClick: onPrevPage,
                      children: "<"
                    }), /* @__PURE__ */ jsx("div", {
                      className: "text-blue-900",
                      children: curPage
                    }), /* @__PURE__ */ jsx("div", {
                      className: "cursor-pointer",
                      onClick: onNextPage,
                      children: ">"
                    })]
                  })]
                }), /* @__PURE__ */ jsx("div", {
                  className: "flex flex-wrap gap-3",
                  children: inventoryBoxes.slice((curPage - 1) * pageBoxNum, curPage * pageBoxNum).map((box, index2) => {
                    return /* @__PURE__ */ jsx(BagBox$1, {
                      children: /* @__PURE__ */ jsx(BagItem, {
                        item: clone(box.item),
                        index: (curPage - 1) * pageBoxNum + index2,
                        tradeBoxes: clone(inventoryBoxes),
                        updateTradeBoxes: setInventoryBoxes,
                        tradeLayer: "inventory"
                      }, `inventory_${box.id}`)
                    }, box.id);
                  })
                })]
              })
            })]
          })]
        })]
      }), /* @__PURE__ */ jsx("div", {
        className: "absolute top-0 right-0 w-1/4 h-full",
        children: /* @__PURE__ */ jsx(Frame, {
          className: "h-full",
          children: /* @__PURE__ */ jsxs("div", {
            className: "p-2",
            children: [/* @__PURE__ */ jsx("b", {
              children: "CONNECTION STATUS"
            }), /* @__PURE__ */ jsx("br", {}), authenticated && principal ? "Connected with " + principalString : "Waiting for IC wallet connection...", /* @__PURE__ */ jsx("br", {}), /* @__PURE__ */ jsx("br", {}), tradeStarted && tradeData && !partner && !tradeId && /* @__PURE__ */ jsxs(Fragment, {
              children: [/* @__PURE__ */ jsx("b", {
                children: " WAITING FOR TRADE PARTNER... "
              }), /* @__PURE__ */ jsx("br", {}), "Send this link to your trade partner", /* @__PURE__ */ jsx("br", {}), /* @__PURE__ */ jsxs("a", {
                className: "text-blue-900",
                href: `${url.host}/?tradeId=${tradeData.id}`,
                children: [url.host, "/?tradeId=", tradeData.id]
              })]
            }), tradeStarted && tradeData && partner && /* @__PURE__ */ jsxs(Fragment, {
              children: ["Trading with ", partner]
            })]
          })
        })
      })]
    })
  });
};
styleInject(css$2);
const App = ({
  type
}) => {
  return /* @__PURE__ */ jsx("div", {
    className: "body",
    children: /* @__PURE__ */ jsx("div", {
      className: "fixed top-0 bottom-0 left-0 right-0",
      children: /* @__PURE__ */ jsx(Trade, {
        type
      })
    })
  });
};
client.createRoot(document.getElementById("root")).render(/* @__PURE__ */ jsx(React.StrictMode, {
  children: /* @__PURE__ */ jsx(App, {})
}));
export {
  AgentError as A,
  Certificate as C,
  PipeArrayBuffer as P,
  Principal$3 as a,
  decode as d,
  lebDecode as l,
  toHex as t
};
